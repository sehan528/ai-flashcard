{
  "name": "Spring 고급 (AOP, Transaction)",
  "description": "AOP, 트랜잭션, JPA 등 고급 주제",
  "cards": [
    {
      "question": "AOP(Aspect-Oriented Programming)란 무엇이며, 언제 사용하나요?",
      "answer": "관심사의 분리를 통해 핵심 로직과 부가 기능을 분리하는 프로그래밍 패러다임입니다. 로깅, 트랜잭션, 보안 등 횡단 관심사(Cross-cutting Concerns)를 처리할 때 사용합니다.",
      "type": "essay",
      "tags": ["Spring", "AOP", "고급"]
    },
    {
      "question": "@Transactional의 동작 원리를 설명하세요.",
      "answer": "Spring AOP를 통해 프록시 패턴으로 구현됩니다. 메서드 시작 시 트랜잭션을 시작하고, 정상 종료 시 commit, 예외 발생 시 rollback합니다.",
      "type": "essay",
      "tags": ["Spring", "Transaction", "AOP"]
    },
    {
      "question": "다음 중 @Transactional의 전파 속성(Propagation)이 아닌 것은?",
      "answer": ["REQUIRED", "REQUIRES_NEW", "SUPPORTS", "INHERITS"],
      "type": "multiple",
      "correctIndex": 3,
      "tags": ["Spring", "Transaction", "전파속성"]
    },
    {
      "question": "JPA의 영속성 컨텍스트(Persistence Context)란 무엇인가요?",
      "answer": "엔티티를 영구 저장하는 환경으로, 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지(Dirty Checking), 지연 로딩 등의 기능을 제공합니다.",
      "type": "essay",
      "tags": ["Spring", "JPA", "영속성"]
    },
    {
      "question": "N+1 문제란 무엇이며, 어떻게 해결하나요?",
      "answer": "연관된 엔티티를 조회할 때 추가 쿼리가 N번 발생하는 문제입니다. Fetch Join, @EntityGraph, Batch Size 설정 등으로 해결할 수 있습니다.",
      "type": "essay",
      "tags": ["Spring", "JPA", "성능"]
    },
    {
      "question": "다음 중 JPA의 엔티티 상태가 아닌 것은?",
      "answer": ["비영속(new)", "영속(managed)", "준영속(detached)", "완전영속(persistent)"],
      "type": "multiple",
      "correctIndex": 3,
      "tags": ["Spring", "JPA", "엔티티"]
    }
  ]
}
