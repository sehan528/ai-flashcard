{
  "name": "자바스크립트 (간략버전)",
  "description": "JavaScript 핵심 개념을 간결하게 정리한 버전",
  "cards": [
    {
      "question": "var, let, const의 차이점 3가지는?",
      "answer": "1. **스코프** - var: 함수 스코프 / let,const: 블록 스코프\n2. **재선언** - var: 가능 / let,const: 불가능\n3. **재할당** - var,let: 가능 / const: 불가능",
      "type": "essay",
      "tags": [
        "JavaScript",
        "변수"
      ]
    },
    {
      "question": "호이스팅이란 무엇이며 var와 let의 차이는?",
      "answer": "**호이스팅:** 선언이 스코프 최상단으로 끌어올려지는 현상\n\n- **var**: 호이스팅 O, undefined로 초기화\n- **let/const**: 호이스팅 O, TDZ(Temporal Dead Zone)로 접근 불가",
      "type": "essay",
      "tags": [
        "JavaScript",
        "호이스팅"
      ]
    },
    {
      "question": "클로저의 개념과 활용 사례 3가지는?",
      "answer": "**개념:** 함수가 선언될 때의 렉시컬 환경을 기억하는 함수\n\n**활용:**\n1. 데이터 은닉 (private 변수)\n2. 부분 적용 함수\n3. 콜백 함수에서 외부 변수 참조",
      "type": "essay",
      "tags": [
        "JavaScript",
        "클로저"
      ]
    },
    {
      "question": "this의 4가지 바인딩 규칙은?",
      "answer": "1. **기본 바인딩** - 전역 객체 (strict: undefined)\n2. **암시적 바인딩** - 호출한 객체\n3. **명시적 바인딩** - call/apply/bind\n4. **new 바인딩** - 새로 생성된 객체",
      "type": "essay",
      "tags": [
        "JavaScript",
        "this"
      ]
    },
    {
      "question": "화살표 함수와 일반 함수의 차이점 4가지는?",
      "answer": "1. **this** - 화살표: 렉시컬 this / 일반: 동적 this\n2. **arguments** - 화살표: 없음 / 일반: 있음\n3. **생성자** - 화살표: 불가 / 일반: 가능 (new 사용)\n4. **prototype** - 화살표: 없음 / 일반: 있음",
      "type": "essay",
      "tags": [
        "JavaScript",
        "화살표함수"
      ]
    },
    {
      "question": "프로토타입 체인의 동작 원리는?",
      "answer": "- 객체의 프로퍼티 접근 시 없으면 [[Prototype]]을 따라 상위 검색\n- Object.prototype까지 올라가며 탐색\n- 없으면 undefined 반환",
      "type": "essay",
      "tags": [
        "JavaScript",
        "프로토타입"
      ]
    },
    {
      "question": "클래스 상속과 프로토타입 상속의 차이는?",
      "answer": "- **클래스 상속**: ES6 class 문법, 명확한 구조\n- **프로토타입 상속**: __proto__ 체인, 유연하지만 복잡\n- 클래스도 내부적으로 프로토타입 기반",
      "type": "essay",
      "tags": [
        "JavaScript",
        "상속"
      ]
    },
    {
      "question": "Promise의 3가지 상태는?",
      "answer": "1. **Pending** - 대기 (초기 상태)\n2. **Fulfilled** - 이행 (성공)\n3. **Rejected** - 거부 (실패)",
      "type": "essay",
      "tags": [
        "JavaScript",
        "Promise"
      ]
    },
    {
      "question": "async/await의 장점 3가지는?",
      "answer": "1. **가독성** - 동기 코드처럼 작성\n2. **에러 처리** - try-catch 사용 가능\n3. **디버깅** - 스택 트레이스 명확",
      "type": "essay",
      "tags": [
        "JavaScript",
        "async"
      ]
    },
    {
      "question": "이벤트 루프의 동작 순서는?",
      "answer": "1. **Call Stack** 실행\n2. **Microtask Queue** (Promise)\n3. **Macrotask Queue** (setTimeout)\n4. **렌더링**\n5. 반복",
      "type": "essay",
      "tags": [
        "JavaScript",
        "이벤트루프"
      ]
    },
    {
      "question": "얕은 복사와 깊은 복사의 차이와 방법은?",
      "answer": "**얕은 복사:**\n- 1단계만 복사, 중첩 객체는 참조 공유\n- 방법: {...obj}, Object.assign()\n\n**깊은 복사:**\n- 모든 중첩 객체까지 복사\n- 방법: JSON.parse(JSON.stringify()), structuredClone()",
      "type": "essay",
      "tags": [
        "JavaScript",
        "복사"
      ]
    },
    {
      "question": "map, filter, reduce의 차이는?",
      "answer": "1. **map** - 각 요소 변환, 같은 길이 배열 반환\n2. **filter** - 조건 만족 요소만, 짧아질 수 있음\n3. **reduce** - 누적 계산, 단일 값 반환",
      "type": "essay",
      "tags": [
        "JavaScript",
        "배열"
      ]
    },
    {
      "question": "Set과 Map의 특징과 차이는?",
      "answer": "**Set:**\n- 중복 없는 값 컬렉션\n- has(), add(), delete()\n\n**Map:**\n- key-value 쌍, 모든 타입 key 가능\n- get(), set(), delete()\n\n**vs Object:** 순서 보장, 크기 추적 쉬움",
      "type": "essay",
      "tags": [
        "JavaScript",
        "자료구조"
      ]
    },
    {
      "question": "디바운싱과 스로틀링의 차이는?",
      "answer": "**디바운싱:**\n- 마지막 이벤트만 처리\n- 연속 이벤트 중단 후 일정 시간 경과 시 실행\n\n**스로틀링:**\n- 일정 시간 간격으로 처리\n- 연속 이벤트 중 주기적으로 실행",
      "type": "essay",
      "tags": [
        "JavaScript",
        "최적화"
      ]
    },
    {
      "question": "메모이제이션이란 무엇이며 언제 사용하나요?",
      "answer": "**개념:** 함수 결과를 캐싱하여 재계산 방지\n\n**사용 시기:**\n- 순수 함수 (같은 입력 → 같은 출력)\n- 계산 비용이 큰 함수\n- 반복 호출이 많은 경우",
      "type": "essay",
      "tags": [
        "JavaScript",
        "최적화"
      ]
    },
    {
      "question": "불변성을 유지해야 하는 이유 3가지는?",
      "answer": "1. **예측 가능성** - 데이터 변경 추적 용이\n2. **디버깅** - 상태 변화 명확\n3. **React 최적화** - 참조 비교로 변경 감지",
      "type": "essay",
      "tags": [
        "JavaScript",
        "불변성"
      ]
    },
    {
      "question": "Proxy 객체의 주요 트랩 5가지는?",
      "answer": "1. **get** - 속성 읽기\n2. **set** - 속성 쓰기\n3. **has** - in 연산자\n4. **deleteProperty** - delete 연산자\n5. **apply** - 함수 호출",
      "type": "essay",
      "tags": [
        "JavaScript",
        "Proxy"
      ]
    },
    {
      "question": "Generator 함수의 특징 3가지는?",
      "answer": "1. **일시 정지** - yield로 실행 중단/재개\n2. **양방향 통신** - next()로 값 전달\n3. **이터러블** - for...of 사용 가능",
      "type": "essay",
      "tags": [
        "JavaScript",
        "Generator"
      ]
    },
    {
      "question": "WeakMap과 Map의 차이점 3가지는?",
      "answer": "1. **키 타입** - WeakMap: 객체만 / Map: 모든 타입\n2. **GC** - WeakMap: 약한 참조로 GC 가능 / Map: 강한 참조\n3. **열거** - WeakMap: 불가 / Map: 가능",
      "type": "essay",
      "tags": [
        "JavaScript",
        "자료구조"
      ]
    },
    {
      "question": "원시 타입과 참조 타입의 차이는?",
      "answer": "**원시 타입:**\n- 값 저장, 불변\n- string, number, boolean, null, undefined, symbol, bigint\n\n**참조 타입:**\n- 주소 저장, 가변\n- object, array, function",
      "type": "essay",
      "tags": [
        "JavaScript",
        "타입"
      ]
    }
  ]
}