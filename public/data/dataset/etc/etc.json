{
  "name": "개발상식 (CS 기타)",
  "description": "가상화, Docker, CI/CD, static 등 개발 필수 지식",
  "cards": [
    {
      "question": "가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.",
      "answer": "**가상화 (Virtualization):**\n\n**개념:**\n- 물리적 하드웨어 리소스를 논리적으로 추상화하여 여러 개의 독립적인 환경을 만드는 기술\n- 하나의 물리 서버에서 여러 개의 가상 환경을 실행\n\n**핵심 목표:**\n- 리소스 효율성 향상\n- 격리된 실행 환경 제공\n- 유연한 인프라 관리\n\n---\n\n**가상머신 (Virtual Machine):**\n\n**개념:**\n- 가상화 기술의 한 구현 방식\n- 하이퍼바이저(Hypervisor)를 통해 완전한 운영체제를 가상화\n\n**구조:**\n- Host OS (물리 서버 운영체제)\n- Hypervisor (VMware, VirtualBox, Hyper-V 등)\n- Guest OS (각 VM의 독립적인 OS)\n- Application\n\n---\n\n**차이점:**\n\n**가상화:**\n- **광범위한 개념**: 하드웨어, OS, 네트워크, 스토리지 등 모든 리소스 가상화 포함\n- **다양한 방식**: VM, 컨테이너, 서버리스 등\n\n**가상머신:**\n- **가상화의 한 방식**: OS 레벨 가상화\n- **완전한 격리**: 각 VM이 독립적인 OS 보유\n- **무거움**: Guest OS 전체를 포함하여 리소스 많이 사용\n\n---\n\n**가상화 방식 비교:**\n\n**1. 가상머신 (VM):**\n- 하이퍼바이저 기반\n- 완전한 OS 격리\n- 무거움 (GB 단위 메모리)\n- 부팅 시간 느림 (분 단위)\n- 강력한 격리\n\n**2. 컨테이너 (Docker 등):**\n- OS 레벨 가상화\n- Host OS 커널 공유\n- 가벼움 (MB 단위 메모리)\n- 부팅 시간 빠름 (초 단위)\n- 프로세스 격리\n\n**3. 서버리스:**\n- 함수 레벨 가상화\n- 인프라 추상화\n- 이벤트 기반 실행\n\n---\n\n**요약:**\n\n- **가상화**: 리소스를 논리적으로 분할하는 기술 전반\n- **가상머신**: 가상화 기술 중 하이퍼바이저를 이용해 완전한 OS를 가상화하는 방식\n\n가상화는 큰 개념이고, 가상머신은 그 구현 방법 중 하나입니다.",
      "type": "essay",
      "tags": [
        "가상화",
        "VM",
        "인프라",
        "클라우드"
      ],
      "id": "etc-001",
      "createdAt": "2025-11-17T15:00:00.000000",
      "studyCount": 0
    },
    {
      "question": "그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?",
      "answer": "**Docker의 분류:**\n\nDocker는 **컨테이너 기반 가상화**에 속합니다.\n\n- **가상화 기술**의 한 방식\n- **가상머신(VM)이 아님**\n- OS 레벨 가상화 (프로세스 격리)\n\n---\n\n**Docker 특징:**\n\n**구조:**\n- Host OS\n- Docker Engine\n- 컨테이너 (독립 실행 환경)\n- Application\n\n**차이점:**\n- Guest OS 없음 (Host OS 커널 공유)\n- 경량화 (MB 단위)\n- 빠른 시작 (초 단위)\n\n---\n\n**VM vs Docker:**\n\n| 항목 | VM | Docker |\n|------|----|----|\n| OS | Guest OS 전체 포함 | Host OS 커널 공유 |\n| 크기 | GB 단위 | MB 단위 |\n| 부팅 | 분 단위 | 초 단위 |\n| 리소스 | 많이 사용 | 적게 사용 |\n| 격리 | 강력 (하드웨어 레벨) | 프로세스 레벨 |\n| 성능 | 오버헤드 있음 | 네이티브에 가까움 |\n\n---\n\n**Docker를 많이 채택하는 이유:**\n\n---\n\n**1. 경량성:**\n- Guest OS 불필요 → 메모리 절약\n- 수십 개 컨테이너를 하나의 호스트에서 실행 가능\n- VM은 수 개만 가능\n\n**2. 빠른 시작/종료:**\n- 초 단위 시작\n- 배포 속도 향상\n- CI/CD 파이프라인에 적합\n\n**3. 이식성 (Portability):**\n- \"Build once, run anywhere\"\n- 동일한 컨테이너 이미지를 어디서나 실행\n- 개발/스테이징/프로덕션 환경 일관성\n\n**4. 개발 환경 일치:**\n- \"내 컴퓨터에서는 되는데...\" 문제 해결\n- 모든 개발자가 동일한 환경\n- 의존성 충돌 방지\n\n**5. 마이크로서비스 아키텍처:**\n- 서비스별 독립 컨테이너\n- 쉬운 스케일링\n- 서비스 간 격리\n\n**6. 버전 관리:**\n- Docker 이미지 버전 관리\n- 롤백 용이\n- 이미지 레이어 캐싱\n\n**7. 리소스 효율:**\n- 동일 하드웨어에 더 많은 애플리케이션\n- 클라우드 비용 절감\n\n**8. DevOps 문화:**\n- Infrastructure as Code\n- 자동화된 배포\n- 컨테이너 오케스트레이션 (Kubernetes)\n\n**9. 생태계:**\n- Docker Hub (공개 이미지 저장소)\n- 수많은 공식/커뮤니티 이미지\n- 쉬운 시작\n\n**10. 격리:**\n- 애플리케이션 간 의존성 충돌 방지\n- 보안 향상 (제한적이지만)\n\n---\n\n**실제 사용 예:**\n\n**개발:**\n- 로컬에서 MySQL, Redis, Kafka 등을 컨테이너로 실행\n- 프로젝트별 독립 환경\n\n**배포:**\n- 동일한 이미지를 개발/스테이징/프로덕션에 배포\n- 일관성 보장\n\n**마이크로서비스:**\n- 각 서비스를 독립 컨테이너로\n- Kubernetes로 오케스트레이션\n\n---\n\n**한계:**\n\n**1. 보안:**\n- Host OS 커널 공유 → 커널 취약점 영향\n- VM보다 격리 약함\n\n**2. OS 제약:**\n- Linux 컨테이너는 Linux에서만 (Windows는 WSL2 필요)\n- 다른 OS 커널 불가\n\n**3. 상태 관리:**\n- 컨테이너는 기본적으로 stateless\n- 영구 데이터는 볼륨 필요\n\n---\n\n**결론:**\n\nDocker는 **컨테이너 기반 가상화**로, VM보다 경량하고 빠르며 이식성이 뛰어납니다. 마이크로서비스, DevOps, 클라우드 네이티브 환경에서 사실상 표준이 되었습니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "컨테이너",
        "가상화",
        "DevOps"
      ],
      "id": "etc-002",
      "createdAt": "2025-11-17T15:00:00.000001",
      "studyCount": 0
    },
    {
      "question": "하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?",
      "answer": "**위험성:**\n\n맞습니다. Docker 컨테이너는 Host OS 커널을 공유하므로 다음 위험이 있습니다:\n\n**1. 리소스 고갈:**\n- 한 컨테이너가 CPU/메모리 독점\n- 다른 컨테이너 성능 저하 또는 중단\n\n**2. 커널 취약점:**\n- 컨테이너에서 커널 익스플로잇\n- Host 및 다른 컨테이너 침해\n\n**3. 네트워크 간섭:**\n- 같은 네트워크의 컨테이너 간 통신\n- 의도치 않은 접근\n\n**4. 파일시스템 접근:**\n- 볼륨 마운트 오용\n- Host 파일시스템 접근\n\n---\n\n**방어 메커니즘:**\n\nDocker와 Linux는 여러 격리 기술을 제공합니다:\n\n---\n\n**1. Namespace (네임스페이스):**\n\n**개념:**\n- 프로세스, 네트워크, 파일시스템 등을 격리\n- 각 컨테이너가 독립된 뷰를 가짐\n\n**종류:**\n\n**PID Namespace:**\n- 프로세스 ID 격리\n- 컨테이너 내부에서 PID 1부터 시작\n- 다른 컨테이너 프로세스 보이지 않음\n\n**Network Namespace:**\n- 네트워크 인터페이스 격리\n- 각 컨테이너가 독립 IP, 포트\n- 브리지 네트워크로 연결\n\n**Mount Namespace:**\n- 파일시스템 격리\n- 각 컨테이너가 독립 루트 파일시스템\n- Host 파일시스템 보이지 않음\n\n**UTS Namespace:**\n- 호스트명, 도메인명 격리\n\n**IPC Namespace:**\n- 프로세스 간 통신 격리\n\n**User Namespace:**\n- UID/GID 매핑\n- 컨테이너 내부 root가 Host에서는 일반 사용자\n\n---\n\n**2. Cgroups (Control Groups):**\n\n**개념:**\n- 리소스 사용량 제한 및 격리\n\n**제한 항목:**\n\n**CPU:**\n- --cpus 옵션\n- CPU 사용률 제한\n\n**메모리:**\n- --memory 옵션\n- 메모리 한계 설정\n- OOM Killer 방지\n\n**I/O:**\n- 디스크 읽기/쓰기 속도 제한\n\n**네트워크:**\n- 대역폭 제한\n\n**효과:**\n- 한 컨테이너의 리소스 독점 방지\n- 다른 컨테이너 영향 최소화\n\n---\n\n**3. Seccomp (Secure Computing Mode):**\n\n**개념:**\n- 시스템 콜 필터링\n- 위험한 시스템 콜 차단\n\n**기본 프로필:**\n- Docker 기본 seccomp 프로필\n- 300개 이상 시스템 콜 중 일부만 허용\n- reboot, mount 등 위험한 콜 차단\n\n**커스텀 프로필:**\n- JSON으로 허용/차단 시스템 콜 정의\n\n---\n\n**4. AppArmor / SELinux:**\n\n**개념:**\n- 강제 접근 제어 (MAC)\n- 프로세스별 권한 정의\n\n**AppArmor:**\n- Ubuntu/Debian에서 사용\n- 프로파일로 파일/네트워크 접근 제어\n\n**SELinux:**\n- RHEL/CentOS에서 사용\n- 레이블 기반 접근 제어\n\n---\n\n**5. Capabilities:**\n\n**개념:**\n- root 권한을 세분화\n- 필요한 권한만 부여\n\n**예시:**\n- CAP_NET_BIND_SERVICE (1024 미만 포트 바인딩)\n- CAP_SYS_ADMIN (시스템 관리)\n\n**기본:**\n- Docker는 일부 위험한 capabilities 제거\n- --cap-drop, --cap-add로 조정\n\n---\n\n**6. Read-only Root Filesystem:**\n\n**개념:**\n- 컨테이너 루트 파일시스템을 읽기 전용으로\n\n**효과:**\n- 악성 파일 쓰기 방지\n- 불변 인프라\n\n---\n\n**7. User Namespace:**\n\n**개념:**\n- 컨테이너 내부 UID를 Host UID로 매핑\n\n**효과:**\n- 컨테이너 내부 root (UID 0)\n- Host에서는 일반 사용자 (UID 100000 등)\n- Host 파일시스템 접근 제한\n\n---\n\n**8. 네트워크 격리:**\n\n**방법:**\n\n**브리지 네트워크:**\n- 기본 격리\n- 컨테이너끼리 브리지를 통해 통신\n\n**사용자 정의 네트워크:**\n- docker network create mynet\n- 네트워크별 격리\n\n**호스트 네트워크 피하기:**\n- --network host는 격리 없음\n- 필요한 경우만 사용\n\n---\n\n**9. 이미지 보안:**\n\n**신뢰할 수 있는 이미지:**\n- 공식 이미지 사용\n- Docker Content Trust (이미지 서명)\n\n**취약점 스캔:**\n- Trivy, Clair 등으로 이미지 스캔\n- 알려진 CVE 확인\n\n**최소 이미지:**\n- Alpine Linux 등 최소 이미지\n- 공격 표면 축소\n\n---\n\n**10. 런타임 보안:**\n\n**Docker Bench Security:**\n- Docker 보안 Best Practice 검사 도구\n\n**Falco:**\n- 런타임 보안 모니터링\n- 비정상 동작 감지\n\n**gVisor, Kata Containers:**\n- 더 강력한 격리\n- 컨테이너별 경량 커널 (gVisor)\n- 컨테이너별 경량 VM (Kata)\n\n---\n\n**실전 권장사항:**\n\n**1. 리소스 제한:**\n- 모든 컨테이너에 CPU/메모리 제한 설정\n\n**2. 최소 권한:**\n- root로 실행 금지 (USER 지시어)\n- 필요한 capabilities만\n- 읽기 전용 파일시스템\n\n**3. 네트워크 분리:**\n- 서비스별 네트워크 분리\n- 필요한 포트만 노출\n\n**4. 정기 업데이트:**\n- Host OS, Docker, 이미지 최신 유지\n- 보안 패치 적용\n\n**5. 모니터링:**\n- 컨테이너 동작 모니터링\n- 이상 징후 감지\n\n**6. 스캔:**\n- 이미지 취약점 스캔\n- CI/CD에 통합\n\n---\n\n**결론:**\n\nDocker는 Namespace, Cgroups, Seccomp, AppArmor 등 여러 격리 메커니즘을 제공하여 컨테이너 간 간섭을 방지합니다. 하지만 VM보다 격리가 약하므로, 리소스 제한, 최소 권한, 보안 스캔 등의 Best Practice를 따라야 합니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "보안",
        "격리",
        "Namespace",
        "Cgroups"
      ],
      "id": "etc-003",
      "createdAt": "2025-11-17T15:00:00.000002",
      "studyCount": 0
    },
    {
      "question": "Docker 위에 Docker를 올릴 순 없을까요?",
      "answer": "**답변: 가능합니다.**\n\nDocker 위에 Docker를 올리는 것을 **Docker-in-Docker (DinD)**라고 합니다.\n\n---\n\n**구현 방법:**\n\n**1. Docker-in-Docker (DinD):**\n\n**공식 이미지:**\n- docker:dind 이미지 사용\n\n**특징:**\n- 컨테이너 내부에서 Docker daemon 실행\n- 완전히 독립적인 Docker 환경\n- Privileged 모드 필요\n\n**장점:**\n- 완전한 격리\n- 내부 Docker와 외부 Docker 독립\n\n**단점:**\n- 보안 위험 (privileged 모드)\n- 리소스 오버헤드\n- 복잡도 증가\n\n---\n\n**2. Docker Socket 마운트:**\n\n**방법:**\n- Host의 Docker socket을 컨테이너에 마운트\n- /var/run/docker.sock\n\n**특징:**\n- 컨테이너 내부에서 Host의 Docker 제어\n- 실제로는 DinD가 아님 (Host Docker 사용)\n- Privileged 모드 불필요\n\n**장점:**\n- 간단\n- 리소스 효율적\n\n**단점:**\n- Host Docker 접근 (보안 위험)\n- 완전한 격리 아님\n- 컨테이너가 Host Docker 제어 가능\n\n---\n\n**사용 사례:**\n\n**1. CI/CD 파이프라인:**\n\n**목적:**\n- Jenkins, GitLab CI 등에서 Docker 이미지 빌드\n\n**시나리오:**\n- Jenkins 컨테이너 내부에서 Docker 이미지 빌드\n- 빌드된 이미지를 레지스트리에 푸시\n\n**방법:**\n- DinD 또는 Docker socket 마운트\n\n---\n\n**2. Docker 개발/테스트:**\n\n**목적:**\n- Docker 자체 개발 또는 테스트\n\n**시나리오:**\n- 격리된 환경에서 Docker 실험\n\n---\n\n**3. 샌드박스 환경:**\n\n**목적:**\n- 안전하게 Docker 명령 실행\n\n---\n\n**DinD vs Docker Socket 비교:**\n\n| 항목 | DinD | Docker Socket |\n|------|------|---------------|\n| 격리 | 완전 격리 | Host Docker 공유 |\n| Privileged | 필요 | 불필요 |\n| 보안 | 중간 (privileged 위험) | 낮음 (Host 접근) |\n| 리소스 | 높음 (daemon 별도) | 낮음 (Host daemon 공유) |\n| 복잡도 | 높음 | 낮음 |\n| 사용 | 완전한 격리 필요 시 | CI/CD 등 간단한 경우 |\n\n---\n\n**보안 고려사항:**\n\n**DinD:**\n- --privileged 플래그 필요\n- 컨테이너가 Host 커널 전체 접근\n- 보안 위험 높음\n\n**Docker Socket 마운트:**\n- 컨테이너가 Host Docker 제어\n- Host의 모든 컨테이너 제어 가능\n- Host 파일시스템 마운트 가능\n- 사실상 root 권한과 동등\n\n**완화:**\n- 신뢰할 수 있는 이미지만 사용\n- 네트워크 격리\n- 리소스 제한\n- 모니터링\n\n---\n\n**대안:**\n\n**1. Kaniko:**\n- DinD 없이 컨테이너 이미지 빌드\n- Kubernetes에서 사용\n- Privileged 모드 불필요\n\n**2. Buildah:**\n- Rootless 컨테이너 빌드\n- Docker daemon 불필요\n\n**3. BuildKit:**\n- Docker의 차세대 빌드 엔진\n- 더 안전하고 빠름\n\n---\n\n**실전 권장사항:**\n\n**CI/CD:**\n- **단순한 경우**: Docker socket 마운트\n- **격리 필요**: DinD\n- **보안 중요**: Kaniko/Buildah\n\n**개발:**\n- DinD로 실험 환경 구축\n\n**프로덕션:**\n- 가능하면 피하기\n- 대안 도구 사용\n\n---\n\n**예시 시나리오:**\n\n**Jenkins CI:**\n\n**방법 1 (Docker Socket):**\n- Jenkins 컨테이너 실행 시 -v /var/run/docker.sock:/var/run/docker.sock\n- Jenkins job에서 docker build\n- Host Docker 사용하여 빌드\n\n**방법 2 (DinD):**\n- docker:dind 컨테이너 실행\n- Jenkins를 DinD에 연결\n- 완전히 격리된 Docker 환경\n\n---\n\n**한계:**\n\n**1. 성능:**\n- 중첩된 환경으로 오버헤드\n\n**2. 복잡도:**\n- 디버깅 어려움\n- 네트워크 설정 복잡\n\n**3. 이식성:**\n- 환경마다 동작 다를 수 있음\n\n---\n\n**결론:**\n\nDocker 위에 Docker를 올리는 것은 가능하며(DinD) 또는 Host Docker를 공유할 수 있습니다(Socket 마운트). CI/CD에서 유용하지만 보안 위험이 있으므로 신중하게 사용하고, 가능하면 Kaniko 같은 대안을 고려하세요.",
      "type": "essay",
      "tags": [
        "Docker",
        "DinD",
        "Docker-in-Docker",
        "CI/CD"
      ],
      "id": "etc-004",
      "createdAt": "2025-11-17T15:00:00.000003",
      "studyCount": 0
    },
    {
      "question": "CI/CD를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.",
      "answer": "**CI/CD 개념:**\n\n**CI (Continuous Integration):**\n- 지속적 통합\n- 코드 변경을 자주 메인 브랜치에 통합\n- 자동 빌드 및 테스트\n\n**CD (Continuous Delivery/Deployment):**\n- 지속적 배포\n- Delivery: 릴리스 준비 자동화\n- Deployment: 프로덕션 자동 배포\n\n---\n\n**CI/CD 파이프라인 구성 요소:**\n\n**1. 소스 코드 관리:**\n- Git (GitHub, GitLab, Bitbucket)\n- 코드 푸시 시 파이프라인 트리거\n\n**2. 빌드:**\n- 소스 코드 컴파일\n- 의존성 설치\n- Docker 이미지 빌드\n\n**3. 테스트:**\n- 단위 테스트\n- 통합 테스트\n- E2E 테스트\n- 정적 분석, 린트\n\n**4. 배포:**\n- 스테이징 환경 배포\n- 프로덕션 배포\n- 롤백 가능\n\n**5. 모니터링:**\n- 배포 후 헬스 체크\n- 메트릭 수집\n- 알림\n\n---\n\n**일반적인 CI/CD 플로우:**\n\n**1. 코드 푸시:**\n- 개발자가 Git에 코드 푸시\n\n**2. 빌드 트리거:**\n- Webhook으로 CI/CD 서버 알림\n\n**3. 빌드:**\n- 소스 코드 체크아웃\n- 의존성 설치\n- 빌드 (jar, Docker 이미지 등)\n\n**4. 테스트:**\n- 유닛 테스트 실행\n- 테스트 실패 시 파이프라인 중단\n\n**5. 정적 분석:**\n- 코드 품질 검사 (SonarQube 등)\n- 취약점 스캔\n\n**6. 배포 (스테이징):**\n- 스테이징 환경에 배포\n- 통합 테스트\n\n**7. 승인 (선택):**\n- 수동 승인 단계\n- 프로덕션 배포 전 검토\n\n**8. 배포 (프로덕션):**\n- 프로덕션 환경 배포\n- Blue-Green, Canary, Rolling 등\n\n**9. 검증:**\n- 헬스 체크\n- 스모크 테스트\n- 실패 시 자동 롤백\n\n---\n\n**주요 CI/CD 도구:**\n\n**1. Jenkins:**\n- 오픈소스, 가장 널리 사용\n- 플러그인 생태계\n- Jenkinsfile (Pipeline as Code)\n\n**2. GitLab CI/CD:**\n- GitLab 통합\n- .gitlab-ci.yml\n- 간편한 설정\n\n**3. GitHub Actions:**\n- GitHub 통합\n- YAML 기반 워크플로우\n- 무료 티어 제공\n\n**4. CircleCI:**\n- 클라우드 기반\n- 빠른 빌드\n- Docker 지원\n\n**5. Travis CI:**\n- GitHub 통합\n- 오픈소스 무료\n\n**6. AWS CodePipeline, Azure DevOps, Google Cloud Build:**\n- 클라우드 네이티브\n- 각 클라우드 플랫폼 통합\n\n---\n\n**실전 예시 (GitHub Actions):**\n\n**시나리오:**\n- Node.js 애플리케이션\n- main 브랜치 푸시 시 자동 배포\n\n**파이프라인:**\n\n**1. Trigger:**\n- main 브랜치 push\n\n**2. 빌드:**\n- Node.js 설치\n- npm install\n- npm run build\n\n**3. 테스트:**\n- npm test\n\n**4. Docker 이미지 빌드:**\n- docker build\n- Docker Hub에 푸시\n\n**5. 배포:**\n- SSH로 서버 접속\n- docker pull\n- docker-compose up -d\n\n**6. 알림:**\n- Slack 알림 (성공/실패)\n\n---\n\n**장점:**\n\n**1. 빠른 피드백:**\n- 코드 푸시 후 즉시 테스트 결과\n- 문제 조기 발견\n\n**2. 자동화:**\n- 수동 배포 없음\n- 반복 작업 제거\n\n**3. 일관성:**\n- 동일한 프로세스로 빌드/배포\n- 환경 차이 최소화\n\n**4. 품질 향상:**\n- 모든 변경에 자동 테스트\n- 코드 품질 유지\n\n**5. 빠른 배포:**\n- 기능 빠르게 출시\n- 버그 수정 신속 배포\n\n**6. 롤백 용이:**\n- 이전 버전으로 쉽게 롤백\n\n---\n\n**Best Practices:**\n\n**1. Pipeline as Code:**\n- Jenkinsfile, .gitlab-ci.yml 등\n- 버전 관리\n- 코드 리뷰\n\n**2. 작은 변경, 자주 통합:**\n- Feature branch는 짧게\n- 자주 merge\n\n**3. 빠른 빌드:**\n- 병렬 실행\n- 캐싱 활용\n- 10분 이내 목표\n\n**4. 포괄적 테스트:**\n- 유닛, 통합, E2E\n- 충분한 커버리지\n\n**5. 환경 분리:**\n- Dev, Staging, Production\n- 환경별 설정 관리\n\n**6. 보안:**\n- 시크릿 관리 (환경 변수, Vault)\n- 취약점 스캔\n- 이미지 스캔\n\n**7. 모니터링:**\n- 파이프라인 메트릭\n- 실패 알림\n- 배포 후 모니터링\n\n**8. 롤백 전략:**\n- 자동 롤백 조건\n- 빠른 롤백 절차\n\n---\n\n**일반적인 문제와 해결:**\n\n**1. 느린 빌드:**\n- 병렬화\n- 캐싱 (의존성, Docker 레이어)\n- 불필요한 단계 제거\n\n**2. Flaky 테스트:**\n- 불안정한 테스트 수정\n- Retry 로직 (신중히)\n\n**3. 환경 차이:**\n- Docker로 일관된 환경\n- Infrastructure as Code\n\n**4. 시크릿 관리:**\n- 환경 변수\n- AWS Secrets Manager, HashiCorp Vault\n\n---\n\n**배포 전략:**\n\n**1. Blue-Green:**\n- 두 개 환경 유지\n- 새 버전을 Green에 배포\n- 트래픽 전환\n- 롤백 빠름\n\n**2. Canary:**\n- 일부 트래픽만 새 버전으로\n- 점진적 확대\n- 문제 조기 감지\n\n**3. Rolling:**\n- 인스턴스를 하나씩 업데이트\n- 무중단 배포\n\n**4. Feature Flag:**\n- 코드는 배포, 기능은 비활성화\n- 런타임에 토글\n\n---\n\n**결론:**\n\nCI/CD는 현대 소프트웨어 개발의 필수 요소로, 코드 변경을 자동으로 빌드, 테스트, 배포하여 개발 속도와 품질을 향상시킵니다. Jenkins, GitHub Actions, GitLab CI 등 다양한 도구가 있으며, Pipeline as Code로 관리하는 것이 Best Practice입니다.",
      "type": "essay",
      "tags": [
        "CI/CD",
        "DevOps",
        "자동화",
        "배포"
      ],
      "id": "etc-005",
      "createdAt": "2025-11-17T15:00:00.000004",
      "studyCount": 0
    },
    {
      "question": "static 키워드는 어떤 의미를 갖나요?",
      "answer": "**static 키워드 개념:**\n\n**핵심 의미:**\n- **정적 (Static)**: 프로그램 실행 시 메모리에 고정 할당\n- **클래스 레벨**: 인스턴스가 아닌 클래스에 속함\n- **공유**: 모든 인스턴스가 같은 값 공유\n\n---\n\n**언어별 static 의미:**\n\n---\n\n**Java/C#:**\n\n**1. Static 변수 (클래스 변수):**\n\n**특징:**\n- 클래스에 속함 (인스턴스와 무관)\n- 모든 객체가 공유\n- 메모리에 한 번만 할당\n- 프로그램 시작 시 생성, 종료 시 소멸\n\n**사용:**\n- 클래스명.변수명으로 접근\n- 인스턴스 생성 없이 사용 가능\n\n**예시 용도:**\n- 상수 (static final)\n- 카운터 (객체 생성 횟수)\n- 공유 자원\n\n**2. Static 메서드 (클래스 메서드):**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출 가능\n- 인스턴스 변수/메서드 접근 불가\n- this 키워드 사용 불가\n\n**사용:**\n- 유틸리티 함수 (Math.max, Collections.sort)\n- 팩토리 메서드\n\n**3. Static 블록:**\n\n**특징:**\n- 클래스 로딩 시 한 번 실행\n- 초기화 코드\n\n**4. Static 내부 클래스:**\n\n**특징:**\n- 외부 클래스 인스턴스 없이 생성 가능\n- 외부 인스턴스 변수 접근 불가\n\n---\n\n**C/C++:**\n\n**1. Static 지역 변수:**\n\n**특징:**\n- 함수 내부 변수이지만 메모리에 계속 유지\n- 함수 종료 후에도 값 유지\n- 다음 호출 시 이전 값 사용\n\n**사용:**\n- 호출 횟수 카운터\n\n**2. Static 전역 변수/함수:**\n\n**특징:**\n- 파일 스코프 제한\n- 다른 파일에서 접근 불가\n- 내부 링크 (Internal Linkage)\n\n**사용:**\n- 파일 내부 헬퍼 함수\n- 캡슐화\n\n---\n\n**JavaScript (ES6+):**\n\n**Static 메서드:**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출\n- this는 클래스 자체\n\n**사용:**\n- 유틸리티 메서드\n\n---\n\n**Python:**\n\n**Static 메서드 (@staticmethod):**\n\n**특징:**\n- 클래스/인스턴스와 무관\n- self, cls 인자 없음\n- 순수 함수처럼 동작\n\n**vs 클래스 메서드 (@classmethod):**\n- classmethod는 cls 인자 받음\n- staticmethod는 인자 없음\n\n---\n\n**static의 주요 특징:**\n\n**1. 메모리:**\n- 힙이 아닌 데이터 영역 (또는 BSS)\n- 프로그램 시작 시 할당\n- 프로그램 종료 시 해제\n- 인스턴스마다 복사 안 됨\n\n**2. 생명주기:**\n- 프로그램 전체 수명\n- 인스턴스 생명주기와 무관\n\n**3. 접근:**\n- 클래스명으로 접근\n- 인스턴스로도 접근 가능 (권장 안 함)\n\n**4. 공유:**\n- 모든 인스턴스가 공유\n- 한 곳에서 변경하면 모든 곳에 반영\n\n**5. 오버라이딩:**\n- 불가 (대부분 언어)\n- 상속되지만 오버라이딩 안 됨\n\n---\n\n**장점:**\n\n**1. 메모리 효율:**\n- 인스턴스마다 복사 안 됨\n- 한 번만 할당\n\n**2. 유틸리티 함수:**\n- 인스턴스 생성 없이 사용\n- Math.sqrt, Integer.parseInt 등\n\n**3. 공유 데이터:**\n- 모든 인스턴스가 공유할 데이터\n\n**4. 싱글톤:**\n- static 변수로 인스턴스 관리\n\n---\n\n**단점:**\n\n**1. 전역 상태:**\n- 테스트 어려움\n- 예측 어려움\n\n**2. 멀티스레딩:**\n- 동시성 문제\n- 동기화 필요\n\n**3. 의존성:**\n- 강한 결합\n- Mock 어려움\n\n**4. OOP 위반:**\n- 객체 지향 원칙에 어긋남\n- 상태 공유\n\n---\n\n**사용 가이드:**\n\n**적합한 사용:**\n- 상수\n- 유틸리티 함수 (순수 함수)\n- 싱글톤 (신중히)\n- 팩토리 메서드\n\n**피해야 할 사용:**\n- 가변 전역 상태\n- 인스턴스 메서드를 static으로\n- 테스트 어려운 코드\n\n---\n\n**예시 시나리오:**\n\n**카운터:**\n- static 변수로 생성된 객체 수 추적\n- 생성자에서 증가\n\n**싱글톤:**\n- private static 인스턴스\n- public static getInstance()\n\n**유틸리티 클래스:**\n- 모든 메서드가 static\n- 인스턴스 생성 방지 (private 생성자)\n\n**상수:**\n- public static final\n- 변경 불가 공유 값\n\n---\n\n**멀티스레딩 주의:**\n\n**문제:**\n- 여러 스레드가 static 변수 동시 수정\n- Race condition\n\n**해결:**\n- synchronized\n- Atomic 클래스\n- ThreadLocal\n\n---\n\n**결론:**\n\nstatic 키워드는 **클래스 레벨의 정적 멤버**를 정의하며, 모든 인스턴스가 공유합니다. 유틸리티 함수와 상수에 유용하지만, 전역 상태로 인한 테스트와 동시성 문제에 주의해야 합니다.",
      "type": "essay",
      "tags": [
        "static",
        "Java",
        "메모리",
        "OOP"
      ],
      "id": "etc-006",
      "createdAt": "2025-11-17T15:00:00.000005",
      "studyCount": 0
    },
    {
      "question": "컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?",
      "answer": "**컴파일 및 런타임 처리:**\n\nstatic 키워드가 붙은 변수와 함수는 컴파일 시점과 런타임 시점에 특별하게 처리됩니다.\n\n---\n\n**1. 메모리 할당:**\n\n**데이터 영역 (또는 BSS 영역):**\n- static 변수는 스택이나 힙이 아닌 **데이터 영역**에 할당\n- 프로그램 시작 시 메모리 할당\n- 프로그램 종료 시 해제\n\n**영역 구분:**\n\n**Data 영역:**\n- 초기화된 static 변수\n- 컴파일 시 값 결정\n\n**BSS 영역 (Block Started by Symbol):**\n- 초기화되지 않은 static 변수\n- 0으로 초기화\n\n**vs 인스턴스 변수:**\n- 인스턴스 변수: 힙 (객체 생성 시 할당)\n- static 변수: 데이터 영역 (프로그램 시작 시 할당)\n\n**vs 지역 변수:**\n- 지역 변수: 스택 (함수 호출 시 할당)\n- static 변수: 데이터 영역 (계속 유지)\n\n---\n\n**2. 초기화:**\n\n**컴파일 타임:**\n- static 변수의 초기값이 컴파일 시 결정됨\n- 상수 표현식만 가능\n\n**런타임:**\n\n**Java:**\n- 클래스 로딩 시 static 변수 초기화\n- static 블록 실행\n- 클래스가 처음 사용될 때 (lazy)\n\n**C/C++:**\n- 프로그램 시작 시 초기화\n- main() 실행 전\n\n**순서:**\n- 선언 순서대로 초기화\n- static 블록 순서대로 실행\n\n---\n\n**3. 링크:**\n\n**C/C++에서:**\n\n**External Linkage (기본):**\n- 다른 파일에서 접근 가능\n- extern 키워드로 선언\n\n**Internal Linkage (static):**\n- 파일 내부로 제한\n- 다른 파일에서 접근 불가\n- 이름 충돌 방지\n\n**컴파일러 처리:**\n- static 함수/변수는 심볼 테이블에 파일 스코프로 표시\n- 링커가 외부 참조 허용 안 함\n\n---\n\n**4. 메서드 바인딩:**\n\n**Java:**\n\n**Static 메서드:**\n- **정적 바인딩 (Static Binding)**\n- 컴파일 타임에 호출 대상 결정\n- 오버라이딩 불가\n- vtable 사용 안 함\n\n**인스턴스 메서드:**\n- **동적 바인딩 (Dynamic Binding)**\n- 런타임에 호출 대상 결정 (다형성)\n- 오버라이딩 가능\n- vtable 사용\n\n**성능:**\n- static 메서드가 약간 더 빠름 (동적 디스패치 없음)\n- 실제로는 미미한 차이\n\n---\n\n**5. 메모리 레이아웃:**\n\n**프로그램 메모리 구조:**\n\n```\n+------------------+\n| Code (Text)      | ← 실행 코드\n+------------------+\n| Data             | ← 초기화된 static 변수\n+------------------+\n| BSS              | ← 초기화 안 된 static 변수\n+------------------+\n| Heap             | ← 동적 할당 (new)\n+------------------+\n| Stack            | ← 지역 변수, 함수 호출\n+------------------+\n```\n\n**static 변수:**\n- Data 또는 BSS 영역\n- 주소 고정 (컴파일 시 결정 가능)\n\n**인스턴스 변수:**\n- Heap 영역\n- 주소 런타임에 결정\n\n---\n\n**6. 컴파일러 최적화:**\n\n**인라이닝:**\n- static 함수는 인라이닝 후보\n- 파일 내부로 제한되므로 안전하게 인라인 가능\n\n**상수 전파:**\n- static final (Java) 또는 const static (C++)는 컴파일 시 값 대체\n\n**Dead Code Elimination:**\n- 사용되지 않는 static 함수 제거\n\n---\n\n**7. 클래스 로딩 (Java):**\n\n**단계:**\n\n**1. Loading:**\n- .class 파일을 메모리에 로드\n\n**2. Linking:**\n- Verification: 바이트코드 검증\n- Preparation: static 변수 메모리 할당 및 기본값 초기화\n- Resolution: 심볼릭 참조를 실제 메모리 주소로\n\n**3. Initialization:**\n- static 변수 초기화 (명시적 값)\n- static 블록 실행\n\n**시점:**\n- 클래스가 처음 사용될 때\n- 인스턴스 생성, static 멤버 접근, main() 포함 클래스 등\n\n**한 번만:**\n- 클래스 로딩은 JVM에서 한 번만\n- static 초기화도 한 번만\n\n---\n\n**8. ABI (Application Binary Interface):**\n\n**C/C++:**\n- static 함수는 외부 심볼 테이블에 노출 안 됨\n- 바이너리 크기 감소\n- 이름 충돌 방지\n\n---\n\n**9. 재배치 (Relocation):**\n\n**컴파일 시:**\n- static 변수 주소는 상대 주소\n\n**링크 시:**\n- 실제 메모리 주소로 재배치\n- 고정 주소\n\n---\n\n**10. 스레드 안전성:**\n\n**초기화:**\n- Java는 클래스 로딩 시 스레드 안전하게 초기화\n- JVM이 동기화 보장\n\n**사용:**\n- static 변수 접근은 동기화 안 됨\n- 멀티스레딩 시 명시적 동기화 필요\n\n---\n\n**성능 영향:**\n\n**메모리:**\n- 인스턴스 변수보다 메모리 효율적 (한 번만 할당)\n- 하지만 프로그램 전체 수명 동안 유지 (해제 안 됨)\n\n**접근 속도:**\n- 고정 주소 → 빠른 접근\n- 인스턴스 변수는 포인터 역참조 필요\n\n**메서드 호출:**\n- static 메서드는 정적 바인딩 → 약간 빠름\n- 실제로는 미미한 차이\n\n---\n\n**컴파일러별 차이:**\n\n**GCC (C/C++):**\n- static 함수는 .o 파일 내부 심볼\n- nm 명령으로 't' (로컬 텍스트) 표시\n\n**Java Compiler (javac):**\n- static 멤버는 바이트코드에서 ACC_STATIC 플래그\n- invokestatic 명령으로 호출\n\n---\n\n**결론:**\n\nstatic 변수는 컴파일 시 데이터/BSS 영역에 할당되고, 프로그램 시작 시 초기화됩니다. static 함수는 정적 바인딩으로 컴파일 타임에 호출 대상이 결정되며, 파일 스코프로 제한될 수 있습니다. 메모리 효율적이지만 프로그램 전체 수명 동안 유지됩니다.",
      "type": "essay",
      "tags": [
        "static",
        "컴파일",
        "메모리",
        "링크"
      ],
      "id": "etc-007",
      "createdAt": "2025-11-17T15:00:00.000006",
      "studyCount": 0
    },
    {
      "question": "Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요?",
      "answer": "**키워드별 차이:**\n\n---\n\n**1. static:**\n\n**의미:**\n- 클래스 레벨 변수\n- 모든 인스턴스가 공유\n- 변경 가능\n\n**특징:**\n- 값 수정 가능\n- 인스턴스와 무관\n- 메모리에 한 번만 할당\n\n**사용:**\n- 공유 데이터\n- 카운터\n\n---\n\n**2. static final:**\n\n**의미:**\n- 클래스 레벨 상수\n- 모든 인스턴스가 공유\n- **변경 불가**\n\n**특징:**\n- 선언 시 또는 static 블록에서 초기화\n- 재할당 불가\n- 컴파일 타임 상수 (원시 타입/String)\n\n**사용:**\n- 상수 (PI, MAX_VALUE)\n- 설정값\n\n---\n\n**3. final:**\n\n**의미:**\n- 인스턴스 레벨 상수\n- 인스턴스마다 값이 다를 수 있음\n- **변경 불가**\n\n**특징:**\n- 생성자에서 초기화\n- 인스턴스마다 별도 메모리\n- 재할당 불가\n\n**사용:**\n- 불변 객체의 필드\n- 생성 시 결정되는 값\n\n---\n\n**비교표:**\n\n| 특성 | static | static final | final |\n|------|--------|--------------|-------|\n| **수준** | 클래스 | 클래스 | 인스턴스 |\n| **공유** | 모든 인스턴스 | 모든 인스턴스 | 개별 인스턴스 |\n| **변경** | 가능 | 불가 | 불가 |\n| **메모리** | 한 번 할당 | 한 번 할당 | 인스턴스마다 |\n| **초기화** | 선언 시/static 블록 | 선언 시/static 블록 | 선언 시/생성자 |\n| **컴파일 상수** | X | O (원시/String) | X |\n\n---\n\n**static vs static final:**\n\n**공통점:**\n- 클래스 레벨\n- 모든 인스턴스 공유\n- 메모리 한 번 할당\n\n**차이점:**\n\n**static:**\n- 값 변경 가능\n- 가변 공유 상태\n\n**static final:**\n- 값 변경 불가\n- 상수\n\n**언제 사용:**\n\n**static:**\n- 공유 카운터\n- 싱글톤 인스턴스\n\n**static final:**\n- 상수 (Math.PI)\n- 설정값\n- 열거형 대안\n\n---\n\n**final vs static final:**\n\n**공통점:**\n- 값 변경 불가 (재할당 불가)\n\n**차이점:**\n\n**final:**\n- 인스턴스마다 별도 값\n- 생성자에서 초기화 가능\n- 인스턴스마다 메모리 할당\n\n**static final:**\n- 모든 인스턴스 같은 값\n- 선언 시 또는 static 블록에서만 초기화\n- 메모리 한 번만 할당\n\n**언제 사용:**\n\n**final:**\n- 생성 시 결정되는 불변 값\n- 인스턴스별로 다를 수 있음\n\n**static final:**\n- 모든 인스턴스에 동일한 상수\n- 컴파일 타임 상수\n\n---\n\n**컴파일 타임 상수:**\n\n**static final (원시 타입/String):**\n- 컴파일러가 값을 코드에 직접 삽입\n- 성능 최적화\n- 클래스 로딩 없이 사용 가능\n\n**final (인스턴스):**\n- 런타임에 값 결정\n- 컴파일 타임 상수 아님\n\n---\n\n**메모리 효율:**\n\n**static final:**\n- 한 번만 할당\n- 모든 인스턴스가 참조\n- 메모리 효율적\n\n**final:**\n- 인스턴스마다 할당\n- 메모리 더 사용\n\n**예:**\n- 100개 인스턴스\n- static final: 1개 메모리\n- final: 100개 메모리\n\n---\n\n**초기화 시점:**\n\n**static:**\n- 클래스 로딩 시\n- static 블록에서도 가능\n- 여러 번 변경 가능\n\n**static final:**\n- 클래스 로딩 시 한 번만\n- 선언 시 또는 static 블록\n- 이후 변경 불가\n\n**final:**\n- 인스턴스 생성 시\n- 선언 시 또는 생성자\n- 이후 변경 불가\n\n---\n\n**참조 타입에서의 차이:**\n\n**주의:**\n- final은 재할당만 방지\n- 객체 내부 상태는 변경 가능\n\n**static final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**진짜 불변:**\n- 참조를 final로\n- 객체도 불변으로 설계 (모든 필드 final, setter 없음)\n\n---\n\n**사용 패턴:**\n\n**static final 상수:**\n- public static final double PI = 3.14159;\n- public static final int MAX_USERS = 1000;\n\n**static 싱글톤:**\n- private static instance;\n- public static getInstance()\n\n**final 불변 필드:**\n- private final String id;\n- 생성자에서 초기화\n\n---\n\n**성능:**\n\n**static final 상수:**\n- 컴파일 타임 인라인\n- 가장 빠름\n\n**static:**\n- 고정 주소\n- 빠른 접근\n\n**final:**\n- 인스턴스 필드 접근\n- 약간 느림 (포인터 역참조)\n\n---\n\n**Thread Safety:**\n\n**static:**\n- 공유 상태 → 동기화 필요\n\n**static final (불변 객체):**\n- 스레드 안전 (값 변경 안 됨)\n\n**final:**\n- 객체가 불변이면 스레드 안전\n- 가변 객체면 동기화 필요\n\n---\n\n**Best Practices:**\n\n**1. 상수는 static final:**\n- public static final로 선언\n- 대문자 + 언더스코어 (UPPER_CASE)\n\n**2. 가변 공유 상태는 주의:**\n- static 변수는 최소화\n- 동기화 고려\n\n**3. 불변 객체는 final:**\n- 모든 필드 final\n- setter 없음\n- 방어적 복사\n\n**4. 싱글톤은 static:**\n- private static instance\n- enum 싱글톤 권장\n\n---\n\n**결론:**\n\n- **static**: 클래스 레벨 가변 변수\n- **static final**: 클래스 레벨 상수 (컴파일 타임 상수 가능)\n- **final**: 인스턴스 레벨 상수 (생성 시 결정)\n\n용도에 맞게 선택하되, 상수는 static final, 불변 필드는 final, 공유 가변 상태는 신중히 사용하세요.",
      "type": "essay",
      "tags": [
        "Java",
        "static",
        "final",
        "상수"
      ],
      "id": "etc-008",
      "createdAt": "2025-11-17T15:00:00.000007",
      "studyCount": 0
    },
    {
      "question": "객체지향 프로그래밍이 무엇인가요?",
      "answer": "**객체지향 프로그래밍 (OOP: Object-Oriented Programming):**\n\n**정의:**\n- 프로그램을 **객체(Object)**들의 모음으로 구성하는 프로그래밍 패러다임\n- 객체는 데이터(속성)와 행동(메서드)을 하나로 묶은 단위\n- 현실 세계의 개념을 모델링\n\n---\n\n**핵심 개념:**\n\n**1. 객체 (Object):**\n- 데이터와 기능을 함께 캡슐화한 단위\n- 상태(속성)와 행동(메서드) 포함\n\n**2. 클래스 (Class):**\n- 객체를 생성하기 위한 설계도/템플릿\n- 공통 속성과 메서드 정의\n\n**3. 인스턴스 (Instance):**\n- 클래스로부터 생성된 실제 객체\n\n---\n\n**OOP의 4대 특징:**\n\n**1. 캡슐화 (Encapsulation):**\n\n**개념:**\n- 데이터와 메서드를 하나로 묶음\n- 내부 구현을 숨기고 인터페이스만 노출\n\n**목적:**\n- 정보 은닉\n- 무결성 보호\n- 변경 영향 최소화\n\n**구현:**\n- private 필드\n- public getter/setter\n- 직접 접근 차단\n\n---\n\n**2. 상속 (Inheritance):**\n\n**개념:**\n- 기존 클래스의 속성과 메서드를 물려받음\n- 코드 재사용\n\n**장점:**\n- 중복 코드 감소\n- 계층 구조 표현\n- 확장 용이\n\n**주의:**\n- 과도한 상속은 복잡도 증가\n- 구성(Composition) 우선 고려\n\n---\n\n**3. 다형성 (Polymorphism):**\n\n**개념:**\n- 같은 인터페이스로 다른 동작\n- 하나의 타입으로 여러 객체 다룸\n\n**종류:**\n- 오버로딩 (컴파일 타임)\n- 오버라이딩 (런타임)\n\n**장점:**\n- 유연성\n- 확장성\n- 코드 간결\n\n---\n\n**4. 추상화 (Abstraction):**\n\n**개념:**\n- 복잡한 세부사항 숨김\n- 핵심 개념만 표현\n\n**구현:**\n- 추상 클래스\n- 인터페이스\n\n**목적:**\n- 복잡도 관리\n- 공통 기능 정의\n- 구현 분리\n\n---\n\n**장점:**\n\n**1. 코드 재사용:**\n- 상속, 다형성으로 중복 감소\n\n**2. 유지보수:**\n- 캡슐화로 변경 영향 최소화\n- 모듈화\n\n**3. 확장성:**\n- 새로운 클래스 추가 용이\n- 기존 코드 수정 최소\n\n**4. 모델링:**\n- 현실 세계 직관적 표현\n- 이해하기 쉬움\n\n**5. 협업:**\n- 명확한 인터페이스\n- 역할 분담\n\n---\n\n**단점:**\n\n**1. 복잡도:**\n- 작은 프로그램에는 과도\n- 학습 곡선\n\n**2. 성능:**\n- 간접 호출 (vtable)\n- 메모리 오버헤드\n\n**3. 설계:**\n- 초기 설계 중요\n- 잘못된 설계는 오히려 복잡\n\n---\n\n**vs 절차적 프로그래밍:**\n\n| 항목 | 절차적 | 객체지향 |\n|------|--------|----------|\n| 중심 | 함수 | 객체 |\n| 데이터 | 전역/지역 변수 | 객체 내부 캡슐화 |\n| 재사용 | 함수 재사용 | 상속, 다형성 |\n| 확장 | 어려움 | 용이 |\n| 복잡도 | 낮음 (작은 프로그램) | 높음 (큰 프로그램에 유리) |\n\n---\n\n**vs 함수형 프로그래밍:**\n\n| 항목 | 객체지향 | 함수형 |\n|------|----------|--------|\n| 상태 | 객체 내부 상태 | 불변 |\n| 부수효과 | 허용 | 최소화 |\n| 데이터 | 캡슐화 | 변환 |\n| 재사용 | 상속, 다형성 | 고차 함수, 합성 |\n\n---\n\n**설계 원칙:**\n\n**SOLID:**\n- 단일 책임 원칙\n- 개방-폐쇄 원칙\n- 리스코프 치환 원칙\n- 인터페이스 분리 원칙\n- 의존관계 역전 원칙\n\n**DRY (Don't Repeat Yourself):**\n- 중복 제거\n\n**KISS (Keep It Simple, Stupid):**\n- 단순하게\n\n**YAGNI (You Aren't Gonna Need It):**\n- 필요한 것만 구현\n\n---\n\n**적용 시나리오:**\n\n**적합:**\n- 대규모 프로젝트\n- 복잡한 도메인\n- 팀 협업\n- 장기 유지보수\n- GUI 애플리케이션\n\n**부적합:**\n- 간단한 스크립트\n- 성능 크리티컬\n- 함수형 패러다임 더 적합한 경우\n\n---\n\n**주요 언어:**\n\n**순수 OOP:**\n- Java, C#, Smalltalk\n\n**멀티 패러다임:**\n- Python, C++, JavaScript, Kotlin\n\n---\n\n**결론:**\n\n객체지향 프로그래밍은 **캡슐화, 상속, 다형성, 추상화**를 통해 현실 세계를 모델링하고 코드 재사용과 유지보수성을 향상시키는 패러다임입니다. 대규모 프로젝트와 팀 협업에 유리하지만, 적절한 설계가 중요합니다.",
      "type": "essay",
      "tags": [
        "OOP",
        "객체지향",
        "캡슐화",
        "상속",
        "다형성"
      ],
      "id": "etc-009",
      "createdAt": "2025-11-17T15:00:00.000008",
      "studyCount": 0
    },
    {
      "question": "SOLID 원칙에 대해 설명해 주세요.",
      "answer": "**SOLID 원칙:**\n\n객체지향 설계의 5가지 기본 원칙으로, 유지보수와 확장이 쉬운 소프트웨어를 만들기 위한 가이드라인입니다.\n\n---\n\n**1. SRP (Single Responsibility Principle) - 단일 책임 원칙:**\n\n**정의:**\n- 클래스는 하나의 책임만 가져야 함\n- 변경 이유가 하나여야 함\n\n**의미:**\n- 한 클래스는 한 가지 일만\n- 여러 기능을 하나에 넣지 않음\n\n**위반 예:**\n- User 클래스가 DB 저장, 이메일 전송, 로깅 모두 수행\n\n**준수:**\n- User 클래스: 사용자 데이터만\n- UserRepository: DB 저장\n- EmailService: 이메일 전송\n- Logger: 로깅\n\n**장점:**\n- 변경 영향 최소화\n- 테스트 용이\n- 이해하기 쉬움\n\n---\n\n**2. OCP (Open-Closed Principle) - 개방-폐쇄 원칙:**\n\n**정의:**\n- 확장에는 열려 있고, 수정에는 닫혀 있어야 함\n- 기존 코드 수정 없이 기능 추가\n\n**의미:**\n- 새 기능 추가 시 기존 코드 변경 최소화\n- 인터페이스, 추상 클래스 활용\n\n**위반 예:**\n- 결제 방법 추가할 때마다 결제 클래스 수정\n\n**준수:**\n- Payment 인터페이스 정의\n- CreditCardPayment, PayPalPayment 구현\n- 새 결제 방법은 새 클래스 추가만\n\n**구현:**\n- 인터페이스/추상 클래스\n- 전략 패턴\n- 템플릿 메서드 패턴\n\n**장점:**\n- 기존 코드 안정성\n- 확장 용이\n\n---\n\n**3. LSP (Liskov Substitution Principle) - 리스코프 치환 원칙:**\n\n**정의:**\n- 서브타입은 기반타입으로 교체 가능해야 함\n- 부모 클래스 대신 자식 클래스 사용해도 문제없어야 함\n\n**의미:**\n- 상속 시 부모의 동작을 완전히 대체\n- 자식이 부모의 계약 위반하면 안 됨\n\n**위반 예:**\n- Rectangle (직사각형) → Square (정사각형) 상속\n- Square는 width와 height가 같아야 함\n- setWidth 호출 시 예상과 다르게 동작\n\n**준수:**\n- 올바른 추상화\n- is-a 관계 재검토\n- 계약(contract) 준수\n\n**장점:**\n- 다형성 안전\n- 예측 가능\n\n---\n\n**4. ISP (Interface Segregation Principle) - 인터페이스 분리 원칙:**\n\n**정의:**\n- 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함\n- 인터페이스를 작고 구체적으로\n\n**의미:**\n- 큰 인터페이스를 여러 작은 인터페이스로 분리\n- 필요한 것만 구현\n\n**위반 예:**\n- Printer 인터페이스: print, scan, fax\n- 단순 프린터는 scan, fax 불필요\n\n**준수:**\n- Printable 인터페이스: print\n- Scannable 인터페이스: scan\n- Faxable 인터페이스: fax\n- 필요한 인터페이스만 구현\n\n**장점:**\n- 불필요한 의존성 제거\n- 인터페이스 명확\n- 변경 영향 최소\n\n---\n\n**5. DIP (Dependency Inversion Principle) - 의존관계 역전 원칙:**\n\n**정의:**\n- 고수준 모듈은 저수준 모듈에 의존하지 않아야 함\n- 둘 다 추상화에 의존\n\n**의미:**\n- 구체 클래스가 아닌 인터페이스에 의존\n- 의존성 주입 (Dependency Injection)\n\n**위반 예:**\n- UserService가 MySQLUserRepository에 직접 의존\n\n**준수:**\n- UserService가 UserRepository 인터페이스에 의존\n- MySQLUserRepository, MongoUserRepository 모두 구현 가능\n- 의존성 주입으로 구현체 전달\n\n**장점:**\n- 결합도 낮춤\n- 테스트 용이 (Mock 가능)\n- 유연성\n\n---\n\n**SOLID 종합 효과:**\n\n**1. 유지보수성:**\n- 변경 영향 최소화\n- 이해하기 쉬움\n\n**2. 확장성:**\n- 새 기능 추가 용이\n- 기존 코드 수정 최소\n\n**3. 테스트:**\n- 단위 테스트 작성 쉬움\n- Mock 가능\n\n**4. 재사용:**\n- 모듈화\n- 다른 프로젝트에 재사용\n\n**5. 유연성:**\n- 요구사항 변경에 대응\n\n---\n\n**적용 가이드:**\n\n**균형:**\n- 모든 원칙을 항상 완벽히 지킬 필요 없음\n- 과도한 추상화는 복잡도 증가\n- 실용성과 원칙의 균형\n\n**점진적:**\n- 처음부터 완벽한 설계 어려움\n- 리팩토링으로 점진적 개선\n\n**상황 판단:**\n- 프로젝트 규모와 복잡도 고려\n- 작은 프로젝트는 간단하게\n\n---\n\n**실전 적용:**\n\n**의존성 주입:**\n- DIP 구현\n- Spring, Dagger 등 프레임워크 활용\n\n**인터페이스 설계:**\n- ISP 고려\n- 작고 명확한 인터페이스\n\n**리팩토링:**\n- 코드 스멜 발견 시 SOLID 검토\n- 지속적 개선\n\n---\n\n**결론:**\n\nSOLID 원칙은 **단일 책임, 개방-폐쇄, 리스코프 치환, 인터페이스 분리, 의존관계 역전**으로, 유지보수와 확장이 쉬운 객체지향 설계를 위한 핵심 가이드라인입니다. 실용성과 균형을 유지하며 적용하세요.",
      "type": "essay",
      "tags": [
        "SOLID",
        "설계원칙",
        "OOP",
        "SRP",
        "OCP",
        "LSP",
        "ISP",
        "DIP"
      ],
      "id": "etc-010",
      "createdAt": "2025-11-17T15:00:00.000009",
      "studyCount": 0
    },
    {
      "question": "다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.",
      "answer": "**다형성 (Polymorphism):**\n\n**정의:**\n- \"여러 형태\" (poly: 여러, morph: 형태)\n- 같은 인터페이스로 다른 동작을 수행\n- 하나의 타입으로 여러 객체를 다룸\n\n**핵심:**\n- 동일한 메서드 호출이 객체에 따라 다르게 동작\n\n---\n\n**정적 다형성 (Static/Compile-time Polymorphism):**\n\n**정의:**\n- 컴파일 타임에 결정\n- 컴파일러가 어떤 메서드 호출할지 결정\n\n**구현 방법:**\n\n**1. 오버로딩 (Overloading):**\n\n**메서드 오버로딩:**\n- 같은 이름, 다른 파라미터\n- 컴파일러가 파라미터로 구분\n\n**특징:**\n- 같은 클래스 내\n- 파라미터 타입/개수/순서 다름\n- 리턴 타입만 다른 것은 안 됨\n\n**연산자 오버로딩 (C++):**\n- 연산자 동작 재정의\n- Java는 미지원\n\n**2. 템플릿/제네릭:**\n- 타입을 파라미터로\n- 컴파일 시 타입 결정\n\n**장점:**\n- 빠름 (런타임 오버헤드 없음)\n- 타입 안전\n\n**단점:**\n- 유연성 부족\n- 컴파일 시 결정되어 변경 불가\n\n---\n\n**동적 다형성 (Dynamic/Runtime Polymorphism):**\n\n**정의:**\n- 런타임에 결정\n- 실제 객체 타입에 따라 메서드 결정\n\n**구현 방법:**\n\n**1. 오버라이딩 (Overriding):**\n\n**메서드 오버라이딩:**\n- 부모 클래스 메서드를 자식이 재정의\n- 같은 시그니처\n\n**특징:**\n- 상속 관계\n- 메서드 이름, 파라미터, 리턴 타입 동일\n- @Override 어노테이션 (Java)\n\n**2. 인터페이스 구현:**\n- 인터페이스 메서드 구현\n- 여러 구현체\n\n**메커니즘:**\n\n**가상 함수 테이블 (vtable):**\n- 각 클래스가 가상 함수 포인터 테이블 보유\n- 런타임에 vtable 참조하여 실제 메서드 호출\n- 약간의 성능 오버헤드\n\n**장점:**\n- 유연성 (런타임 결정)\n- 확장성 (새 클래스 추가)\n- 다형성의 진정한 힘\n\n**단점:**\n- 런타임 오버헤드 (vtable 참조)\n- 약간 느림\n\n---\n\n**비교:**\n\n| 항목 | 정적 다형성 | 동적 다형성 |\n|------|-------------|-------------|\n| **결정 시점** | 컴파일 타임 | 런타임 |\n| **구현** | 오버로딩, 템플릿 | 오버라이딩, 인터페이스 |\n| **바인딩** | 정적 바인딩 | 동적 바인딩 |\n| **성능** | 빠름 | 약간 느림 (vtable) |\n| **유연성** | 낮음 | 높음 |\n| **확장** | 컴파일 시 결정 | 런타임 확장 가능 |\n| **예** | print(int), print(String) | Animal.speak() → Dog, Cat |\n\n---\n\n**동적 다형성 예시:**\n\n**시나리오:**\n- Animal 부모 클래스\n- Dog, Cat 자식 클래스\n- speak() 메서드 오버라이딩\n\n**효과:**\n- Animal 타입으로 Dog, Cat 다룸\n- speak() 호출 시 실제 객체에 따라 다르게 동작\n- Dog: \"멍멍\", Cat: \"야옹\"\n\n**장점:**\n- 새 동물 추가 시 Animal 타입으로 다룸\n- 기존 코드 수정 불필요\n- 확장에 열려 있음 (OCP)\n\n---\n\n**정적 다형성 예시:**\n\n**메서드 오버로딩:**\n- print(int x)\n- print(String s)\n- print(double d)\n\n**효과:**\n- 같은 이름 print\n- 파라미터 타입에 따라 다른 메서드 호출\n- 컴파일러가 결정\n\n---\n\n**다형성의 장점:**\n\n**1. 코드 재사용:**\n- 공통 인터페이스로 여러 구현\n\n**2. 확장성:**\n- 새 클래스 추가 용이\n- 기존 코드 수정 최소\n\n**3. 유지보수:**\n- 변경 영향 최소화\n\n**4. 유연성:**\n- 런타임에 동작 변경\n\n**5. 간결함:**\n- 타입별 분기 불필요\n\n---\n\n**다형성 활용 패턴:**\n\n**1. 전략 패턴 (Strategy):**\n- 알고리즘을 인터페이스로\n- 런타임에 전략 교체\n\n**2. 템플릿 메서드 (Template Method):**\n- 골격은 부모가 정의\n- 세부는 자식이 구현\n\n**3. 팩토리 (Factory):**\n- 인터페이스 타입 반환\n- 실제 구현체는 숨김\n\n**4. 의존성 주입 (DI):**\n- 인터페이스에 의존\n- 구현체는 주입\n\n---\n\n**주의사항:**\n\n**1. 오버라이딩 규칙:**\n- 접근 제어자: 더 넓게 또는 같게\n- 예외: 더 좁게 또는 같게\n- 리턴 타입: 공변 반환 타입 가능\n\n**2. final 메서드:**\n- 오버라이딩 불가\n\n**3. static 메서드:**\n- 오버라이딩 불가\n- 정적 바인딩\n\n**4. private 메서드:**\n- 오버라이딩 불가 (접근 불가)\n\n---\n\n**언어별 차이:**\n\n**Java:**\n- 기본적으로 모든 메서드가 가상 (오버라이딩 가능)\n- final로 방지\n\n**C++:**\n- virtual 키워드 명시 필요\n- 명시하지 않으면 정적 바인딩\n\n**Python:**\n- 모든 메서드가 가상\n- 덕 타이핑\n\n---\n\n**결론:**\n\n다형성은 **같은 인터페이스로 다른 동작**을 수행하는 OOP의 핵심입니다. **정적 다형성**(오버로딩, 컴파일 타임)은 빠르고, **동적 다형성**(오버라이딩, 런타임)은 유연합니다. 상황에 맞게 활용하세요.",
      "type": "essay",
      "tags": [
        "다형성",
        "Polymorphism",
        "오버로딩",
        "오버라이딩",
        "OOP"
      ],
      "id": "etc-011",
      "createdAt": "2025-11-17T15:00:00.000010",
      "studyCount": 0
    },
    {
      "question": "오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.",
      "answer": "**오버로딩 (Overloading):**\n\n**정의:**\n- 같은 이름의 메서드를 여러 개 정의\n- 파라미터가 다름 (타입, 개수, 순서)\n\n**조건:**\n- 메서드 이름: 동일\n- 파라미터: 타입, 개수, 순서 중 하나 이상 다름\n- 리턴 타입: 무관 (리턴 타입만 다른 것은 불가)\n- 접근 제어자: 무관\n\n**위치:**\n- 같은 클래스 내\n\n**바인딩:**\n- 정적 바인딩 (컴파일 타임)\n- 컴파일러가 파라미터로 구분\n\n**목적:**\n- 같은 기능을 다양한 파라미터로 제공\n- 편의성\n\n**다형성:**\n- 정적 다형성 (Compile-time Polymorphism)\n\n---\n\n**오버라이딩 (Overriding):**\n\n**정의:**\n- 부모 클래스의 메서드를 자식 클래스에서 재정의\n- 같은 시그니처\n\n**조건:**\n- 메서드 이름: 동일\n- 파라미터: 완전히 동일 (타입, 개수, 순서)\n- 리턴 타입: 동일 (또는 공변 반환 타입)\n- 접근 제어자: 같거나 더 넓게\n- 예외: 같거나 더 좁게\n\n**위치:**\n- 상속 관계 (부모-자식)\n\n**바인딩:**\n- 동적 바인딩 (런타임)\n- 실제 객체 타입으로 결정\n\n**목적:**\n- 부모 메서드 동작을 변경\n- 자식마다 다른 구현\n\n**다형성:**\n- 동적 다형성 (Runtime Polymorphism)\n\n**어노테이션:**\n- @Override (Java, 권장)\n\n---\n\n**비교표:**\n\n| 항목 | 오버로딩 | 오버라이딩 |\n|------|----------|-----------|\n| **정의** | 같은 이름, 다른 파라미터 | 부모 메서드 재정의 |\n| **위치** | 같은 클래스 | 상속 관계 |\n| **파라미터** | 다름 | 동일 |\n| **리턴 타입** | 무관 | 동일 (공변 가능) |\n| **접근 제어자** | 무관 | 같거나 넓게 |\n| **바인딩** | 정적 (컴파일 타임) | 동적 (런타임) |\n| **다형성** | 정적 다형성 | 동적 다형성 |\n| **목적** | 편의성 | 기능 변경 |\n| **키워드** | 없음 | @Override (권장) |\n\n---\n\n**오버로딩 예시:**\n\n**시나리오:**\n- print 메서드를 다양한 타입으로\n\n**구현:**\n- print(int x)\n- print(String s)\n- print(int x, int y)\n\n**효과:**\n- 같은 이름 print\n- 파라미터에 따라 다른 메서드 호출\n- 컴파일러가 자동 선택\n\n**장점:**\n- 일관된 메서드 이름\n- 사용 편의\n\n---\n\n**오버라이딩 예시:**\n\n**시나리오:**\n- Animal 부모 클래스의 speak() 메서드\n- Dog, Cat 자식 클래스에서 재정의\n\n**구현:**\n- Animal: speak() → \"소리\"\n- Dog: speak() → \"멍멍\" (오버라이딩)\n- Cat: speak() → \"야옹\" (오버라이딩)\n\n**효과:**\n- Animal 타입으로 Dog, Cat 다룸\n- speak() 호출 시 실제 객체에 따라 다르게 동작\n- 런타임에 결정\n\n**장점:**\n- 다형성\n- 확장성\n\n---\n\n**주의사항:**\n\n**오버로딩:**\n\n**1. 리턴 타입만 다른 것은 불가:**\n- 오류 발생\n- 파라미터가 달라야 함\n\n**2. 가변 인자 (Varargs):**\n- 가장 낮은 우선순위\n- 정확히 맞는 메서드가 없을 때 선택\n\n**3. 자동 형변환:**\n- 작은 타입 → 큰 타입 자동 변환\n- int → long 가능\n\n---\n\n**오버라이딩:**\n\n**1. 접근 제어자:**\n- 더 좁게 불가\n- protected → public (가능)\n- public → protected (불가)\n\n**2. 예외:**\n- 더 넓은 예외 불가\n- IOException → Exception (불가)\n- Exception → IOException (가능)\n\n**3. 리턴 타입 (공변 반환 타입):**\n- 자식 타입 가능\n- Animal → Dog (가능, Java 5+)\n\n**4. final 메서드:**\n- 오버라이딩 불가\n\n**5. static 메서드:**\n- 오버라이딩 불가 (숨김, Hiding)\n\n**6. private 메서드:**\n- 오버라이딩 불가 (접근 불가)\n\n---\n\n**오버라이딩 규칙 위반:**\n\n**시그니처 다름:**\n- 오버라이딩 아님\n- 별개 메서드 (오버로딩도 아님)\n\n**접근 제어자 좁힘:**\n- 컴파일 에러\n\n**더 넓은 예외:**\n- 컴파일 에러\n\n---\n\n**@Override 어노테이션:**\n\n**역할:**\n- 오버라이딩 의도 명시\n- 컴파일러가 검증\n\n**장점:**\n- 실수 방지 (오타, 시그니처 불일치)\n- 가독성\n\n**권장:**\n- 항상 사용\n\n---\n\n**언어별 차이:**\n\n**Java:**\n- 모든 메서드 기본적으로 가상 (오버라이딩 가능)\n- final로 방지\n\n**C++:**\n- virtual 키워드 명시 필요\n- 명시 안 하면 오버라이딩 안 됨 (숨김)\n\n**Python:**\n- 모든 메서드 가상\n- 별도 키워드 없음\n\n---\n\n**실전 사용:**\n\n**오버로딩:**\n- 생성자 오버로딩 (다양한 초기화 방법)\n- 유틸리티 메서드 (다양한 입력 처리)\n\n**오버라이딩:**\n- 템플릿 메서드 패턴\n- 전략 패턴\n- 다형성 활용\n\n---\n\n**성능:**\n\n**오버로딩:**\n- 정적 바인딩 → 빠름\n- 컴파일 시 결정되어 오버헤드 없음\n\n**오버라이딩:**\n- 동적 바인딩 → 약간 느림\n- vtable 참조 오버헤드 (미미)\n\n---\n\n**결론:**\n\n**오버로딩:**\n- 같은 이름, 다른 파라미터\n- 같은 클래스 내\n- 정적 바인딩\n- 편의성\n\n**오버라이딩:**\n- 부모 메서드 재정의\n- 상속 관계\n- 동적 바인딩\n- 다형성\n\n두 개념은 이름만 비슷하고 완전히 다른 개념입니다.",
      "type": "essay",
      "tags": [
        "오버로딩",
        "오버라이딩",
        "Overloading",
        "Overriding",
        "OOP"
      ],
      "id": "etc-012",
      "createdAt": "2025-11-17T15:00:00.000011",
      "studyCount": 0
    },
    {
      "question": "클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까요? 그 반대는 성립하나요?",
      "answer": "**클래스 → 객체지향?**\n\n**답변: 아니요, 반드시 그렇지 않습니다.**\n\n---\n\n**클래스가 있어도 객체지향이 아닐 수 있는 이유:**\n\n**1. 객체지향의 핵심:**\n- 캡슐화, 상속, 다형성, 추상화\n- 클래스는 단지 도구일 뿐\n\n**2. 클래스를 절차적으로 사용:**\n- 클래스를 단순히 데이터 구조체로만 사용\n- 절차적 함수들을 모아놓은 네임스페이스로 사용\n- OOP 원칙 무시\n\n**예시 (C++):**\n- C++는 클래스 지원\n- 하지만 절차적으로 코딩 가능\n- struct와 함수 중심 코드\n\n**예시 (Python):**\n- 클래스 있지만 멀티 패러다임\n- 절차적, 함수형으로도 작성 가능\n\n**3. 단순 데이터 홀더:**\n- getter/setter만 있는 클래스\n- 빈약한 도메인 모델 (Anemic Domain Model)\n- 객체지향이라 보기 어려움\n\n---\n\n**진정한 객체지향:**\n\n**필요 조건:**\n- 캡슐화 (데이터와 행동 결합, 정보 은닉)\n- 상속 (코드 재사용)\n- 다형성 (동적 바인딩)\n- 추상화 (인터페이스/추상 클래스)\n\n**철학:**\n- 메시지 전달\n- 책임 주도 설계\n- SOLID 원칙\n\n**단순히 클래스 사용 ≠ 객체지향**\n\n---\n\n**객체지향 → 클래스?**\n\n**답변: 아니요, 반드시 그렇지 않습니다.**\n\n---\n\n**클래스 없이도 객체지향 가능:**\n\n**1. 프로토타입 기반 (Prototype-based):**\n\n**JavaScript (ES5 이전):**\n- 클래스 없음 (ES6 이전)\n- 프로토타입 체인으로 상속\n- 객체에서 객체 생성\n- 객체지향 가능\n\n**Self 언어:**\n- 순수 프로토타입 기반\n- 클래스 개념 없음\n\n**특징:**\n- 클래스 대신 프로토타입 객체\n- 동적으로 객체 생성 및 확장\n- 상속은 프로토타입 체인\n\n**2. 덕 타이핑 (Duck Typing):**\n\n**Python, Ruby:**\n- 클래스 있지만 필수 아님\n- 인터페이스 대신 덕 타이핑\n- \"오리처럼 걷고 꽥꽥거리면 오리다\"\n- 타입보다 행동 중심\n\n**3. 구조체 + 함수 포인터:**\n\n**C:**\n- 클래스 없음\n- struct + 함수 포인터로 OOP 흉내\n- 캡슐화, 다형성 구현 가능 (제한적)\n\n---\n\n**정리:**\n\n**클래스 → 객체지향?**\n- **X**: 클래스 있어도 절차적으로 사용 가능\n- 클래스는 도구, OOP는 설계 철학\n\n**객체지향 → 클래스?**\n- **X**: 프로토타입 기반 (JavaScript), 덕 타이핑 등\n- 클래스 없이도 OOP 가능\n\n---\n\n**핵심:**\n\n**클래스:**\n- 구현 메커니즘\n- 문법적 도구\n\n**객체지향:**\n- 설계 패러다임\n- 철학 (캡슐화, 상속, 다형성, 추상화)\n\n**클래스 ≠ 객체지향**\n\n---\n\n**실제 사례:**\n\n**클래스 있지만 비객체지향:**\n- C++ 코드를 C 스타일로 작성\n- Java로 절차적 프로그래밍\n- 단순 데이터 클래스만 사용\n\n**클래스 없지만 객체지향:**\n- JavaScript (ES5 이전) 프로토타입\n- Self 언어\n- Lua 테이블 기반 OOP\n\n---\n\n**멀티 패러다임 언어:**\n\n**Python, JavaScript, C++, Scala:**\n- 객체지향, 절차적, 함수형 모두 가능\n- 클래스 지원하지만 강제 아님\n- 개발자 선택\n\n---\n\n**결론:**\n\n클래스는 객체지향을 구현하는 **하나의 방법**일 뿐이며, 클래스가 있다고 해서 반드시 객체지향 언어는 아닙니다. 반대로 클래스 없이도 프로토타입 기반 등으로 객체지향이 가능합니다. 중요한 것은 **OOP 원칙과 철학의 적용** 여부입니다.",
      "type": "essay",
      "tags": [
        "OOP",
        "클래스",
        "프로토타입",
        "패러다임"
      ],
      "id": "etc-013",
      "createdAt": "2025-11-17T15:00:00.000012",
      "studyCount": 0
    },
    {
      "question": "프레임워크와 라이브러리의 차이에 대해 설명해 주세요.",
      "answer": "**핵심 차이: 제어의 역전 (IoC)**\n\n---\n\n**라이브러리 (Library):**\n\n**정의:**\n- 개발자가 **호출**하는 코드 모음\n- 특정 기능을 제공하는 도구 모음\n\n**특징:**\n- **개발자가 제어권 보유**\n- 필요할 때 라이브러리 함수 호출\n- 애플리케이션 흐름을 개발자가 결정\n\n**비유:**\n- 도구 상자\n- 필요한 도구를 꺼내 사용\n\n**예시:**\n- lodash (JavaScript 유틸리티)\n- Axios (HTTP 클라이언트)\n- jQuery (DOM 조작)\n- NumPy (Python 수치 계산)\n- Jackson (JSON 파싱)\n\n**사용 방식:**\n- 내 코드에서 라이브러리 함수 호출\n- 언제, 어떻게 사용할지 개발자 결정\n\n---\n\n**프레임워크 (Framework):**\n\n**정의:**\n- 애플리케이션의 **골격(뼈대)**을 제공\n- 개발자가 **채워넣는** 구조\n\n**특징:**\n- **프레임워크가 제어권 보유** (IoC)\n- 정해진 구조와 규칙\n- 프레임워크가 개발자 코드를 호출\n\n**비유:**\n- 집의 골조\n- 정해진 틀 안에서 작업\n\n**예시:**\n- Spring (Java 백엔드)\n- Django (Python 웹)\n- React (JavaScript UI)\n- Angular (JavaScript 프레임워크)\n- Express (Node.js 웹)\n- Ruby on Rails\n\n**사용 방식:**\n- 프레임워크가 정한 구조 따름\n- 특정 위치에 코드 작성\n- 프레임워크가 내 코드 호출\n\n---\n\n**제어의 역전 (IoC: Inversion of Control):**\n\n**라이브러리:**\n- 내 코드 → 라이브러리 호출\n- **내가 제어**\n\n**프레임워크:**\n- 프레임워크 → 내 코드 호출\n- **프레임워크가 제어**\n- Hollywood Principle: \"Don't call us, we'll call you\"\n\n---\n\n**비교표:**\n\n| 항목 | 라이브러리 | 프레임워크 |\n|------|-----------|-----------|\n| **제어권** | 개발자 | 프레임워크 |\n| **호출 방향** | 개발자 → 라이브러리 | 프레임워크 → 개발자 코드 |\n| **자유도** | 높음 | 낮음 (규칙 따름) |\n| **구조** | 제공 안 함 | 전체 구조 제공 |\n| **역할** | 특정 기능 | 애플리케이션 골격 |\n| **선택** | 부분적 사용 | 전체 도입 |\n| **예시** | lodash, Axios | Spring, Django |\n\n---\n\n**구체적 예시:**\n\n**라이브러리 (Axios):**\n- HTTP 요청이 필요할 때\n- axios.get() 호출\n- 내가 원할 때, 원하는 방식으로\n\n**프레임워크 (Spring):**\n- @Controller 어노테이션 달면\n- Spring이 HTTP 요청을 내 메서드로 라우팅\n- 프레임워크가 생명주기 관리\n- 의존성 주입도 프레임워크가 처리\n\n**라이브러리 (jQuery):**\n- DOM 조작 필요 시\n- $('selector').method() 호출\n- 내가 언제, 어떻게 조작할지 결정\n\n**프레임워크 (React):**\n- 컴포넌트 정의\n- React가 렌더링 시점 결정\n- 생명주기 메서드를 React가 호출\n\n---\n\n**자유도 vs 편의성:**\n\n**라이브러리:**\n- **자유도 높음**: 원하는 대로 사용\n- **편의성 낮음**: 구조는 직접 설계\n\n**프레임워크:**\n- **자유도 낮음**: 규칙 따라야 함\n- **편의성 높음**: 구조, 패턴 제공\n\n---\n\n**선택 기준:**\n\n**라이브러리:**\n- 특정 기능만 필요\n- 기존 구조 유지\n- 유연성 중요\n- 작은 프로젝트\n\n**프레임워크:**\n- 전체 애플리케이션 개발\n- 구조화 필요\n- 팀 협업 (일관성)\n- 큰 프로젝트\n- Best Practice 원함\n\n---\n\n**혼합 사용:**\n\n**실제로는:**\n- 프레임워크 + 라이브러리 함께 사용\n- Spring + Jackson\n- React + Axios\n- Django + NumPy\n\n**프레임워크 내에서:**\n- 프레임워크가 제어\n- 필요 시 라이브러리 호출\n\n---\n\n**경계가 모호한 경우:**\n\n**Express (Node.js):**\n- 자칭 \"미니멀 프레임워크\"\n- 라이브러리처럼 사용 가능\n- 하지만 라우팅 등은 프레임워크적\n\n**React:**\n- 공식적으로는 \"라이브러리\"\n- 하지만 프레임워크처럼 구조 제공 (컴포넌트, 생명주기)\n- 논쟁 있음\n\n**기준:**\n- IoC 정도에 따라 판단\n- 제어권이 누구에게 있는가\n\n---\n\n**학습 곡선:**\n\n**라이브러리:**\n- 특정 함수만 배우면 됨\n- 낮은 진입 장벽\n\n**프레임워크:**\n- 전체 구조와 개념 이해 필요\n- 높은 진입 장벽\n- 하지만 마스터하면 생산성 높음\n\n---\n\n**의존성:**\n\n**라이브러리:**\n- 쉽게 교체 가능\n- 다른 라이브러리로 변경 용이\n\n**프레임워크:**\n- 교체 어려움\n- 프레임워크에 종속 (Vendor Lock-in)\n- 전체 재작성 필요할 수 있음\n\n---\n\n**실전 팁:**\n\n**1. 프레임워크 선택 신중히:**\n- 장기적 관점\n- 커뮤니티, 생태계 고려\n\n**2. 프레임워크 규칙 따르기:**\n- 저항하지 말고 철학 이해\n- Best Practice 수용\n\n**3. 라이브러리는 필요한 만큼:**\n- 과도한 의존 지양\n- 직접 구현도 고려\n\n**4. 문서 읽기:**\n- 프레임워크는 특히 문서 중요\n- 구조와 규칙 이해\n\n---\n\n**결론:**\n\n**라이브러리:**\n- 개발자가 호출하는 도구\n- 제어권: 개발자\n- 자유롭게 사용\n\n**프레임워크:**\n- 개발자 코드를 호출하는 골격\n- 제어권: 프레임워크 (IoC)\n- 규칙 따름\n\n핵심은 **제어의 역전(IoC)** 여부입니다.",
      "type": "essay",
      "tags": [
        "프레임워크",
        "라이브러리",
        "IoC",
        "제어의역전"
      ],
      "id": "etc-014",
      "createdAt": "2025-11-17T15:00:00.000013",
      "studyCount": 0
    },
    {
      "question": "Call By Value와 Call By Reference의 차이를 설명해 주세요.",
      "answer": "**호출 방식 (Calling Convention):**\n\n함수에 인자를 전달하는 방식입니다.\n\n---\n\n**Call By Value (값에 의한 호출):**\n\n**개념:**\n- 인자의 **값(복사본)**을 전달\n- 함수 내부에서 파라미터 변경해도 원본 영향 없음\n\n**동작:**\n1. 인자 값 복사\n2. 복사본을 함수에 전달\n3. 함수 내부에서 복사본 수정\n4. 원본은 변경 안 됨\n\n**특징:**\n- 원본 데이터 안전\n- 메모리 사용 (복사본 생성)\n- 큰 데이터는 비효율적\n\n**언어:**\n- C (기본), Java (원시 타입), Go, Rust (기본)\n\n---\n\n**Call By Reference (참조에 의한 호출):**\n\n**개념:**\n- 인자의 **참조(주소)**를 전달\n- 함수 내부에서 원본 직접 수정 가능\n\n**동작:**\n1. 인자의 메모리 주소 전달\n2. 함수가 주소로 원본 접근\n3. 원본 직접 수정\n4. 호출자도 변경 확인\n\n**특징:**\n- 원본 수정 가능\n- 메모리 효율적 (복사 없음)\n- 부수효과 (side effect) 주의\n\n**언어:**\n- C++ (참조자 &), C# (ref 키워드)\n\n---\n\n**비교:**\n\n| 항목 | Call By Value | Call By Reference |\n|------|---------------|-------------------|\n| **전달** | 값 복사 | 주소(참조) 전달 |\n| **원본 변경** | 불가 | 가능 |\n| **메모리** | 복사본 생성 | 복사 없음 |\n| **성능** | 큰 데이터 시 느림 | 빠름 |\n| **안전성** | 안전 | 부수효과 주의 |\n\n---\n\n**언어별 동작:**\n\n---\n\n**C:**\n\n**기본: Call By Value**\n- 모든 인자는 값 복사\n\n**포인터로 참조 흉내:**\n- 포인터 전달 (주소 복사)\n- 역참조로 원본 수정\n\n**참조 전달 없음:**\n- 진정한 Call By Reference 없음\n- 포인터는 주소 값의 복사 (Call By Value)\n\n---\n\n**C++:**\n\n**Call By Value:**\n- 기본 전달 방식\n\n**Call By Reference:**\n- 참조자 (&) 사용\n- 원본 직접 접근\n\n**포인터:**\n- 포인터 값 복사 (Call By Value)\n- 역참조로 원본 수정 가능\n\n---\n\n**Java:**\n\n**항상 Call By Value!**\n\n**원시 타입 (int, double 등):**\n- 값 복사\n- 원본 변경 불가\n\n**참조 타입 (객체):**\n- **참조 값 복사** (Call By Value of Reference)\n- 참조가 가리키는 객체는 같음\n- 객체 내부는 수정 가능\n- 하지만 참조 자체는 변경 안 됨\n\n**핵심:**\n- Java는 Call By Reference 없음\n- 참조 값의 복사 (Call By Value)\n\n---\n\n**Python:**\n\n**Call By Object Reference (또는 Call By Sharing):**\n\n**동작:**\n- 객체 참조 전달\n- 불변 객체 (int, str, tuple): 값처럼 동작\n- 가변 객체 (list, dict): 참조처럼 동작\n\n**특징:**\n- 엄밀히는 Call By Value도 Reference도 아님\n- 객체 참조의 복사\n\n---\n\n**JavaScript:**\n\n**Call By Value (원시 타입):**\n- number, string, boolean 등\n- 값 복사\n\n**Call By Sharing (객체):**\n- 객체, 배열\n- 참조 복사\n- 객체 내부 수정 가능\n- 참조 자체 변경 불가\n\n---\n\n**Go:**\n\n**Call By Value:**\n- 기본적으로 모든 것이 값 복사\n\n**포인터:**\n- 포인터로 참조 전달 흉내\n- *Type으로 포인터 타입\n\n---\n\n**C#:**\n\n**Call By Value (기본):**\n- 값 타입, 참조 타입 모두\n\n**ref 키워드:**\n- Call By Reference\n- 원본 변경 가능\n\n**out 키워드:**\n- 출력 전용 참조\n- 초기화 안 된 변수 전달 가능\n\n---\n\n**용어 혼란:**\n\n**Java는 Call By Value인가 Reference인가?**\n\n**정답: Call By Value**\n\n**혼란:**\n- 객체를 전달하면 주소가 복사됨\n- 하지만 이것도 값(주소 값) 복사\n- **Call By Value of Reference**\n\n**진정한 Call By Reference:**\n- 변수 자체의 별명\n- 참조 자체를 바꿀 수 있음\n- Java는 불가능\n\n---\n\n**실전 예시:**\n\n**C++ Call By Reference:**\n- void swap(int &a, int &b)\n- a와 b는 원본의 별명\n- 값 교환 시 원본도 교환\n\n**Java (Call By Value):**\n- void swap(Integer a, Integer b)\n- a, b는 참조 복사\n- 참조를 바꿔도 원본 참조는 그대로\n- 교환 안 됨\n\n**해결 (Java):**\n- 배열 사용 (swap(arr[0], arr[1]))\n- Wrapper 객체 사용\n\n---\n\n**포인터 vs 참조:**\n\n**포인터 (C/C++):**\n- 주소를 담는 변수\n- null 가능\n- 산술 연산 가능 (포인터 증가)\n- 역참조 필요 (*)\n\n**참조 (C++):**\n- 변수의 별명\n- null 불가 (초기화 필수)\n- 산술 연산 불가\n- 역참조 불필요\n\n---\n\n**성능:**\n\n**Call By Value:**\n- 작은 데이터: 영향 미미\n- 큰 데이터: 복사 비용\n\n**Call By Reference:**\n- 항상 주소만 전달 (빠름)\n- 큰 객체 전달 시 유리\n\n---\n\n**안전성:**\n\n**Call By Value:**\n- 원본 안전\n- 부수효과 없음\n- 함수형 프로그래밍 선호\n\n**Call By Reference:**\n- 원본 변경 가능\n- 부수효과 주의\n- 의도하지 않은 변경 위험\n\n---\n\n**Best Practices:**\n\n**1. 기본은 Call By Value:**\n- 안전성 우선\n\n**2. 성능 필요 시 참조:**\n- 큰 객체 전달\n- const 참조로 안전성 확보 (C++)\n\n**3. 명확한 의도:**\n- 수정 의도면 명시 (ref, &)\n- 읽기만이면 const\n\n**4. 불변 객체:**\n- 가능하면 불변 객체 사용\n- 참조 전달해도 안전\n\n---\n\n**결론:**\n\n**Call By Value:**\n- 값 복사\n- 원본 안전\n- 메모리 사용\n\n**Call By Reference:**\n- 참조(주소) 전달\n- 원본 수정 가능\n- 효율적\n\n언어마다 동작 방식이 다르므로 정확히 이해하고 사용해야 합니다. Java는 항상 Call By Value라는 점을 기억하세요.",
      "type": "essay",
      "tags": [
        "Call By Value",
        "Call By Reference",
        "파라미터전달",
        "메모리"
      ],
      "id": "etc-015",
      "createdAt": "2025-11-17T15:00:00.000014",
      "studyCount": 0
    },
    {
      "question": "과연 모든 언어에 Call By Value와 Call By Reference 개념이 존재할까요?",
      "answer": "**답변: 아니요, 모든 언어에 이 개념이 명확히 존재하는 것은 아닙니다.**\n\n---\n\n**전통적 분류의 한계:**\n\nCall By Value와 Call By Reference는 **C/C++ 중심의 분류**이며, 모든 언어를 설명하기에 부족합니다.\n\n---\n\n**다양한 전달 방식:**\n\n---\n\n**1. Call By Value (값에 의한 호출):**\n\n**언어:**\n- C (기본)\n- Go (기본)\n\n**특징:**\n- 값 복사\n- 원본 불변\n\n---\n\n**2. Call By Reference (참조에 의한 호출):**\n\n**언어:**\n- C++ (참조자 &)\n- C# (ref, out 키워드)\n\n**특징:**\n- 변수의 별명\n- 원본 직접 수정\n\n---\n\n**3. Call By Sharing (공유에 의한 호출):**\n\n**또는 Call By Object Reference**\n\n**언어:**\n- Python\n- JavaScript\n- Ruby\n- Java (엄밀히는 Call By Value of Reference)\n\n**개념:**\n- 객체 참조를 값으로 전달\n- 객체는 공유됨\n- 불변 객체는 Value처럼, 가변 객체는 Reference처럼 동작\n\n**특징:**\n- 참조 복사\n- 객체 내부 수정 가능\n- 참조 자체는 변경 불가\n\n**Java의 경우:**\n- 공식적으로는 \"항상 Call By Value\"\n- 하지만 객체는 참조 값 복사\n- Call By Sharing에 가까운 동작\n\n---\n\n**4. Call By Name (이름에 의한 호출):**\n\n**언어:**\n- Algol\n- Scala (이름 파라미터)\n\n**개념:**\n- 인자 표현식을 전달\n- 사용 시점에 평가\n- Lazy Evaluation\n\n**특징:**\n- 지연 평가\n- 매번 재평가\n\n---\n\n**5. Call By Need:**\n\n**언어:**\n- Haskell\n\n**개념:**\n- Call By Name + 메모이제이션\n- 첫 평가 후 캐시\n- Lazy Evaluation\n\n---\n\n**언어별 실제 동작:**\n\n---\n\n**Python:**\n\n**Call By Object Reference (또는 Sharing):**\n\n**불변 객체 (int, str, tuple):**\n- 값처럼 동작\n- \"변경\"하면 새 객체 생성\n\n**가변 객체 (list, dict, 객체):**\n- 참조처럼 동작\n- 내부 수정 가능\n\n**핵심:**\n- 모든 것이 객체\n- 객체 참조를 전달\n- Call By Value도 Reference도 아닌 제3의 방식\n\n---\n\n**JavaScript:**\n\n**원시 타입 (number, string, boolean):**\n- Call By Value처럼\n\n**객체 (object, array, function):**\n- Call By Sharing\n- 참조 복사, 내부 수정 가능\n\n---\n\n**Java:**\n\n**공식: 항상 Call By Value**\n\n**하지만:**\n- 객체는 참조 값 복사\n- 동작은 Call By Sharing과 유사\n\n**혼란:**\n- \"Java는 Reference인가 Value인가?\" 논쟁\n- 정답: Value (참조 값의 복사)\n- 하지만 Sharing으로 이해하는 게 직관적\n\n---\n\n**Haskell:**\n\n**순수 함수형:**\n- 모든 값이 불변\n- Call By Need (지연 평가)\n- 부수효과 없음\n\n**특징:**\n- 전통적 분류에 맞지 않음\n- 평가 전략이 다름\n\n---\n\n**Rust:**\n\n**소유권 (Ownership) 시스템:**\n\n**Move Semantics:**\n- 소유권 이동\n- 기존 변수 무효화\n\n**Borrow (차용):**\n- 불변 참조 (&T)\n- 가변 참조 (&mut T)\n\n**특징:**\n- Call By Value/Reference 개념 초월\n- 소유권이라는 독특한 개념\n\n---\n\n**왜 단순 분류가 어려운가:**\n\n**1. 언어 패러다임 차이:**\n- 함수형: 불변, 평가 전략\n- 객체지향: 객체 공유\n- 시스템: 포인터, 소유권\n\n**2. 메모리 모델:**\n- 스택/힙 구분 명확한 언어 vs 추상화된 언어\n- GC 유무\n\n**3. 타입 시스템:**\n- 원시 타입 vs 객체\n- 불변 vs 가변\n\n---\n\n**올바른 이해:**\n\n**전통적 분류:**\n- C/C++ 시대의 용어\n- 저수준 메모리 관점\n\n**현대 언어:**\n- 더 복잡하고 다양한 전달 방식\n- 단순히 Value/Reference로 분류 어려움\n\n**대신:**\n- \"이 언어에서 인자 전달 시 무슨 일이 일어나는가?\"\n- 구체적으로 이해\n\n---\n\n**실용적 접근:**\n\n**각 언어의 문서 확인:**\n- Java: \"pass-by-value\"\n- Python: \"pass-by-object-reference\"\n- Rust: \"move and borrow\"\n\n**동작 이해:**\n- 원본이 변경되는가?\n- 복사가 일어나는가?\n- 성능 영향은?\n\n---\n\n**혼란스러운 용어:**\n\n**Java의 경우:**\n- \"pass-by-value\" (공식)\n- \"pass-by-reference-value\" (비공식)\n- \"pass-by-sharing\" (학계)\n\n**모두 같은 동작:**\n- 참조 값 복사\n- 이름만 다름\n\n---\n\n**결론:**\n\n**전통적 분류:**\n- Call By Value\n- Call By Reference\n\n**현실:**\n- Call By Sharing (Python, Java, JS)\n- Call By Name/Need (Haskell)\n- 소유권 (Rust)\n- 기타 다양한 방식\n\n**모든 언어가 Value/Reference로 분류되지 않습니다.** 각 언어의 특성을 이해하고, 단순한 분류에 집착하지 말고 **실제 동작 방식**을 정확히 파악하는 것이 중요합니다.",
      "type": "essay",
      "tags": [
        "Call By Value",
        "Call By Reference",
        "Call By Sharing",
        "파라미터전달"
      ],
      "id": "etc-016",
      "createdAt": "2025-11-17T15:00:00.000015",
      "studyCount": 0
    },
    {
      "question": "순수함수가 무엇인지를 함수형 프로그래밍 매커니즘과 연관지어 설명해 주세요.",
      "answer": "순수함수(Pure Function)는 다음 두 가지 조건을 만족하는 함수입니다:\n\n1. **참조 투명성(Referential Transparency)**: 동일한 입력에 대해 항상 동일한 출력을 반환합니다.\n2. **부수효과 없음(No Side Effects)**: 함수 외부의 상태를 변경하지 않습니다.\n\n함수형 프로그래밍과의 연관성:\n- **불변성(Immutability)**: 순수함수는 입력값을 변경하지 않고 새로운 값을 반환하므로 불변성을 유지합니다.\n- **합성 가능성(Composability)**: 순수함수는 다른 함수와 조합하여 복잡한 로직을 구성할 수 있습니다.\n- **예측 가능성**: 외부 상태에 의존하지 않아 함수의 동작을 쉽게 예측하고 추론할 수 있습니다.\n- **테스트 용이성**: 입력과 출력만 검증하면 되므로 단위 테스트가 간단합니다.\n- **병렬화**: 상태 공유가 없어 동시성 프로그래밍에서 안전하게 사용할 수 있습니다.\n\n함수형 프로그래밍은 이러한 순수함수를 기본 빌딩 블록으로 사용하여 프로그램을 구성하는 패러다임입니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "순수함수"
      ],
      "id": "etc-017",
      "createdAt": "2025-11-17T15:00:00.000017",
      "studyCount": 0
    },
    {
      "question": "Side Effect가 무엇인가요? 이를 모두 없애는 프로그래밍이 이상적이라고 할 수 있을까요?",
      "answer": "Side Effect(부수효과)는 함수가 자신의 반환값 외에 외부 환경에 영향을 주는 모든 동작을 의미합니다.\n\n대표적인 Side Effect:\n- 전역 변수나 정적 변수 수정\n- 파일 시스템 읽기/쓰기\n- 데이터베이스 작업\n- 네트워크 통신\n- 콘솔 입출력\n- 객체의 상태 변경\n- 예외 발생\n\n모든 Side Effect를 없애는 것이 이상적일까?\n**아니오, 실용적이지 않습니다.**\n\n이유:\n1. **실제 프로그램의 필요성**: 실제 소프트웨어는 사용자 입력, 파일 저장, 데이터베이스 접근, 화면 출력 등 Side Effect가 필수적입니다.\n2. **I/O는 본질적으로 Side Effect**: 외부 세계와의 상호작용 없이는 유용한 프로그램을 만들 수 없습니다.\n\n현실적인 접근:\n- Side Effect를 완전히 제거하는 대신 **격리하고 관리**합니다.\n- 핵심 비즈니스 로직은 순수함수로 작성하고, Side Effect는 프로그램의 경계부(입출력 계층)에 제한합니다.\n- 함수형 프로그래밍의 Monad, Effect System 등은 Side Effect를 명시적으로 다루는 방법을 제공합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "부수효과"
      ],
      "id": "etc-018",
      "createdAt": "2025-11-17T15:00:00.000018",
      "studyCount": 0
    },
    {
      "question": "왜 함수형 프로그래밍 매커니즘을 사용한다고 생각하시나요?",
      "answer": "함수형 프로그래밍을 사용하는 주요 이유:\n\n1. **동시성 안전성(Concurrency Safety)**\n   - 불변 데이터와 순수함수는 공유 상태 문제를 원천적으로 방지합니다.\n   - 멀티코어 환경에서 병렬 처리를 안전하게 구현할 수 있습니다.\n\n2. **코드 추론 용이성(Easier Reasoning)**\n   - 함수가 외부 상태에 의존하지 않아 동작을 예측하기 쉽습니다.\n   - 실행 순서에 덜 민감하여 디버깅이 간단합니다.\n\n3. **테스트 용이성(Testability)**\n   - 순수함수는 입력과 출력만 검증하면 되어 단위 테스트가 간단합니다.\n   - 목(Mock) 객체나 복잡한 테스트 설정이 덜 필요합니다.\n\n4. **모듈성과 재사용성(Modularity & Reusability)**\n   - 작은 순수함수들을 조합하여 복잡한 로직을 구성할 수 있습니다.\n   - 고차함수를 통한 추상화로 코드 재사용성이 높아집니다.\n\n5. **버그 감소**\n   - 불변성으로 인한 예기치 않은 상태 변경 방지\n   - 참조 투명성으로 인한 예측 가능한 동작\n\n6. **선언적 스타일(Declarative Style)**\n   - \"어떻게\"보다 \"무엇을\"에 집중하여 코드 가독성이 향상됩니다.\n\n현대 소프트웨어의 복잡성과 동시성 요구사항이 증가하면서 함수형 프로그래밍의 장점이 더욱 부각되고 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍"
      ],
      "id": "etc-019",
      "createdAt": "2025-11-17T15:00:00.000019",
      "studyCount": 0
    },
    {
      "question": "순수함수는 Thread Safe 한가요? 왜 그럴까요?",
      "answer": "네, 순수함수는 Thread Safe합니다.\n\n이유:\n\n1. **공유 상태 없음(No Shared State)**\n   - 순수함수는 외부 변수나 전역 상태를 읽거나 수정하지 않습니다.\n   - 각 함수 호출이 독립적이므로 동시 실행 시 경쟁 조건(Race Condition)이 발생하지 않습니다.\n\n2. **불변성(Immutability)**\n   - 입력 데이터를 변경하지 않고 새로운 값을 반환합니다.\n   - 여러 스레드가 동시에 같은 데이터를 읽어도 안전합니다.\n\n3. **결정적 동작(Deterministic Behavior)**\n   - 동일한 입력에 대해 항상 동일한 출력을 보장합니다.\n   - 실행 타이밍이나 다른 스레드의 동작에 영향받지 않습니다.\n\n4. **외부 의존성 없음**\n   - 외부 리소스(파일, 네트워크, 데이터베이스)에 접근하지 않습니다.\n   - I/O 관련 동시성 문제가 발생하지 않습니다.\n\n5. **락(Lock) 불필요**\n   - 상태 공유가 없어 명시적인 동기화 메커니즘이 필요 없습니다.\n   - 성능 오버헤드와 데드락 위험이 없습니다.\n\n이러한 특성 덕분에 순수함수는 멀티스레드 환경에서 별도의 동기화 없이도 안전하게 병렬 실행될 수 있으며, 이는 함수형 프로그래밍이 동시성 프로그래밍에 적합한 주요 이유 중 하나입니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "동시성",
        "스레드안전성"
      ],
      "id": "etc-020",
      "createdAt": "2025-11-17T15:00:00.000020",
      "studyCount": 0
    },
    {
      "question": "고차함수에 대해 설명해 주세요.",
      "answer": "고차함수(Higher-Order Function)는 다음 중 하나 이상을 만족하는 함수입니다:\n1. 함수를 인자로 받는 함수\n2. 함수를 반환하는 함수\n\n주요 특징:\n\n**함수를 인자로 받는 경우:**\n- map, filter, reduce 등이 대표적입니다.\n- 동작의 일부를 외부에서 주입받아 추상화 수준을 높입니다.\n- 반복되는 패턴을 재사용 가능한 형태로 추상화합니다.\n\n**함수를 반환하는 경우:**\n- 클로저(Closure)를 활용하여 상태를 캡슐화할 수 있습니다.\n- 커링(Currying)과 부분 적용(Partial Application)을 구현할 수 있습니다.\n- 함수 팩토리 패턴을 만들 수 있습니다.\n\n장점:\n1. **추상화**: 공통 패턴을 일반화하여 코드 중복을 줄입니다.\n2. **재사용성**: 동작을 파라미터화하여 다양한 상황에서 재사용할 수 있습니다.\n3. **합성**: 작은 함수들을 조합하여 복잡한 로직을 구성할 수 있습니다.\n4. **선언적 코드**: \"무엇을\" 하는지에 집중하여 가독성이 향상됩니다.\n\n고차함수는 함수형 프로그래밍의 핵심 개념이며, 현대 프로그래밍 언어들은 대부분 고차함수를 지원합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "고차함수"
      ],
      "id": "etc-021",
      "createdAt": "2025-11-17T15:00:00.000021",
      "studyCount": 0
    },
    {
      "question": "MVC 패턴이 무엇인가요?",
      "answer": "MVC(Model-View-Controller)는 소프트웨어를 세 가지 역할로 분리하는 아키텍처 패턴입니다.\n\n**구성 요소:**\n\n1. **Model (모델)**\n   - 애플리케이션의 데이터와 비즈니스 로직을 담당합니다.\n   - 데이터의 상태와 그 상태를 변경하는 로직을 포함합니다.\n   - View나 Controller에 독립적이어야 합니다.\n   - 데이터 변경 시 Observer 패턴 등을 통해 View에 알립니다.\n\n2. **View (뷰)**\n   - 사용자에게 보여지는 UI를 담당합니다.\n   - Model의 데이터를 시각적으로 표현합니다.\n   - 사용자 입력을 받아 Controller에 전달합니다.\n   - 비즈니스 로직을 포함하지 않습니다.\n\n3. **Controller (컨트롤러)**\n   - 사용자의 입력을 받아 처리합니다.\n   - Model과 View 사이의 중재자 역할을 합니다.\n   - 사용자 입력에 따라 Model을 업데이트하고, 적절한 View를 선택합니다.\n   - 애플리케이션의 흐름을 제어합니다.\n\n**동작 흐름:**\n사용자 입력 → Controller → Model 업데이트 → View 업데이트 → 화면 표시\n\n**장점:**\n- **관심사의 분리**: 각 컴포넌트가 명확한 책임을 가집니다.\n- **재사용성**: Model은 여러 View에서 재사용 가능합니다.\n- **유지보수성**: 변경이 필요한 부분만 수정할 수 있습니다.\n- **병렬 개발**: 각 계층을 독립적으로 개발할 수 있습니다.\n- **테스트 용이성**: 각 컴포넌트를 독립적으로 테스트할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "아키텍처패턴",
        "MVC"
      ],
      "id": "etc-022",
      "createdAt": "2025-11-17T15:00:00.000022",
      "studyCount": 0
    },
    {
      "question": "다른 아키텍쳐 패턴은 없나요? MVC랑 비교해서 어떤 차이가 있나요?",
      "answer": "MVC 외에 다양한 아키텍처 패턴이 있으며, 각각의 특징과 장단점이 있습니다.\n\n**1. MVP (Model-View-Presenter)**\n- **차이점**: Controller 대신 Presenter가 View와 1:1 관계를 맺습니다.\n- Presenter가 View의 인터페이스를 통해 View를 완전히 제어합니다.\n- View는 Presenter에게 모든 이벤트를 위임합니다.\n- **장점**: View와 Model이 완전히 분리되어 테스트가 용이합니다.\n- **단점**: Presenter와 View 간 1:1 매핑으로 클래스가 많아질 수 있습니다.\n\n**2. MVVM (Model-View-ViewModel)**\n- **차이점**: Controller/Presenter 대신 ViewModel이 있으며, 데이터 바인딩을 사용합니다.\n- ViewModel은 View의 추상화이며, View 상태와 동작을 포함합니다.\n- 양방향 데이터 바인딩으로 View와 ViewModel이 자동 동기화됩니다.\n- **장점**: View 로직을 선언적으로 작성하여 코드가 간결합니다.\n- **단점**: 데이터 바인딩 메커니즘이 복잡할 수 있습니다.\n\n**3. Clean Architecture (클린 아키텍처)**\n- **차이점**: 계층형 동심원 구조로 의존성이 안쪽으로만 향합니다.\n- Entities (핵심 비즈니스 로직) → Use Cases → Interface Adapters → Frameworks\n- **장점**: 프레임워크 독립적이며 테스트가 매우 용이합니다.\n- **단점**: 초기 구조 설계가 복잡하고 러닝 커브가 높습니다.\n\n**4. Hexagonal Architecture (육각형 아키텍처, Ports & Adapters)**\n- **차이점**: 비즈니스 로직을 중심에 두고 외부 시스템과의 통신을 Port와 Adapter로 추상화합니다.\n- Port는 인터페이스, Adapter는 구현체입니다.\n- **장점**: 외부 시스템 교체가 용이하고 테스트가 간단합니다.\n- **단점**: 추상화 계층이 많아 초기 개발 비용이 높습니다.\n\n**5. Flux/Redux (단방향 데이터 흐름)**\n- **차이점**: Action → Dispatcher → Store → View의 단방향 흐름을 강제합니다.\n- 상태 관리가 중앙집중화되어 예측 가능합니다.\n- **장점**: 디버깅과 상태 추적이 용이합니다.\n- **단점**: 보일러플레이트 코드가 많을 수 있습니다.\n\n**선택 기준:**\n- 프로젝트 규모, 팀 경험, 요구사항, 플랫폼 특성 등을 고려하여 선택합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "아키텍처패턴"
      ],
      "id": "etc-023",
      "createdAt": "2025-11-17T15:00:00.000023",
      "studyCount": 0
    },
    {
      "question": "디자인 패턴이 무엇인지 설명해주고, 대표적인 디자인 패턴에 대해 설명해 주세요.",
      "answer": "디자인 패턴(Design Pattern)은 소프트웨어 설계에서 반복적으로 발생하는 문제들에 대한 재사용 가능한 해결책입니다.\n\n**디자인 패턴의 목적:**\n- 검증된 설계 방법을 제공하여 개발 시간을 단축합니다.\n- 개발자 간 공통 언어를 제공하여 의사소통을 원활하게 합니다.\n- 유지보수성과 확장성을 향상시킵니다.\n- 코드의 재사용성을 높입니다.\n\n**GoF(Gang of Four) 디자인 패턴 분류:**\n\n**1. 생성 패턴 (Creational Patterns)**\n객체 생성 메커니즘을 다룹니다.\n\n- **Singleton**: 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- **Factory Method**: 객체 생성 로직을 서브클래스로 위임합니다.\n- **Abstract Factory**: 관련된 객체군을 생성하는 인터페이스를 제공합니다.\n- **Builder**: 복잡한 객체의 생성 과정을 단계별로 분리합니다.\n- **Prototype**: 기존 객체를 복제하여 새 객체를 생성합니다.\n\n**2. 구조 패턴 (Structural Patterns)**\n클래스와 객체를 조합하여 더 큰 구조를 만듭니다.\n\n- **Adapter**: 호환되지 않는 인터페이스를 연결합니다.\n- **Decorator**: 객체에 동적으로 새로운 기능을 추가합니다.\n- **Proxy**: 객체에 대한 접근을 제어하는 대리자를 제공합니다.\n- **Composite**: 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현합니다.\n- **Facade**: 복잡한 서브시스템에 대한 단순한 인터페이스를 제공합니다.\n\n**3. 행위 패턴 (Behavioral Patterns)**\n객체 간의 책임 분배와 알고리즘을 다룹니다.\n\n- **Strategy**: 알고리즘군을 정의하고 캡슐화하여 교환 가능하게 만듭니다.\n- **Observer**: 객체의 상태 변화를 관찰자들에게 자동으로 알립니다.\n- **Template Method**: 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에 위임합니다.\n- **Command**: 요청을 객체로 캡슐화하여 매개변수화합니다.\n- **Iterator**: 컬렉션의 내부 구조를 노출하지 않고 순차 접근을 제공합니다.\n\n디자인 패턴은 만능이 아니며, 상황에 맞게 적절히 사용해야 합니다. 과도한 사용은 오히려 코드를 복잡하게 만들 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "디자인패턴"
      ],
      "id": "etc-024",
      "createdAt": "2025-11-17T15:00:00.000024",
      "studyCount": 0
    },
    {
      "question": "Singleton의 장단점에 대해 설명해 주세요.",
      "answer": "Singleton 패턴의 장점과 단점:\n\n**장점:**\n\n1. **단일 인스턴스 보장**\n   - 클래스의 인스턴스가 정확히 하나만 존재하도록 보장합니다.\n   - 메모리 낭비를 방지할 수 있습니다.\n\n2. **전역 접근점 제공**\n   - 애플리케이션 어디서나 접근 가능한 전역 접근점을 제공합니다.\n   - 인스턴스에 대한 일관된 접근 방법을 제공합니다.\n\n3. **지연 초기화(Lazy Initialization)**\n   - 실제로 필요할 때까지 인스턴스 생성을 지연시킬 수 있습니다.\n   - 리소스를 효율적으로 사용할 수 있습니다.\n\n4. **공유 리소스 관리**\n   - 데이터베이스 연결, 로거, 설정 관리 등 공유 리소스를 효과적으로 관리할 수 있습니다.\n\n**단점:**\n\n1. **전역 상태(Global State)**\n   - 전역 변수와 유사한 문제를 발생시킵니다.\n   - 프로그램의 여러 부분이 암묵적으로 연결되어 결합도가 높아집니다.\n\n2. **테스트 어려움**\n   - 단위 테스트 시 Mock 객체로 대체하기 어렵습니다.\n   - 테스트 간 상태 공유로 인해 독립적인 테스트가 어렵습니다.\n\n3. **동시성 문제**\n   - 멀티스레드 환경에서 동기화 처리가 필요합니다.\n   - 잘못 구현하면 여러 인스턴스가 생성될 수 있습니다.\n\n4. **단일 책임 원칙(SRP) 위반**\n   - 비즈니스 로직과 인스턴스 생성 관리라는 두 가지 책임을 가집니다.\n\n5. **의존성 주입(DI) 불가**\n   - 의존성을 외부에서 주입받기 어려워 유연성이 떨어집니다.\n   - 대체 구현을 제공하기 어렵습니다.\n\n6. **상속 제한**\n   - Private 생성자로 인해 상속이 어렵거나 불가능합니다.\n\n**권장 사항:**\nSingleton은 신중하게 사용해야 하며, 가능하면 의존성 주입(DI) 컨테이너를 통한 스코프 관리를 고려하는 것이 좋습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "디자인패턴",
        "싱글톤"
      ],
      "id": "etc-025",
      "createdAt": "2025-11-17T15:00:00.000025",
      "studyCount": 0
    },
    {
      "question": "Singleton이 하나의 객체를 생성한다는 것을 어떻게 보장할 수 있을까요?",
      "answer": "Singleton이 단일 인스턴스를 보장하는 여러 방법:\n\n**1. Private 생성자**\n- 외부에서 new 키워드로 인스턴스를 생성하지 못하도록 생성자를 private으로 선언합니다.\n- 클래스 내부에서만 인스턴스를 생성할 수 있게 합니다.\n\n**2. Static 인스턴스 변수**\n- 클래스 내부에 static 변수로 유일한 인스턴스를 저장합니다.\n- 클래스 레벨에서 하나만 존재하도록 보장합니다.\n\n**3. 멀티스레드 환경에서의 안전성 보장 방법:**\n\n**A. Eager Initialization (즉시 초기화)**\n- 클래스 로딩 시점에 인스턴스를 생성합니다.\n- 클래스 로더가 스레드 안전성을 보장합니다.\n- 단점: 사용하지 않아도 인스턴스가 생성됩니다.\n\n**B. Synchronized Method (동기화 메서드)**\n- 인스턴스를 반환하는 메서드에 synchronized 키워드를 사용합니다.\n- 스레드 안전성을 보장하지만 성능 오버헤드가 있습니다.\n\n**C. Double-Checked Locking (이중 확인 잠금)**\n- 인스턴스가 null인지 두 번 확인하여 불필요한 동기화를 줄입니다.\n- volatile 키워드를 함께 사용하여 가시성 문제를 해결합니다.\n- 성능과 안전성의 균형을 맞춥니다.\n\n**D. Bill Pugh Solution (Inner Static Helper Class)**\n- 내부 정적 클래스를 사용하여 인스턴스를 보유합니다.\n- 클래스 로딩 시점이 달라 Lazy Initialization과 Thread Safety를 모두 보장합니다.\n- Java에서 가장 권장되는 방법 중 하나입니다.\n\n**E. Enum (Java 전용)**\n- Enum 타입으로 Singleton을 구현합니다.\n- 직렬화와 리플렉션 공격에도 안전합니다.\n- Joshua Bloch가 \"Effective Java\"에서 권장하는 방법입니다.\n\n**4. 추가 고려사항:**\n- **리플렉션 공격 방지**: 생성자에서 이미 인스턴스가 존재하면 예외를 던집니다.\n- **직렬화/역직렬화**: readResolve 메서드를 구현하여 역직렬화 시에도 동일한 인스턴스를 반환합니다.\n- **클래스 로더 문제**: 여러 클래스 로더 환경에서는 각 로더마다 인스턴스가 생성될 수 있습니다.\n\n각 방법은 상황에 따라 장단점이 있으므로, 요구사항에 맞는 방법을 선택해야 합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "디자인패턴",
        "싱글톤",
        "동시성"
      ],
      "id": "etc-026",
      "createdAt": "2025-11-17T15:00:00.000026",
      "studyCount": 0
    },
    {
      "question": "GC에 대해 설명해 주세요.",
      "answer": "GC(Garbage Collection, 가비지 컬렉션)는 프로그램이 동적으로 할당한 메모리 중 더 이상 사용하지 않는 메모리를 자동으로 회수하는 메모리 관리 기법입니다.\n\n**GC의 목적:**\n- 메모리 누수(Memory Leak) 방지\n- 댕글링 포인터(Dangling Pointer) 문제 해결\n- 이중 해제(Double Free) 오류 방지\n- 개발자의 메모리 관리 부담 감소\n\n**GC의 기본 원리:**\n\n1. **도달 가능성(Reachability) 판단**\n   - GC Root로부터 참조 체인을 따라갈 수 있는 객체는 \"살아있는(Live)\" 객체입니다.\n   - 도달할 수 없는 객체는 \"가비지\"로 간주되어 회수 대상이 됩니다.\n\n2. **GC Root의 종류**\n   - 스택의 지역 변수\n   - 정적 변수\n   - JNI 참조 (Java의 경우)\n   - 활성화된 스레드\n\n**주요 GC 알고리즘:**\n\n1. **Reference Counting (참조 카운팅)**\n   - 각 객체의 참조 횟수를 추적합니다.\n   - 참조 횟수가 0이 되면 즉시 회수합니다.\n   - 순환 참조 문제가 있습니다.\n\n2. **Mark and Sweep (표시 및 수거)**\n   - Mark 단계: GC Root부터 도달 가능한 객체를 표시합니다.\n   - Sweep 단계: 표시되지 않은 객체의 메모리를 회수합니다.\n   - 메모리 단편화가 발생할 수 있습니다.\n\n3. **Mark and Compact (표시 및 압축)**\n   - Mark and Sweep에 압축 단계를 추가합니다.\n   - 살아있는 객체를 한쪽으로 모아 단편화를 해결합니다.\n\n4. **Generational GC (세대별 수집)**\n   - 객체의 수명을 기준으로 Young Generation과 Old Generation으로 나눕니다.\n   - 대부분의 객체는 금방 죽는다는 \"Weak Generational Hypothesis\"에 기반합니다.\n   - Young Generation을 자주, Old Generation을 드물게 수집합니다.\n\n5. **Copying (복사)**\n   - 메모리를 두 영역으로 나누어 사용합니다.\n   - 살아있는 객체를 다른 영역으로 복사합니다.\n   - 단편화가 없지만 메모리 사용량이 2배입니다.\n\n**GC의 동작 방식:**\n- **Stop-the-World**: GC가 실행될 때 애플리케이션 스레드를 일시 정지합니다.\n- **Concurrent GC**: 애플리케이션과 동시에 실행되어 일시 정지 시간을 줄입니다.\n\nGC는 메모리 관리를 자동화하여 개발 생산성을 높이지만, 성능 오버헤드와 예측 불가능한 일시 정지 시간이 발생할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-027",
      "createdAt": "2025-11-17T15:00:00.000027",
      "studyCount": 0
    },
    {
      "question": "본인이 사용하는 언어에서는 GC를 어떻게 구현했나요?",
      "answer": "주요 프로그래밍 언어별 GC 구현 방식:\n\n**Java (JVM)**\n\n1. **Generational GC 기반**\n   - Young Generation: Eden, Survivor 0, Survivor 1로 구성\n   - Old Generation: 오래 살아남은 객체 저장\n   - Permanent/Metaspace: 클래스 메타데이터 저장\n\n2. **다양한 GC 알고리즘 제공**\n   - **Serial GC**: 단일 스레드, 작은 애플리케이션용\n   - **Parallel GC**: 멀티 스레드, 처리량 중심\n   - **CMS (Concurrent Mark Sweep)**: 낮은 지연 시간 목표\n   - **G1 GC**: 대용량 힙, 예측 가능한 일시 정지 시간\n   - **ZGC/Shenandoah**: 매우 낮은 지연 시간 (밀리초 이하)\n\n3. **Minor GC vs Major GC**\n   - Minor GC: Young Generation 수집 (빠름)\n   - Major/Full GC: 전체 힙 수집 (느림)\n\n**Python**\n\n1. **Reference Counting (주 메커니즘)**\n   - 각 객체의 참조 횟수를 추적합니다.\n   - 참조 횟수가 0이 되면 즉시 메모리를 회수합니다.\n   - 실시간성이 좋지만 순환 참조를 처리하지 못합니다.\n\n2. **Cycle Detector (순환 참조 탐지)**\n   - Generational GC 알고리즘을 사용합니다.\n   - 3세대(Generation 0, 1, 2)로 나누어 관리합니다.\n   - 주기적으로 순환 참조를 탐지하고 회수합니다.\n\n**JavaScript (V8 엔진)**\n\n1. **Generational GC**\n   - Young Generation (New Space): Scavenger 알고리즘 사용\n   - Old Generation (Old Space): Mark-Sweep-Compact 사용\n\n2. **Incremental Marking**\n   - GC 작업을 작은 단위로 나누어 일시 정지 시간을 줄입니다.\n\n3. **Concurrent Marking**\n   - 메인 스레드와 병렬로 마킹 작업을 수행합니다.\n\n**Go**\n\n1. **Concurrent Mark-Sweep**\n   - 애플리케이션과 동시에 실행되는 GC\n   - 일시 정지 시간을 밀리초 이하로 유지하는 것이 목표\n\n2. **삼색 표시(Tri-color Marking)**\n   - 흰색(미방문), 회색(방문 중), 검은색(방문 완료)로 객체를 분류합니다.\n\n3. **Write Barrier**\n   - 포인터 변경을 추적하여 일관성을 유지합니다.\n\n**C# (.NET)**\n\n1. **Generational GC**\n   - 3세대(Gen 0, 1, 2)로 구성\n   - Large Object Heap (LOH): 85KB 이상 객체 저장\n\n2. **Workstation vs Server GC**\n   - Workstation: 낮은 지연 시간\n   - Server: 높은 처리량\n\n각 언어는 사용 사례와 성능 목표에 맞춰 서로 다른 GC 전략을 채택하고 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-028",
      "createdAt": "2025-11-17T15:00:00.000028",
      "studyCount": 0
    },
    {
      "question": "GC의 장단점에 대해 설명해 주세요.",
      "answer": "GC(Garbage Collection)의 장단점:\n\n**장점:**\n\n1. **자동 메모리 관리**\n   - 개발자가 명시적으로 메모리를 해제할 필요가 없습니다.\n   - 메모리 관리의 복잡성을 언어/런타임이 담당합니다.\n\n2. **메모리 안전성 향상**\n   - 메모리 누수(Memory Leak) 발생 가능성을 크게 줄입니다.\n   - 댕글링 포인터(Dangling Pointer) 문제를 방지합니다.\n   - 이중 해제(Double Free) 오류를 방지합니다.\n\n3. **개발 생산성 향상**\n   - 메모리 관리 코드 작성 부담이 없어 비즈니스 로직에 집중할 수 있습니다.\n   - 버그 발생 가능성이 줄어듭니다.\n\n4. **메모리 압축**\n   - 일부 GC는 메모리 단편화를 해소하는 압축(Compaction) 기능을 제공합니다.\n\n**단점:**\n\n1. **성능 오버헤드**\n   - GC 실행 시 CPU 자원을 소모합니다.\n   - 메모리 추적을 위한 추가 메타데이터가 필요합니다.\n\n2. **Stop-the-World (STW) 일시 정지**\n   - GC 실행 중 애플리케이션이 일시 정지됩니다.\n   - 실시간 시스템이나 저지연 요구사항이 있는 시스템에서 문제가 될 수 있습니다.\n   - 예측 불가능한 지연 시간이 발생합니다.\n\n3. **메모리 사용량 증가**\n   - GC를 위한 추가 메타데이터와 여유 공간이 필요합니다.\n   - 수동 메모리 관리보다 더 많은 메모리를 사용할 수 있습니다.\n\n4. **제어권 부족**\n   - 개발자가 정확히 언제 메모리가 해제될지 알 수 없습니다.\n   - 특정 시점에 메모리를 해제하도록 강제할 수 없습니다.\n\n5. **GC 튜닝의 어려움**\n   - 최적의 성능을 위해서는 GC 파라미터 조정이 필요할 수 있습니다.\n   - GC 동작 방식에 대한 깊은 이해가 필요합니다.\n\n6. **즉시성 부족**\n   - 객체가 더 이상 사용되지 않아도 즉시 회수되지 않을 수 있습니다.\n   - 파일 핸들, 네트워크 연결 등 리소스 해제가 지연될 수 있습니다.\n\n**결론:**\nGC는 대부분의 애플리케이션에서 생산성과 안전성 측면에서 큰 이점을 제공하지만, 실시간 시스템이나 극한의 성능이 필요한 경우에는 수동 메모리 관리가 더 적합할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-029",
      "createdAt": "2025-11-17T15:00:00.000029",
      "studyCount": 0
    },
    {
      "question": "GC는 어떤 영역에 있는 데이터를 관리하나요?",
      "answer": "GC가 관리하는 메모리 영역과 관리하지 않는 영역:\n\n**GC가 관리하는 영역:**\n\n1. **힙(Heap) 메모리**\n   - 동적으로 할당된 객체들이 저장되는 영역입니다.\n   - new 키워드나 동적 할당으로 생성된 객체들이 위치합니다.\n   - GC의 주요 관리 대상입니다.\n\n2. **힙 메모리의 세부 구조 (Java 기준):**\n   - **Young Generation**: 새로 생성된 객체\n     - Eden Space\n     - Survivor Space (S0, S1)\n   - **Old Generation (Tenured)**: 오래 살아남은 객체\n   - **Metaspace/Permanent Generation**: 클래스 메타데이터 (일부 GC가 관리)\n\n**GC가 관리하지 않는 영역:**\n\n1. **스택(Stack) 메모리**\n   - 지역 변수, 메서드 호출 정보, 파라미터 등이 저장됩니다.\n   - 스코프를 벗어나면 자동으로 제거됩니다 (LIFO 구조).\n   - GC의 관리 대상이 아니지만, **GC Root의 역할**을 합니다.\n\n2. **코드(Code) 영역**\n   - 실행 가능한 코드(바이트코드, 네이티브 코드)가 저장됩니다.\n   - 읽기 전용이며 프로그램 실행 내내 유지됩니다.\n\n3. **데이터(Data) 영역**\n   - 전역 변수, 정적 변수가 저장됩니다.\n   - 프로그램 시작 시 할당되고 종료 시 해제됩니다.\n   - 정적 변수는 GC Root가 될 수 있습니다.\n\n4. **네이티브 메모리 (Off-Heap)**\n   - JNI, Direct Buffer 등으로 할당된 메모리\n   - GC가 직접 관리하지 않으며 명시적 해제가 필요합니다.\n\n**GC Root (GC의 시작점):**\nGC는 다음 위치에서 시작하여 도달 가능한 객체를 추적합니다:\n- 스택의 지역 변수\n- 정적 변수 (Static fields)\n- JNI 참조\n- 활성 스레드\n- 동기화 모니터\n\n**중요 포인트:**\n- GC는 힙 메모리만 직접 관리하지만, 스택과 정적 변수는 GC Root로서 객체의 생존 여부를 결정하는 데 중요한 역할을 합니다.\n- 스택 메모리는 자동으로 관리되지만 GC와는 다른 메커니즘(스코프 기반)으로 동작합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-030",
      "createdAt": "2025-11-17T15:00:00.000030",
      "studyCount": 0
    },
    {
      "question": "Reference Counting 방식에 대해 설명하고, 이 알고리즘에서 발생할 수 있는 순환 참조 및 Retain Cycle에 대해 설명해 주세요.",
      "answer": "**Reference Counting (참조 카운팅) 방식:**\n\n각 객체가 몇 개의 참조에 의해 가리켜지고 있는지를 추적하는 GC 방식입니다.\n\n**동작 원리:**\n1. 각 객체는 참조 카운터를 가집니다.\n2. 새로운 참조가 생성되면 카운터를 증가시킵니다.\n3. 참조가 제거되면 카운터를 감소시킵니다.\n4. 카운터가 0이 되면 즉시 메모리를 회수합니다.\n\n**장점:**\n- 구현이 단순하고 직관적입니다.\n- 메모리 회수가 즉각적으로 일어납니다.\n- Stop-the-World 일시 정지가 없습니다.\n- 메모리 사용 패턴이 예측 가능합니다.\n\n**단점:**\n- 참조가 변경될 때마다 카운터 업데이트 오버헤드가 발생합니다.\n- 순환 참조 문제를 해결할 수 없습니다.\n- 멀티스레드 환경에서 카운터 업데이트를 동기화해야 합니다.\n- 추가 메모리 공간이 필요합니다 (카운터 저장).\n\n**순환 참조(Circular Reference) / Retain Cycle 문제:**\n\n**정의:**\n두 개 이상의 객체가 서로를 참조하여 고리를 형성하는 상황입니다.\n\n**문제점:**\n- 객체들이 외부에서 접근 불가능해도 서로를 참조하고 있어 참조 카운트가 0이 되지 않습니다.\n- 메모리가 영구적으로 회수되지 않아 메모리 누수가 발생합니다.\n\n**예시 시나리오:**\n- 객체 A가 객체 B를 참조\n- 객체 B가 객체 A를 참조\n- 외부에서 A와 B로의 참조가 모두 끊어짐\n- 하지만 A의 참조 카운트 = 1 (B가 참조), B의 참조 카운트 = 1 (A가 참조)\n- 둘 다 카운트가 0이 아니므로 메모리가 회수되지 않음\n\n**해결 방법:**\n\n1. **약한 참조(Weak Reference)**\n   - 참조 카운트를 증가시키지 않는 특별한 참조 타입을 사용합니다.\n   - 순환 참조의 한쪽을 약한 참조로 만들어 고리를 끊습니다.\n\n2. **수동 참조 해제**\n   - 개발자가 명시적으로 참조를 nil/null로 설정하여 고리를 끊습니다.\n\n3. **Cycle Detection (순환 참조 탐지)**\n   - Reference Counting과 함께 주기적으로 순환 참조를 탐지하는 알고리즘을 실행합니다.\n   - Python이 이 방식을 사용합니다 (Reference Counting + Cycle Detector).\n\n4. **자동 참조 관리 도구**\n   - ARC (Automatic Reference Counting) 같은 컴파일러 지원을 활용합니다.\n   - Swift, Objective-C 등에서 사용됩니다.\n\n**실제 사례:**\n- Python: Reference Counting + Generational Cycle Detector\n- Swift: ARC + weak/unowned 참조\n- Objective-C: ARC + weak/strong 참조\n\n순환 참조는 Reference Counting의 가장 큰 약점이며, 이를 해결하기 위해 추가적인 메커니즘이 필요합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC",
        "순환참조"
      ],
      "id": "etc-031",
      "createdAt": "2025-11-17T15:00:00.000031",
      "studyCount": 0
    },
    {
      "question": "32비트와 64비트의 차이는 무엇인가요?",
      "answer": "32비트와 64비트의 차이점:\n\n**1. 레지스터와 데이터 처리 단위**\n- **32비트**: CPU 레지스터가 32비트 크기로, 한 번에 32비트(4바이트) 데이터를 처리합니다.\n- **64비트**: CPU 레지스터가 64비트 크기로, 한 번에 64비트(8바이트) 데이터를 처리합니다.\n\n**2. 주소 공간 (Address Space)**\n- **32비트**: 2^32 = 약 43억 개의 주소를 표현할 수 있습니다.\n  - 최대 4GB의 메모리를 직접 주소 지정할 수 있습니다.\n  - 실제로는 OS와 하드웨어 예약으로 약 3.2~3.5GB만 사용 가능합니다.\n- **64비트**: 2^64 = 약 1844경 개의 주소를 표현할 수 있습니다.\n  - 이론적으로 16 exabytes (약 1600만 TB)의 메모리를 주소 지정할 수 있습니다.\n  - 실제로는 하드웨어와 OS 제약으로 수십 TB ~ 수백 TB까지 지원합니다.\n\n**3. 메모리 제한**\n- **32비트 시스템**:\n  - 프로세스당 최대 4GB 메모리 (Windows: 2GB 기본, 3GB 옵션)\n  - 대용량 데이터 처리나 서버 애플리케이션에 제약이 있습니다.\n- **64비트 시스템**:\n  - 프로세스당 수 TB 이상의 메모리 사용 가능\n  - 대용량 데이터베이스, 빅데이터, 과학 계산 등에 적합합니다.\n\n**4. 성능**\n- **32비트**:\n  - 포인터와 레지스터 크기가 작아 메모리 사용량이 적습니다.\n  - 캐시 효율성이 더 좋을 수 있습니다 (포인터 크기가 작아서).\n- **64비트**:\n  - 더 많은 레지스터를 사용할 수 있습니다 (x86-64는 레지스터 수 증가).\n  - 큰 숫자 연산이 더 빠릅니다.\n  - 포인터 크기가 2배로 증가하여 메모리 사용량과 캐시 미스가 증가할 수 있습니다.\n\n**5. 호환성**\n- **32비트**: 32비트 애플리케이션만 실행 가능합니다.\n- **64비트**: 대부분 32비트 애플리케이션도 실행 가능합니다 (WoW64, 호환 모드).\n\n**6. 정수 크기 (언어/플랫폼 의존적)**\n- 일부 언어에서 long, pointer 등의 크기가 달라집니다.\n- C/C++: long과 포인터 크기가 변경될 수 있습니다 (LP64, LLP64 모델).\n\n**7. 보안**\n- **64비트**: ASLR(Address Space Layout Randomization) 등의 보안 기능이 더 효과적입니다.\n- 더 넓은 주소 공간으로 인해 메모리 공격이 어렵습니다.\n\n**실용적 차이:**\n- 4GB 이상 RAM을 사용하려면 64비트 시스템이 필수입니다.\n- 현대 애플리케이션과 OS는 대부분 64비트를 권장하거나 요구합니다.\n- 일부 레거시 하드웨어나 드라이버는 32비트만 지원할 수 있습니다.\n\n**선택 기준:**\n- 대용량 메모리가 필요한 경우: 64비트\n- 레거시 시스템 지원: 32비트\n- 현대 시스템: 대부분 64비트 권장",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "컴퓨터구조"
      ],
      "id": "etc-032",
      "createdAt": "2025-11-17T15:00:00.000032",
      "studyCount": 0
    }
  ]
}