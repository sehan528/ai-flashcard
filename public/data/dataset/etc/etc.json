{
  "name": "개발상식 (CS 기타)",
  "description": "가상화, Docker, CI/CD, static 등 개발 필수 지식",
  "cards": [
    {
      "question": "가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.",
      "answer": "**가상화 (Virtualization):**\n\n**개념:**\n- 물리적 하드웨어 리소스를 논리적으로 추상화하여 여러 개의 독립적인 환경을 만드는 기술\n- 하나의 물리 서버에서 여러 개의 가상 환경을 실행\n\n**핵심 목표:**\n- 리소스 효율성 향상\n- 격리된 실행 환경 제공\n- 유연한 인프라 관리\n\n---\n\n**가상머신 (Virtual Machine):**\n\n**개념:**\n- 가상화 기술의 한 구현 방식\n- 하이퍼바이저(Hypervisor)를 통해 완전한 운영체제를 가상화\n\n**구조:**\n- Host OS (물리 서버 운영체제)\n- Hypervisor (VMware, VirtualBox, Hyper-V 등)\n- Guest OS (각 VM의 독립적인 OS)\n- Application\n\n---\n\n**차이점:**\n\n**가상화:**\n- **광범위한 개념**: 하드웨어, OS, 네트워크, 스토리지 등 모든 리소스 가상화 포함\n- **다양한 방식**: VM, 컨테이너, 서버리스 등\n\n**가상머신:**\n- **가상화의 한 방식**: OS 레벨 가상화\n- **완전한 격리**: 각 VM이 독립적인 OS 보유\n- **무거움**: Guest OS 전체를 포함하여 리소스 많이 사용\n\n---\n\n**가상화 방식 비교:**\n\n**1. 가상머신 (VM):**\n- 하이퍼바이저 기반\n- 완전한 OS 격리\n- 무거움 (GB 단위 메모리)\n- 부팅 시간 느림 (분 단위)\n- 강력한 격리\n\n**2. 컨테이너 (Docker 등):**\n- OS 레벨 가상화\n- Host OS 커널 공유\n- 가벼움 (MB 단위 메모리)\n- 부팅 시간 빠름 (초 단위)\n- 프로세스 격리\n\n**3. 서버리스:**\n- 함수 레벨 가상화\n- 인프라 추상화\n- 이벤트 기반 실행\n\n---\n\n**요약:**\n\n- **가상화**: 리소스를 논리적으로 분할하는 기술 전반\n- **가상머신**: 가상화 기술 중 하이퍼바이저를 이용해 완전한 OS를 가상화하는 방식\n\n가상화는 큰 개념이고, 가상머신은 그 구현 방법 중 하나입니다.",
      "type": "essay",
      "tags": [
        "가상화",
        "VM",
        "인프라",
        "클라우드"
      ],
      "id": "etc-001",
      "createdAt": "2025-11-17T15:00:00.000000",
      "studyCount": 0
    },
    {
      "question": "그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?",
      "answer": "**Docker의 분류:**\n\nDocker는 **컨테이너 기반 가상화**에 속합니다.\n\n- **가상화 기술**의 한 방식\n- **가상머신(VM)이 아님**\n- OS 레벨 가상화 (프로세스 격리)\n\n---\n\n**Docker 특징:**\n\n**구조:**\n- Host OS\n- Docker Engine\n- 컨테이너 (독립 실행 환경)\n- Application\n\n**차이점:**\n- Guest OS 없음 (Host OS 커널 공유)\n- 경량화 (MB 단위)\n- 빠른 시작 (초 단위)\n\n---\n\n**VM vs Docker:**\n\n| 항목 | VM | Docker |\n|------|----|----|\n| OS | Guest OS 전체 포함 | Host OS 커널 공유 |\n| 크기 | GB 단위 | MB 단위 |\n| 부팅 | 분 단위 | 초 단위 |\n| 리소스 | 많이 사용 | 적게 사용 |\n| 격리 | 강력 (하드웨어 레벨) | 프로세스 레벨 |\n| 성능 | 오버헤드 있음 | 네이티브에 가까움 |\n\n---\n\n**Docker를 많이 채택하는 이유:**\n\n---\n\n**1. 경량성:**\n- Guest OS 불필요 → 메모리 절약\n- 수십 개 컨테이너를 하나의 호스트에서 실행 가능\n- VM은 수 개만 가능\n\n**2. 빠른 시작/종료:**\n- 초 단위 시작\n- 배포 속도 향상\n- CI/CD 파이프라인에 적합\n\n**3. 이식성 (Portability):**\n- \"Build once, run anywhere\"\n- 동일한 컨테이너 이미지를 어디서나 실행\n- 개발/스테이징/프로덕션 환경 일관성\n\n**4. 개발 환경 일치:**\n- \"내 컴퓨터에서는 되는데...\" 문제 해결\n- 모든 개발자가 동일한 환경\n- 의존성 충돌 방지\n\n**5. 마이크로서비스 아키텍처:**\n- 서비스별 독립 컨테이너\n- 쉬운 스케일링\n- 서비스 간 격리\n\n**6. 버전 관리:**\n- Docker 이미지 버전 관리\n- 롤백 용이\n- 이미지 레이어 캐싱\n\n**7. 리소스 효율:**\n- 동일 하드웨어에 더 많은 애플리케이션\n- 클라우드 비용 절감\n\n**8. DevOps 문화:**\n- Infrastructure as Code\n- 자동화된 배포\n- 컨테이너 오케스트레이션 (Kubernetes)\n\n**9. 생태계:**\n- Docker Hub (공개 이미지 저장소)\n- 수많은 공식/커뮤니티 이미지\n- 쉬운 시작\n\n**10. 격리:**\n- 애플리케이션 간 의존성 충돌 방지\n- 보안 향상 (제한적이지만)\n\n---\n\n**실제 사용 예:**\n\n**개발:**\n- 로컬에서 MySQL, Redis, Kafka 등을 컨테이너로 실행\n- 프로젝트별 독립 환경\n\n**배포:**\n- 동일한 이미지를 개발/스테이징/프로덕션에 배포\n- 일관성 보장\n\n**마이크로서비스:**\n- 각 서비스를 독립 컨테이너로\n- Kubernetes로 오케스트레이션\n\n---\n\n**한계:**\n\n**1. 보안:**\n- Host OS 커널 공유 → 커널 취약점 영향\n- VM보다 격리 약함\n\n**2. OS 제약:**\n- Linux 컨테이너는 Linux에서만 (Windows는 WSL2 필요)\n- 다른 OS 커널 불가\n\n**3. 상태 관리:**\n- 컨테이너는 기본적으로 stateless\n- 영구 데이터는 볼륨 필요\n\n---\n\n**결론:**\n\nDocker는 **컨테이너 기반 가상화**로, VM보다 경량하고 빠르며 이식성이 뛰어납니다. 마이크로서비스, DevOps, 클라우드 네이티브 환경에서 사실상 표준이 되었습니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "컨테이너",
        "가상화",
        "DevOps"
      ],
      "id": "etc-002",
      "createdAt": "2025-11-17T15:00:00.000001",
      "studyCount": 0
    },
    {
      "question": "하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?",
      "answer": "**위험성:**\n\n맞습니다. Docker 컨테이너는 Host OS 커널을 공유하므로 다음 위험이 있습니다:\n\n**1. 리소스 고갈:**\n- 한 컨테이너가 CPU/메모리 독점\n- 다른 컨테이너 성능 저하 또는 중단\n\n**2. 커널 취약점:**\n- 컨테이너에서 커널 익스플로잇\n- Host 및 다른 컨테이너 침해\n\n**3. 네트워크 간섭:**\n- 같은 네트워크의 컨테이너 간 통신\n- 의도치 않은 접근\n\n**4. 파일시스템 접근:**\n- 볼륨 마운트 오용\n- Host 파일시스템 접근\n\n---\n\n**방어 메커니즘:**\n\nDocker와 Linux는 여러 격리 기술을 제공합니다:\n\n---\n\n**1. Namespace (네임스페이스):**\n\n**개념:**\n- 프로세스, 네트워크, 파일시스템 등을 격리\n- 각 컨테이너가 독립된 뷰를 가짐\n\n**종류:**\n\n**PID Namespace:**\n- 프로세스 ID 격리\n- 컨테이너 내부에서 PID 1부터 시작\n- 다른 컨테이너 프로세스 보이지 않음\n\n**Network Namespace:**\n- 네트워크 인터페이스 격리\n- 각 컨테이너가 독립 IP, 포트\n- 브리지 네트워크로 연결\n\n**Mount Namespace:**\n- 파일시스템 격리\n- 각 컨테이너가 독립 루트 파일시스템\n- Host 파일시스템 보이지 않음\n\n**UTS Namespace:**\n- 호스트명, 도메인명 격리\n\n**IPC Namespace:**\n- 프로세스 간 통신 격리\n\n**User Namespace:**\n- UID/GID 매핑\n- 컨테이너 내부 root가 Host에서는 일반 사용자\n\n---\n\n**2. Cgroups (Control Groups):**\n\n**개념:**\n- 리소스 사용량 제한 및 격리\n\n**제한 항목:**\n\n**CPU:**\n- --cpus 옵션\n- CPU 사용률 제한\n\n**메모리:**\n- --memory 옵션\n- 메모리 한계 설정\n- OOM Killer 방지\n\n**I/O:**\n- 디스크 읽기/쓰기 속도 제한\n\n**네트워크:**\n- 대역폭 제한\n\n**효과:**\n- 한 컨테이너의 리소스 독점 방지\n- 다른 컨테이너 영향 최소화\n\n---\n\n**3. Seccomp (Secure Computing Mode):**\n\n**개념:**\n- 시스템 콜 필터링\n- 위험한 시스템 콜 차단\n\n**기본 프로필:**\n- Docker 기본 seccomp 프로필\n- 300개 이상 시스템 콜 중 일부만 허용\n- reboot, mount 등 위험한 콜 차단\n\n**커스텀 프로필:**\n- JSON으로 허용/차단 시스템 콜 정의\n\n---\n\n**4. AppArmor / SELinux:**\n\n**개념:**\n- 강제 접근 제어 (MAC)\n- 프로세스별 권한 정의\n\n**AppArmor:**\n- Ubuntu/Debian에서 사용\n- 프로파일로 파일/네트워크 접근 제어\n\n**SELinux:**\n- RHEL/CentOS에서 사용\n- 레이블 기반 접근 제어\n\n---\n\n**5. Capabilities:**\n\n**개념:**\n- root 권한을 세분화\n- 필요한 권한만 부여\n\n**예시:**\n- CAP_NET_BIND_SERVICE (1024 미만 포트 바인딩)\n- CAP_SYS_ADMIN (시스템 관리)\n\n**기본:**\n- Docker는 일부 위험한 capabilities 제거\n- --cap-drop, --cap-add로 조정\n\n---\n\n**6. Read-only Root Filesystem:**\n\n**개념:**\n- 컨테이너 루트 파일시스템을 읽기 전용으로\n\n**효과:**\n- 악성 파일 쓰기 방지\n- 불변 인프라\n\n---\n\n**7. User Namespace:**\n\n**개념:**\n- 컨테이너 내부 UID를 Host UID로 매핑\n\n**효과:**\n- 컨테이너 내부 root (UID 0)\n- Host에서는 일반 사용자 (UID 100000 등)\n- Host 파일시스템 접근 제한\n\n---\n\n**8. 네트워크 격리:**\n\n**방법:**\n\n**브리지 네트워크:**\n- 기본 격리\n- 컨테이너끼리 브리지를 통해 통신\n\n**사용자 정의 네트워크:**\n- docker network create mynet\n- 네트워크별 격리\n\n**호스트 네트워크 피하기:**\n- --network host는 격리 없음\n- 필요한 경우만 사용\n\n---\n\n**9. 이미지 보안:**\n\n**신뢰할 수 있는 이미지:**\n- 공식 이미지 사용\n- Docker Content Trust (이미지 서명)\n\n**취약점 스캔:**\n- Trivy, Clair 등으로 이미지 스캔\n- 알려진 CVE 확인\n\n**최소 이미지:**\n- Alpine Linux 등 최소 이미지\n- 공격 표면 축소\n\n---\n\n**10. 런타임 보안:**\n\n**Docker Bench Security:**\n- Docker 보안 Best Practice 검사 도구\n\n**Falco:**\n- 런타임 보안 모니터링\n- 비정상 동작 감지\n\n**gVisor, Kata Containers:**\n- 더 강력한 격리\n- 컨테이너별 경량 커널 (gVisor)\n- 컨테이너별 경량 VM (Kata)\n\n---\n\n**실전 권장사항:**\n\n**1. 리소스 제한:**\n- 모든 컨테이너에 CPU/메모리 제한 설정\n\n**2. 최소 권한:**\n- root로 실행 금지 (USER 지시어)\n- 필요한 capabilities만\n- 읽기 전용 파일시스템\n\n**3. 네트워크 분리:**\n- 서비스별 네트워크 분리\n- 필요한 포트만 노출\n\n**4. 정기 업데이트:**\n- Host OS, Docker, 이미지 최신 유지\n- 보안 패치 적용\n\n**5. 모니터링:**\n- 컨테이너 동작 모니터링\n- 이상 징후 감지\n\n**6. 스캔:**\n- 이미지 취약점 스캔\n- CI/CD에 통합\n\n---\n\n**결론:**\n\nDocker는 Namespace, Cgroups, Seccomp, AppArmor 등 여러 격리 메커니즘을 제공하여 컨테이너 간 간섭을 방지합니다. 하지만 VM보다 격리가 약하므로, 리소스 제한, 최소 권한, 보안 스캔 등의 Best Practice를 따라야 합니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "보안",
        "격리",
        "Namespace",
        "Cgroups"
      ],
      "id": "etc-003",
      "createdAt": "2025-11-17T15:00:00.000002",
      "studyCount": 0
    },
    {
      "question": "Docker 위에 Docker를 올릴 순 없을까요?",
      "answer": "**답변: 가능합니다.**\n\nDocker 위에 Docker를 올리는 것을 **Docker-in-Docker (DinD)**라고 합니다.\n\n---\n\n**구현 방법:**\n\n**1. Docker-in-Docker (DinD):**\n\n**공식 이미지:**\n- docker:dind 이미지 사용\n\n**특징:**\n- 컨테이너 내부에서 Docker daemon 실행\n- 완전히 독립적인 Docker 환경\n- Privileged 모드 필요\n\n**장점:**\n- 완전한 격리\n- 내부 Docker와 외부 Docker 독립\n\n**단점:**\n- 보안 위험 (privileged 모드)\n- 리소스 오버헤드\n- 복잡도 증가\n\n---\n\n**2. Docker Socket 마운트:**\n\n**방법:**\n- Host의 Docker socket을 컨테이너에 마운트\n- /var/run/docker.sock\n\n**특징:**\n- 컨테이너 내부에서 Host의 Docker 제어\n- 실제로는 DinD가 아님 (Host Docker 사용)\n- Privileged 모드 불필요\n\n**장점:**\n- 간단\n- 리소스 효율적\n\n**단점:**\n- Host Docker 접근 (보안 위험)\n- 완전한 격리 아님\n- 컨테이너가 Host Docker 제어 가능\n\n---\n\n**사용 사례:**\n\n**1. CI/CD 파이프라인:**\n\n**목적:**\n- Jenkins, GitLab CI 등에서 Docker 이미지 빌드\n\n**시나리오:**\n- Jenkins 컨테이너 내부에서 Docker 이미지 빌드\n- 빌드된 이미지를 레지스트리에 푸시\n\n**방법:**\n- DinD 또는 Docker socket 마운트\n\n---\n\n**2. Docker 개발/테스트:**\n\n**목적:**\n- Docker 자체 개발 또는 테스트\n\n**시나리오:**\n- 격리된 환경에서 Docker 실험\n\n---\n\n**3. 샌드박스 환경:**\n\n**목적:**\n- 안전하게 Docker 명령 실행\n\n---\n\n**DinD vs Docker Socket 비교:**\n\n| 항목 | DinD | Docker Socket |\n|------|------|---------------|\n| 격리 | 완전 격리 | Host Docker 공유 |\n| Privileged | 필요 | 불필요 |\n| 보안 | 중간 (privileged 위험) | 낮음 (Host 접근) |\n| 리소스 | 높음 (daemon 별도) | 낮음 (Host daemon 공유) |\n| 복잡도 | 높음 | 낮음 |\n| 사용 | 완전한 격리 필요 시 | CI/CD 등 간단한 경우 |\n\n---\n\n**보안 고려사항:**\n\n**DinD:**\n- --privileged 플래그 필요\n- 컨테이너가 Host 커널 전체 접근\n- 보안 위험 높음\n\n**Docker Socket 마운트:**\n- 컨테이너가 Host Docker 제어\n- Host의 모든 컨테이너 제어 가능\n- Host 파일시스템 마운트 가능\n- 사실상 root 권한과 동등\n\n**완화:**\n- 신뢰할 수 있는 이미지만 사용\n- 네트워크 격리\n- 리소스 제한\n- 모니터링\n\n---\n\n**대안:**\n\n**1. Kaniko:**\n- DinD 없이 컨테이너 이미지 빌드\n- Kubernetes에서 사용\n- Privileged 모드 불필요\n\n**2. Buildah:**\n- Rootless 컨테이너 빌드\n- Docker daemon 불필요\n\n**3. BuildKit:**\n- Docker의 차세대 빌드 엔진\n- 더 안전하고 빠름\n\n---\n\n**실전 권장사항:**\n\n**CI/CD:**\n- **단순한 경우**: Docker socket 마운트\n- **격리 필요**: DinD\n- **보안 중요**: Kaniko/Buildah\n\n**개발:**\n- DinD로 실험 환경 구축\n\n**프로덕션:**\n- 가능하면 피하기\n- 대안 도구 사용\n\n---\n\n**예시 시나리오:**\n\n**Jenkins CI:**\n\n**방법 1 (Docker Socket):**\n- Jenkins 컨테이너 실행 시 -v /var/run/docker.sock:/var/run/docker.sock\n- Jenkins job에서 docker build\n- Host Docker 사용하여 빌드\n\n**방법 2 (DinD):**\n- docker:dind 컨테이너 실행\n- Jenkins를 DinD에 연결\n- 완전히 격리된 Docker 환경\n\n---\n\n**한계:**\n\n**1. 성능:**\n- 중첩된 환경으로 오버헤드\n\n**2. 복잡도:**\n- 디버깅 어려움\n- 네트워크 설정 복잡\n\n**3. 이식성:**\n- 환경마다 동작 다를 수 있음\n\n---\n\n**결론:**\n\nDocker 위에 Docker를 올리는 것은 가능하며(DinD) 또는 Host Docker를 공유할 수 있습니다(Socket 마운트). CI/CD에서 유용하지만 보안 위험이 있으므로 신중하게 사용하고, 가능하면 Kaniko 같은 대안을 고려하세요.",
      "type": "essay",
      "tags": [
        "Docker",
        "DinD",
        "Docker-in-Docker",
        "CI/CD"
      ],
      "id": "etc-004",
      "createdAt": "2025-11-17T15:00:00.000003",
      "studyCount": 0
    },
    {
      "question": "CI/CD를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.",
      "answer": "**CI/CD 개념:**\n\n**CI (Continuous Integration):**\n- 지속적 통합\n- 코드 변경을 자주 메인 브랜치에 통합\n- 자동 빌드 및 테스트\n\n**CD (Continuous Delivery/Deployment):**\n- 지속적 배포\n- Delivery: 릴리스 준비 자동화\n- Deployment: 프로덕션 자동 배포\n\n---\n\n**CI/CD 파이프라인 구성 요소:**\n\n**1. 소스 코드 관리:**\n- Git (GitHub, GitLab, Bitbucket)\n- 코드 푸시 시 파이프라인 트리거\n\n**2. 빌드:**\n- 소스 코드 컴파일\n- 의존성 설치\n- Docker 이미지 빌드\n\n**3. 테스트:**\n- 단위 테스트\n- 통합 테스트\n- E2E 테스트\n- 정적 분석, 린트\n\n**4. 배포:**\n- 스테이징 환경 배포\n- 프로덕션 배포\n- 롤백 가능\n\n**5. 모니터링:**\n- 배포 후 헬스 체크\n- 메트릭 수집\n- 알림\n\n---\n\n**일반적인 CI/CD 플로우:**\n\n**1. 코드 푸시:**\n- 개발자가 Git에 코드 푸시\n\n**2. 빌드 트리거:**\n- Webhook으로 CI/CD 서버 알림\n\n**3. 빌드:**\n- 소스 코드 체크아웃\n- 의존성 설치\n- 빌드 (jar, Docker 이미지 등)\n\n**4. 테스트:**\n- 유닛 테스트 실행\n- 테스트 실패 시 파이프라인 중단\n\n**5. 정적 분석:**\n- 코드 품질 검사 (SonarQube 등)\n- 취약점 스캔\n\n**6. 배포 (스테이징):**\n- 스테이징 환경에 배포\n- 통합 테스트\n\n**7. 승인 (선택):**\n- 수동 승인 단계\n- 프로덕션 배포 전 검토\n\n**8. 배포 (프로덕션):**\n- 프로덕션 환경 배포\n- Blue-Green, Canary, Rolling 등\n\n**9. 검증:**\n- 헬스 체크\n- 스모크 테스트\n- 실패 시 자동 롤백\n\n---\n\n**주요 CI/CD 도구:**\n\n**1. Jenkins:**\n- 오픈소스, 가장 널리 사용\n- 플러그인 생태계\n- Jenkinsfile (Pipeline as Code)\n\n**2. GitLab CI/CD:**\n- GitLab 통합\n- .gitlab-ci.yml\n- 간편한 설정\n\n**3. GitHub Actions:**\n- GitHub 통합\n- YAML 기반 워크플로우\n- 무료 티어 제공\n\n**4. CircleCI:**\n- 클라우드 기반\n- 빠른 빌드\n- Docker 지원\n\n**5. Travis CI:**\n- GitHub 통합\n- 오픈소스 무료\n\n**6. AWS CodePipeline, Azure DevOps, Google Cloud Build:**\n- 클라우드 네이티브\n- 각 클라우드 플랫폼 통합\n\n---\n\n**실전 예시 (GitHub Actions):**\n\n**시나리오:**\n- Node.js 애플리케이션\n- main 브랜치 푸시 시 자동 배포\n\n**파이프라인:**\n\n**1. Trigger:**\n- main 브랜치 push\n\n**2. 빌드:**\n- Node.js 설치\n- npm install\n- npm run build\n\n**3. 테스트:**\n- npm test\n\n**4. Docker 이미지 빌드:**\n- docker build\n- Docker Hub에 푸시\n\n**5. 배포:**\n- SSH로 서버 접속\n- docker pull\n- docker-compose up -d\n\n**6. 알림:**\n- Slack 알림 (성공/실패)\n\n---\n\n**장점:**\n\n**1. 빠른 피드백:**\n- 코드 푸시 후 즉시 테스트 결과\n- 문제 조기 발견\n\n**2. 자동화:**\n- 수동 배포 없음\n- 반복 작업 제거\n\n**3. 일관성:**\n- 동일한 프로세스로 빌드/배포\n- 환경 차이 최소화\n\n**4. 품질 향상:**\n- 모든 변경에 자동 테스트\n- 코드 품질 유지\n\n**5. 빠른 배포:**\n- 기능 빠르게 출시\n- 버그 수정 신속 배포\n\n**6. 롤백 용이:**\n- 이전 버전으로 쉽게 롤백\n\n---\n\n**Best Practices:**\n\n**1. Pipeline as Code:**\n- Jenkinsfile, .gitlab-ci.yml 등\n- 버전 관리\n- 코드 리뷰\n\n**2. 작은 변경, 자주 통합:**\n- Feature branch는 짧게\n- 자주 merge\n\n**3. 빠른 빌드:**\n- 병렬 실행\n- 캐싱 활용\n- 10분 이내 목표\n\n**4. 포괄적 테스트:**\n- 유닛, 통합, E2E\n- 충분한 커버리지\n\n**5. 환경 분리:**\n- Dev, Staging, Production\n- 환경별 설정 관리\n\n**6. 보안:**\n- 시크릿 관리 (환경 변수, Vault)\n- 취약점 스캔\n- 이미지 스캔\n\n**7. 모니터링:**\n- 파이프라인 메트릭\n- 실패 알림\n- 배포 후 모니터링\n\n**8. 롤백 전략:**\n- 자동 롤백 조건\n- 빠른 롤백 절차\n\n---\n\n**일반적인 문제와 해결:**\n\n**1. 느린 빌드:**\n- 병렬화\n- 캐싱 (의존성, Docker 레이어)\n- 불필요한 단계 제거\n\n**2. Flaky 테스트:**\n- 불안정한 테스트 수정\n- Retry 로직 (신중히)\n\n**3. 환경 차이:**\n- Docker로 일관된 환경\n- Infrastructure as Code\n\n**4. 시크릿 관리:**\n- 환경 변수\n- AWS Secrets Manager, HashiCorp Vault\n\n---\n\n**배포 전략:**\n\n**1. Blue-Green:**\n- 두 개 환경 유지\n- 새 버전을 Green에 배포\n- 트래픽 전환\n- 롤백 빠름\n\n**2. Canary:**\n- 일부 트래픽만 새 버전으로\n- 점진적 확대\n- 문제 조기 감지\n\n**3. Rolling:**\n- 인스턴스를 하나씩 업데이트\n- 무중단 배포\n\n**4. Feature Flag:**\n- 코드는 배포, 기능은 비활성화\n- 런타임에 토글\n\n---\n\n**결론:**\n\nCI/CD는 현대 소프트웨어 개발의 필수 요소로, 코드 변경을 자동으로 빌드, 테스트, 배포하여 개발 속도와 품질을 향상시킵니다. Jenkins, GitHub Actions, GitLab CI 등 다양한 도구가 있으며, Pipeline as Code로 관리하는 것이 Best Practice입니다.",
      "type": "essay",
      "tags": [
        "CI/CD",
        "DevOps",
        "자동화",
        "배포"
      ],
      "id": "etc-005",
      "createdAt": "2025-11-17T15:00:00.000004",
      "studyCount": 0
    },
    {
      "question": "static 키워드는 어떤 의미를 갖나요?",
      "answer": "**static 키워드 개념:**\n\n**핵심 의미:**\n- **정적 (Static)**: 프로그램 실행 시 메모리에 고정 할당\n- **클래스 레벨**: 인스턴스가 아닌 클래스에 속함\n- **공유**: 모든 인스턴스가 같은 값 공유\n\n---\n\n**언어별 static 의미:**\n\n---\n\n**Java/C#:**\n\n**1. Static 변수 (클래스 변수):**\n\n**특징:**\n- 클래스에 속함 (인스턴스와 무관)\n- 모든 객체가 공유\n- 메모리에 한 번만 할당\n- 프로그램 시작 시 생성, 종료 시 소멸\n\n**사용:**\n- 클래스명.변수명으로 접근\n- 인스턴스 생성 없이 사용 가능\n\n**예시 용도:**\n- 상수 (static final)\n- 카운터 (객체 생성 횟수)\n- 공유 자원\n\n**2. Static 메서드 (클래스 메서드):**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출 가능\n- 인스턴스 변수/메서드 접근 불가\n- this 키워드 사용 불가\n\n**사용:**\n- 유틸리티 함수 (Math.max, Collections.sort)\n- 팩토리 메서드\n\n**3. Static 블록:**\n\n**특징:**\n- 클래스 로딩 시 한 번 실행\n- 초기화 코드\n\n**4. Static 내부 클래스:**\n\n**특징:**\n- 외부 클래스 인스턴스 없이 생성 가능\n- 외부 인스턴스 변수 접근 불가\n\n---\n\n**C/C++:**\n\n**1. Static 지역 변수:**\n\n**특징:**\n- 함수 내부 변수이지만 메모리에 계속 유지\n- 함수 종료 후에도 값 유지\n- 다음 호출 시 이전 값 사용\n\n**사용:**\n- 호출 횟수 카운터\n\n**2. Static 전역 변수/함수:**\n\n**특징:**\n- 파일 스코프 제한\n- 다른 파일에서 접근 불가\n- 내부 링크 (Internal Linkage)\n\n**사용:**\n- 파일 내부 헬퍼 함수\n- 캡슐화\n\n---\n\n**JavaScript (ES6+):**\n\n**Static 메서드:**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출\n- this는 클래스 자체\n\n**사용:**\n- 유틸리티 메서드\n\n---\n\n**Python:**\n\n**Static 메서드 (@staticmethod):**\n\n**특징:**\n- 클래스/인스턴스와 무관\n- self, cls 인자 없음\n- 순수 함수처럼 동작\n\n**vs 클래스 메서드 (@classmethod):**\n- classmethod는 cls 인자 받음\n- staticmethod는 인자 없음\n\n---\n\n**static의 주요 특징:**\n\n**1. 메모리:**\n- 힙이 아닌 데이터 영역 (또는 BSS)\n- 프로그램 시작 시 할당\n- 프로그램 종료 시 해제\n- 인스턴스마다 복사 안 됨\n\n**2. 생명주기:**\n- 프로그램 전체 수명\n- 인스턴스 생명주기와 무관\n\n**3. 접근:**\n- 클래스명으로 접근\n- 인스턴스로도 접근 가능 (권장 안 함)\n\n**4. 공유:**\n- 모든 인스턴스가 공유\n- 한 곳에서 변경하면 모든 곳에 반영\n\n**5. 오버라이딩:**\n- 불가 (대부분 언어)\n- 상속되지만 오버라이딩 안 됨\n\n---\n\n**장점:**\n\n**1. 메모리 효율:**\n- 인스턴스마다 복사 안 됨\n- 한 번만 할당\n\n**2. 유틸리티 함수:**\n- 인스턴스 생성 없이 사용\n- Math.sqrt, Integer.parseInt 등\n\n**3. 공유 데이터:**\n- 모든 인스턴스가 공유할 데이터\n\n**4. 싱글톤:**\n- static 변수로 인스턴스 관리\n\n---\n\n**단점:**\n\n**1. 전역 상태:**\n- 테스트 어려움\n- 예측 어려움\n\n**2. 멀티스레딩:**\n- 동시성 문제\n- 동기화 필요\n\n**3. 의존성:**\n- 강한 결합\n- Mock 어려움\n\n**4. OOP 위반:**\n- 객체 지향 원칙에 어긋남\n- 상태 공유\n\n---\n\n**사용 가이드:**\n\n**적합한 사용:**\n- 상수\n- 유틸리티 함수 (순수 함수)\n- 싱글톤 (신중히)\n- 팩토리 메서드\n\n**피해야 할 사용:**\n- 가변 전역 상태\n- 인스턴스 메서드를 static으로\n- 테스트 어려운 코드\n\n---\n\n**예시 시나리오:**\n\n**카운터:**\n- static 변수로 생성된 객체 수 추적\n- 생성자에서 증가\n\n**싱글톤:**\n- private static 인스턴스\n- public static getInstance()\n\n**유틸리티 클래스:**\n- 모든 메서드가 static\n- 인스턴스 생성 방지 (private 생성자)\n\n**상수:**\n- public static final\n- 변경 불가 공유 값\n\n---\n\n**멀티스레딩 주의:**\n\n**문제:**\n- 여러 스레드가 static 변수 동시 수정\n- Race condition\n\n**해결:**\n- synchronized\n- Atomic 클래스\n- ThreadLocal\n\n---\n\n**결론:**\n\nstatic 키워드는 **클래스 레벨의 정적 멤버**를 정의하며, 모든 인스턴스가 공유합니다. 유틸리티 함수와 상수에 유용하지만, 전역 상태로 인한 테스트와 동시성 문제에 주의해야 합니다.",
      "type": "essay",
      "tags": [
        "static",
        "Java",
        "메모리",
        "OOP"
      ],
      "id": "etc-006",
      "createdAt": "2025-11-17T15:00:00.000005",
      "studyCount": 0
    },
    {
      "question": "컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?",
      "answer": "**컴파일 및 런타임 처리:**\n\nstatic 키워드가 붙은 변수와 함수는 컴파일 시점과 런타임 시점에 특별하게 처리됩니다.\n\n---\n\n**1. 메모리 할당:**\n\n**데이터 영역 (또는 BSS 영역):**\n- static 변수는 스택이나 힙이 아닌 **데이터 영역**에 할당\n- 프로그램 시작 시 메모리 할당\n- 프로그램 종료 시 해제\n\n**영역 구분:**\n\n**Data 영역:**\n- 초기화된 static 변수\n- 컴파일 시 값 결정\n\n**BSS 영역 (Block Started by Symbol):**\n- 초기화되지 않은 static 변수\n- 0으로 초기화\n\n**vs 인스턴스 변수:**\n- 인스턴스 변수: 힙 (객체 생성 시 할당)\n- static 변수: 데이터 영역 (프로그램 시작 시 할당)\n\n**vs 지역 변수:**\n- 지역 변수: 스택 (함수 호출 시 할당)\n- static 변수: 데이터 영역 (계속 유지)\n\n---\n\n**2. 초기화:**\n\n**컴파일 타임:**\n- static 변수의 초기값이 컴파일 시 결정됨\n- 상수 표현식만 가능\n\n**런타임:**\n\n**Java:**\n- 클래스 로딩 시 static 변수 초기화\n- static 블록 실행\n- 클래스가 처음 사용될 때 (lazy)\n\n**C/C++:**\n- 프로그램 시작 시 초기화\n- main() 실행 전\n\n**순서:**\n- 선언 순서대로 초기화\n- static 블록 순서대로 실행\n\n---\n\n**3. 링크:**\n\n**C/C++에서:**\n\n**External Linkage (기본):**\n- 다른 파일에서 접근 가능\n- extern 키워드로 선언\n\n**Internal Linkage (static):**\n- 파일 내부로 제한\n- 다른 파일에서 접근 불가\n- 이름 충돌 방지\n\n**컴파일러 처리:**\n- static 함수/변수는 심볼 테이블에 파일 스코프로 표시\n- 링커가 외부 참조 허용 안 함\n\n---\n\n**4. 메서드 바인딩:**\n\n**Java:**\n\n**Static 메서드:**\n- **정적 바인딩 (Static Binding)**\n- 컴파일 타임에 호출 대상 결정\n- 오버라이딩 불가\n- vtable 사용 안 함\n\n**인스턴스 메서드:**\n- **동적 바인딩 (Dynamic Binding)**\n- 런타임에 호출 대상 결정 (다형성)\n- 오버라이딩 가능\n- vtable 사용\n\n**성능:**\n- static 메서드가 약간 더 빠름 (동적 디스패치 없음)\n- 실제로는 미미한 차이\n\n---\n\n**5. 메모리 레이아웃:**\n\n**프로그램 메모리 구조:**\n\n```\n+------------------+\n| Code (Text)      | ← 실행 코드\n+------------------+\n| Data             | ← 초기화된 static 변수\n+------------------+\n| BSS              | ← 초기화 안 된 static 변수\n+------------------+\n| Heap             | ← 동적 할당 (new)\n+------------------+\n| Stack            | ← 지역 변수, 함수 호출\n+------------------+\n```\n\n**static 변수:**\n- Data 또는 BSS 영역\n- 주소 고정 (컴파일 시 결정 가능)\n\n**인스턴스 변수:**\n- Heap 영역\n- 주소 런타임에 결정\n\n---\n\n**6. 컴파일러 최적화:**\n\n**인라이닝:**\n- static 함수는 인라이닝 후보\n- 파일 내부로 제한되므로 안전하게 인라인 가능\n\n**상수 전파:**\n- static final (Java) 또는 const static (C++)는 컴파일 시 값 대체\n\n**Dead Code Elimination:**\n- 사용되지 않는 static 함수 제거\n\n---\n\n**7. 클래스 로딩 (Java):**\n\n**단계:**\n\n**1. Loading:**\n- .class 파일을 메모리에 로드\n\n**2. Linking:**\n- Verification: 바이트코드 검증\n- Preparation: static 변수 메모리 할당 및 기본값 초기화\n- Resolution: 심볼릭 참조를 실제 메모리 주소로\n\n**3. Initialization:**\n- static 변수 초기화 (명시적 값)\n- static 블록 실행\n\n**시점:**\n- 클래스가 처음 사용될 때\n- 인스턴스 생성, static 멤버 접근, main() 포함 클래스 등\n\n**한 번만:**\n- 클래스 로딩은 JVM에서 한 번만\n- static 초기화도 한 번만\n\n---\n\n**8. ABI (Application Binary Interface):**\n\n**C/C++:**\n- static 함수는 외부 심볼 테이블에 노출 안 됨\n- 바이너리 크기 감소\n- 이름 충돌 방지\n\n---\n\n**9. 재배치 (Relocation):**\n\n**컴파일 시:**\n- static 변수 주소는 상대 주소\n\n**링크 시:**\n- 실제 메모리 주소로 재배치\n- 고정 주소\n\n---\n\n**10. 스레드 안전성:**\n\n**초기화:**\n- Java는 클래스 로딩 시 스레드 안전하게 초기화\n- JVM이 동기화 보장\n\n**사용:**\n- static 변수 접근은 동기화 안 됨\n- 멀티스레딩 시 명시적 동기화 필요\n\n---\n\n**성능 영향:**\n\n**메모리:**\n- 인스턴스 변수보다 메모리 효율적 (한 번만 할당)\n- 하지만 프로그램 전체 수명 동안 유지 (해제 안 됨)\n\n**접근 속도:**\n- 고정 주소 → 빠른 접근\n- 인스턴스 변수는 포인터 역참조 필요\n\n**메서드 호출:**\n- static 메서드는 정적 바인딩 → 약간 빠름\n- 실제로는 미미한 차이\n\n---\n\n**컴파일러별 차이:**\n\n**GCC (C/C++):**\n- static 함수는 .o 파일 내부 심볼\n- nm 명령으로 't' (로컬 텍스트) 표시\n\n**Java Compiler (javac):**\n- static 멤버는 바이트코드에서 ACC_STATIC 플래그\n- invokestatic 명령으로 호출\n\n---\n\n**결론:**\n\nstatic 변수는 컴파일 시 데이터/BSS 영역에 할당되고, 프로그램 시작 시 초기화됩니다. static 함수는 정적 바인딩으로 컴파일 타임에 호출 대상이 결정되며, 파일 스코프로 제한될 수 있습니다. 메모리 효율적이지만 프로그램 전체 수명 동안 유지됩니다.",
      "type": "essay",
      "tags": [
        "static",
        "컴파일",
        "메모리",
        "링크"
      ],
      "id": "etc-007",
      "createdAt": "2025-11-17T15:00:00.000006",
      "studyCount": 0
    },
    {
      "question": "Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요?",
      "answer": "**키워드별 차이:**\n\n---\n\n**1. static:**\n\n**의미:**\n- 클래스 레벨 변수\n- 모든 인스턴스가 공유\n- 변경 가능\n\n**특징:**\n- 값 수정 가능\n- 인스턴스와 무관\n- 메모리에 한 번만 할당\n\n**사용:**\n- 공유 데이터\n- 카운터\n\n---\n\n**2. static final:**\n\n**의미:**\n- 클래스 레벨 상수\n- 모든 인스턴스가 공유\n- **변경 불가**\n\n**특징:**\n- 선언 시 또는 static 블록에서 초기화\n- 재할당 불가\n- 컴파일 타임 상수 (원시 타입/String)\n\n**사용:**\n- 상수 (PI, MAX_VALUE)\n- 설정값\n\n---\n\n**3. final:**\n\n**의미:**\n- 인스턴스 레벨 상수\n- 인스턴스마다 값이 다를 수 있음\n- **변경 불가**\n\n**특징:**\n- 생성자에서 초기화\n- 인스턴스마다 별도 메모리\n- 재할당 불가\n\n**사용:**\n- 불변 객체의 필드\n- 생성 시 결정되는 값\n\n---\n\n**비교표:**\n\n| 특성 | static | static final | final |\n|------|--------|--------------|-------|\n| **수준** | 클래스 | 클래스 | 인스턴스 |\n| **공유** | 모든 인스턴스 | 모든 인스턴스 | 개별 인스턴스 |\n| **변경** | 가능 | 불가 | 불가 |\n| **메모리** | 한 번 할당 | 한 번 할당 | 인스턴스마다 |\n| **초기화** | 선언 시/static 블록 | 선언 시/static 블록 | 선언 시/생성자 |\n| **컴파일 상수** | X | O (원시/String) | X |\n\n---\n\n**static vs static final:**\n\n**공통점:**\n- 클래스 레벨\n- 모든 인스턴스 공유\n- 메모리 한 번 할당\n\n**차이점:**\n\n**static:**\n- 값 변경 가능\n- 가변 공유 상태\n\n**static final:**\n- 값 변경 불가\n- 상수\n\n**언제 사용:**\n\n**static:**\n- 공유 카운터\n- 싱글톤 인스턴스\n\n**static final:**\n- 상수 (Math.PI)\n- 설정값\n- 열거형 대안\n\n---\n\n**final vs static final:**\n\n**공통점:**\n- 값 변경 불가 (재할당 불가)\n\n**차이점:**\n\n**final:**\n- 인스턴스마다 별도 값\n- 생성자에서 초기화 가능\n- 인스턴스마다 메모리 할당\n\n**static final:**\n- 모든 인스턴스 같은 값\n- 선언 시 또는 static 블록에서만 초기화\n- 메모리 한 번만 할당\n\n**언제 사용:**\n\n**final:**\n- 생성 시 결정되는 불변 값\n- 인스턴스별로 다를 수 있음\n\n**static final:**\n- 모든 인스턴스에 동일한 상수\n- 컴파일 타임 상수\n\n---\n\n**컴파일 타임 상수:**\n\n**static final (원시 타입/String):**\n- 컴파일러가 값을 코드에 직접 삽입\n- 성능 최적화\n- 클래스 로딩 없이 사용 가능\n\n**final (인스턴스):**\n- 런타임에 값 결정\n- 컴파일 타임 상수 아님\n\n---\n\n**메모리 효율:**\n\n**static final:**\n- 한 번만 할당\n- 모든 인스턴스가 참조\n- 메모리 효율적\n\n**final:**\n- 인스턴스마다 할당\n- 메모리 더 사용\n\n**예:**\n- 100개 인스턴스\n- static final: 1개 메모리\n- final: 100개 메모리\n\n---\n\n**초기화 시점:**\n\n**static:**\n- 클래스 로딩 시\n- static 블록에서도 가능\n- 여러 번 변경 가능\n\n**static final:**\n- 클래스 로딩 시 한 번만\n- 선언 시 또는 static 블록\n- 이후 변경 불가\n\n**final:**\n- 인스턴스 생성 시\n- 선언 시 또는 생성자\n- 이후 변경 불가\n\n---\n\n**참조 타입에서의 차이:**\n\n**주의:**\n- final은 재할당만 방지\n- 객체 내부 상태는 변경 가능\n\n**static final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**진짜 불변:**\n- 참조를 final로\n- 객체도 불변으로 설계 (모든 필드 final, setter 없음)\n\n---\n\n**사용 패턴:**\n\n**static final 상수:**\n- public static final double PI = 3.14159;\n- public static final int MAX_USERS = 1000;\n\n**static 싱글톤:**\n- private static instance;\n- public static getInstance()\n\n**final 불변 필드:**\n- private final String id;\n- 생성자에서 초기화\n\n---\n\n**성능:**\n\n**static final 상수:**\n- 컴파일 타임 인라인\n- 가장 빠름\n\n**static:**\n- 고정 주소\n- 빠른 접근\n\n**final:**\n- 인스턴스 필드 접근\n- 약간 느림 (포인터 역참조)\n\n---\n\n**Thread Safety:**\n\n**static:**\n- 공유 상태 → 동기화 필요\n\n**static final (불변 객체):**\n- 스레드 안전 (값 변경 안 됨)\n\n**final:**\n- 객체가 불변이면 스레드 안전\n- 가변 객체면 동기화 필요\n\n---\n\n**Best Practices:**\n\n**1. 상수는 static final:**\n- public static final로 선언\n- 대문자 + 언더스코어 (UPPER_CASE)\n\n**2. 가변 공유 상태는 주의:**\n- static 변수는 최소화\n- 동기화 고려\n\n**3. 불변 객체는 final:**\n- 모든 필드 final\n- setter 없음\n- 방어적 복사\n\n**4. 싱글톤은 static:**\n- private static instance\n- enum 싱글톤 권장\n\n---\n\n**결론:**\n\n- **static**: 클래스 레벨 가변 변수\n- **static final**: 클래스 레벨 상수 (컴파일 타임 상수 가능)\n- **final**: 인스턴스 레벨 상수 (생성 시 결정)\n\n용도에 맞게 선택하되, 상수는 static final, 불변 필드는 final, 공유 가변 상태는 신중히 사용하세요.",
      "type": "essay",
      "tags": [
        "Java",
        "static",
        "final",
        "상수"
      ],
      "id": "etc-008",
      "createdAt": "2025-11-17T15:00:00.000007",
      "studyCount": 0
    }
  ]
}