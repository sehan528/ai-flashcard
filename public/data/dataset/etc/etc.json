{
  "name": "개발상식 (CS 기타)",
  "description": "가상화, Docker, CI/CD, static 등 개발 필수 지식",
  "cards": [
    {
      "question": "가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.",
      "answer": "**가상화 (Virtualization):**\n\n**개념:**\n- 물리적 하드웨어 리소스를 논리적으로 추상화하여 여러 개의 독립적인 환경을 만드는 기술\n- 하나의 물리 서버에서 여러 개의 가상 환경을 실행\n\n**핵심 목표:**\n- 리소스 효율성 향상\n- 격리된 실행 환경 제공\n- 유연한 인프라 관리\n\n---\n\n**가상머신 (Virtual Machine):**\n\n**개념:**\n- 가상화 기술의 한 구현 방식\n- 하이퍼바이저(Hypervisor)를 통해 완전한 운영체제를 가상화\n\n**구조:**\n- Host OS (물리 서버 운영체제)\n- Hypervisor (VMware, VirtualBox, Hyper-V 등)\n- Guest OS (각 VM의 독립적인 OS)\n- Application\n\n---\n\n**차이점:**\n\n**가상화:**\n- **광범위한 개념**: 하드웨어, OS, 네트워크, 스토리지 등 모든 리소스 가상화 포함\n- **다양한 방식**: VM, 컨테이너, 서버리스 등\n\n**가상머신:**\n- **가상화의 한 방식**: OS 레벨 가상화\n- **완전한 격리**: 각 VM이 독립적인 OS 보유\n- **무거움**: Guest OS 전체를 포함하여 리소스 많이 사용\n\n---\n\n**가상화 방식 비교:**\n\n**1. 가상머신 (VM):**\n- 하이퍼바이저 기반\n- 완전한 OS 격리\n- 무거움 (GB 단위 메모리)\n- 부팅 시간 느림 (분 단위)\n- 강력한 격리\n\n**2. 컨테이너 (Docker 등):**\n- OS 레벨 가상화\n- Host OS 커널 공유\n- 가벼움 (MB 단위 메모리)\n- 부팅 시간 빠름 (초 단위)\n- 프로세스 격리\n\n**3. 서버리스:**\n- 함수 레벨 가상화\n- 인프라 추상화\n- 이벤트 기반 실행\n\n---\n\n**요약:**\n\n- **가상화**: 리소스를 논리적으로 분할하는 기술 전반\n- **가상머신**: 가상화 기술 중 하이퍼바이저를 이용해 완전한 OS를 가상화하는 방식\n\n가상화는 큰 개념이고, 가상머신은 그 구현 방법 중 하나입니다.",
      "type": "essay",
      "tags": [
        "가상화",
        "VM",
        "인프라",
        "클라우드"
      ],
      "id": "etc-001",
      "createdAt": "2025-11-17T15:00:00.000000",
      "studyCount": 0
    },
    {
      "question": "그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?",
      "answer": "**Docker의 분류:**\n\nDocker는 **컨테이너 기반 가상화**에 속합니다.\n\n- **가상화 기술**의 한 방식\n- **가상머신(VM)이 아님**\n- OS 레벨 가상화 (프로세스 격리)\n\n---\n\n**Docker 특징:**\n\n**구조:**\n- Host OS\n- Docker Engine\n- 컨테이너 (독립 실행 환경)\n- Application\n\n**차이점:**\n- Guest OS 없음 (Host OS 커널 공유)\n- 경량화 (MB 단위)\n- 빠른 시작 (초 단위)\n\n---\n\n**VM vs Docker:**\n\n| 항목 | VM | Docker |\n|------|----|----|\n| OS | Guest OS 전체 포함 | Host OS 커널 공유 |\n| 크기 | GB 단위 | MB 단위 |\n| 부팅 | 분 단위 | 초 단위 |\n| 리소스 | 많이 사용 | 적게 사용 |\n| 격리 | 강력 (하드웨어 레벨) | 프로세스 레벨 |\n| 성능 | 오버헤드 있음 | 네이티브에 가까움 |\n\n---\n\n**Docker를 많이 채택하는 이유:**\n\n---\n\n**1. 경량성:**\n- Guest OS 불필요 → 메모리 절약\n- 수십 개 컨테이너를 하나의 호스트에서 실행 가능\n- VM은 수 개만 가능\n\n**2. 빠른 시작/종료:**\n- 초 단위 시작\n- 배포 속도 향상\n- CI/CD 파이프라인에 적합\n\n**3. 이식성 (Portability):**\n- \"Build once, run anywhere\"\n- 동일한 컨테이너 이미지를 어디서나 실행\n- 개발/스테이징/프로덕션 환경 일관성\n\n**4. 개발 환경 일치:**\n- \"내 컴퓨터에서는 되는데...\" 문제 해결\n- 모든 개발자가 동일한 환경\n- 의존성 충돌 방지\n\n**5. 마이크로서비스 아키텍처:**\n- 서비스별 독립 컨테이너\n- 쉬운 스케일링\n- 서비스 간 격리\n\n**6. 버전 관리:**\n- Docker 이미지 버전 관리\n- 롤백 용이\n- 이미지 레이어 캐싱\n\n**7. 리소스 효율:**\n- 동일 하드웨어에 더 많은 애플리케이션\n- 클라우드 비용 절감\n\n**8. DevOps 문화:**\n- Infrastructure as Code\n- 자동화된 배포\n- 컨테이너 오케스트레이션 (Kubernetes)\n\n**9. 생태계:**\n- Docker Hub (공개 이미지 저장소)\n- 수많은 공식/커뮤니티 이미지\n- 쉬운 시작\n\n**10. 격리:**\n- 애플리케이션 간 의존성 충돌 방지\n- 보안 향상 (제한적이지만)\n\n---\n\n**실제 사용 예:**\n\n**개발:**\n- 로컬에서 MySQL, Redis, Kafka 등을 컨테이너로 실행\n- 프로젝트별 독립 환경\n\n**배포:**\n- 동일한 이미지를 개발/스테이징/프로덕션에 배포\n- 일관성 보장\n\n**마이크로서비스:**\n- 각 서비스를 독립 컨테이너로\n- Kubernetes로 오케스트레이션\n\n---\n\n**한계:**\n\n**1. 보안:**\n- Host OS 커널 공유 → 커널 취약점 영향\n- VM보다 격리 약함\n\n**2. OS 제약:**\n- Linux 컨테이너는 Linux에서만 (Windows는 WSL2 필요)\n- 다른 OS 커널 불가\n\n**3. 상태 관리:**\n- 컨테이너는 기본적으로 stateless\n- 영구 데이터는 볼륨 필요\n\n---\n\n**결론:**\n\nDocker는 **컨테이너 기반 가상화**로, VM보다 경량하고 빠르며 이식성이 뛰어납니다. 마이크로서비스, DevOps, 클라우드 네이티브 환경에서 사실상 표준이 되었습니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "컨테이너",
        "가상화",
        "DevOps"
      ],
      "id": "etc-002",
      "createdAt": "2025-11-17T15:00:00.000001",
      "studyCount": 0
    },
    {
      "question": "하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?",
      "answer": "**위험성:**\n\n맞습니다. Docker 컨테이너는 Host OS 커널을 공유하므로 다음 위험이 있습니다:\n\n**1. 리소스 고갈:**\n- 한 컨테이너가 CPU/메모리 독점\n- 다른 컨테이너 성능 저하 또는 중단\n\n**2. 커널 취약점:**\n- 컨테이너에서 커널 익스플로잇\n- Host 및 다른 컨테이너 침해\n\n**3. 네트워크 간섭:**\n- 같은 네트워크의 컨테이너 간 통신\n- 의도치 않은 접근\n\n**4. 파일시스템 접근:**\n- 볼륨 마운트 오용\n- Host 파일시스템 접근\n\n---\n\n**방어 메커니즘:**\n\nDocker와 Linux는 여러 격리 기술을 제공합니다:\n\n---\n\n**1. Namespace (네임스페이스):**\n\n**개념:**\n- 프로세스, 네트워크, 파일시스템 등을 격리\n- 각 컨테이너가 독립된 뷰를 가짐\n\n**종류:**\n\n**PID Namespace:**\n- 프로세스 ID 격리\n- 컨테이너 내부에서 PID 1부터 시작\n- 다른 컨테이너 프로세스 보이지 않음\n\n**Network Namespace:**\n- 네트워크 인터페이스 격리\n- 각 컨테이너가 독립 IP, 포트\n- 브리지 네트워크로 연결\n\n**Mount Namespace:**\n- 파일시스템 격리\n- 각 컨테이너가 독립 루트 파일시스템\n- Host 파일시스템 보이지 않음\n\n**UTS Namespace:**\n- 호스트명, 도메인명 격리\n\n**IPC Namespace:**\n- 프로세스 간 통신 격리\n\n**User Namespace:**\n- UID/GID 매핑\n- 컨테이너 내부 root가 Host에서는 일반 사용자\n\n---\n\n**2. Cgroups (Control Groups):**\n\n**개념:**\n- 리소스 사용량 제한 및 격리\n\n**제한 항목:**\n\n**CPU:**\n- --cpus 옵션\n- CPU 사용률 제한\n\n**메모리:**\n- --memory 옵션\n- 메모리 한계 설정\n- OOM Killer 방지\n\n**I/O:**\n- 디스크 읽기/쓰기 속도 제한\n\n**네트워크:**\n- 대역폭 제한\n\n**효과:**\n- 한 컨테이너의 리소스 독점 방지\n- 다른 컨테이너 영향 최소화\n\n---\n\n**3. Seccomp (Secure Computing Mode):**\n\n**개념:**\n- 시스템 콜 필터링\n- 위험한 시스템 콜 차단\n\n**기본 프로필:**\n- Docker 기본 seccomp 프로필\n- 300개 이상 시스템 콜 중 일부만 허용\n- reboot, mount 등 위험한 콜 차단\n\n**커스텀 프로필:**\n- JSON으로 허용/차단 시스템 콜 정의\n\n---\n\n**4. AppArmor / SELinux:**\n\n**개념:**\n- 강제 접근 제어 (MAC)\n- 프로세스별 권한 정의\n\n**AppArmor:**\n- Ubuntu/Debian에서 사용\n- 프로파일로 파일/네트워크 접근 제어\n\n**SELinux:**\n- RHEL/CentOS에서 사용\n- 레이블 기반 접근 제어\n\n---\n\n**5. Capabilities:**\n\n**개념:**\n- root 권한을 세분화\n- 필요한 권한만 부여\n\n**예시:**\n- CAP_NET_BIND_SERVICE (1024 미만 포트 바인딩)\n- CAP_SYS_ADMIN (시스템 관리)\n\n**기본:**\n- Docker는 일부 위험한 capabilities 제거\n- --cap-drop, --cap-add로 조정\n\n---\n\n**6. Read-only Root Filesystem:**\n\n**개념:**\n- 컨테이너 루트 파일시스템을 읽기 전용으로\n\n**효과:**\n- 악성 파일 쓰기 방지\n- 불변 인프라\n\n---\n\n**7. User Namespace:**\n\n**개념:**\n- 컨테이너 내부 UID를 Host UID로 매핑\n\n**효과:**\n- 컨테이너 내부 root (UID 0)\n- Host에서는 일반 사용자 (UID 100000 등)\n- Host 파일시스템 접근 제한\n\n---\n\n**8. 네트워크 격리:**\n\n**방법:**\n\n**브리지 네트워크:**\n- 기본 격리\n- 컨테이너끼리 브리지를 통해 통신\n\n**사용자 정의 네트워크:**\n- docker network create mynet\n- 네트워크별 격리\n\n**호스트 네트워크 피하기:**\n- --network host는 격리 없음\n- 필요한 경우만 사용\n\n---\n\n**9. 이미지 보안:**\n\n**신뢰할 수 있는 이미지:**\n- 공식 이미지 사용\n- Docker Content Trust (이미지 서명)\n\n**취약점 스캔:**\n- Trivy, Clair 등으로 이미지 스캔\n- 알려진 CVE 확인\n\n**최소 이미지:**\n- Alpine Linux 등 최소 이미지\n- 공격 표면 축소\n\n---\n\n**10. 런타임 보안:**\n\n**Docker Bench Security:**\n- Docker 보안 Best Practice 검사 도구\n\n**Falco:**\n- 런타임 보안 모니터링\n- 비정상 동작 감지\n\n**gVisor, Kata Containers:**\n- 더 강력한 격리\n- 컨테이너별 경량 커널 (gVisor)\n- 컨테이너별 경량 VM (Kata)\n\n---\n\n**실전 권장사항:**\n\n**1. 리소스 제한:**\n- 모든 컨테이너에 CPU/메모리 제한 설정\n\n**2. 최소 권한:**\n- root로 실행 금지 (USER 지시어)\n- 필요한 capabilities만\n- 읽기 전용 파일시스템\n\n**3. 네트워크 분리:**\n- 서비스별 네트워크 분리\n- 필요한 포트만 노출\n\n**4. 정기 업데이트:**\n- Host OS, Docker, 이미지 최신 유지\n- 보안 패치 적용\n\n**5. 모니터링:**\n- 컨테이너 동작 모니터링\n- 이상 징후 감지\n\n**6. 스캔:**\n- 이미지 취약점 스캔\n- CI/CD에 통합\n\n---\n\n**결론:**\n\nDocker는 Namespace, Cgroups, Seccomp, AppArmor 등 여러 격리 메커니즘을 제공하여 컨테이너 간 간섭을 방지합니다. 하지만 VM보다 격리가 약하므로, 리소스 제한, 최소 권한, 보안 스캔 등의 Best Practice를 따라야 합니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "보안",
        "격리",
        "Namespace",
        "Cgroups"
      ],
      "id": "etc-003",
      "createdAt": "2025-11-17T15:00:00.000002",
      "studyCount": 0
    },
    {
      "question": "Docker 위에 Docker를 올릴 순 없을까요?",
      "answer": "**답변: 가능합니다.**\n\nDocker 위에 Docker를 올리는 것을 **Docker-in-Docker (DinD)**라고 합니다.\n\n---\n\n**구현 방법:**\n\n**1. Docker-in-Docker (DinD):**\n\n**공식 이미지:**\n- docker:dind 이미지 사용\n\n**특징:**\n- 컨테이너 내부에서 Docker daemon 실행\n- 완전히 독립적인 Docker 환경\n- Privileged 모드 필요\n\n**장점:**\n- 완전한 격리\n- 내부 Docker와 외부 Docker 독립\n\n**단점:**\n- 보안 위험 (privileged 모드)\n- 리소스 오버헤드\n- 복잡도 증가\n\n---\n\n**2. Docker Socket 마운트:**\n\n**방법:**\n- Host의 Docker socket을 컨테이너에 마운트\n- /var/run/docker.sock\n\n**특징:**\n- 컨테이너 내부에서 Host의 Docker 제어\n- 실제로는 DinD가 아님 (Host Docker 사용)\n- Privileged 모드 불필요\n\n**장점:**\n- 간단\n- 리소스 효율적\n\n**단점:**\n- Host Docker 접근 (보안 위험)\n- 완전한 격리 아님\n- 컨테이너가 Host Docker 제어 가능\n\n---\n\n**사용 사례:**\n\n**1. CI/CD 파이프라인:**\n\n**목적:**\n- Jenkins, GitLab CI 등에서 Docker 이미지 빌드\n\n**시나리오:**\n- Jenkins 컨테이너 내부에서 Docker 이미지 빌드\n- 빌드된 이미지를 레지스트리에 푸시\n\n**방법:**\n- DinD 또는 Docker socket 마운트\n\n---\n\n**2. Docker 개발/테스트:**\n\n**목적:**\n- Docker 자체 개발 또는 테스트\n\n**시나리오:**\n- 격리된 환경에서 Docker 실험\n\n---\n\n**3. 샌드박스 환경:**\n\n**목적:**\n- 안전하게 Docker 명령 실행\n\n---\n\n**DinD vs Docker Socket 비교:**\n\n| 항목 | DinD | Docker Socket |\n|------|------|---------------|\n| 격리 | 완전 격리 | Host Docker 공유 |\n| Privileged | 필요 | 불필요 |\n| 보안 | 중간 (privileged 위험) | 낮음 (Host 접근) |\n| 리소스 | 높음 (daemon 별도) | 낮음 (Host daemon 공유) |\n| 복잡도 | 높음 | 낮음 |\n| 사용 | 완전한 격리 필요 시 | CI/CD 등 간단한 경우 |\n\n---\n\n**보안 고려사항:**\n\n**DinD:**\n- --privileged 플래그 필요\n- 컨테이너가 Host 커널 전체 접근\n- 보안 위험 높음\n\n**Docker Socket 마운트:**\n- 컨테이너가 Host Docker 제어\n- Host의 모든 컨테이너 제어 가능\n- Host 파일시스템 마운트 가능\n- 사실상 root 권한과 동등\n\n**완화:**\n- 신뢰할 수 있는 이미지만 사용\n- 네트워크 격리\n- 리소스 제한\n- 모니터링\n\n---\n\n**대안:**\n\n**1. Kaniko:**\n- DinD 없이 컨테이너 이미지 빌드\n- Kubernetes에서 사용\n- Privileged 모드 불필요\n\n**2. Buildah:**\n- Rootless 컨테이너 빌드\n- Docker daemon 불필요\n\n**3. BuildKit:**\n- Docker의 차세대 빌드 엔진\n- 더 안전하고 빠름\n\n---\n\n**실전 권장사항:**\n\n**CI/CD:**\n- **단순한 경우**: Docker socket 마운트\n- **격리 필요**: DinD\n- **보안 중요**: Kaniko/Buildah\n\n**개발:**\n- DinD로 실험 환경 구축\n\n**프로덕션:**\n- 가능하면 피하기\n- 대안 도구 사용\n\n---\n\n**예시 시나리오:**\n\n**Jenkins CI:**\n\n**방법 1 (Docker Socket):**\n- Jenkins 컨테이너 실행 시 -v /var/run/docker.sock:/var/run/docker.sock\n- Jenkins job에서 docker build\n- Host Docker 사용하여 빌드\n\n**방법 2 (DinD):**\n- docker:dind 컨테이너 실행\n- Jenkins를 DinD에 연결\n- 완전히 격리된 Docker 환경\n\n---\n\n**한계:**\n\n**1. 성능:**\n- 중첩된 환경으로 오버헤드\n\n**2. 복잡도:**\n- 디버깅 어려움\n- 네트워크 설정 복잡\n\n**3. 이식성:**\n- 환경마다 동작 다를 수 있음\n\n---\n\n**결론:**\n\nDocker 위에 Docker를 올리는 것은 가능하며(DinD) 또는 Host Docker를 공유할 수 있습니다(Socket 마운트). CI/CD에서 유용하지만 보안 위험이 있으므로 신중하게 사용하고, 가능하면 Kaniko 같은 대안을 고려하세요.",
      "type": "essay",
      "tags": [
        "Docker",
        "DinD",
        "Docker-in-Docker",
        "CI/CD"
      ],
      "id": "etc-004",
      "createdAt": "2025-11-17T15:00:00.000003",
      "studyCount": 0
    },
    {
      "question": "CI/CD를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.",
      "answer": "**CI/CD 개념:**\n\n**CI (Continuous Integration):**\n- 지속적 통합\n- 코드 변경을 자주 메인 브랜치에 통합\n- 자동 빌드 및 테스트\n\n**CD (Continuous Delivery/Deployment):**\n- 지속적 배포\n- Delivery: 릴리스 준비 자동화\n- Deployment: 프로덕션 자동 배포\n\n---\n\n**CI/CD 파이프라인 구성 요소:**\n\n**1. 소스 코드 관리:**\n- Git (GitHub, GitLab, Bitbucket)\n- 코드 푸시 시 파이프라인 트리거\n\n**2. 빌드:**\n- 소스 코드 컴파일\n- 의존성 설치\n- Docker 이미지 빌드\n\n**3. 테스트:**\n- 단위 테스트\n- 통합 테스트\n- E2E 테스트\n- 정적 분석, 린트\n\n**4. 배포:**\n- 스테이징 환경 배포\n- 프로덕션 배포\n- 롤백 가능\n\n**5. 모니터링:**\n- 배포 후 헬스 체크\n- 메트릭 수집\n- 알림\n\n---\n\n**일반적인 CI/CD 플로우:**\n\n**1. 코드 푸시:**\n- 개발자가 Git에 코드 푸시\n\n**2. 빌드 트리거:**\n- Webhook으로 CI/CD 서버 알림\n\n**3. 빌드:**\n- 소스 코드 체크아웃\n- 의존성 설치\n- 빌드 (jar, Docker 이미지 등)\n\n**4. 테스트:**\n- 유닛 테스트 실행\n- 테스트 실패 시 파이프라인 중단\n\n**5. 정적 분석:**\n- 코드 품질 검사 (SonarQube 등)\n- 취약점 스캔\n\n**6. 배포 (스테이징):**\n- 스테이징 환경에 배포\n- 통합 테스트\n\n**7. 승인 (선택):**\n- 수동 승인 단계\n- 프로덕션 배포 전 검토\n\n**8. 배포 (프로덕션):**\n- 프로덕션 환경 배포\n- Blue-Green, Canary, Rolling 등\n\n**9. 검증:**\n- 헬스 체크\n- 스모크 테스트\n- 실패 시 자동 롤백\n\n---\n\n**주요 CI/CD 도구:**\n\n**1. Jenkins:**\n- 오픈소스, 가장 널리 사용\n- 플러그인 생태계\n- Jenkinsfile (Pipeline as Code)\n\n**2. GitLab CI/CD:**\n- GitLab 통합\n- .gitlab-ci.yml\n- 간편한 설정\n\n**3. GitHub Actions:**\n- GitHub 통합\n- YAML 기반 워크플로우\n- 무료 티어 제공\n\n**4. CircleCI:**\n- 클라우드 기반\n- 빠른 빌드\n- Docker 지원\n\n**5. Travis CI:**\n- GitHub 통합\n- 오픈소스 무료\n\n**6. AWS CodePipeline, Azure DevOps, Google Cloud Build:**\n- 클라우드 네이티브\n- 각 클라우드 플랫폼 통합\n\n---\n\n**실전 예시 (GitHub Actions):**\n\n**시나리오:**\n- Node.js 애플리케이션\n- main 브랜치 푸시 시 자동 배포\n\n**파이프라인:**\n\n**1. Trigger:**\n- main 브랜치 push\n\n**2. 빌드:**\n- Node.js 설치\n- npm install\n- npm run build\n\n**3. 테스트:**\n- npm test\n\n**4. Docker 이미지 빌드:**\n- docker build\n- Docker Hub에 푸시\n\n**5. 배포:**\n- SSH로 서버 접속\n- docker pull\n- docker-compose up -d\n\n**6. 알림:**\n- Slack 알림 (성공/실패)\n\n---\n\n**장점:**\n\n**1. 빠른 피드백:**\n- 코드 푸시 후 즉시 테스트 결과\n- 문제 조기 발견\n\n**2. 자동화:**\n- 수동 배포 없음\n- 반복 작업 제거\n\n**3. 일관성:**\n- 동일한 프로세스로 빌드/배포\n- 환경 차이 최소화\n\n**4. 품질 향상:**\n- 모든 변경에 자동 테스트\n- 코드 품질 유지\n\n**5. 빠른 배포:**\n- 기능 빠르게 출시\n- 버그 수정 신속 배포\n\n**6. 롤백 용이:**\n- 이전 버전으로 쉽게 롤백\n\n---\n\n**Best Practices:**\n\n**1. Pipeline as Code:**\n- Jenkinsfile, .gitlab-ci.yml 등\n- 버전 관리\n- 코드 리뷰\n\n**2. 작은 변경, 자주 통합:**\n- Feature branch는 짧게\n- 자주 merge\n\n**3. 빠른 빌드:**\n- 병렬 실행\n- 캐싱 활용\n- 10분 이내 목표\n\n**4. 포괄적 테스트:**\n- 유닛, 통합, E2E\n- 충분한 커버리지\n\n**5. 환경 분리:**\n- Dev, Staging, Production\n- 환경별 설정 관리\n\n**6. 보안:**\n- 시크릿 관리 (환경 변수, Vault)\n- 취약점 스캔\n- 이미지 스캔\n\n**7. 모니터링:**\n- 파이프라인 메트릭\n- 실패 알림\n- 배포 후 모니터링\n\n**8. 롤백 전략:**\n- 자동 롤백 조건\n- 빠른 롤백 절차\n\n---\n\n**일반적인 문제와 해결:**\n\n**1. 느린 빌드:**\n- 병렬화\n- 캐싱 (의존성, Docker 레이어)\n- 불필요한 단계 제거\n\n**2. Flaky 테스트:**\n- 불안정한 테스트 수정\n- Retry 로직 (신중히)\n\n**3. 환경 차이:**\n- Docker로 일관된 환경\n- Infrastructure as Code\n\n**4. 시크릿 관리:**\n- 환경 변수\n- AWS Secrets Manager, HashiCorp Vault\n\n---\n\n**배포 전략:**\n\n**1. Blue-Green:**\n- 두 개 환경 유지\n- 새 버전을 Green에 배포\n- 트래픽 전환\n- 롤백 빠름\n\n**2. Canary:**\n- 일부 트래픽만 새 버전으로\n- 점진적 확대\n- 문제 조기 감지\n\n**3. Rolling:**\n- 인스턴스를 하나씩 업데이트\n- 무중단 배포\n\n**4. Feature Flag:**\n- 코드는 배포, 기능은 비활성화\n- 런타임에 토글\n\n---\n\n**결론:**\n\nCI/CD는 현대 소프트웨어 개발의 필수 요소로, 코드 변경을 자동으로 빌드, 테스트, 배포하여 개발 속도와 품질을 향상시킵니다. Jenkins, GitHub Actions, GitLab CI 등 다양한 도구가 있으며, Pipeline as Code로 관리하는 것이 Best Practice입니다.",
      "type": "essay",
      "tags": [
        "CI/CD",
        "DevOps",
        "자동화",
        "배포"
      ],
      "id": "etc-005",
      "createdAt": "2025-11-17T15:00:00.000004",
      "studyCount": 0
    },
    {
      "question": "static 키워드는 어떤 의미를 갖나요?",
      "answer": "**static 키워드 개념:**\n\n**핵심 의미:**\n- **정적 (Static)**: 프로그램 실행 시 메모리에 고정 할당\n- **클래스 레벨**: 인스턴스가 아닌 클래스에 속함\n- **공유**: 모든 인스턴스가 같은 값 공유\n\n---\n\n**언어별 static 의미:**\n\n---\n\n**Java/C#:**\n\n**1. Static 변수 (클래스 변수):**\n\n**특징:**\n- 클래스에 속함 (인스턴스와 무관)\n- 모든 객체가 공유\n- 메모리에 한 번만 할당\n- 프로그램 시작 시 생성, 종료 시 소멸\n\n**사용:**\n- 클래스명.변수명으로 접근\n- 인스턴스 생성 없이 사용 가능\n\n**예시 용도:**\n- 상수 (static final)\n- 카운터 (객체 생성 횟수)\n- 공유 자원\n\n**2. Static 메서드 (클래스 메서드):**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출 가능\n- 인스턴스 변수/메서드 접근 불가\n- this 키워드 사용 불가\n\n**사용:**\n- 유틸리티 함수 (Math.max, Collections.sort)\n- 팩토리 메서드\n\n**3. Static 블록:**\n\n**특징:**\n- 클래스 로딩 시 한 번 실행\n- 초기화 코드\n\n**4. Static 내부 클래스:**\n\n**특징:**\n- 외부 클래스 인스턴스 없이 생성 가능\n- 외부 인스턴스 변수 접근 불가\n\n---\n\n**C/C++:**\n\n**1. Static 지역 변수:**\n\n**특징:**\n- 함수 내부 변수이지만 메모리에 계속 유지\n- 함수 종료 후에도 값 유지\n- 다음 호출 시 이전 값 사용\n\n**사용:**\n- 호출 횟수 카운터\n\n**2. Static 전역 변수/함수:**\n\n**특징:**\n- 파일 스코프 제한\n- 다른 파일에서 접근 불가\n- 내부 링크 (Internal Linkage)\n\n**사용:**\n- 파일 내부 헬퍼 함수\n- 캡슐화\n\n---\n\n**JavaScript (ES6+):**\n\n**Static 메서드:**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출\n- this는 클래스 자체\n\n**사용:**\n- 유틸리티 메서드\n\n---\n\n**Python:**\n\n**Static 메서드 (@staticmethod):**\n\n**특징:**\n- 클래스/인스턴스와 무관\n- self, cls 인자 없음\n- 순수 함수처럼 동작\n\n**vs 클래스 메서드 (@classmethod):**\n- classmethod는 cls 인자 받음\n- staticmethod는 인자 없음\n\n---\n\n**static의 주요 특징:**\n\n**1. 메모리:**\n- 힙이 아닌 데이터 영역 (또는 BSS)\n- 프로그램 시작 시 할당\n- 프로그램 종료 시 해제\n- 인스턴스마다 복사 안 됨\n\n**2. 생명주기:**\n- 프로그램 전체 수명\n- 인스턴스 생명주기와 무관\n\n**3. 접근:**\n- 클래스명으로 접근\n- 인스턴스로도 접근 가능 (권장 안 함)\n\n**4. 공유:**\n- 모든 인스턴스가 공유\n- 한 곳에서 변경하면 모든 곳에 반영\n\n**5. 오버라이딩:**\n- 불가 (대부분 언어)\n- 상속되지만 오버라이딩 안 됨\n\n---\n\n**장점:**\n\n**1. 메모리 효율:**\n- 인스턴스마다 복사 안 됨\n- 한 번만 할당\n\n**2. 유틸리티 함수:**\n- 인스턴스 생성 없이 사용\n- Math.sqrt, Integer.parseInt 등\n\n**3. 공유 데이터:**\n- 모든 인스턴스가 공유할 데이터\n\n**4. 싱글톤:**\n- static 변수로 인스턴스 관리\n\n---\n\n**단점:**\n\n**1. 전역 상태:**\n- 테스트 어려움\n- 예측 어려움\n\n**2. 멀티스레딩:**\n- 동시성 문제\n- 동기화 필요\n\n**3. 의존성:**\n- 강한 결합\n- Mock 어려움\n\n**4. OOP 위반:**\n- 객체 지향 원칙에 어긋남\n- 상태 공유\n\n---\n\n**사용 가이드:**\n\n**적합한 사용:**\n- 상수\n- 유틸리티 함수 (순수 함수)\n- 싱글톤 (신중히)\n- 팩토리 메서드\n\n**피해야 할 사용:**\n- 가변 전역 상태\n- 인스턴스 메서드를 static으로\n- 테스트 어려운 코드\n\n---\n\n**예시 시나리오:**\n\n**카운터:**\n- static 변수로 생성된 객체 수 추적\n- 생성자에서 증가\n\n**싱글톤:**\n- private static 인스턴스\n- public static getInstance()\n\n**유틸리티 클래스:**\n- 모든 메서드가 static\n- 인스턴스 생성 방지 (private 생성자)\n\n**상수:**\n- public static final\n- 변경 불가 공유 값\n\n---\n\n**멀티스레딩 주의:**\n\n**문제:**\n- 여러 스레드가 static 변수 동시 수정\n- Race condition\n\n**해결:**\n- synchronized\n- Atomic 클래스\n- ThreadLocal\n\n---\n\n**결론:**\n\nstatic 키워드는 **클래스 레벨의 정적 멤버**를 정의하며, 모든 인스턴스가 공유합니다. 유틸리티 함수와 상수에 유용하지만, 전역 상태로 인한 테스트와 동시성 문제에 주의해야 합니다.",
      "type": "essay",
      "tags": [
        "static",
        "Java",
        "메모리",
        "OOP"
      ],
      "id": "etc-006",
      "createdAt": "2025-11-17T15:00:00.000005",
      "studyCount": 0
    },
    {
      "question": "컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?",
      "answer": "**컴파일 및 런타임 처리:**\n\nstatic 키워드가 붙은 변수와 함수는 컴파일 시점과 런타임 시점에 특별하게 처리됩니다.\n\n---\n\n**1. 메모리 할당:**\n\n**데이터 영역 (또는 BSS 영역):**\n- static 변수는 스택이나 힙이 아닌 **데이터 영역**에 할당\n- 프로그램 시작 시 메모리 할당\n- 프로그램 종료 시 해제\n\n**영역 구분:**\n\n**Data 영역:**\n- 초기화된 static 변수\n- 컴파일 시 값 결정\n\n**BSS 영역 (Block Started by Symbol):**\n- 초기화되지 않은 static 변수\n- 0으로 초기화\n\n**vs 인스턴스 변수:**\n- 인스턴스 변수: 힙 (객체 생성 시 할당)\n- static 변수: 데이터 영역 (프로그램 시작 시 할당)\n\n**vs 지역 변수:**\n- 지역 변수: 스택 (함수 호출 시 할당)\n- static 변수: 데이터 영역 (계속 유지)\n\n---\n\n**2. 초기화:**\n\n**컴파일 타임:**\n- static 변수의 초기값이 컴파일 시 결정됨\n- 상수 표현식만 가능\n\n**런타임:**\n\n**Java:**\n- 클래스 로딩 시 static 변수 초기화\n- static 블록 실행\n- 클래스가 처음 사용될 때 (lazy)\n\n**C/C++:**\n- 프로그램 시작 시 초기화\n- main() 실행 전\n\n**순서:**\n- 선언 순서대로 초기화\n- static 블록 순서대로 실행\n\n---\n\n**3. 링크:**\n\n**C/C++에서:**\n\n**External Linkage (기본):**\n- 다른 파일에서 접근 가능\n- extern 키워드로 선언\n\n**Internal Linkage (static):**\n- 파일 내부로 제한\n- 다른 파일에서 접근 불가\n- 이름 충돌 방지\n\n**컴파일러 처리:**\n- static 함수/변수는 심볼 테이블에 파일 스코프로 표시\n- 링커가 외부 참조 허용 안 함\n\n---\n\n**4. 메서드 바인딩:**\n\n**Java:**\n\n**Static 메서드:**\n- **정적 바인딩 (Static Binding)**\n- 컴파일 타임에 호출 대상 결정\n- 오버라이딩 불가\n- vtable 사용 안 함\n\n**인스턴스 메서드:**\n- **동적 바인딩 (Dynamic Binding)**\n- 런타임에 호출 대상 결정 (다형성)\n- 오버라이딩 가능\n- vtable 사용\n\n**성능:**\n- static 메서드가 약간 더 빠름 (동적 디스패치 없음)\n- 실제로는 미미한 차이\n\n---\n\n**5. 메모리 레이아웃:**\n\n**프로그램 메모리 구조:**\n\n```\n+------------------+\n| Code (Text)      | ← 실행 코드\n+------------------+\n| Data             | ← 초기화된 static 변수\n+------------------+\n| BSS              | ← 초기화 안 된 static 변수\n+------------------+\n| Heap             | ← 동적 할당 (new)\n+------------------+\n| Stack            | ← 지역 변수, 함수 호출\n+------------------+\n```\n\n**static 변수:**\n- Data 또는 BSS 영역\n- 주소 고정 (컴파일 시 결정 가능)\n\n**인스턴스 변수:**\n- Heap 영역\n- 주소 런타임에 결정\n\n---\n\n**6. 컴파일러 최적화:**\n\n**인라이닝:**\n- static 함수는 인라이닝 후보\n- 파일 내부로 제한되므로 안전하게 인라인 가능\n\n**상수 전파:**\n- static final (Java) 또는 const static (C++)는 컴파일 시 값 대체\n\n**Dead Code Elimination:**\n- 사용되지 않는 static 함수 제거\n\n---\n\n**7. 클래스 로딩 (Java):**\n\n**단계:**\n\n**1. Loading:**\n- .class 파일을 메모리에 로드\n\n**2. Linking:**\n- Verification: 바이트코드 검증\n- Preparation: static 변수 메모리 할당 및 기본값 초기화\n- Resolution: 심볼릭 참조를 실제 메모리 주소로\n\n**3. Initialization:**\n- static 변수 초기화 (명시적 값)\n- static 블록 실행\n\n**시점:**\n- 클래스가 처음 사용될 때\n- 인스턴스 생성, static 멤버 접근, main() 포함 클래스 등\n\n**한 번만:**\n- 클래스 로딩은 JVM에서 한 번만\n- static 초기화도 한 번만\n\n---\n\n**8. ABI (Application Binary Interface):**\n\n**C/C++:**\n- static 함수는 외부 심볼 테이블에 노출 안 됨\n- 바이너리 크기 감소\n- 이름 충돌 방지\n\n---\n\n**9. 재배치 (Relocation):**\n\n**컴파일 시:**\n- static 변수 주소는 상대 주소\n\n**링크 시:**\n- 실제 메모리 주소로 재배치\n- 고정 주소\n\n---\n\n**10. 스레드 안전성:**\n\n**초기화:**\n- Java는 클래스 로딩 시 스레드 안전하게 초기화\n- JVM이 동기화 보장\n\n**사용:**\n- static 변수 접근은 동기화 안 됨\n- 멀티스레딩 시 명시적 동기화 필요\n\n---\n\n**성능 영향:**\n\n**메모리:**\n- 인스턴스 변수보다 메모리 효율적 (한 번만 할당)\n- 하지만 프로그램 전체 수명 동안 유지 (해제 안 됨)\n\n**접근 속도:**\n- 고정 주소 → 빠른 접근\n- 인스턴스 변수는 포인터 역참조 필요\n\n**메서드 호출:**\n- static 메서드는 정적 바인딩 → 약간 빠름\n- 실제로는 미미한 차이\n\n---\n\n**컴파일러별 차이:**\n\n**GCC (C/C++):**\n- static 함수는 .o 파일 내부 심볼\n- nm 명령으로 't' (로컬 텍스트) 표시\n\n**Java Compiler (javac):**\n- static 멤버는 바이트코드에서 ACC_STATIC 플래그\n- invokestatic 명령으로 호출\n\n---\n\n**결론:**\n\nstatic 변수는 컴파일 시 데이터/BSS 영역에 할당되고, 프로그램 시작 시 초기화됩니다. static 함수는 정적 바인딩으로 컴파일 타임에 호출 대상이 결정되며, 파일 스코프로 제한될 수 있습니다. 메모리 효율적이지만 프로그램 전체 수명 동안 유지됩니다.",
      "type": "essay",
      "tags": [
        "static",
        "컴파일",
        "메모리",
        "링크"
      ],
      "id": "etc-007",
      "createdAt": "2025-11-17T15:00:00.000006",
      "studyCount": 0
    },
    {
      "question": "Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요?",
      "answer": "**키워드별 차이:**\n\n---\n\n**1. static:**\n\n**의미:**\n- 클래스 레벨 변수\n- 모든 인스턴스가 공유\n- 변경 가능\n\n**특징:**\n- 값 수정 가능\n- 인스턴스와 무관\n- 메모리에 한 번만 할당\n\n**사용:**\n- 공유 데이터\n- 카운터\n\n---\n\n**2. static final:**\n\n**의미:**\n- 클래스 레벨 상수\n- 모든 인스턴스가 공유\n- **변경 불가**\n\n**특징:**\n- 선언 시 또는 static 블록에서 초기화\n- 재할당 불가\n- 컴파일 타임 상수 (원시 타입/String)\n\n**사용:**\n- 상수 (PI, MAX_VALUE)\n- 설정값\n\n---\n\n**3. final:**\n\n**의미:**\n- 인스턴스 레벨 상수\n- 인스턴스마다 값이 다를 수 있음\n- **변경 불가**\n\n**특징:**\n- 생성자에서 초기화\n- 인스턴스마다 별도 메모리\n- 재할당 불가\n\n**사용:**\n- 불변 객체의 필드\n- 생성 시 결정되는 값\n\n---\n\n**비교표:**\n\n| 특성 | static | static final | final |\n|------|--------|--------------|-------|\n| **수준** | 클래스 | 클래스 | 인스턴스 |\n| **공유** | 모든 인스턴스 | 모든 인스턴스 | 개별 인스턴스 |\n| **변경** | 가능 | 불가 | 불가 |\n| **메모리** | 한 번 할당 | 한 번 할당 | 인스턴스마다 |\n| **초기화** | 선언 시/static 블록 | 선언 시/static 블록 | 선언 시/생성자 |\n| **컴파일 상수** | X | O (원시/String) | X |\n\n---\n\n**static vs static final:**\n\n**공통점:**\n- 클래스 레벨\n- 모든 인스턴스 공유\n- 메모리 한 번 할당\n\n**차이점:**\n\n**static:**\n- 값 변경 가능\n- 가변 공유 상태\n\n**static final:**\n- 값 변경 불가\n- 상수\n\n**언제 사용:**\n\n**static:**\n- 공유 카운터\n- 싱글톤 인스턴스\n\n**static final:**\n- 상수 (Math.PI)\n- 설정값\n- 열거형 대안\n\n---\n\n**final vs static final:**\n\n**공통점:**\n- 값 변경 불가 (재할당 불가)\n\n**차이점:**\n\n**final:**\n- 인스턴스마다 별도 값\n- 생성자에서 초기화 가능\n- 인스턴스마다 메모리 할당\n\n**static final:**\n- 모든 인스턴스 같은 값\n- 선언 시 또는 static 블록에서만 초기화\n- 메모리 한 번만 할당\n\n**언제 사용:**\n\n**final:**\n- 생성 시 결정되는 불변 값\n- 인스턴스별로 다를 수 있음\n\n**static final:**\n- 모든 인스턴스에 동일한 상수\n- 컴파일 타임 상수\n\n---\n\n**컴파일 타임 상수:**\n\n**static final (원시 타입/String):**\n- 컴파일러가 값을 코드에 직접 삽입\n- 성능 최적화\n- 클래스 로딩 없이 사용 가능\n\n**final (인스턴스):**\n- 런타임에 값 결정\n- 컴파일 타임 상수 아님\n\n---\n\n**메모리 효율:**\n\n**static final:**\n- 한 번만 할당\n- 모든 인스턴스가 참조\n- 메모리 효율적\n\n**final:**\n- 인스턴스마다 할당\n- 메모리 더 사용\n\n**예:**\n- 100개 인스턴스\n- static final: 1개 메모리\n- final: 100개 메모리\n\n---\n\n**초기화 시점:**\n\n**static:**\n- 클래스 로딩 시\n- static 블록에서도 가능\n- 여러 번 변경 가능\n\n**static final:**\n- 클래스 로딩 시 한 번만\n- 선언 시 또는 static 블록\n- 이후 변경 불가\n\n**final:**\n- 인스턴스 생성 시\n- 선언 시 또는 생성자\n- 이후 변경 불가\n\n---\n\n**참조 타입에서의 차이:**\n\n**주의:**\n- final은 재할당만 방지\n- 객체 내부 상태는 변경 가능\n\n**static final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**진짜 불변:**\n- 참조를 final로\n- 객체도 불변으로 설계 (모든 필드 final, setter 없음)\n\n---\n\n**사용 패턴:**\n\n**static final 상수:**\n- public static final double PI = 3.14159;\n- public static final int MAX_USERS = 1000;\n\n**static 싱글톤:**\n- private static instance;\n- public static getInstance()\n\n**final 불변 필드:**\n- private final String id;\n- 생성자에서 초기화\n\n---\n\n**성능:**\n\n**static final 상수:**\n- 컴파일 타임 인라인\n- 가장 빠름\n\n**static:**\n- 고정 주소\n- 빠른 접근\n\n**final:**\n- 인스턴스 필드 접근\n- 약간 느림 (포인터 역참조)\n\n---\n\n**Thread Safety:**\n\n**static:**\n- 공유 상태 → 동기화 필요\n\n**static final (불변 객체):**\n- 스레드 안전 (값 변경 안 됨)\n\n**final:**\n- 객체가 불변이면 스레드 안전\n- 가변 객체면 동기화 필요\n\n---\n\n**Best Practices:**\n\n**1. 상수는 static final:**\n- public static final로 선언\n- 대문자 + 언더스코어 (UPPER_CASE)\n\n**2. 가변 공유 상태는 주의:**\n- static 변수는 최소화\n- 동기화 고려\n\n**3. 불변 객체는 final:**\n- 모든 필드 final\n- setter 없음\n- 방어적 복사\n\n**4. 싱글톤은 static:**\n- private static instance\n- enum 싱글톤 권장\n\n---\n\n**결론:**\n\n- **static**: 클래스 레벨 가변 변수\n- **static final**: 클래스 레벨 상수 (컴파일 타임 상수 가능)\n- **final**: 인스턴스 레벨 상수 (생성 시 결정)\n\n용도에 맞게 선택하되, 상수는 static final, 불변 필드는 final, 공유 가변 상태는 신중히 사용하세요.",
      "type": "essay",
      "tags": [
        "Java",
        "static",
        "final",
        "상수"
      ],
      "id": "etc-008",
      "createdAt": "2025-11-17T15:00:00.000007",
      "studyCount": 0
    },
    {
      "question": "객체지향 프로그래밍이 무엇인가요?",
      "answer": "**객체지향 프로그래밍 (OOP: Object-Oriented Programming):**\n\n**정의:**\n- 프로그램을 **객체(Object)**들의 모음으로 구성하는 프로그래밍 패러다임\n- 객체는 데이터(속성)와 행동(메서드)을 하나로 묶은 단위\n- 현실 세계의 개념을 모델링\n\n---\n\n**핵심 개념:**\n\n**1. 객체 (Object):**\n- 데이터와 기능을 함께 캡슐화한 단위\n- 상태(속성)와 행동(메서드) 포함\n\n**2. 클래스 (Class):**\n- 객체를 생성하기 위한 설계도/템플릿\n- 공통 속성과 메서드 정의\n\n**3. 인스턴스 (Instance):**\n- 클래스로부터 생성된 실제 객체\n\n---\n\n**OOP의 4대 특징:**\n\n**1. 캡슐화 (Encapsulation):**\n\n**개념:**\n- 데이터와 메서드를 하나로 묶음\n- 내부 구현을 숨기고 인터페이스만 노출\n\n**목적:**\n- 정보 은닉\n- 무결성 보호\n- 변경 영향 최소화\n\n**구현:**\n- private 필드\n- public getter/setter\n- 직접 접근 차단\n\n---\n\n**2. 상속 (Inheritance):**\n\n**개념:**\n- 기존 클래스의 속성과 메서드를 물려받음\n- 코드 재사용\n\n**장점:**\n- 중복 코드 감소\n- 계층 구조 표현\n- 확장 용이\n\n**주의:**\n- 과도한 상속은 복잡도 증가\n- 구성(Composition) 우선 고려\n\n---\n\n**3. 다형성 (Polymorphism):**\n\n**개념:**\n- 같은 인터페이스로 다른 동작\n- 하나의 타입으로 여러 객체 다룸\n\n**종류:**\n- 오버로딩 (컴파일 타임)\n- 오버라이딩 (런타임)\n\n**장점:**\n- 유연성\n- 확장성\n- 코드 간결\n\n---\n\n**4. 추상화 (Abstraction):**\n\n**개념:**\n- 복잡한 세부사항 숨김\n- 핵심 개념만 표현\n\n**구현:**\n- 추상 클래스\n- 인터페이스\n\n**목적:**\n- 복잡도 관리\n- 공통 기능 정의\n- 구현 분리\n\n---\n\n**장점:**\n\n**1. 코드 재사용:**\n- 상속, 다형성으로 중복 감소\n\n**2. 유지보수:**\n- 캡슐화로 변경 영향 최소화\n- 모듈화\n\n**3. 확장성:**\n- 새로운 클래스 추가 용이\n- 기존 코드 수정 최소\n\n**4. 모델링:**\n- 현실 세계 직관적 표현\n- 이해하기 쉬움\n\n**5. 협업:**\n- 명확한 인터페이스\n- 역할 분담\n\n---\n\n**단점:**\n\n**1. 복잡도:**\n- 작은 프로그램에는 과도\n- 학습 곡선\n\n**2. 성능:**\n- 간접 호출 (vtable)\n- 메모리 오버헤드\n\n**3. 설계:**\n- 초기 설계 중요\n- 잘못된 설계는 오히려 복잡\n\n---\n\n**vs 절차적 프로그래밍:**\n\n| 항목 | 절차적 | 객체지향 |\n|------|--------|----------|\n| 중심 | 함수 | 객체 |\n| 데이터 | 전역/지역 변수 | 객체 내부 캡슐화 |\n| 재사용 | 함수 재사용 | 상속, 다형성 |\n| 확장 | 어려움 | 용이 |\n| 복잡도 | 낮음 (작은 프로그램) | 높음 (큰 프로그램에 유리) |\n\n---\n\n**vs 함수형 프로그래밍:**\n\n| 항목 | 객체지향 | 함수형 |\n|------|----------|--------|\n| 상태 | 객체 내부 상태 | 불변 |\n| 부수효과 | 허용 | 최소화 |\n| 데이터 | 캡슐화 | 변환 |\n| 재사용 | 상속, 다형성 | 고차 함수, 합성 |\n\n---\n\n**설계 원칙:**\n\n**SOLID:**\n- 단일 책임 원칙\n- 개방-폐쇄 원칙\n- 리스코프 치환 원칙\n- 인터페이스 분리 원칙\n- 의존관계 역전 원칙\n\n**DRY (Don't Repeat Yourself):**\n- 중복 제거\n\n**KISS (Keep It Simple, Stupid):**\n- 단순하게\n\n**YAGNI (You Aren't Gonna Need It):**\n- 필요한 것만 구현\n\n---\n\n**적용 시나리오:**\n\n**적합:**\n- 대규모 프로젝트\n- 복잡한 도메인\n- 팀 협업\n- 장기 유지보수\n- GUI 애플리케이션\n\n**부적합:**\n- 간단한 스크립트\n- 성능 크리티컬\n- 함수형 패러다임 더 적합한 경우\n\n---\n\n**주요 언어:**\n\n**순수 OOP:**\n- Java, C#, Smalltalk\n\n**멀티 패러다임:**\n- Python, C++, JavaScript, Kotlin\n\n---\n\n**결론:**\n\n객체지향 프로그래밍은 **캡슐화, 상속, 다형성, 추상화**를 통해 현실 세계를 모델링하고 코드 재사용과 유지보수성을 향상시키는 패러다임입니다. 대규모 프로젝트와 팀 협업에 유리하지만, 적절한 설계가 중요합니다.",
      "type": "essay",
      "tags": [
        "OOP",
        "객체지향",
        "캡슐화",
        "상속",
        "다형성"
      ],
      "id": "etc-009",
      "createdAt": "2025-11-17T15:00:00.000008",
      "studyCount": 0
    },
    {
      "question": "SOLID 원칙에 대해 설명해 주세요.",
      "answer": "**SOLID 원칙:**\n\n객체지향 설계의 5가지 기본 원칙으로, 유지보수와 확장이 쉬운 소프트웨어를 만들기 위한 가이드라인입니다.\n\n---\n\n**1. SRP (Single Responsibility Principle) - 단일 책임 원칙:**\n\n**정의:**\n- 클래스는 하나의 책임만 가져야 함\n- 변경 이유가 하나여야 함\n\n**의미:**\n- 한 클래스는 한 가지 일만\n- 여러 기능을 하나에 넣지 않음\n\n**위반 예:**\n- User 클래스가 DB 저장, 이메일 전송, 로깅 모두 수행\n\n**준수:**\n- User 클래스: 사용자 데이터만\n- UserRepository: DB 저장\n- EmailService: 이메일 전송\n- Logger: 로깅\n\n**장점:**\n- 변경 영향 최소화\n- 테스트 용이\n- 이해하기 쉬움\n\n---\n\n**2. OCP (Open-Closed Principle) - 개방-폐쇄 원칙:**\n\n**정의:**\n- 확장에는 열려 있고, 수정에는 닫혀 있어야 함\n- 기존 코드 수정 없이 기능 추가\n\n**의미:**\n- 새 기능 추가 시 기존 코드 변경 최소화\n- 인터페이스, 추상 클래스 활용\n\n**위반 예:**\n- 결제 방법 추가할 때마다 결제 클래스 수정\n\n**준수:**\n- Payment 인터페이스 정의\n- CreditCardPayment, PayPalPayment 구현\n- 새 결제 방법은 새 클래스 추가만\n\n**구현:**\n- 인터페이스/추상 클래스\n- 전략 패턴\n- 템플릿 메서드 패턴\n\n**장점:**\n- 기존 코드 안정성\n- 확장 용이\n\n---\n\n**3. LSP (Liskov Substitution Principle) - 리스코프 치환 원칙:**\n\n**정의:**\n- 서브타입은 기반타입으로 교체 가능해야 함\n- 부모 클래스 대신 자식 클래스 사용해도 문제없어야 함\n\n**의미:**\n- 상속 시 부모의 동작을 완전히 대체\n- 자식이 부모의 계약 위반하면 안 됨\n\n**위반 예:**\n- Rectangle (직사각형) → Square (정사각형) 상속\n- Square는 width와 height가 같아야 함\n- setWidth 호출 시 예상과 다르게 동작\n\n**준수:**\n- 올바른 추상화\n- is-a 관계 재검토\n- 계약(contract) 준수\n\n**장점:**\n- 다형성 안전\n- 예측 가능\n\n---\n\n**4. ISP (Interface Segregation Principle) - 인터페이스 분리 원칙:**\n\n**정의:**\n- 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함\n- 인터페이스를 작고 구체적으로\n\n**의미:**\n- 큰 인터페이스를 여러 작은 인터페이스로 분리\n- 필요한 것만 구현\n\n**위반 예:**\n- Printer 인터페이스: print, scan, fax\n- 단순 프린터는 scan, fax 불필요\n\n**준수:**\n- Printable 인터페이스: print\n- Scannable 인터페이스: scan\n- Faxable 인터페이스: fax\n- 필요한 인터페이스만 구현\n\n**장점:**\n- 불필요한 의존성 제거\n- 인터페이스 명확\n- 변경 영향 최소\n\n---\n\n**5. DIP (Dependency Inversion Principle) - 의존관계 역전 원칙:**\n\n**정의:**\n- 고수준 모듈은 저수준 모듈에 의존하지 않아야 함\n- 둘 다 추상화에 의존\n\n**의미:**\n- 구체 클래스가 아닌 인터페이스에 의존\n- 의존성 주입 (Dependency Injection)\n\n**위반 예:**\n- UserService가 MySQLUserRepository에 직접 의존\n\n**준수:**\n- UserService가 UserRepository 인터페이스에 의존\n- MySQLUserRepository, MongoUserRepository 모두 구현 가능\n- 의존성 주입으로 구현체 전달\n\n**장점:**\n- 결합도 낮춤\n- 테스트 용이 (Mock 가능)\n- 유연성\n\n---\n\n**SOLID 종합 효과:**\n\n**1. 유지보수성:**\n- 변경 영향 최소화\n- 이해하기 쉬움\n\n**2. 확장성:**\n- 새 기능 추가 용이\n- 기존 코드 수정 최소\n\n**3. 테스트:**\n- 단위 테스트 작성 쉬움\n- Mock 가능\n\n**4. 재사용:**\n- 모듈화\n- 다른 프로젝트에 재사용\n\n**5. 유연성:**\n- 요구사항 변경에 대응\n\n---\n\n**적용 가이드:**\n\n**균형:**\n- 모든 원칙을 항상 완벽히 지킬 필요 없음\n- 과도한 추상화는 복잡도 증가\n- 실용성과 원칙의 균형\n\n**점진적:**\n- 처음부터 완벽한 설계 어려움\n- 리팩토링으로 점진적 개선\n\n**상황 판단:**\n- 프로젝트 규모와 복잡도 고려\n- 작은 프로젝트는 간단하게\n\n---\n\n**실전 적용:**\n\n**의존성 주입:**\n- DIP 구현\n- Spring, Dagger 등 프레임워크 활용\n\n**인터페이스 설계:**\n- ISP 고려\n- 작고 명확한 인터페이스\n\n**리팩토링:**\n- 코드 스멜 발견 시 SOLID 검토\n- 지속적 개선\n\n---\n\n**결론:**\n\nSOLID 원칙은 **단일 책임, 개방-폐쇄, 리스코프 치환, 인터페이스 분리, 의존관계 역전**으로, 유지보수와 확장이 쉬운 객체지향 설계를 위한 핵심 가이드라인입니다. 실용성과 균형을 유지하며 적용하세요.",
      "type": "essay",
      "tags": [
        "SOLID",
        "설계원칙",
        "OOP",
        "SRP",
        "OCP",
        "LSP",
        "ISP",
        "DIP"
      ],
      "id": "etc-010",
      "createdAt": "2025-11-17T15:00:00.000009",
      "studyCount": 0
    },
    {
      "question": "다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.",
      "answer": "**다형성 (Polymorphism):**\n\n**정의:**\n- \"여러 형태\" (poly: 여러, morph: 형태)\n- 같은 인터페이스로 다른 동작을 수행\n- 하나의 타입으로 여러 객체를 다룸\n\n**핵심:**\n- 동일한 메서드 호출이 객체에 따라 다르게 동작\n\n---\n\n**정적 다형성 (Static/Compile-time Polymorphism):**\n\n**정의:**\n- 컴파일 타임에 결정\n- 컴파일러가 어떤 메서드 호출할지 결정\n\n**구현 방법:**\n\n**1. 오버로딩 (Overloading):**\n\n**메서드 오버로딩:**\n- 같은 이름, 다른 파라미터\n- 컴파일러가 파라미터로 구분\n\n**특징:**\n- 같은 클래스 내\n- 파라미터 타입/개수/순서 다름\n- 리턴 타입만 다른 것은 안 됨\n\n**연산자 오버로딩 (C++):**\n- 연산자 동작 재정의\n- Java는 미지원\n\n**2. 템플릿/제네릭:**\n- 타입을 파라미터로\n- 컴파일 시 타입 결정\n\n**장점:**\n- 빠름 (런타임 오버헤드 없음)\n- 타입 안전\n\n**단점:**\n- 유연성 부족\n- 컴파일 시 결정되어 변경 불가\n\n---\n\n**동적 다형성 (Dynamic/Runtime Polymorphism):**\n\n**정의:**\n- 런타임에 결정\n- 실제 객체 타입에 따라 메서드 결정\n\n**구현 방법:**\n\n**1. 오버라이딩 (Overriding):**\n\n**메서드 오버라이딩:**\n- 부모 클래스 메서드를 자식이 재정의\n- 같은 시그니처\n\n**특징:**\n- 상속 관계\n- 메서드 이름, 파라미터, 리턴 타입 동일\n- @Override 어노테이션 (Java)\n\n**2. 인터페이스 구현:**\n- 인터페이스 메서드 구현\n- 여러 구현체\n\n**메커니즘:**\n\n**가상 함수 테이블 (vtable):**\n- 각 클래스가 가상 함수 포인터 테이블 보유\n- 런타임에 vtable 참조하여 실제 메서드 호출\n- 약간의 성능 오버헤드\n\n**장점:**\n- 유연성 (런타임 결정)\n- 확장성 (새 클래스 추가)\n- 다형성의 진정한 힘\n\n**단점:**\n- 런타임 오버헤드 (vtable 참조)\n- 약간 느림\n\n---\n\n**비교:**\n\n| 항목 | 정적 다형성 | 동적 다형성 |\n|------|-------------|-------------|\n| **결정 시점** | 컴파일 타임 | 런타임 |\n| **구현** | 오버로딩, 템플릿 | 오버라이딩, 인터페이스 |\n| **바인딩** | 정적 바인딩 | 동적 바인딩 |\n| **성능** | 빠름 | 약간 느림 (vtable) |\n| **유연성** | 낮음 | 높음 |\n| **확장** | 컴파일 시 결정 | 런타임 확장 가능 |\n| **예** | print(int), print(String) | Animal.speak() → Dog, Cat |\n\n---\n\n**동적 다형성 예시:**\n\n**시나리오:**\n- Animal 부모 클래스\n- Dog, Cat 자식 클래스\n- speak() 메서드 오버라이딩\n\n**효과:**\n- Animal 타입으로 Dog, Cat 다룸\n- speak() 호출 시 실제 객체에 따라 다르게 동작\n- Dog: \"멍멍\", Cat: \"야옹\"\n\n**장점:**\n- 새 동물 추가 시 Animal 타입으로 다룸\n- 기존 코드 수정 불필요\n- 확장에 열려 있음 (OCP)\n\n---\n\n**정적 다형성 예시:**\n\n**메서드 오버로딩:**\n- print(int x)\n- print(String s)\n- print(double d)\n\n**효과:**\n- 같은 이름 print\n- 파라미터 타입에 따라 다른 메서드 호출\n- 컴파일러가 결정\n\n---\n\n**다형성의 장점:**\n\n**1. 코드 재사용:**\n- 공통 인터페이스로 여러 구현\n\n**2. 확장성:**\n- 새 클래스 추가 용이\n- 기존 코드 수정 최소\n\n**3. 유지보수:**\n- 변경 영향 최소화\n\n**4. 유연성:**\n- 런타임에 동작 변경\n\n**5. 간결함:**\n- 타입별 분기 불필요\n\n---\n\n**다형성 활용 패턴:**\n\n**1. 전략 패턴 (Strategy):**\n- 알고리즘을 인터페이스로\n- 런타임에 전략 교체\n\n**2. 템플릿 메서드 (Template Method):**\n- 골격은 부모가 정의\n- 세부는 자식이 구현\n\n**3. 팩토리 (Factory):**\n- 인터페이스 타입 반환\n- 실제 구현체는 숨김\n\n**4. 의존성 주입 (DI):**\n- 인터페이스에 의존\n- 구현체는 주입\n\n---\n\n**주의사항:**\n\n**1. 오버라이딩 규칙:**\n- 접근 제어자: 더 넓게 또는 같게\n- 예외: 더 좁게 또는 같게\n- 리턴 타입: 공변 반환 타입 가능\n\n**2. final 메서드:**\n- 오버라이딩 불가\n\n**3. static 메서드:**\n- 오버라이딩 불가\n- 정적 바인딩\n\n**4. private 메서드:**\n- 오버라이딩 불가 (접근 불가)\n\n---\n\n**언어별 차이:**\n\n**Java:**\n- 기본적으로 모든 메서드가 가상 (오버라이딩 가능)\n- final로 방지\n\n**C++:**\n- virtual 키워드 명시 필요\n- 명시하지 않으면 정적 바인딩\n\n**Python:**\n- 모든 메서드가 가상\n- 덕 타이핑\n\n---\n\n**결론:**\n\n다형성은 **같은 인터페이스로 다른 동작**을 수행하는 OOP의 핵심입니다. **정적 다형성**(오버로딩, 컴파일 타임)은 빠르고, **동적 다형성**(오버라이딩, 런타임)은 유연합니다. 상황에 맞게 활용하세요.",
      "type": "essay",
      "tags": [
        "다형성",
        "Polymorphism",
        "오버로딩",
        "오버라이딩",
        "OOP"
      ],
      "id": "etc-011",
      "createdAt": "2025-11-17T15:00:00.000010",
      "studyCount": 0
    },
    {
      "question": "오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.",
      "answer": "**오버로딩 (Overloading):**\n\n**정의:**\n- 같은 이름의 메서드를 여러 개 정의\n- 파라미터가 다름 (타입, 개수, 순서)\n\n**조건:**\n- 메서드 이름: 동일\n- 파라미터: 타입, 개수, 순서 중 하나 이상 다름\n- 리턴 타입: 무관 (리턴 타입만 다른 것은 불가)\n- 접근 제어자: 무관\n\n**위치:**\n- 같은 클래스 내\n\n**바인딩:**\n- 정적 바인딩 (컴파일 타임)\n- 컴파일러가 파라미터로 구분\n\n**목적:**\n- 같은 기능을 다양한 파라미터로 제공\n- 편의성\n\n**다형성:**\n- 정적 다형성 (Compile-time Polymorphism)\n\n---\n\n**오버라이딩 (Overriding):**\n\n**정의:**\n- 부모 클래스의 메서드를 자식 클래스에서 재정의\n- 같은 시그니처\n\n**조건:**\n- 메서드 이름: 동일\n- 파라미터: 완전히 동일 (타입, 개수, 순서)\n- 리턴 타입: 동일 (또는 공변 반환 타입)\n- 접근 제어자: 같거나 더 넓게\n- 예외: 같거나 더 좁게\n\n**위치:**\n- 상속 관계 (부모-자식)\n\n**바인딩:**\n- 동적 바인딩 (런타임)\n- 실제 객체 타입으로 결정\n\n**목적:**\n- 부모 메서드 동작을 변경\n- 자식마다 다른 구현\n\n**다형성:**\n- 동적 다형성 (Runtime Polymorphism)\n\n**어노테이션:**\n- @Override (Java, 권장)\n\n---\n\n**비교표:**\n\n| 항목 | 오버로딩 | 오버라이딩 |\n|------|----------|-----------|\n| **정의** | 같은 이름, 다른 파라미터 | 부모 메서드 재정의 |\n| **위치** | 같은 클래스 | 상속 관계 |\n| **파라미터** | 다름 | 동일 |\n| **리턴 타입** | 무관 | 동일 (공변 가능) |\n| **접근 제어자** | 무관 | 같거나 넓게 |\n| **바인딩** | 정적 (컴파일 타임) | 동적 (런타임) |\n| **다형성** | 정적 다형성 | 동적 다형성 |\n| **목적** | 편의성 | 기능 변경 |\n| **키워드** | 없음 | @Override (권장) |\n\n---\n\n**오버로딩 예시:**\n\n**시나리오:**\n- print 메서드를 다양한 타입으로\n\n**구현:**\n- print(int x)\n- print(String s)\n- print(int x, int y)\n\n**효과:**\n- 같은 이름 print\n- 파라미터에 따라 다른 메서드 호출\n- 컴파일러가 자동 선택\n\n**장점:**\n- 일관된 메서드 이름\n- 사용 편의\n\n---\n\n**오버라이딩 예시:**\n\n**시나리오:**\n- Animal 부모 클래스의 speak() 메서드\n- Dog, Cat 자식 클래스에서 재정의\n\n**구현:**\n- Animal: speak() → \"소리\"\n- Dog: speak() → \"멍멍\" (오버라이딩)\n- Cat: speak() → \"야옹\" (오버라이딩)\n\n**효과:**\n- Animal 타입으로 Dog, Cat 다룸\n- speak() 호출 시 실제 객체에 따라 다르게 동작\n- 런타임에 결정\n\n**장점:**\n- 다형성\n- 확장성\n\n---\n\n**주의사항:**\n\n**오버로딩:**\n\n**1. 리턴 타입만 다른 것은 불가:**\n- 오류 발생\n- 파라미터가 달라야 함\n\n**2. 가변 인자 (Varargs):**\n- 가장 낮은 우선순위\n- 정확히 맞는 메서드가 없을 때 선택\n\n**3. 자동 형변환:**\n- 작은 타입 → 큰 타입 자동 변환\n- int → long 가능\n\n---\n\n**오버라이딩:**\n\n**1. 접근 제어자:**\n- 더 좁게 불가\n- protected → public (가능)\n- public → protected (불가)\n\n**2. 예외:**\n- 더 넓은 예외 불가\n- IOException → Exception (불가)\n- Exception → IOException (가능)\n\n**3. 리턴 타입 (공변 반환 타입):**\n- 자식 타입 가능\n- Animal → Dog (가능, Java 5+)\n\n**4. final 메서드:**\n- 오버라이딩 불가\n\n**5. static 메서드:**\n- 오버라이딩 불가 (숨김, Hiding)\n\n**6. private 메서드:**\n- 오버라이딩 불가 (접근 불가)\n\n---\n\n**오버라이딩 규칙 위반:**\n\n**시그니처 다름:**\n- 오버라이딩 아님\n- 별개 메서드 (오버로딩도 아님)\n\n**접근 제어자 좁힘:**\n- 컴파일 에러\n\n**더 넓은 예외:**\n- 컴파일 에러\n\n---\n\n**@Override 어노테이션:**\n\n**역할:**\n- 오버라이딩 의도 명시\n- 컴파일러가 검증\n\n**장점:**\n- 실수 방지 (오타, 시그니처 불일치)\n- 가독성\n\n**권장:**\n- 항상 사용\n\n---\n\n**언어별 차이:**\n\n**Java:**\n- 모든 메서드 기본적으로 가상 (오버라이딩 가능)\n- final로 방지\n\n**C++:**\n- virtual 키워드 명시 필요\n- 명시 안 하면 오버라이딩 안 됨 (숨김)\n\n**Python:**\n- 모든 메서드 가상\n- 별도 키워드 없음\n\n---\n\n**실전 사용:**\n\n**오버로딩:**\n- 생성자 오버로딩 (다양한 초기화 방법)\n- 유틸리티 메서드 (다양한 입력 처리)\n\n**오버라이딩:**\n- 템플릿 메서드 패턴\n- 전략 패턴\n- 다형성 활용\n\n---\n\n**성능:**\n\n**오버로딩:**\n- 정적 바인딩 → 빠름\n- 컴파일 시 결정되어 오버헤드 없음\n\n**오버라이딩:**\n- 동적 바인딩 → 약간 느림\n- vtable 참조 오버헤드 (미미)\n\n---\n\n**결론:**\n\n**오버로딩:**\n- 같은 이름, 다른 파라미터\n- 같은 클래스 내\n- 정적 바인딩\n- 편의성\n\n**오버라이딩:**\n- 부모 메서드 재정의\n- 상속 관계\n- 동적 바인딩\n- 다형성\n\n두 개념은 이름만 비슷하고 완전히 다른 개념입니다.",
      "type": "essay",
      "tags": [
        "오버로딩",
        "오버라이딩",
        "Overloading",
        "Overriding",
        "OOP"
      ],
      "id": "etc-012",
      "createdAt": "2025-11-17T15:00:00.000011",
      "studyCount": 0
    },
    {
      "question": "클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까요? 그 반대는 성립하나요?",
      "answer": "**클래스 → 객체지향?**\n\n**답변: 아니요, 반드시 그렇지 않습니다.**\n\n---\n\n**클래스가 있어도 객체지향이 아닐 수 있는 이유:**\n\n**1. 객체지향의 핵심:**\n- 캡슐화, 상속, 다형성, 추상화\n- 클래스는 단지 도구일 뿐\n\n**2. 클래스를 절차적으로 사용:**\n- 클래스를 단순히 데이터 구조체로만 사용\n- 절차적 함수들을 모아놓은 네임스페이스로 사용\n- OOP 원칙 무시\n\n**예시 (C++):**\n- C++는 클래스 지원\n- 하지만 절차적으로 코딩 가능\n- struct와 함수 중심 코드\n\n**예시 (Python):**\n- 클래스 있지만 멀티 패러다임\n- 절차적, 함수형으로도 작성 가능\n\n**3. 단순 데이터 홀더:**\n- getter/setter만 있는 클래스\n- 빈약한 도메인 모델 (Anemic Domain Model)\n- 객체지향이라 보기 어려움\n\n---\n\n**진정한 객체지향:**\n\n**필요 조건:**\n- 캡슐화 (데이터와 행동 결합, 정보 은닉)\n- 상속 (코드 재사용)\n- 다형성 (동적 바인딩)\n- 추상화 (인터페이스/추상 클래스)\n\n**철학:**\n- 메시지 전달\n- 책임 주도 설계\n- SOLID 원칙\n\n**단순히 클래스 사용 ≠ 객체지향**\n\n---\n\n**객체지향 → 클래스?**\n\n**답변: 아니요, 반드시 그렇지 않습니다.**\n\n---\n\n**클래스 없이도 객체지향 가능:**\n\n**1. 프로토타입 기반 (Prototype-based):**\n\n**JavaScript (ES5 이전):**\n- 클래스 없음 (ES6 이전)\n- 프로토타입 체인으로 상속\n- 객체에서 객체 생성\n- 객체지향 가능\n\n**Self 언어:**\n- 순수 프로토타입 기반\n- 클래스 개념 없음\n\n**특징:**\n- 클래스 대신 프로토타입 객체\n- 동적으로 객체 생성 및 확장\n- 상속은 프로토타입 체인\n\n**2. 덕 타이핑 (Duck Typing):**\n\n**Python, Ruby:**\n- 클래스 있지만 필수 아님\n- 인터페이스 대신 덕 타이핑\n- \"오리처럼 걷고 꽥꽥거리면 오리다\"\n- 타입보다 행동 중심\n\n**3. 구조체 + 함수 포인터:**\n\n**C:**\n- 클래스 없음\n- struct + 함수 포인터로 OOP 흉내\n- 캡슐화, 다형성 구현 가능 (제한적)\n\n---\n\n**정리:**\n\n**클래스 → 객체지향?**\n- **X**: 클래스 있어도 절차적으로 사용 가능\n- 클래스는 도구, OOP는 설계 철학\n\n**객체지향 → 클래스?**\n- **X**: 프로토타입 기반 (JavaScript), 덕 타이핑 등\n- 클래스 없이도 OOP 가능\n\n---\n\n**핵심:**\n\n**클래스:**\n- 구현 메커니즘\n- 문법적 도구\n\n**객체지향:**\n- 설계 패러다임\n- 철학 (캡슐화, 상속, 다형성, 추상화)\n\n**클래스 ≠ 객체지향**\n\n---\n\n**실제 사례:**\n\n**클래스 있지만 비객체지향:**\n- C++ 코드를 C 스타일로 작성\n- Java로 절차적 프로그래밍\n- 단순 데이터 클래스만 사용\n\n**클래스 없지만 객체지향:**\n- JavaScript (ES5 이전) 프로토타입\n- Self 언어\n- Lua 테이블 기반 OOP\n\n---\n\n**멀티 패러다임 언어:**\n\n**Python, JavaScript, C++, Scala:**\n- 객체지향, 절차적, 함수형 모두 가능\n- 클래스 지원하지만 강제 아님\n- 개발자 선택\n\n---\n\n**결론:**\n\n클래스는 객체지향을 구현하는 **하나의 방법**일 뿐이며, 클래스가 있다고 해서 반드시 객체지향 언어는 아닙니다. 반대로 클래스 없이도 프로토타입 기반 등으로 객체지향이 가능합니다. 중요한 것은 **OOP 원칙과 철학의 적용** 여부입니다.",
      "type": "essay",
      "tags": [
        "OOP",
        "클래스",
        "프로토타입",
        "패러다임"
      ],
      "id": "etc-013",
      "createdAt": "2025-11-17T15:00:00.000012",
      "studyCount": 0
    },
    {
      "question": "프레임워크와 라이브러리의 차이에 대해 설명해 주세요.",
      "answer": "**핵심 차이: 제어의 역전 (IoC)**\n\n---\n\n**라이브러리 (Library):**\n\n**정의:**\n- 개발자가 **호출**하는 코드 모음\n- 특정 기능을 제공하는 도구 모음\n\n**특징:**\n- **개발자가 제어권 보유**\n- 필요할 때 라이브러리 함수 호출\n- 애플리케이션 흐름을 개발자가 결정\n\n**비유:**\n- 도구 상자\n- 필요한 도구를 꺼내 사용\n\n**예시:**\n- lodash (JavaScript 유틸리티)\n- Axios (HTTP 클라이언트)\n- jQuery (DOM 조작)\n- NumPy (Python 수치 계산)\n- Jackson (JSON 파싱)\n\n**사용 방식:**\n- 내 코드에서 라이브러리 함수 호출\n- 언제, 어떻게 사용할지 개발자 결정\n\n---\n\n**프레임워크 (Framework):**\n\n**정의:**\n- 애플리케이션의 **골격(뼈대)**을 제공\n- 개발자가 **채워넣는** 구조\n\n**특징:**\n- **프레임워크가 제어권 보유** (IoC)\n- 정해진 구조와 규칙\n- 프레임워크가 개발자 코드를 호출\n\n**비유:**\n- 집의 골조\n- 정해진 틀 안에서 작업\n\n**예시:**\n- Spring (Java 백엔드)\n- Django (Python 웹)\n- React (JavaScript UI)\n- Angular (JavaScript 프레임워크)\n- Express (Node.js 웹)\n- Ruby on Rails\n\n**사용 방식:**\n- 프레임워크가 정한 구조 따름\n- 특정 위치에 코드 작성\n- 프레임워크가 내 코드 호출\n\n---\n\n**제어의 역전 (IoC: Inversion of Control):**\n\n**라이브러리:**\n- 내 코드 → 라이브러리 호출\n- **내가 제어**\n\n**프레임워크:**\n- 프레임워크 → 내 코드 호출\n- **프레임워크가 제어**\n- Hollywood Principle: \"Don't call us, we'll call you\"\n\n---\n\n**비교표:**\n\n| 항목 | 라이브러리 | 프레임워크 |\n|------|-----------|-----------|\n| **제어권** | 개발자 | 프레임워크 |\n| **호출 방향** | 개발자 → 라이브러리 | 프레임워크 → 개발자 코드 |\n| **자유도** | 높음 | 낮음 (규칙 따름) |\n| **구조** | 제공 안 함 | 전체 구조 제공 |\n| **역할** | 특정 기능 | 애플리케이션 골격 |\n| **선택** | 부분적 사용 | 전체 도입 |\n| **예시** | lodash, Axios | Spring, Django |\n\n---\n\n**구체적 예시:**\n\n**라이브러리 (Axios):**\n- HTTP 요청이 필요할 때\n- axios.get() 호출\n- 내가 원할 때, 원하는 방식으로\n\n**프레임워크 (Spring):**\n- @Controller 어노테이션 달면\n- Spring이 HTTP 요청을 내 메서드로 라우팅\n- 프레임워크가 생명주기 관리\n- 의존성 주입도 프레임워크가 처리\n\n**라이브러리 (jQuery):**\n- DOM 조작 필요 시\n- $('selector').method() 호출\n- 내가 언제, 어떻게 조작할지 결정\n\n**프레임워크 (React):**\n- 컴포넌트 정의\n- React가 렌더링 시점 결정\n- 생명주기 메서드를 React가 호출\n\n---\n\n**자유도 vs 편의성:**\n\n**라이브러리:**\n- **자유도 높음**: 원하는 대로 사용\n- **편의성 낮음**: 구조는 직접 설계\n\n**프레임워크:**\n- **자유도 낮음**: 규칙 따라야 함\n- **편의성 높음**: 구조, 패턴 제공\n\n---\n\n**선택 기준:**\n\n**라이브러리:**\n- 특정 기능만 필요\n- 기존 구조 유지\n- 유연성 중요\n- 작은 프로젝트\n\n**프레임워크:**\n- 전체 애플리케이션 개발\n- 구조화 필요\n- 팀 협업 (일관성)\n- 큰 프로젝트\n- Best Practice 원함\n\n---\n\n**혼합 사용:**\n\n**실제로는:**\n- 프레임워크 + 라이브러리 함께 사용\n- Spring + Jackson\n- React + Axios\n- Django + NumPy\n\n**프레임워크 내에서:**\n- 프레임워크가 제어\n- 필요 시 라이브러리 호출\n\n---\n\n**경계가 모호한 경우:**\n\n**Express (Node.js):**\n- 자칭 \"미니멀 프레임워크\"\n- 라이브러리처럼 사용 가능\n- 하지만 라우팅 등은 프레임워크적\n\n**React:**\n- 공식적으로는 \"라이브러리\"\n- 하지만 프레임워크처럼 구조 제공 (컴포넌트, 생명주기)\n- 논쟁 있음\n\n**기준:**\n- IoC 정도에 따라 판단\n- 제어권이 누구에게 있는가\n\n---\n\n**학습 곡선:**\n\n**라이브러리:**\n- 특정 함수만 배우면 됨\n- 낮은 진입 장벽\n\n**프레임워크:**\n- 전체 구조와 개념 이해 필요\n- 높은 진입 장벽\n- 하지만 마스터하면 생산성 높음\n\n---\n\n**의존성:**\n\n**라이브러리:**\n- 쉽게 교체 가능\n- 다른 라이브러리로 변경 용이\n\n**프레임워크:**\n- 교체 어려움\n- 프레임워크에 종속 (Vendor Lock-in)\n- 전체 재작성 필요할 수 있음\n\n---\n\n**실전 팁:**\n\n**1. 프레임워크 선택 신중히:**\n- 장기적 관점\n- 커뮤니티, 생태계 고려\n\n**2. 프레임워크 규칙 따르기:**\n- 저항하지 말고 철학 이해\n- Best Practice 수용\n\n**3. 라이브러리는 필요한 만큼:**\n- 과도한 의존 지양\n- 직접 구현도 고려\n\n**4. 문서 읽기:**\n- 프레임워크는 특히 문서 중요\n- 구조와 규칙 이해\n\n---\n\n**결론:**\n\n**라이브러리:**\n- 개발자가 호출하는 도구\n- 제어권: 개발자\n- 자유롭게 사용\n\n**프레임워크:**\n- 개발자 코드를 호출하는 골격\n- 제어권: 프레임워크 (IoC)\n- 규칙 따름\n\n핵심은 **제어의 역전(IoC)** 여부입니다.",
      "type": "essay",
      "tags": [
        "프레임워크",
        "라이브러리",
        "IoC",
        "제어의역전"
      ],
      "id": "etc-014",
      "createdAt": "2025-11-17T15:00:00.000013",
      "studyCount": 0
    },
    {
      "question": "Call By Value와 Call By Reference의 차이를 설명해 주세요.",
      "answer": "**호출 방식 (Calling Convention):**\n\n함수에 인자를 전달하는 방식입니다.\n\n---\n\n**Call By Value (값에 의한 호출):**\n\n**개념:**\n- 인자의 **값(복사본)**을 전달\n- 함수 내부에서 파라미터 변경해도 원본 영향 없음\n\n**동작:**\n1. 인자 값 복사\n2. 복사본을 함수에 전달\n3. 함수 내부에서 복사본 수정\n4. 원본은 변경 안 됨\n\n**특징:**\n- 원본 데이터 안전\n- 메모리 사용 (복사본 생성)\n- 큰 데이터는 비효율적\n\n**언어:**\n- C (기본), Java (원시 타입), Go, Rust (기본)\n\n---\n\n**Call By Reference (참조에 의한 호출):**\n\n**개념:**\n- 인자의 **참조(주소)**를 전달\n- 함수 내부에서 원본 직접 수정 가능\n\n**동작:**\n1. 인자의 메모리 주소 전달\n2. 함수가 주소로 원본 접근\n3. 원본 직접 수정\n4. 호출자도 변경 확인\n\n**특징:**\n- 원본 수정 가능\n- 메모리 효율적 (복사 없음)\n- 부수효과 (side effect) 주의\n\n**언어:**\n- C++ (참조자 &), C# (ref 키워드)\n\n---\n\n**비교:**\n\n| 항목 | Call By Value | Call By Reference |\n|------|---------------|-------------------|\n| **전달** | 값 복사 | 주소(참조) 전달 |\n| **원본 변경** | 불가 | 가능 |\n| **메모리** | 복사본 생성 | 복사 없음 |\n| **성능** | 큰 데이터 시 느림 | 빠름 |\n| **안전성** | 안전 | 부수효과 주의 |\n\n---\n\n**언어별 동작:**\n\n---\n\n**C:**\n\n**기본: Call By Value**\n- 모든 인자는 값 복사\n\n**포인터로 참조 흉내:**\n- 포인터 전달 (주소 복사)\n- 역참조로 원본 수정\n\n**참조 전달 없음:**\n- 진정한 Call By Reference 없음\n- 포인터는 주소 값의 복사 (Call By Value)\n\n---\n\n**C++:**\n\n**Call By Value:**\n- 기본 전달 방식\n\n**Call By Reference:**\n- 참조자 (&) 사용\n- 원본 직접 접근\n\n**포인터:**\n- 포인터 값 복사 (Call By Value)\n- 역참조로 원본 수정 가능\n\n---\n\n**Java:**\n\n**항상 Call By Value!**\n\n**원시 타입 (int, double 등):**\n- 값 복사\n- 원본 변경 불가\n\n**참조 타입 (객체):**\n- **참조 값 복사** (Call By Value of Reference)\n- 참조가 가리키는 객체는 같음\n- 객체 내부는 수정 가능\n- 하지만 참조 자체는 변경 안 됨\n\n**핵심:**\n- Java는 Call By Reference 없음\n- 참조 값의 복사 (Call By Value)\n\n---\n\n**Python:**\n\n**Call By Object Reference (또는 Call By Sharing):**\n\n**동작:**\n- 객체 참조 전달\n- 불변 객체 (int, str, tuple): 값처럼 동작\n- 가변 객체 (list, dict): 참조처럼 동작\n\n**특징:**\n- 엄밀히는 Call By Value도 Reference도 아님\n- 객체 참조의 복사\n\n---\n\n**JavaScript:**\n\n**Call By Value (원시 타입):**\n- number, string, boolean 등\n- 값 복사\n\n**Call By Sharing (객체):**\n- 객체, 배열\n- 참조 복사\n- 객체 내부 수정 가능\n- 참조 자체 변경 불가\n\n---\n\n**Go:**\n\n**Call By Value:**\n- 기본적으로 모든 것이 값 복사\n\n**포인터:**\n- 포인터로 참조 전달 흉내\n- *Type으로 포인터 타입\n\n---\n\n**C#:**\n\n**Call By Value (기본):**\n- 값 타입, 참조 타입 모두\n\n**ref 키워드:**\n- Call By Reference\n- 원본 변경 가능\n\n**out 키워드:**\n- 출력 전용 참조\n- 초기화 안 된 변수 전달 가능\n\n---\n\n**용어 혼란:**\n\n**Java는 Call By Value인가 Reference인가?**\n\n**정답: Call By Value**\n\n**혼란:**\n- 객체를 전달하면 주소가 복사됨\n- 하지만 이것도 값(주소 값) 복사\n- **Call By Value of Reference**\n\n**진정한 Call By Reference:**\n- 변수 자체의 별명\n- 참조 자체를 바꿀 수 있음\n- Java는 불가능\n\n---\n\n**실전 예시:**\n\n**C++ Call By Reference:**\n- void swap(int &a, int &b)\n- a와 b는 원본의 별명\n- 값 교환 시 원본도 교환\n\n**Java (Call By Value):**\n- void swap(Integer a, Integer b)\n- a, b는 참조 복사\n- 참조를 바꿔도 원본 참조는 그대로\n- 교환 안 됨\n\n**해결 (Java):**\n- 배열 사용 (swap(arr[0], arr[1]))\n- Wrapper 객체 사용\n\n---\n\n**포인터 vs 참조:**\n\n**포인터 (C/C++):**\n- 주소를 담는 변수\n- null 가능\n- 산술 연산 가능 (포인터 증가)\n- 역참조 필요 (*)\n\n**참조 (C++):**\n- 변수의 별명\n- null 불가 (초기화 필수)\n- 산술 연산 불가\n- 역참조 불필요\n\n---\n\n**성능:**\n\n**Call By Value:**\n- 작은 데이터: 영향 미미\n- 큰 데이터: 복사 비용\n\n**Call By Reference:**\n- 항상 주소만 전달 (빠름)\n- 큰 객체 전달 시 유리\n\n---\n\n**안전성:**\n\n**Call By Value:**\n- 원본 안전\n- 부수효과 없음\n- 함수형 프로그래밍 선호\n\n**Call By Reference:**\n- 원본 변경 가능\n- 부수효과 주의\n- 의도하지 않은 변경 위험\n\n---\n\n**Best Practices:**\n\n**1. 기본은 Call By Value:**\n- 안전성 우선\n\n**2. 성능 필요 시 참조:**\n- 큰 객체 전달\n- const 참조로 안전성 확보 (C++)\n\n**3. 명확한 의도:**\n- 수정 의도면 명시 (ref, &)\n- 읽기만이면 const\n\n**4. 불변 객체:**\n- 가능하면 불변 객체 사용\n- 참조 전달해도 안전\n\n---\n\n**결론:**\n\n**Call By Value:**\n- 값 복사\n- 원본 안전\n- 메모리 사용\n\n**Call By Reference:**\n- 참조(주소) 전달\n- 원본 수정 가능\n- 효율적\n\n언어마다 동작 방식이 다르므로 정확히 이해하고 사용해야 합니다. Java는 항상 Call By Value라는 점을 기억하세요.",
      "type": "essay",
      "tags": [
        "Call By Value",
        "Call By Reference",
        "파라미터전달",
        "메모리"
      ],
      "id": "etc-015",
      "createdAt": "2025-11-17T15:00:00.000014",
      "studyCount": 0
    },
    {
      "question": "과연 모든 언어에 Call By Value와 Call By Reference 개념이 존재할까요?",
      "answer": "**답변: 아니요, 모든 언어에 이 개념이 명확히 존재하는 것은 아닙니다.**\n\n---\n\n**전통적 분류의 한계:**\n\nCall By Value와 Call By Reference는 **C/C++ 중심의 분류**이며, 모든 언어를 설명하기에 부족합니다.\n\n---\n\n**다양한 전달 방식:**\n\n---\n\n**1. Call By Value (값에 의한 호출):**\n\n**언어:**\n- C (기본)\n- Go (기본)\n\n**특징:**\n- 값 복사\n- 원본 불변\n\n---\n\n**2. Call By Reference (참조에 의한 호출):**\n\n**언어:**\n- C++ (참조자 &)\n- C# (ref, out 키워드)\n\n**특징:**\n- 변수의 별명\n- 원본 직접 수정\n\n---\n\n**3. Call By Sharing (공유에 의한 호출):**\n\n**또는 Call By Object Reference**\n\n**언어:**\n- Python\n- JavaScript\n- Ruby\n- Java (엄밀히는 Call By Value of Reference)\n\n**개념:**\n- 객체 참조를 값으로 전달\n- 객체는 공유됨\n- 불변 객체는 Value처럼, 가변 객체는 Reference처럼 동작\n\n**특징:**\n- 참조 복사\n- 객체 내부 수정 가능\n- 참조 자체는 변경 불가\n\n**Java의 경우:**\n- 공식적으로는 \"항상 Call By Value\"\n- 하지만 객체는 참조 값 복사\n- Call By Sharing에 가까운 동작\n\n---\n\n**4. Call By Name (이름에 의한 호출):**\n\n**언어:**\n- Algol\n- Scala (이름 파라미터)\n\n**개념:**\n- 인자 표현식을 전달\n- 사용 시점에 평가\n- Lazy Evaluation\n\n**특징:**\n- 지연 평가\n- 매번 재평가\n\n---\n\n**5. Call By Need:**\n\n**언어:**\n- Haskell\n\n**개념:**\n- Call By Name + 메모이제이션\n- 첫 평가 후 캐시\n- Lazy Evaluation\n\n---\n\n**언어별 실제 동작:**\n\n---\n\n**Python:**\n\n**Call By Object Reference (또는 Sharing):**\n\n**불변 객체 (int, str, tuple):**\n- 값처럼 동작\n- \"변경\"하면 새 객체 생성\n\n**가변 객체 (list, dict, 객체):**\n- 참조처럼 동작\n- 내부 수정 가능\n\n**핵심:**\n- 모든 것이 객체\n- 객체 참조를 전달\n- Call By Value도 Reference도 아닌 제3의 방식\n\n---\n\n**JavaScript:**\n\n**원시 타입 (number, string, boolean):**\n- Call By Value처럼\n\n**객체 (object, array, function):**\n- Call By Sharing\n- 참조 복사, 내부 수정 가능\n\n---\n\n**Java:**\n\n**공식: 항상 Call By Value**\n\n**하지만:**\n- 객체는 참조 값 복사\n- 동작은 Call By Sharing과 유사\n\n**혼란:**\n- \"Java는 Reference인가 Value인가?\" 논쟁\n- 정답: Value (참조 값의 복사)\n- 하지만 Sharing으로 이해하는 게 직관적\n\n---\n\n**Haskell:**\n\n**순수 함수형:**\n- 모든 값이 불변\n- Call By Need (지연 평가)\n- 부수효과 없음\n\n**특징:**\n- 전통적 분류에 맞지 않음\n- 평가 전략이 다름\n\n---\n\n**Rust:**\n\n**소유권 (Ownership) 시스템:**\n\n**Move Semantics:**\n- 소유권 이동\n- 기존 변수 무효화\n\n**Borrow (차용):**\n- 불변 참조 (&T)\n- 가변 참조 (&mut T)\n\n**특징:**\n- Call By Value/Reference 개념 초월\n- 소유권이라는 독특한 개념\n\n---\n\n**왜 단순 분류가 어려운가:**\n\n**1. 언어 패러다임 차이:**\n- 함수형: 불변, 평가 전략\n- 객체지향: 객체 공유\n- 시스템: 포인터, 소유권\n\n**2. 메모리 모델:**\n- 스택/힙 구분 명확한 언어 vs 추상화된 언어\n- GC 유무\n\n**3. 타입 시스템:**\n- 원시 타입 vs 객체\n- 불변 vs 가변\n\n---\n\n**올바른 이해:**\n\n**전통적 분류:**\n- C/C++ 시대의 용어\n- 저수준 메모리 관점\n\n**현대 언어:**\n- 더 복잡하고 다양한 전달 방식\n- 단순히 Value/Reference로 분류 어려움\n\n**대신:**\n- \"이 언어에서 인자 전달 시 무슨 일이 일어나는가?\"\n- 구체적으로 이해\n\n---\n\n**실용적 접근:**\n\n**각 언어의 문서 확인:**\n- Java: \"pass-by-value\"\n- Python: \"pass-by-object-reference\"\n- Rust: \"move and borrow\"\n\n**동작 이해:**\n- 원본이 변경되는가?\n- 복사가 일어나는가?\n- 성능 영향은?\n\n---\n\n**혼란스러운 용어:**\n\n**Java의 경우:**\n- \"pass-by-value\" (공식)\n- \"pass-by-reference-value\" (비공식)\n- \"pass-by-sharing\" (학계)\n\n**모두 같은 동작:**\n- 참조 값 복사\n- 이름만 다름\n\n---\n\n**결론:**\n\n**전통적 분류:**\n- Call By Value\n- Call By Reference\n\n**현실:**\n- Call By Sharing (Python, Java, JS)\n- Call By Name/Need (Haskell)\n- 소유권 (Rust)\n- 기타 다양한 방식\n\n**모든 언어가 Value/Reference로 분류되지 않습니다.** 각 언어의 특성을 이해하고, 단순한 분류에 집착하지 말고 **실제 동작 방식**을 정확히 파악하는 것이 중요합니다.",
      "type": "essay",
      "tags": [
        "Call By Value",
        "Call By Reference",
        "Call By Sharing",
        "파라미터전달"
      ],
      "id": "etc-016",
      "createdAt": "2025-11-17T15:00:00.000015",
      "studyCount": 0
    },
    {
      "question": "순수함수가 무엇인지를 함수형 프로그래밍 매커니즘과 연관지어 설명해 주세요.",
      "answer": "순수함수(Pure Function)는 다음 두 가지 조건을 만족하는 함수입니다:\n\n1. **참조 투명성(Referential Transparency)**: 동일한 입력에 대해 항상 동일한 출력을 반환합니다.\n2. **부수효과 없음(No Side Effects)**: 함수 외부의 상태를 변경하지 않습니다.\n\n함수형 프로그래밍과의 연관성:\n- **불변성(Immutability)**: 순수함수는 입력값을 변경하지 않고 새로운 값을 반환하므로 불변성을 유지합니다.\n- **합성 가능성(Composability)**: 순수함수는 다른 함수와 조합하여 복잡한 로직을 구성할 수 있습니다.\n- **예측 가능성**: 외부 상태에 의존하지 않아 함수의 동작을 쉽게 예측하고 추론할 수 있습니다.\n- **테스트 용이성**: 입력과 출력만 검증하면 되므로 단위 테스트가 간단합니다.\n- **병렬화**: 상태 공유가 없어 동시성 프로그래밍에서 안전하게 사용할 수 있습니다.\n\n함수형 프로그래밍은 이러한 순수함수를 기본 빌딩 블록으로 사용하여 프로그램을 구성하는 패러다임입니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "순수함수"
      ],
      "id": "etc-017",
      "createdAt": "2025-11-17T15:00:00.000017",
      "studyCount": 0
    },
    {
      "question": "Side Effect가 무엇인가요? 이를 모두 없애는 프로그래밍이 이상적이라고 할 수 있을까요?",
      "answer": "Side Effect(부수효과)는 함수가 자신의 반환값 외에 외부 환경에 영향을 주는 모든 동작을 의미합니다.\n\n대표적인 Side Effect:\n- 전역 변수나 정적 변수 수정\n- 파일 시스템 읽기/쓰기\n- 데이터베이스 작업\n- 네트워크 통신\n- 콘솔 입출력\n- 객체의 상태 변경\n- 예외 발생\n\n모든 Side Effect를 없애는 것이 이상적일까?\n**아니오, 실용적이지 않습니다.**\n\n이유:\n1. **실제 프로그램의 필요성**: 실제 소프트웨어는 사용자 입력, 파일 저장, 데이터베이스 접근, 화면 출력 등 Side Effect가 필수적입니다.\n2. **I/O는 본질적으로 Side Effect**: 외부 세계와의 상호작용 없이는 유용한 프로그램을 만들 수 없습니다.\n\n현실적인 접근:\n- Side Effect를 완전히 제거하는 대신 **격리하고 관리**합니다.\n- 핵심 비즈니스 로직은 순수함수로 작성하고, Side Effect는 프로그램의 경계부(입출력 계층)에 제한합니다.\n- 함수형 프로그래밍의 Monad, Effect System 등은 Side Effect를 명시적으로 다루는 방법을 제공합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "부수효과"
      ],
      "id": "etc-018",
      "createdAt": "2025-11-17T15:00:00.000018",
      "studyCount": 0
    },
    {
      "question": "왜 함수형 프로그래밍 매커니즘을 사용한다고 생각하시나요?",
      "answer": "함수형 프로그래밍을 사용하는 주요 이유:\n\n1. **동시성 안전성(Concurrency Safety)**\n   - 불변 데이터와 순수함수는 공유 상태 문제를 원천적으로 방지합니다.\n   - 멀티코어 환경에서 병렬 처리를 안전하게 구현할 수 있습니다.\n\n2. **코드 추론 용이성(Easier Reasoning)**\n   - 함수가 외부 상태에 의존하지 않아 동작을 예측하기 쉽습니다.\n   - 실행 순서에 덜 민감하여 디버깅이 간단합니다.\n\n3. **테스트 용이성(Testability)**\n   - 순수함수는 입력과 출력만 검증하면 되어 단위 테스트가 간단합니다.\n   - 목(Mock) 객체나 복잡한 테스트 설정이 덜 필요합니다.\n\n4. **모듈성과 재사용성(Modularity & Reusability)**\n   - 작은 순수함수들을 조합하여 복잡한 로직을 구성할 수 있습니다.\n   - 고차함수를 통한 추상화로 코드 재사용성이 높아집니다.\n\n5. **버그 감소**\n   - 불변성으로 인한 예기치 않은 상태 변경 방지\n   - 참조 투명성으로 인한 예측 가능한 동작\n\n6. **선언적 스타일(Declarative Style)**\n   - \"어떻게\"보다 \"무엇을\"에 집중하여 코드 가독성이 향상됩니다.\n\n현대 소프트웨어의 복잡성과 동시성 요구사항이 증가하면서 함수형 프로그래밍의 장점이 더욱 부각되고 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍"
      ],
      "id": "etc-019",
      "createdAt": "2025-11-17T15:00:00.000019",
      "studyCount": 0
    },
    {
      "question": "순수함수는 Thread Safe 한가요? 왜 그럴까요?",
      "answer": "네, 순수함수는 Thread Safe합니다.\n\n이유:\n\n1. **공유 상태 없음(No Shared State)**\n   - 순수함수는 외부 변수나 전역 상태를 읽거나 수정하지 않습니다.\n   - 각 함수 호출이 독립적이므로 동시 실행 시 경쟁 조건(Race Condition)이 발생하지 않습니다.\n\n2. **불변성(Immutability)**\n   - 입력 데이터를 변경하지 않고 새로운 값을 반환합니다.\n   - 여러 스레드가 동시에 같은 데이터를 읽어도 안전합니다.\n\n3. **결정적 동작(Deterministic Behavior)**\n   - 동일한 입력에 대해 항상 동일한 출력을 보장합니다.\n   - 실행 타이밍이나 다른 스레드의 동작에 영향받지 않습니다.\n\n4. **외부 의존성 없음**\n   - 외부 리소스(파일, 네트워크, 데이터베이스)에 접근하지 않습니다.\n   - I/O 관련 동시성 문제가 발생하지 않습니다.\n\n5. **락(Lock) 불필요**\n   - 상태 공유가 없어 명시적인 동기화 메커니즘이 필요 없습니다.\n   - 성능 오버헤드와 데드락 위험이 없습니다.\n\n이러한 특성 덕분에 순수함수는 멀티스레드 환경에서 별도의 동기화 없이도 안전하게 병렬 실행될 수 있으며, 이는 함수형 프로그래밍이 동시성 프로그래밍에 적합한 주요 이유 중 하나입니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "동시성",
        "스레드안전성"
      ],
      "id": "etc-020",
      "createdAt": "2025-11-17T15:00:00.000020",
      "studyCount": 0
    },
    {
      "question": "고차함수에 대해 설명해 주세요.",
      "answer": "고차함수(Higher-Order Function)는 다음 중 하나 이상을 만족하는 함수입니다:\n1. 함수를 인자로 받는 함수\n2. 함수를 반환하는 함수\n\n주요 특징:\n\n**함수를 인자로 받는 경우:**\n- map, filter, reduce 등이 대표적입니다.\n- 동작의 일부를 외부에서 주입받아 추상화 수준을 높입니다.\n- 반복되는 패턴을 재사용 가능한 형태로 추상화합니다.\n\n**함수를 반환하는 경우:**\n- 클로저(Closure)를 활용하여 상태를 캡슐화할 수 있습니다.\n- 커링(Currying)과 부분 적용(Partial Application)을 구현할 수 있습니다.\n- 함수 팩토리 패턴을 만들 수 있습니다.\n\n장점:\n1. **추상화**: 공통 패턴을 일반화하여 코드 중복을 줄입니다.\n2. **재사용성**: 동작을 파라미터화하여 다양한 상황에서 재사용할 수 있습니다.\n3. **합성**: 작은 함수들을 조합하여 복잡한 로직을 구성할 수 있습니다.\n4. **선언적 코드**: \"무엇을\" 하는지에 집중하여 가독성이 향상됩니다.\n\n고차함수는 함수형 프로그래밍의 핵심 개념이며, 현대 프로그래밍 언어들은 대부분 고차함수를 지원합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "함수형프로그래밍",
        "고차함수"
      ],
      "id": "etc-021",
      "createdAt": "2025-11-17T15:00:00.000021",
      "studyCount": 0
    },
    {
      "question": "MVC 패턴이 무엇인가요?",
      "answer": "MVC(Model-View-Controller)는 소프트웨어를 세 가지 역할로 분리하는 아키텍처 패턴입니다.\n\n**구성 요소:**\n\n1. **Model (모델)**\n   - 애플리케이션의 데이터와 비즈니스 로직을 담당합니다.\n   - 데이터의 상태와 그 상태를 변경하는 로직을 포함합니다.\n   - View나 Controller에 독립적이어야 합니다.\n   - 데이터 변경 시 Observer 패턴 등을 통해 View에 알립니다.\n\n2. **View (뷰)**\n   - 사용자에게 보여지는 UI를 담당합니다.\n   - Model의 데이터를 시각적으로 표현합니다.\n   - 사용자 입력을 받아 Controller에 전달합니다.\n   - 비즈니스 로직을 포함하지 않습니다.\n\n3. **Controller (컨트롤러)**\n   - 사용자의 입력을 받아 처리합니다.\n   - Model과 View 사이의 중재자 역할을 합니다.\n   - 사용자 입력에 따라 Model을 업데이트하고, 적절한 View를 선택합니다.\n   - 애플리케이션의 흐름을 제어합니다.\n\n**동작 흐름:**\n사용자 입력 → Controller → Model 업데이트 → View 업데이트 → 화면 표시\n\n**장점:**\n- **관심사의 분리**: 각 컴포넌트가 명확한 책임을 가집니다.\n- **재사용성**: Model은 여러 View에서 재사용 가능합니다.\n- **유지보수성**: 변경이 필요한 부분만 수정할 수 있습니다.\n- **병렬 개발**: 각 계층을 독립적으로 개발할 수 있습니다.\n- **테스트 용이성**: 각 컴포넌트를 독립적으로 테스트할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "아키텍처패턴",
        "MVC"
      ],
      "id": "etc-022",
      "createdAt": "2025-11-17T15:00:00.000022",
      "studyCount": 0
    },
    {
      "question": "다른 아키텍쳐 패턴은 없나요? MVC랑 비교해서 어떤 차이가 있나요?",
      "answer": "MVC 외에 다양한 아키텍처 패턴이 있으며, 각각의 특징과 장단점이 있습니다.\n\n**1. MVP (Model-View-Presenter)**\n- **차이점**: Controller 대신 Presenter가 View와 1:1 관계를 맺습니다.\n- Presenter가 View의 인터페이스를 통해 View를 완전히 제어합니다.\n- View는 Presenter에게 모든 이벤트를 위임합니다.\n- **장점**: View와 Model이 완전히 분리되어 테스트가 용이합니다.\n- **단점**: Presenter와 View 간 1:1 매핑으로 클래스가 많아질 수 있습니다.\n\n**2. MVVM (Model-View-ViewModel)**\n- **차이점**: Controller/Presenter 대신 ViewModel이 있으며, 데이터 바인딩을 사용합니다.\n- ViewModel은 View의 추상화이며, View 상태와 동작을 포함합니다.\n- 양방향 데이터 바인딩으로 View와 ViewModel이 자동 동기화됩니다.\n- **장점**: View 로직을 선언적으로 작성하여 코드가 간결합니다.\n- **단점**: 데이터 바인딩 메커니즘이 복잡할 수 있습니다.\n\n**3. Clean Architecture (클린 아키텍처)**\n- **차이점**: 계층형 동심원 구조로 의존성이 안쪽으로만 향합니다.\n- Entities (핵심 비즈니스 로직) → Use Cases → Interface Adapters → Frameworks\n- **장점**: 프레임워크 독립적이며 테스트가 매우 용이합니다.\n- **단점**: 초기 구조 설계가 복잡하고 러닝 커브가 높습니다.\n\n**4. Hexagonal Architecture (육각형 아키텍처, Ports & Adapters)**\n- **차이점**: 비즈니스 로직을 중심에 두고 외부 시스템과의 통신을 Port와 Adapter로 추상화합니다.\n- Port는 인터페이스, Adapter는 구현체입니다.\n- **장점**: 외부 시스템 교체가 용이하고 테스트가 간단합니다.\n- **단점**: 추상화 계층이 많아 초기 개발 비용이 높습니다.\n\n**5. Flux/Redux (단방향 데이터 흐름)**\n- **차이점**: Action → Dispatcher → Store → View의 단방향 흐름을 강제합니다.\n- 상태 관리가 중앙집중화되어 예측 가능합니다.\n- **장점**: 디버깅과 상태 추적이 용이합니다.\n- **단점**: 보일러플레이트 코드가 많을 수 있습니다.\n\n**선택 기준:**\n- 프로젝트 규모, 팀 경험, 요구사항, 플랫폼 특성 등을 고려하여 선택합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "아키텍처패턴"
      ],
      "id": "etc-023",
      "createdAt": "2025-11-17T15:00:00.000023",
      "studyCount": 0
    },
    {
      "question": "디자인 패턴이 무엇인지 설명해주고, 대표적인 디자인 패턴에 대해 설명해 주세요.",
      "answer": "디자인 패턴(Design Pattern)은 소프트웨어 설계에서 반복적으로 발생하는 문제들에 대한 재사용 가능한 해결책입니다.\n\n**디자인 패턴의 목적:**\n- 검증된 설계 방법을 제공하여 개발 시간을 단축합니다.\n- 개발자 간 공통 언어를 제공하여 의사소통을 원활하게 합니다.\n- 유지보수성과 확장성을 향상시킵니다.\n- 코드의 재사용성을 높입니다.\n\n**GoF(Gang of Four) 디자인 패턴 분류:**\n\n**1. 생성 패턴 (Creational Patterns)**\n객체 생성 메커니즘을 다룹니다.\n\n- **Singleton**: 클래스의 인스턴스가 하나만 존재하도록 보장합니다.\n- **Factory Method**: 객체 생성 로직을 서브클래스로 위임합니다.\n- **Abstract Factory**: 관련된 객체군을 생성하는 인터페이스를 제공합니다.\n- **Builder**: 복잡한 객체의 생성 과정을 단계별로 분리합니다.\n- **Prototype**: 기존 객체를 복제하여 새 객체를 생성합니다.\n\n**2. 구조 패턴 (Structural Patterns)**\n클래스와 객체를 조합하여 더 큰 구조를 만듭니다.\n\n- **Adapter**: 호환되지 않는 인터페이스를 연결합니다.\n- **Decorator**: 객체에 동적으로 새로운 기능을 추가합니다.\n- **Proxy**: 객체에 대한 접근을 제어하는 대리자를 제공합니다.\n- **Composite**: 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현합니다.\n- **Facade**: 복잡한 서브시스템에 대한 단순한 인터페이스를 제공합니다.\n\n**3. 행위 패턴 (Behavioral Patterns)**\n객체 간의 책임 분배와 알고리즘을 다룹니다.\n\n- **Strategy**: 알고리즘군을 정의하고 캡슐화하여 교환 가능하게 만듭니다.\n- **Observer**: 객체의 상태 변화를 관찰자들에게 자동으로 알립니다.\n- **Template Method**: 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에 위임합니다.\n- **Command**: 요청을 객체로 캡슐화하여 매개변수화합니다.\n- **Iterator**: 컬렉션의 내부 구조를 노출하지 않고 순차 접근을 제공합니다.\n\n디자인 패턴은 만능이 아니며, 상황에 맞게 적절히 사용해야 합니다. 과도한 사용은 오히려 코드를 복잡하게 만들 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "디자인패턴"
      ],
      "id": "etc-024",
      "createdAt": "2025-11-17T15:00:00.000024",
      "studyCount": 0
    },
    {
      "question": "Singleton의 장단점에 대해 설명해 주세요.",
      "answer": "Singleton 패턴의 장점과 단점:\n\n**장점:**\n\n1. **단일 인스턴스 보장**\n   - 클래스의 인스턴스가 정확히 하나만 존재하도록 보장합니다.\n   - 메모리 낭비를 방지할 수 있습니다.\n\n2. **전역 접근점 제공**\n   - 애플리케이션 어디서나 접근 가능한 전역 접근점을 제공합니다.\n   - 인스턴스에 대한 일관된 접근 방법을 제공합니다.\n\n3. **지연 초기화(Lazy Initialization)**\n   - 실제로 필요할 때까지 인스턴스 생성을 지연시킬 수 있습니다.\n   - 리소스를 효율적으로 사용할 수 있습니다.\n\n4. **공유 리소스 관리**\n   - 데이터베이스 연결, 로거, 설정 관리 등 공유 리소스를 효과적으로 관리할 수 있습니다.\n\n**단점:**\n\n1. **전역 상태(Global State)**\n   - 전역 변수와 유사한 문제를 발생시킵니다.\n   - 프로그램의 여러 부분이 암묵적으로 연결되어 결합도가 높아집니다.\n\n2. **테스트 어려움**\n   - 단위 테스트 시 Mock 객체로 대체하기 어렵습니다.\n   - 테스트 간 상태 공유로 인해 독립적인 테스트가 어렵습니다.\n\n3. **동시성 문제**\n   - 멀티스레드 환경에서 동기화 처리가 필요합니다.\n   - 잘못 구현하면 여러 인스턴스가 생성될 수 있습니다.\n\n4. **단일 책임 원칙(SRP) 위반**\n   - 비즈니스 로직과 인스턴스 생성 관리라는 두 가지 책임을 가집니다.\n\n5. **의존성 주입(DI) 불가**\n   - 의존성을 외부에서 주입받기 어려워 유연성이 떨어집니다.\n   - 대체 구현을 제공하기 어렵습니다.\n\n6. **상속 제한**\n   - Private 생성자로 인해 상속이 어렵거나 불가능합니다.\n\n**권장 사항:**\nSingleton은 신중하게 사용해야 하며, 가능하면 의존성 주입(DI) 컨테이너를 통한 스코프 관리를 고려하는 것이 좋습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "디자인패턴",
        "싱글톤"
      ],
      "id": "etc-025",
      "createdAt": "2025-11-17T15:00:00.000025",
      "studyCount": 0
    },
    {
      "question": "Singleton이 하나의 객체를 생성한다는 것을 어떻게 보장할 수 있을까요?",
      "answer": "Singleton이 단일 인스턴스를 보장하는 여러 방법:\n\n**1. Private 생성자**\n- 외부에서 new 키워드로 인스턴스를 생성하지 못하도록 생성자를 private으로 선언합니다.\n- 클래스 내부에서만 인스턴스를 생성할 수 있게 합니다.\n\n**2. Static 인스턴스 변수**\n- 클래스 내부에 static 변수로 유일한 인스턴스를 저장합니다.\n- 클래스 레벨에서 하나만 존재하도록 보장합니다.\n\n**3. 멀티스레드 환경에서의 안전성 보장 방법:**\n\n**A. Eager Initialization (즉시 초기화)**\n- 클래스 로딩 시점에 인스턴스를 생성합니다.\n- 클래스 로더가 스레드 안전성을 보장합니다.\n- 단점: 사용하지 않아도 인스턴스가 생성됩니다.\n\n**B. Synchronized Method (동기화 메서드)**\n- 인스턴스를 반환하는 메서드에 synchronized 키워드를 사용합니다.\n- 스레드 안전성을 보장하지만 성능 오버헤드가 있습니다.\n\n**C. Double-Checked Locking (이중 확인 잠금)**\n- 인스턴스가 null인지 두 번 확인하여 불필요한 동기화를 줄입니다.\n- volatile 키워드를 함께 사용하여 가시성 문제를 해결합니다.\n- 성능과 안전성의 균형을 맞춥니다.\n\n**D. Bill Pugh Solution (Inner Static Helper Class)**\n- 내부 정적 클래스를 사용하여 인스턴스를 보유합니다.\n- 클래스 로딩 시점이 달라 Lazy Initialization과 Thread Safety를 모두 보장합니다.\n- Java에서 가장 권장되는 방법 중 하나입니다.\n\n**E. Enum (Java 전용)**\n- Enum 타입으로 Singleton을 구현합니다.\n- 직렬화와 리플렉션 공격에도 안전합니다.\n- Joshua Bloch가 \"Effective Java\"에서 권장하는 방법입니다.\n\n**4. 추가 고려사항:**\n- **리플렉션 공격 방지**: 생성자에서 이미 인스턴스가 존재하면 예외를 던집니다.\n- **직렬화/역직렬화**: readResolve 메서드를 구현하여 역직렬화 시에도 동일한 인스턴스를 반환합니다.\n- **클래스 로더 문제**: 여러 클래스 로더 환경에서는 각 로더마다 인스턴스가 생성될 수 있습니다.\n\n각 방법은 상황에 따라 장단점이 있으므로, 요구사항에 맞는 방법을 선택해야 합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "디자인패턴",
        "싱글톤",
        "동시성"
      ],
      "id": "etc-026",
      "createdAt": "2025-11-17T15:00:00.000026",
      "studyCount": 0
    },
    {
      "question": "GC에 대해 설명해 주세요.",
      "answer": "GC(Garbage Collection, 가비지 컬렉션)는 프로그램이 동적으로 할당한 메모리 중 더 이상 사용하지 않는 메모리를 자동으로 회수하는 메모리 관리 기법입니다.\n\n**GC의 목적:**\n- 메모리 누수(Memory Leak) 방지\n- 댕글링 포인터(Dangling Pointer) 문제 해결\n- 이중 해제(Double Free) 오류 방지\n- 개발자의 메모리 관리 부담 감소\n\n**GC의 기본 원리:**\n\n1. **도달 가능성(Reachability) 판단**\n   - GC Root로부터 참조 체인을 따라갈 수 있는 객체는 \"살아있는(Live)\" 객체입니다.\n   - 도달할 수 없는 객체는 \"가비지\"로 간주되어 회수 대상이 됩니다.\n\n2. **GC Root의 종류**\n   - 스택의 지역 변수\n   - 정적 변수\n   - JNI 참조 (Java의 경우)\n   - 활성화된 스레드\n\n**주요 GC 알고리즘:**\n\n1. **Reference Counting (참조 카운팅)**\n   - 각 객체의 참조 횟수를 추적합니다.\n   - 참조 횟수가 0이 되면 즉시 회수합니다.\n   - 순환 참조 문제가 있습니다.\n\n2. **Mark and Sweep (표시 및 수거)**\n   - Mark 단계: GC Root부터 도달 가능한 객체를 표시합니다.\n   - Sweep 단계: 표시되지 않은 객체의 메모리를 회수합니다.\n   - 메모리 단편화가 발생할 수 있습니다.\n\n3. **Mark and Compact (표시 및 압축)**\n   - Mark and Sweep에 압축 단계를 추가합니다.\n   - 살아있는 객체를 한쪽으로 모아 단편화를 해결합니다.\n\n4. **Generational GC (세대별 수집)**\n   - 객체의 수명을 기준으로 Young Generation과 Old Generation으로 나눕니다.\n   - 대부분의 객체는 금방 죽는다는 \"Weak Generational Hypothesis\"에 기반합니다.\n   - Young Generation을 자주, Old Generation을 드물게 수집합니다.\n\n5. **Copying (복사)**\n   - 메모리를 두 영역으로 나누어 사용합니다.\n   - 살아있는 객체를 다른 영역으로 복사합니다.\n   - 단편화가 없지만 메모리 사용량이 2배입니다.\n\n**GC의 동작 방식:**\n- **Stop-the-World**: GC가 실행될 때 애플리케이션 스레드를 일시 정지합니다.\n- **Concurrent GC**: 애플리케이션과 동시에 실행되어 일시 정지 시간을 줄입니다.\n\nGC는 메모리 관리를 자동화하여 개발 생산성을 높이지만, 성능 오버헤드와 예측 불가능한 일시 정지 시간이 발생할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-027",
      "createdAt": "2025-11-17T15:00:00.000027",
      "studyCount": 0
    },
    {
      "question": "본인이 사용하는 언어에서는 GC를 어떻게 구현했나요?",
      "answer": "주요 프로그래밍 언어별 GC 구현 방식:\n\n**Java (JVM)**\n\n1. **Generational GC 기반**\n   - Young Generation: Eden, Survivor 0, Survivor 1로 구성\n   - Old Generation: 오래 살아남은 객체 저장\n   - Permanent/Metaspace: 클래스 메타데이터 저장\n\n2. **다양한 GC 알고리즘 제공**\n   - **Serial GC**: 단일 스레드, 작은 애플리케이션용\n   - **Parallel GC**: 멀티 스레드, 처리량 중심\n   - **CMS (Concurrent Mark Sweep)**: 낮은 지연 시간 목표\n   - **G1 GC**: 대용량 힙, 예측 가능한 일시 정지 시간\n   - **ZGC/Shenandoah**: 매우 낮은 지연 시간 (밀리초 이하)\n\n3. **Minor GC vs Major GC**\n   - Minor GC: Young Generation 수집 (빠름)\n   - Major/Full GC: 전체 힙 수집 (느림)\n\n**Python**\n\n1. **Reference Counting (주 메커니즘)**\n   - 각 객체의 참조 횟수를 추적합니다.\n   - 참조 횟수가 0이 되면 즉시 메모리를 회수합니다.\n   - 실시간성이 좋지만 순환 참조를 처리하지 못합니다.\n\n2. **Cycle Detector (순환 참조 탐지)**\n   - Generational GC 알고리즘을 사용합니다.\n   - 3세대(Generation 0, 1, 2)로 나누어 관리합니다.\n   - 주기적으로 순환 참조를 탐지하고 회수합니다.\n\n**JavaScript (V8 엔진)**\n\n1. **Generational GC**\n   - Young Generation (New Space): Scavenger 알고리즘 사용\n   - Old Generation (Old Space): Mark-Sweep-Compact 사용\n\n2. **Incremental Marking**\n   - GC 작업을 작은 단위로 나누어 일시 정지 시간을 줄입니다.\n\n3. **Concurrent Marking**\n   - 메인 스레드와 병렬로 마킹 작업을 수행합니다.\n\n**Go**\n\n1. **Concurrent Mark-Sweep**\n   - 애플리케이션과 동시에 실행되는 GC\n   - 일시 정지 시간을 밀리초 이하로 유지하는 것이 목표\n\n2. **삼색 표시(Tri-color Marking)**\n   - 흰색(미방문), 회색(방문 중), 검은색(방문 완료)로 객체를 분류합니다.\n\n3. **Write Barrier**\n   - 포인터 변경을 추적하여 일관성을 유지합니다.\n\n**C# (.NET)**\n\n1. **Generational GC**\n   - 3세대(Gen 0, 1, 2)로 구성\n   - Large Object Heap (LOH): 85KB 이상 객체 저장\n\n2. **Workstation vs Server GC**\n   - Workstation: 낮은 지연 시간\n   - Server: 높은 처리량\n\n각 언어는 사용 사례와 성능 목표에 맞춰 서로 다른 GC 전략을 채택하고 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-028",
      "createdAt": "2025-11-17T15:00:00.000028",
      "studyCount": 0
    },
    {
      "question": "GC의 장단점에 대해 설명해 주세요.",
      "answer": "GC(Garbage Collection)의 장단점:\n\n**장점:**\n\n1. **자동 메모리 관리**\n   - 개발자가 명시적으로 메모리를 해제할 필요가 없습니다.\n   - 메모리 관리의 복잡성을 언어/런타임이 담당합니다.\n\n2. **메모리 안전성 향상**\n   - 메모리 누수(Memory Leak) 발생 가능성을 크게 줄입니다.\n   - 댕글링 포인터(Dangling Pointer) 문제를 방지합니다.\n   - 이중 해제(Double Free) 오류를 방지합니다.\n\n3. **개발 생산성 향상**\n   - 메모리 관리 코드 작성 부담이 없어 비즈니스 로직에 집중할 수 있습니다.\n   - 버그 발생 가능성이 줄어듭니다.\n\n4. **메모리 압축**\n   - 일부 GC는 메모리 단편화를 해소하는 압축(Compaction) 기능을 제공합니다.\n\n**단점:**\n\n1. **성능 오버헤드**\n   - GC 실행 시 CPU 자원을 소모합니다.\n   - 메모리 추적을 위한 추가 메타데이터가 필요합니다.\n\n2. **Stop-the-World (STW) 일시 정지**\n   - GC 실행 중 애플리케이션이 일시 정지됩니다.\n   - 실시간 시스템이나 저지연 요구사항이 있는 시스템에서 문제가 될 수 있습니다.\n   - 예측 불가능한 지연 시간이 발생합니다.\n\n3. **메모리 사용량 증가**\n   - GC를 위한 추가 메타데이터와 여유 공간이 필요합니다.\n   - 수동 메모리 관리보다 더 많은 메모리를 사용할 수 있습니다.\n\n4. **제어권 부족**\n   - 개발자가 정확히 언제 메모리가 해제될지 알 수 없습니다.\n   - 특정 시점에 메모리를 해제하도록 강제할 수 없습니다.\n\n5. **GC 튜닝의 어려움**\n   - 최적의 성능을 위해서는 GC 파라미터 조정이 필요할 수 있습니다.\n   - GC 동작 방식에 대한 깊은 이해가 필요합니다.\n\n6. **즉시성 부족**\n   - 객체가 더 이상 사용되지 않아도 즉시 회수되지 않을 수 있습니다.\n   - 파일 핸들, 네트워크 연결 등 리소스 해제가 지연될 수 있습니다.\n\n**결론:**\nGC는 대부분의 애플리케이션에서 생산성과 안전성 측면에서 큰 이점을 제공하지만, 실시간 시스템이나 극한의 성능이 필요한 경우에는 수동 메모리 관리가 더 적합할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-029",
      "createdAt": "2025-11-17T15:00:00.000029",
      "studyCount": 0
    },
    {
      "question": "GC는 어떤 영역에 있는 데이터를 관리하나요?",
      "answer": "GC가 관리하는 메모리 영역과 관리하지 않는 영역:\n\n**GC가 관리하는 영역:**\n\n1. **힙(Heap) 메모리**\n   - 동적으로 할당된 객체들이 저장되는 영역입니다.\n   - new 키워드나 동적 할당으로 생성된 객체들이 위치합니다.\n   - GC의 주요 관리 대상입니다.\n\n2. **힙 메모리의 세부 구조 (Java 기준):**\n   - **Young Generation**: 새로 생성된 객체\n     - Eden Space\n     - Survivor Space (S0, S1)\n   - **Old Generation (Tenured)**: 오래 살아남은 객체\n   - **Metaspace/Permanent Generation**: 클래스 메타데이터 (일부 GC가 관리)\n\n**GC가 관리하지 않는 영역:**\n\n1. **스택(Stack) 메모리**\n   - 지역 변수, 메서드 호출 정보, 파라미터 등이 저장됩니다.\n   - 스코프를 벗어나면 자동으로 제거됩니다 (LIFO 구조).\n   - GC의 관리 대상이 아니지만, **GC Root의 역할**을 합니다.\n\n2. **코드(Code) 영역**\n   - 실행 가능한 코드(바이트코드, 네이티브 코드)가 저장됩니다.\n   - 읽기 전용이며 프로그램 실행 내내 유지됩니다.\n\n3. **데이터(Data) 영역**\n   - 전역 변수, 정적 변수가 저장됩니다.\n   - 프로그램 시작 시 할당되고 종료 시 해제됩니다.\n   - 정적 변수는 GC Root가 될 수 있습니다.\n\n4. **네이티브 메모리 (Off-Heap)**\n   - JNI, Direct Buffer 등으로 할당된 메모리\n   - GC가 직접 관리하지 않으며 명시적 해제가 필요합니다.\n\n**GC Root (GC의 시작점):**\nGC는 다음 위치에서 시작하여 도달 가능한 객체를 추적합니다:\n- 스택의 지역 변수\n- 정적 변수 (Static fields)\n- JNI 참조\n- 활성 스레드\n- 동기화 모니터\n\n**중요 포인트:**\n- GC는 힙 메모리만 직접 관리하지만, 스택과 정적 변수는 GC Root로서 객체의 생존 여부를 결정하는 데 중요한 역할을 합니다.\n- 스택 메모리는 자동으로 관리되지만 GC와는 다른 메커니즘(스코프 기반)으로 동작합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC"
      ],
      "id": "etc-030",
      "createdAt": "2025-11-17T15:00:00.000030",
      "studyCount": 0
    },
    {
      "question": "Reference Counting 방식에 대해 설명하고, 이 알고리즘에서 발생할 수 있는 순환 참조 및 Retain Cycle에 대해 설명해 주세요.",
      "answer": "**Reference Counting (참조 카운팅) 방식:**\n\n각 객체가 몇 개의 참조에 의해 가리켜지고 있는지를 추적하는 GC 방식입니다.\n\n**동작 원리:**\n1. 각 객체는 참조 카운터를 가집니다.\n2. 새로운 참조가 생성되면 카운터를 증가시킵니다.\n3. 참조가 제거되면 카운터를 감소시킵니다.\n4. 카운터가 0이 되면 즉시 메모리를 회수합니다.\n\n**장점:**\n- 구현이 단순하고 직관적입니다.\n- 메모리 회수가 즉각적으로 일어납니다.\n- Stop-the-World 일시 정지가 없습니다.\n- 메모리 사용 패턴이 예측 가능합니다.\n\n**단점:**\n- 참조가 변경될 때마다 카운터 업데이트 오버헤드가 발생합니다.\n- 순환 참조 문제를 해결할 수 없습니다.\n- 멀티스레드 환경에서 카운터 업데이트를 동기화해야 합니다.\n- 추가 메모리 공간이 필요합니다 (카운터 저장).\n\n**순환 참조(Circular Reference) / Retain Cycle 문제:**\n\n**정의:**\n두 개 이상의 객체가 서로를 참조하여 고리를 형성하는 상황입니다.\n\n**문제점:**\n- 객체들이 외부에서 접근 불가능해도 서로를 참조하고 있어 참조 카운트가 0이 되지 않습니다.\n- 메모리가 영구적으로 회수되지 않아 메모리 누수가 발생합니다.\n\n**예시 시나리오:**\n- 객체 A가 객체 B를 참조\n- 객체 B가 객체 A를 참조\n- 외부에서 A와 B로의 참조가 모두 끊어짐\n- 하지만 A의 참조 카운트 = 1 (B가 참조), B의 참조 카운트 = 1 (A가 참조)\n- 둘 다 카운트가 0이 아니므로 메모리가 회수되지 않음\n\n**해결 방법:**\n\n1. **약한 참조(Weak Reference)**\n   - 참조 카운트를 증가시키지 않는 특별한 참조 타입을 사용합니다.\n   - 순환 참조의 한쪽을 약한 참조로 만들어 고리를 끊습니다.\n\n2. **수동 참조 해제**\n   - 개발자가 명시적으로 참조를 nil/null로 설정하여 고리를 끊습니다.\n\n3. **Cycle Detection (순환 참조 탐지)**\n   - Reference Counting과 함께 주기적으로 순환 참조를 탐지하는 알고리즘을 실행합니다.\n   - Python이 이 방식을 사용합니다 (Reference Counting + Cycle Detector).\n\n4. **자동 참조 관리 도구**\n   - ARC (Automatic Reference Counting) 같은 컴파일러 지원을 활용합니다.\n   - Swift, Objective-C 등에서 사용됩니다.\n\n**실제 사례:**\n- Python: Reference Counting + Generational Cycle Detector\n- Swift: ARC + weak/unowned 참조\n- Objective-C: ARC + weak/strong 참조\n\n순환 참조는 Reference Counting의 가장 큰 약점이며, 이를 해결하기 위해 추가적인 메커니즘이 필요합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "메모리관리",
        "GC",
        "순환참조"
      ],
      "id": "etc-031",
      "createdAt": "2025-11-17T15:00:00.000031",
      "studyCount": 0
    },
    {
      "question": "32비트와 64비트의 차이는 무엇인가요?",
      "answer": "32비트와 64비트의 차이점:\n\n**1. 레지스터와 데이터 처리 단위**\n- **32비트**: CPU 레지스터가 32비트 크기로, 한 번에 32비트(4바이트) 데이터를 처리합니다.\n- **64비트**: CPU 레지스터가 64비트 크기로, 한 번에 64비트(8바이트) 데이터를 처리합니다.\n\n**2. 주소 공간 (Address Space)**\n- **32비트**: 2^32 = 약 43억 개의 주소를 표현할 수 있습니다.\n  - 최대 4GB의 메모리를 직접 주소 지정할 수 있습니다.\n  - 실제로는 OS와 하드웨어 예약으로 약 3.2~3.5GB만 사용 가능합니다.\n- **64비트**: 2^64 = 약 1844경 개의 주소를 표현할 수 있습니다.\n  - 이론적으로 16 exabytes (약 1600만 TB)의 메모리를 주소 지정할 수 있습니다.\n  - 실제로는 하드웨어와 OS 제약으로 수십 TB ~ 수백 TB까지 지원합니다.\n\n**3. 메모리 제한**\n- **32비트 시스템**:\n  - 프로세스당 최대 4GB 메모리 (Windows: 2GB 기본, 3GB 옵션)\n  - 대용량 데이터 처리나 서버 애플리케이션에 제약이 있습니다.\n- **64비트 시스템**:\n  - 프로세스당 수 TB 이상의 메모리 사용 가능\n  - 대용량 데이터베이스, 빅데이터, 과학 계산 등에 적합합니다.\n\n**4. 성능**\n- **32비트**:\n  - 포인터와 레지스터 크기가 작아 메모리 사용량이 적습니다.\n  - 캐시 효율성이 더 좋을 수 있습니다 (포인터 크기가 작아서).\n- **64비트**:\n  - 더 많은 레지스터를 사용할 수 있습니다 (x86-64는 레지스터 수 증가).\n  - 큰 숫자 연산이 더 빠릅니다.\n  - 포인터 크기가 2배로 증가하여 메모리 사용량과 캐시 미스가 증가할 수 있습니다.\n\n**5. 호환성**\n- **32비트**: 32비트 애플리케이션만 실행 가능합니다.\n- **64비트**: 대부분 32비트 애플리케이션도 실행 가능합니다 (WoW64, 호환 모드).\n\n**6. 정수 크기 (언어/플랫폼 의존적)**\n- 일부 언어에서 long, pointer 등의 크기가 달라집니다.\n- C/C++: long과 포인터 크기가 변경될 수 있습니다 (LP64, LLP64 모델).\n\n**7. 보안**\n- **64비트**: ASLR(Address Space Layout Randomization) 등의 보안 기능이 더 효과적입니다.\n- 더 넓은 주소 공간으로 인해 메모리 공격이 어렵습니다.\n\n**실용적 차이:**\n- 4GB 이상 RAM을 사용하려면 64비트 시스템이 필수입니다.\n- 현대 애플리케이션과 OS는 대부분 64비트를 권장하거나 요구합니다.\n- 일부 레거시 하드웨어나 드라이버는 32비트만 지원할 수 있습니다.\n\n**선택 기준:**\n- 대용량 메모리가 필요한 경우: 64비트\n- 레거시 시스템 지원: 32비트\n- 현대 시스템: 대부분 64비트 권장",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "컴퓨터구조"
      ],
      "id": "etc-032",
      "createdAt": "2025-11-17T15:00:00.000032",
      "studyCount": 0
    },
    {
      "question": "32비트에서 가용한 메모리의 크기는 최대 4GB라고 하는데, 왜 그런걸까요?",
      "answer": "32비트 시스템에서 최대 4GB 메모리만 사용할 수 있는 이유는 **주소 공간의 크기 제한** 때문입니다.\n\n**수학적 설명:**\n\n1. **32비트 주소**\n   - 32비트 시스템에서 메모리 주소는 32비트로 표현됩니다.\n   - 32비트로 표현 가능한 서로 다른 값의 개수: 2^32 = 4,294,967,296\n\n2. **바이트 단위 주소 지정**\n   - 대부분의 컴퓨터 아키텍처는 바이트(byte) 단위로 메모리를 주소 지정합니다.\n   - 각 주소는 1바이트의 메모리 위치를 가리킵니다.\n\n3. **최대 메모리 계산**\n   - 4,294,967,296개의 서로 다른 주소\n   - × 1바이트\n   - = 4,294,967,296 바이트\n   - = 4GB (1GB = 2^30 바이트 = 1,073,741,824 바이트)\n\n**추가 설명:**\n\n**실제 사용 가능한 메모리는 4GB보다 적습니다:**\n\n1. **커널 공간 예약**\n   - Windows: 일반적으로 2GB는 커널 공간, 2GB는 사용자 공간 (기본값)\n   - Linux: 일반적으로 1GB는 커널 공간, 3GB는 사용자 공간\n\n2. **메모리 매핑된 I/O**\n   - PCI 장치, 그래픽 카드 등이 주소 공간을 차지합니다.\n   - BIOS/UEFI 펌웨어 영역\n\n3. **실제 사용 가능 메모리**\n   - 4GB RAM을 설치해도 실제로는 약 3.2~3.5GB만 사용 가능한 경우가 많습니다.\n\n**PAE (Physical Address Extension):**\n- 32비트 시스템에서도 4GB 이상의 물리적 RAM을 사용할 수 있게 하는 기술\n- CPU가 36비트 물리 주소를 사용하여 최대 64GB까지 지원\n- 하지만 각 프로세스는 여전히 4GB 가상 주소 공간 제한을 가집니다\n- 서버용 32비트 OS에서 주로 사용되었습니다\n\n**64비트와의 비교:**\n- 64비트: 2^64 = 약 16 exabytes (1600만 TB)\n- 실용적으로는 OS와 하드웨어 제약으로 수십~수백 TB 지원\n- 현대적인 워크로드에 충분한 주소 공간 제공\n\n**결론:**\n32비트의 4GB 제한은 수학적 필연입니다. 2^32개의 고유한 주소로 2^32바이트(4GB)만 표현할 수 있기 때문입니다. 이것이 현대 시스템이 64비트로 전환한 주요 이유 중 하나입니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "컴퓨터구조",
        "메모리"
      ],
      "id": "etc-033",
      "createdAt": "2025-11-17T15:00:00.000033",
      "studyCount": 0
    },
    {
      "question": "인증과 인가의 차이에 대해 설명해 주세요.",
      "answer": "인증(Authentication)과 인가(Authorization)는 보안 시스템의 핵심 개념이지만 서로 다른 목적을 가집니다.\n\n**인증 (Authentication) - \"당신은 누구인가?\"**\n\n**정의:**\n사용자의 신원을 확인하는 과정입니다.\n\n**목적:**\n- 사용자가 자신이 주장하는 사람이 맞는지 검증합니다.\n- \"이 사용자가 정말 본인인가?\"를 확인합니다.\n\n**방법:**\n1. **지식 기반 (Something You Know)**\n   - 비밀번호, PIN, 보안 질문\n\n2. **소유 기반 (Something You Have)**\n   - OTP 토큰, 스마트카드, 휴대폰 (SMS/앱 인증)\n\n3. **생체 기반 (Something You Are)**\n   - 지문, 홍채, 안면 인식, 음성 인식\n\n4. **다중 인증 (Multi-Factor Authentication, MFA)**\n   - 위의 방법 중 2개 이상을 조합\n\n**예시:**\n- 로그인 시 아이디와 비밀번호 입력\n- 지문으로 스마트폰 잠금 해제\n- 은행 앱 접속 시 OTP 인증\n\n---\n\n**인가 (Authorization) - \"무엇을 할 수 있는가?\"**\n\n**정의:**\n인증된 사용자가 특정 리소스나 기능에 접근할 권한이 있는지 확인하는 과정입니다.\n\n**목적:**\n- 사용자의 권한과 허가 범위를 결정합니다.\n- \"이 사용자가 이 작업을 수행할 수 있는가?\"를 판단합니다.\n\n**방법:**\n1. **역할 기반 접근 제어 (RBAC - Role-Based Access Control)**\n   - 사용자에게 역할을 부여하고, 역할별로 권한을 설정\n\n2. **속성 기반 접근 제어 (ABAC - Attribute-Based Access Control)**\n   - 사용자, 리소스, 환경의 속성을 기반으로 권한 결정\n\n3. **접근 제어 목록 (ACL - Access Control List)**\n   - 각 리소스에 대해 누가 어떤 작업을 할 수 있는지 명시\n\n4. **정책 기반 접근 제어 (PBAC - Policy-Based Access Control)**\n   - 정책 규칙에 따라 접근 권한 결정\n\n**예시:**\n- 관리자만 사용자 계정 삭제 가능\n- 일반 사용자는 자신의 게시글만 수정 가능\n- 부서별로 접근 가능한 폴더가 다름\n\n---\n\n**핵심 차이점:**\n\n| 구분 | 인증 (Authentication) | 인가 (Authorization) |\n|------|---------------------|---------------------|\n| 질문 | \"당신은 누구인가?\" | \"무엇을 할 수 있는가?\" |\n| 목적 | 신원 확인 | 권한 확인 |\n| 순서 | 먼저 수행됨 | 인증 이후 수행됨 |\n| 방법 | 비밀번호, 생체인식, OTP | RBAC, ACL, 정책 |\n| 결과 | 신원 검증 성공/실패 | 접근 허용/거부 |\n\n**관계:**\n1. **인증이 먼저, 인가가 나중**\n   - 먼저 누구인지 확인(인증)한 후, 무엇을 할 수 있는지 결정(인가)합니다.\n   \n2. **독립적이지만 연계됨**\n   - 인증 없이 인가는 의미가 없습니다.\n   - 인증되었다고 해서 모든 권한이 주어지는 것은 아닙니다.\n\n**실제 시나리오:**\n1. 사용자가 아이디/비밀번호로 로그인 → **인증**\n2. 로그인 성공 → 인증 완료\n3. 관리자 페이지 접근 시도 → **인가** 검사\n4. 일반 사용자 권한으로는 접근 거부 → 인가 실패\n\n두 개념을 모두 적절히 구현해야 안전하고 효과적인 보안 시스템을 구축할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "보안",
        "인증",
        "인가"
      ],
      "id": "etc-034",
      "createdAt": "2025-11-17T15:00:00.000034",
      "studyCount": 0
    },
    {
      "question": "OAuth가 무엇인지 설명하고, 이것은 인증인지 인가인지에 대해 설명해 주세요.",
      "answer": "**OAuth (Open Authorization)란?**\n\nOAuth는 사용자가 비밀번호를 제공하지 않고도 다른 애플리케이션에게 자신의 리소스에 대한 제한적인 접근 권한을 위임할 수 있게 해주는 개방형 표준 프로토콜입니다.\n\n**핵심 개념:**\n사용자가 A 서비스의 리소스에 대한 접근 권한을 B 서비스에게 안전하게 위임하는 것입니다.\n\n---\n\n**OAuth는 인증인가, 인가인가?**\n\n**OAuth는 '인가(Authorization)' 프로토콜입니다.**\n\n**이유:**\n- OAuth의 본래 목적은 **권한 위임(Authorization Delegation)**입니다.\n- \"누구인지\"를 확인하는 것이 아니라, \"무엇에 접근할 수 있는지\"를 다룹니다.\n- 사용자 신원을 직접 검증하지 않고, 접근 권한을 부여합니다.\n\n**주의사항:**\n- OAuth를 인증 목적으로 잘못 사용하는 경우가 많습니다.\n- 인증이 필요한 경우 OpenID Connect (OIDC)를 사용해야 합니다.\n- OIDC는 OAuth 2.0 위에 구축된 인증 계층입니다.\n\n---\n\n**OAuth 2.0의 주요 구성 요소:**\n\n1. **Resource Owner (리소스 소유자)**\n   - 보호된 리소스에 대한 접근을 허가할 수 있는 사용자\n\n2. **Client (클라이언트)**\n   - 리소스 소유자의 보호된 리소스에 접근하려는 애플리케이션\n\n3. **Authorization Server (인가 서버)**\n   - 리소스 소유자를 인증하고 권한 부여 후 액세스 토큰을 발급하는 서버\n\n4. **Resource Server (리소스 서버)**\n   - 보호된 리소스를 호스팅하는 서버\n   - 액세스 토큰을 검증하고 요청을 처리\n\n---\n\n**OAuth 2.0 주요 흐름 (Authorization Code Grant):**\n\n1. 클라이언트가 사용자를 인가 서버로 리디렉션\n2. 사용자가 인가 서버에서 로그인 및 권한 승인\n3. 인가 서버가 인가 코드를 클라이언트에게 반환\n4. 클라이언트가 인가 코드로 액세스 토큰 요청\n5. 인가 서버가 액세스 토큰 발급\n6. 클라이언트가 액세스 토큰으로 리소스 서버에 API 요청\n7. 리소스 서버가 토큰 검증 후 리소스 제공\n\n---\n\n**OAuth 2.0의 다양한 Grant Types:**\n\n1. **Authorization Code Grant**\n   - 가장 안전하고 권장되는 방식\n   - 서버 사이드 애플리케이션에 적합\n\n2. **Implicit Grant**\n   - 클라이언트 사이드 애플리케이션용 (현재는 비권장)\n   - PKCE를 사용한 Authorization Code Grant로 대체 권장\n\n3. **Resource Owner Password Credentials**\n   - 사용자 아이디/비밀번호를 직접 사용 (비권장)\n   - 신뢰할 수 있는 자사 애플리케이션에만 사용\n\n4. **Client Credentials**\n   - 기계 간(M2M) 통신용\n   - 사용자 컨텍스트 없이 클라이언트 자체가 리소스 접근\n\n5. **PKCE (Proof Key for Code Exchange)**\n   - Authorization Code Grant의 보안 강화 확장\n   - 모바일/SPA 애플리케이션에 필수\n\n---\n\n**실제 사용 예시:**\n\n\"Google 계정으로 로그인\" 버튼을 누를 때:\n1. 구글이 사용자 신원 확인 → **인증** (구글 자체 시스템)\n2. 사용자가 \"이 앱이 내 이메일 주소를 볼 수 있도록 허용\" → **인가** (OAuth)\n3. 앱이 액세스 토큰을 받아 구글 API에서 이메일 주소 조회\n\n---\n\n**OAuth vs OpenID Connect (OIDC):**\n\n| 구분 | OAuth 2.0 | OpenID Connect |\n|------|-----------|----------------|\n| 목적 | 인가 (Authorization) | 인증 (Authentication) |\n| 제공 | 액세스 토큰 | ID 토큰 + 액세스 토큰 |\n| 사용 사례 | API 접근 권한 위임 | SSO, 신원 확인 |\n\n**결론:**\nOAuth 2.0은 **인가 프로토콜**이며, 사용자 신원 확인이 필요한 경우 OAuth 위에 구축된 **OpenID Connect**를 사용해야 합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "보안",
        "OAuth",
        "인가"
      ],
      "id": "etc-035",
      "createdAt": "2025-11-17T15:00:00.000035",
      "studyCount": 0
    },
    {
      "question": "JWT 인증 방식이 무엇인가요?",
      "answer": "**JWT (JSON Web Token)란?**\n\nJWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준(RFC 7519)입니다. 주로 인증과 정보 교환에 사용됩니다.\n\n---\n\n**JWT의 구조:**\n\nJWT는 점(.)으로 구분된 세 부분으로 구성됩니다:\n**Header.Payload.Signature**\n\n**1. Header (헤더)**\n- 토큰 타입(JWT)과 서명 알고리즘(HMAC, RSA 등)을 포함합니다.\n- Base64Url로 인코딩됩니다.\n\n**2. Payload (페이로드)**\n- 실제 전달할 데이터(Claims)를 포함합니다.\n- 사용자 ID, 권한, 만료 시간 등의 정보를 담습니다.\n- Base64Url로 인코딩됩니다 (암호화 아님!).\n\n**3. Signature (서명)**\n- Header와 Payload를 조합하고 비밀키로 서명한 값입니다.\n- 토큰의 무결성을 검증하는 데 사용됩니다.\n- 생성 방법: HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)\n\n---\n\n**JWT의 주요 Claims:**\n\n**Registered Claims (등록된 클레임):**\n- **iss** (Issuer): 토큰 발급자\n- **sub** (Subject): 토큰 주제 (일반적으로 사용자 ID)\n- **aud** (Audience): 토큰 대상자\n- **exp** (Expiration Time): 만료 시간\n- **nbf** (Not Before): 토큰 활성화 시간\n- **iat** (Issued At): 토큰 발급 시간\n- **jti** (JWT ID): 토큰 고유 식별자\n\n**Private Claims (사용자 정의 클레임):**\n- 서비스에서 필요한 커스텀 정보 (예: role, permissions)\n\n---\n\n**JWT 인증 흐름:**\n\n1. **로그인 요청**\n   - 사용자가 아이디/비밀번호로 로그인 요청\n\n2. **자격 증명 검증**\n   - 서버가 사용자 자격 증명을 확인\n\n3. **JWT 발급**\n   - 서버가 사용자 정보를 포함한 JWT를 생성하고 서명\n   - 클라이언트에게 JWT 반환\n\n4. **JWT 저장**\n   - 클라이언트가 JWT를 저장 (LocalStorage, SessionStorage, Cookie 등)\n\n5. **API 요청**\n   - 클라이언트가 HTTP 헤더에 JWT를 포함하여 요청\n   - 일반적으로 Authorization: Bearer <token> 형식\n\n6. **JWT 검증**\n   - 서버가 토큰의 서명을 검증\n   - 만료 시간 확인\n   - Payload에서 사용자 정보 추출\n\n7. **응답**\n   - 검증 성공 시 요청 처리 및 응답\n   - 실패 시 401 Unauthorized 반환\n\n---\n\n**JWT의 장점:**\n\n1. **Stateless (무상태)**\n   - 서버가 세션을 저장할 필요가 없습니다.\n   - 확장성이 뛰어나며 분산 시스템에 적합합니다.\n\n2. **Self-contained (자가 수용)**\n   - 토큰 자체에 사용자 정보가 포함되어 있습니다.\n   - 데이터베이스 조회 없이 사용자 정보 확인 가능합니다.\n\n3. **크로스 도메인 인증**\n   - CORS 문제 없이 여러 도메인에서 사용 가능합니다.\n   - 마이크로서비스 아키텍처에 적합합니다.\n\n4. **모바일 친화적**\n   - 쿠키 없이 토큰만으로 인증 가능합니다.\n\n---\n\n**JWT의 단점과 주의사항:**\n\n1. **토큰 크기**\n   - Payload가 커질수록 토큰 크기가 증가합니다.\n   - 매 요청마다 전송되므로 네트워크 오버헤드가 있습니다.\n\n2. **토큰 취소 어려움**\n   - Stateless 특성상 서버에서 강제로 토큰을 무효화하기 어렵습니다.\n   - 블랙리스트나 Redis 등의 추가 메커니즘이 필요합니다.\n\n3. **보안 주의사항**\n   - **Payload는 암호화되지 않음**: 민감한 정보를 넣으면 안 됩니다.\n   - **XSS 공격**: LocalStorage 저장 시 XSS 공격에 취약합니다.\n   - **CSRF 공격**: Cookie 저장 시 CSRF 공격 가능성이 있습니다.\n   - **짧은 만료 시간 설정**: 토큰 탈취 위험을 줄이기 위해 짧게 설정합니다.\n\n4. **Refresh Token 필요**\n   - 짧은 만료 시간으로 인해 Refresh Token 메커니즘이 필요합니다.\n\n---\n\n**Access Token vs Refresh Token:**\n\n- **Access Token**: 짧은 수명 (15분~1시간), API 접근용\n- **Refresh Token**: 긴 수명 (1일~1주), Access Token 재발급용\n- Access Token 만료 시 Refresh Token으로 새로운 Access Token 발급\n\n---\n\n**JWT 사용 시 Best Practices:**\n\n1. HTTPS 사용 필수\n2. 짧은 만료 시간 설정\n3. 민감한 정보는 Payload에 넣지 않기\n4. 강력한 서명 알고리즘 사용 (최소 HS256, 권장 RS256)\n5. Refresh Token 메커니즘 구현\n6. XSS/CSRF 방어 조치\n\nJWT는 현대 웹 애플리케이션에서 널리 사용되는 인증 방식이지만, 보안 고려사항을 충분히 이해하고 적용해야 합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "보안",
        "JWT",
        "인증"
      ],
      "id": "etc-036",
      "createdAt": "2025-11-17T15:00:00.000036",
      "studyCount": 0
    },
    {
      "question": "JWT의 Signature는 어떻게 만들어지나요?",
      "answer": "JWT의 Signature는 토큰의 무결성을 보장하고 위변조를 방지하기 위해 생성되는 암호화된 값입니다.\n\n---\n\n**Signature 생성 과정:**\n\n**1. Header와 Payload 인코딩**\n- Header와 Payload를 각각 Base64Url로 인코딩합니다.\n- 결과: encodedHeader, encodedPayload\n\n**2. 결합**\n- 인코딩된 Header와 Payload를 점(.)으로 연결합니다.\n- 결과: encodedHeader + \".\" + encodedPayload\n\n**3. 서명 생성**\n- 결합된 문자열을 비밀키(또는 개인키)와 함께 지정된 알고리즘으로 서명합니다.\n- 결과를 Base64Url로 인코딩합니다.\n\n**일반 형식:**\nSignature = Base64UrlEncode(\n  Algorithm(\n    Base64UrlEncode(header) + \".\" + Base64UrlEncode(payload),\n    secret\n  )\n)\n\n---\n\n**주요 서명 알고리즘:**\n\n**1. HMAC (대칭키 방식)**\n\n**HS256 (HMAC-SHA256):**\n- 가장 많이 사용되는 방식\n- 서버만 비밀키를 가지고 있습니다.\n- 서명 생성과 검증에 동일한 키를 사용합니다.\n- 빠르고 간단하지만, 키가 노출되면 위험합니다.\n\n**HS384, HS512:**\n- SHA-384, SHA-512 해시 함수를 사용하는 변형\n\n**장점:**\n- 빠른 성능\n- 간단한 구현\n\n**단점:**\n- 키를 안전하게 공유해야 함\n- 다중 서비스 환경에서 키 관리가 복잡함\n\n**2. RSA (비대칭키 방식)**\n\n**RS256 (RSA-SHA256):**\n- 개인키로 서명하고 공개키로 검증합니다.\n- 공개키를 여러 서비스와 공유해도 안전합니다.\n- 마이크로서비스 환경에 적합합니다.\n\n**RS384, RS512:**\n- SHA-384, SHA-512 해시 함수를 사용하는 변형\n\n**장점:**\n- 키 배포가 안전 (공개키만 배포)\n- 분산 시스템에 적합\n\n**단점:**\n- HMAC보다 느림\n- 키 크기가 큼 (최소 2048비트 권장)\n\n**3. ECDSA (타원곡선 암호화)**\n\n**ES256, ES384, ES512:**\n- RSA보다 작은 키 크기로 동일한 보안 수준 제공\n- 성능이 우수함\n\n---\n\n**Signature 생성 예시 (개념적):**\n\n**HMAC-SHA256 사용 시:**\n\n1. Header (원본 JSON):\n   { \"alg\": \"HS256\", \"typ\": \"JWT\" }\n\n2. Payload (원본 JSON):\n   { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 }\n\n3. Base64Url 인코딩:\n   - encodedHeader = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\"\n   - encodedPayload = \"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ\"\n\n4. 결합:\n   - data = encodedHeader + \".\" + encodedPayload\n\n5. HMAC-SHA256 서명:\n   - signature = HMACSHA256(data, \"your-256-bit-secret\")\n   - Base64Url 인코딩: \"SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\n\n6. 최종 JWT:\n   - Header.Payload.Signature\n   - \"eyJhbGci...9.eyJzdWIi...Q.SflKxwRJ...w5c\"\n\n---\n\n**Signature 검증 과정:**\n\n1. **JWT 수신**\n   - 클라이언트로부터 JWT를 받습니다.\n\n2. **분리**\n   - 점(.)을 기준으로 Header, Payload, Signature로 분리합니다.\n\n3. **서명 재생성**\n   - Header와 Payload를 동일한 방법으로 결합하고 서명합니다.\n\n4. **비교**\n   - 재생성한 서명과 받은 서명을 비교합니다.\n   - 일치하면 토큰이 위변조되지 않았음을 확인합니다.\n\n5. **Claims 검증**\n   - exp (만료 시간) 확인\n   - iss, aud 등 기타 클레임 검증\n\n---\n\n**보안 고려사항:**\n\n1. **강력한 비밀키 사용**\n   - 최소 256비트 (32바이트) 이상의 무작위 문자열\n   - 예측 가능한 키는 절대 사용하지 않음\n\n2. **알고리즘 선택**\n   - HS256: 단일 서비스, 빠른 성능 필요 시\n   - RS256: 마이크로서비스, 공개키 배포 가능 시 (권장)\n\n3. **none 알고리즘 거부**\n   - alg: \"none\"은 서명 없이 토큰을 수용하므로 매우 위험\n   - 반드시 검증 단계에서 거부해야 함\n\n4. **키 관리**\n   - 환경 변수나 보안 vault에 저장\n   - 코드에 하드코딩 금지\n   - 주기적인 키 로테이션\n\nSignature는 JWT의 핵심 보안 요소로, 올바른 알고리즘 선택과 안전한 키 관리가 매우 중요합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "보안",
        "JWT",
        "암호화"
      ],
      "id": "etc-037",
      "createdAt": "2025-11-17T15:00:00.000037",
      "studyCount": 0
    },
    {
      "question": "만약 Access Token이 탈취되면, 어떻게 대응할 수 있을까요?",
      "answer": "Access Token 탈취 시 대응 방법과 예방 전략:\n\n---\n\n**즉각적인 대응 방법:**\n\n**1. 짧은 만료 시간의 중요성**\n- Access Token의 만료 시간을 짧게 설정 (15분~1시간)\n- 탈취되더라도 피해 기간을 제한합니다.\n- 만료 후에는 자동으로 무효화되어 더 이상 사용할 수 없습니다.\n\n**2. 토큰 무효화 (Revocation)**\n- 의심스러운 활동 감지 시 즉시 토큰을 무효화합니다.\n- 방법:\n  - **블랙리스트**: 무효화된 토큰 목록을 Redis 등에 저장하고 검증 시 확인\n  - **토큰 버전 관리**: 사용자별 토큰 버전을 DB에 저장하고 검증 시 확인\n  - **즉시 로그아웃**: 사용자의 모든 활성 세션 종료\n\n**3. 강제 재인증**\n- 의심스러운 활동 감지 시 사용자에게 재로그인 요구\n- 새로운 Access Token과 Refresh Token 발급\n\n---\n\n**예방 및 탐지 메커니즘:**\n\n**1. HTTPS 사용 (필수)**\n- 모든 통신을 암호화하여 중간자 공격(MITM)을 방지합니다.\n- HTTP로 전송 시 토큰이 평문으로 노출됩니다.\n\n**2. 토큰 저장 위치 최적화**\n- **LocalStorage/SessionStorage**: XSS 공격에 취약\n- **HttpOnly Cookie**: XSS로부터 안전하지만 CSRF 공격 가능\n- **메모리 내 저장**: 가장 안전하지만 새로고침 시 손실\n- 권장: HttpOnly + Secure + SameSite 쿠키 또는 메모리 저장\n\n**3. XSS (Cross-Site Scripting) 방어**\n- 사용자 입력 검증 및 이스케이프 처리\n- Content Security Policy (CSP) 헤더 설정\n- Sanitization 라이브러리 사용\n\n**4. CSRF (Cross-Site Request Forgery) 방어**\n- SameSite 쿠키 속성 사용\n- CSRF 토큰 사용\n- Custom Header 검증\n\n**5. IP 주소 및 Device Fingerprinting**\n- 토큰 발급 시 IP 주소와 디바이스 정보를 기록\n- 요청 시 불일치하면 의심스러운 활동으로 간주\n- 단점: 정상 사용자의 IP 변경 시 불편\n\n**6. 이상 행위 탐지 (Anomaly Detection)**\n- 비정상적인 API 호출 패턴 감지\n- 짧은 시간에 여러 지역에서의 접속 감지\n- 평소와 다른 행동 패턴 탐지\n\n**7. Token Binding**\n- 토큰을 특정 TLS 세션에 바인딩\n- 토큰이 다른 세션에서 사용되는 것을 방지\n\n**8. 짧은 수명 + Refresh Token 조합**\n- Access Token: 짧은 수명 (15분~1시간)\n- Refresh Token: 긴 수명, 더 엄격한 검증\n- Access Token 탈취 시 피해를 최소화\n\n---\n\n**탈취 감지 시 대응 절차:**\n\n**1. 로그 분석**\n- 의심스러운 IP, 위치, 디바이스에서의 접근 확인\n- 비정상적인 API 호출 패턴 확인\n\n**2. 토큰 무효화**\n- 해당 Access Token을 블랙리스트에 추가\n- 가능하면 사용자의 모든 토큰 무효화\n\n**3. 사용자 알림**\n- 이메일/SMS로 의심스러운 활동 알림\n- 비밀번호 변경 권장\n\n**4. 강제 재인증**\n- 모든 디바이스에서 로그아웃\n- 재로그인 요구\n\n**5. 침해 범위 파악**\n- 어떤 데이터에 접근했는지 확인\n- 피해 범위 평가\n\n---\n\n**추가 보안 조치:**\n\n**1. Rate Limiting**\n- API 호출 빈도 제한\n- 무차별 대입 공격 방지\n\n**2. 민감한 작업에 재인증 요구**\n- 비밀번호 변경, 결제 등 중요 작업 시 재인증\n- MFA (Multi-Factor Authentication) 사용\n\n**3. 토큰 로테이션**\n- 주기적으로 새로운 Access Token 발급\n- Silent Refresh 메커니즘 사용\n\n**4. 보안 헤더 설정**\n- X-Content-Type-Options\n- X-Frame-Options\n- Strict-Transport-Security (HSTS)\n\n**5. 로깅 및 모니터링**\n- 모든 인증 활동 로깅\n- 실시간 모니터링 시스템 구축\n- 이상 행위 자동 경고\n\n---\n\n**중요 원칙:**\n\n1. **다층 방어 (Defense in Depth)**\n   - 단일 보안 조치에 의존하지 않고 여러 계층의 보안을 적용\n\n2. **최소 권한 원칙**\n   - Access Token에 필요한 최소한의 권한만 부여\n\n3. **Zero Trust 접근**\n   - 모든 요청을 검증하고 의심\n\n4. **사용자 교육**\n   - 피싱 방지 교육\n   - 안전한 인터넷 사용 습관 교육\n\nAccess Token 탈취는 완전히 방지할 수 없지만, 짧은 만료 시간과 적절한 모니터링으로 피해를 최소화할 수 있습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "보안",
        "JWT",
        "토큰보안"
      ],
      "id": "etc-038",
      "createdAt": "2025-11-17T15:00:00.000038",
      "studyCount": 0
    },
    {
      "question": "반대로 Refresh Token이 탈취되면, 어떻게 대응해야 할까요?",
      "answer": "Refresh Token 탈취는 Access Token 탈취보다 훨씬 심각한 보안 사고입니다. 공격자가 지속적으로 새로운 Access Token을 발급받을 수 있기 때문입니다.\n\n---\n\n**Refresh Token 탈취가 더 위험한 이유:**\n\n1. **긴 유효 기간**: 일반적으로 며칠~몇 주 동안 유효합니다.\n2. **지속적인 접근**: 새로운 Access Token을 계속 발급받을 수 있습니다.\n3. **탐지 어려움**: Access Token처럼 자주 사용되지 않아 이상 행위 탐지가 어렵습니다.\n\n---\n\n**즉각적인 대응 방법:**\n\n**1. 모든 토큰 즉시 무효화**\n- 해당 사용자의 모든 Refresh Token을 즉시 무효화합니다.\n- 모든 디바이스에서 강제 로그아웃 처리합니다.\n- DB에서 해당 사용자의 모든 토큰 레코드를 삭제합니다.\n\n**2. Access Token도 함께 무효화**\n- 현재 발급된 모든 Access Token을 블랙리스트에 추가합니다.\n- 공격자의 접근을 즉시 차단합니다.\n\n**3. 사용자 알림 및 비밀번호 재설정**\n- 즉시 사용자에게 이메일/SMS로 알림을 보냅니다.\n- 비밀번호 강제 변경을 요구합니다.\n- 다른 계정에서도 동일한 비밀번호 사용 시 변경 권고합니다.\n\n**4. 강제 재인증**\n- 모든 디바이스에서 다시 로그인하도록 요구합니다.\n- MFA (다중 인증)를 필수로 요구합니다.\n\n---\n\n**예방 메커니즘:**\n\n**1. Refresh Token Rotation (토큰 회전)**\n- Refresh Token 사용 시마다 새로운 Refresh Token을 발급합니다.\n- 이전 Refresh Token은 즉시 무효화합니다.\n- 한 번 사용된 Refresh Token은 재사용할 수 없습니다.\n\n**작동 방식:**\n- 클라이언트가 Refresh Token으로 새 Access Token 요청\n- 서버가 새 Access Token + 새 Refresh Token 발급\n- 이전 Refresh Token은 무효화\n- 이전 토큰 재사용 시도 → 탈취로 간주하고 모든 토큰 무효화\n\n**2. Refresh Token 재사용 감지 (Reuse Detection)**\n- 이미 사용된 Refresh Token이 다시 사용되면 탈취로 간주합니다.\n- 즉시 해당 사용자의 모든 토큰을 무효화합니다.\n- 사용자에게 경고 알림을 보냅니다.\n\n**3. Secure Storage (안전한 저장)**\n- **서버 측**: DB에 해시된 형태로 저장 (bcrypt, scrypt 등)\n- **클라이언트 측**: \n  - HttpOnly + Secure + SameSite 쿠키 (웹)\n  - Keychain/Keystore (모바일)\n  - 절대 LocalStorage 사용 금지\n\n**4. Device Fingerprinting**\n- Refresh Token 발급 시 디바이스 정보를 기록합니다.\n- 요청 시 디바이스 정보가 일치하지 않으면 거부합니다.\n- User-Agent, IP 주소, OS 정보 등을 종합적으로 확인합니다.\n\n**5. Geo-fencing (지리적 제한)**\n- 평소와 다른 지역에서의 접근 시도를 감지합니다.\n- 의심스러운 위치에서의 요청은 추가 인증을 요구합니다.\n\n**6. IP 화이트리스트 (선택적)**\n- 특정 IP 범위에서만 Refresh Token 사용을 허용합니다.\n- 기업 환경이나 제한된 환경에서 유용합니다.\n\n---\n\n**탐지 및 모니터링:**\n\n**1. 비정상 패턴 감지**\n- 짧은 시간에 여러 디바이스에서 Refresh Token 사용\n- 평소와 다른 시간대의 토큰 갱신\n- 비정상적으로 빈번한 토큰 갱신\n\n**2. 동시 접속 감지**\n- 서로 다른 지역에서 동시에 Refresh Token 사용\n- 물리적으로 불가능한 위치 이동 감지\n\n**3. 실시간 알림 시스템**\n- 새로운 디바이스에서 로그인 시 알림\n- 비밀번호 변경 시 알림\n- 토큰 갱신 시 알림 (선택적)\n\n---\n\n**추가 보안 조치:**\n\n**1. 짧은 만료 시간**\n- Refresh Token의 만료 시간을 가능한 짧게 설정합니다 (1~7일).\n- 장기간 사용하지 않으면 재인증을 요구합니다.\n\n**2. Sliding Window 방식**\n- Refresh Token 사용 시마다 만료 시간을 연장합니다.\n- 사용하지 않으면 자동으로 만료됩니다.\n\n**3. 디바이스 수 제한**\n- 동시에 로그인할 수 있는 디바이스 수를 제한합니다.\n- 새 디바이스 로그인 시 오래된 디바이스는 자동 로그아웃합니다.\n\n**4. 중요 작업 시 재인증**\n- 비밀번호 변경, 결제 등 중요한 작업 시에는 Refresh Token으로는 불충분합니다.\n- 반드시 비밀번호나 MFA로 재인증을 요구합니다.\n\n**5. 정기적인 토큰 만료**\n- 일정 기간(예: 30일)마다 모든 Refresh Token을 무효화합니다.\n- 사용자에게 재로그인을 요구합니다.\n\n---\n\n**탈취 감지 시 대응 프로세스:**\n\n**1. 탐지 (Detection)**\n- Refresh Token 재사용 감지\n- 비정상적인 패턴 감지\n\n**2. 격리 (Isolation)**\n- 해당 사용자의 모든 토큰 즉시 무효화\n- 모든 활성 세션 종료\n\n**3. 조사 (Investigation)**\n- 침해 범위 파악 (어떤 데이터에 접근했는지)\n- 공격 경로 분석\n- 로그 분석\n\n**4. 알림 (Notification)**\n- 사용자에게 즉시 알림\n- 비밀번호 변경 요구\n- 계정 활동 검토 요청\n\n**5. 복구 (Recovery)**\n- 비밀번호 재설정 후 새 토큰 발급\n- MFA 강제 활성화 (선택적)\n- 보안 강화 조치 적용\n\n**6. 예방 (Prevention)**\n- 유사 사고 재발 방지 대책 수립\n- 보안 정책 강화\n- 모니터링 강화\n\n---\n\n**Best Practices:**\n\n1. **Refresh Token Rotation은 필수**\n2. **HttpOnly 쿠키로 저장 (웹)**\n3. **재사용 감지 메커니즘 구현**\n4. **디바이스 및 IP 정보 추적**\n5. **실시간 모니터링 및 경고 시스템**\n6. **정기적인 보안 감사**\n\nRefresh Token은 매우 민감한 자격 증명이므로, 탈취 예방과 빠른 탐지가 가장 중요합니다. Refresh Token Rotation과 재사용 감지는 반드시 구현해야 하는 필수 보안 조치입니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "보안",
        "JWT",
        "토큰보안"
      ],
      "id": "etc-039",
      "createdAt": "2025-11-17T15:00:00.000039",
      "studyCount": 0
    },
    {
      "question": "암호화 알고리즘에 대해 설명해 주세요.",
      "answer": "암호화 알고리즘은 데이터를 제3자가 읽을 수 없는 형태로 변환하는 수학적 절차입니다. 크게 대칭키 암호화, 비대칭키 암호화, 해시 함수로 분류됩니다.\n\n---\n\n**1. 대칭키 암호화 (Symmetric Encryption)**\n\n**정의:**\n암호화와 복호화에 동일한 키를 사용하는 방식입니다.\n\n**주요 알고리즘:**\n\n**A. AES (Advanced Encryption Standard)**\n- 현재 가장 널리 사용되는 표준\n- 블록 크기: 128비트\n- 키 크기: 128, 192, 256비트 (AES-128, AES-192, AES-256)\n- 매우 빠르고 안전함\n- 용도: 파일 암호화, 디스크 암호화, VPN, TLS/SSL\n\n**B. DES (Data Encryption Standard)**\n- 레거시 알고리즘, 현재는 사용 금지\n- 56비트 키로 인해 무차별 대입 공격에 취약\n\n**C. 3DES (Triple DES)**\n- DES를 3번 적용하여 보안 강화\n- AES로 대체 권장\n\n**D. ChaCha20**\n- 스트림 암호 방식\n- 모바일 환경에서 AES보다 효율적\n- TLS 1.3에서 지원\n\n**장점:**\n- 암호화/복호화 속도가 매우 빠름\n- 대용량 데이터 처리에 적합\n\n**단점:**\n- 키 배포 문제 (안전하게 키를 공유해야 함)\n- 키 관리의 복잡성 (N명이 통신하려면 N(N-1)/2개의 키 필요)\n\n**사용 사례:**\n- 저장 데이터 암호화\n- 빠른 대칭키 교환 후 대량 데이터 전송\n- VPN, 디스크 암호화\n\n---\n\n**2. 비대칭키 암호화 (Asymmetric Encryption / Public Key Cryptography)**\n\n**정의:**\n공개키(Public Key)와 개인키(Private Key) 쌍을 사용하는 방식입니다.\n- 공개키로 암호화 → 개인키로 복호화\n- 개인키로 서명 → 공개키로 검증\n\n**주요 알고리즘:**\n\n**A. RSA (Rivest-Shamir-Adleman)**\n- 가장 널리 사용되는 비대칭키 알고리즘\n- 키 크기: 2048, 3072, 4096비트 (최소 2048비트 권장)\n- 소인수분해의 어려움에 기반\n- 용도: 디지털 서명, 키 교환, SSL/TLS 인증서\n\n**B. ECC (Elliptic Curve Cryptography)**\n- 타원곡선 암호화\n- RSA보다 작은 키로 동일한 보안 수준 제공\n  - ECC 256비트 ≈ RSA 3072비트\n- 모바일 환경에 적합\n- 알고리즘: ECDSA (서명), ECDH (키 교환)\n\n**C. Diffie-Hellman (DH)**\n- 키 교환 프로토콜\n- 안전하지 않은 채널에서 공통 비밀키를 생성\n- TLS/SSL에서 사용\n\n**D. ElGamal**\n- 암호화와 디지털 서명에 사용\n- Diffie-Hellman 기반\n\n**장점:**\n- 키 배포 문제 해결 (공개키는 공개해도 안전)\n- 디지털 서명 가능\n- 키 교환 용이\n\n**단점:**\n- 대칭키보다 매우 느림\n- 키 크기가 큼\n- 대용량 데이터 암호화에 비효율적\n\n**사용 사례:**\n- SSL/TLS 핸드셰이크\n- 디지털 서명\n- 대칭키 암호화 전 키 교환\n- 이메일 암호화 (PGP, S/MIME)\n\n---\n\n**3. 해시 함수 (Hash Functions)**\n\n**정의:**\n임의 길이의 데이터를 고정 길이의 해시 값으로 변환하는 단방향 함수입니다.\n복호화가 불가능합니다.\n\n**특성:**\n- **결정성**: 동일한 입력은 항상 동일한 출력\n- **빠른 계산**: 해시 값을 빠르게 계산\n- **눈사태 효과**: 입력의 작은 변화가 해시 값을 크게 변경\n- **충돌 저항성**: 동일한 해시를 가진 두 입력을 찾기 어려움\n- **단방향성**: 해시 값으로 원본을 복구할 수 없음\n\n**주요 알고리즘:**\n\n**A. SHA (Secure Hash Algorithm) 계열**\n- **SHA-1**: 160비트, 현재는 안전하지 않음 (사용 금지)\n- **SHA-256**: 256비트, 널리 사용되며 안전함\n- **SHA-512**: 512비트, 더 높은 보안 수준\n- **SHA-3**: 최신 표준, 다른 구조 사용\n\n**B. MD5 (Message Digest 5)**\n- 128비트 해시\n- 충돌 공격에 취약하여 보안 용도로 사용 금지\n- 파일 무결성 검증에는 여전히 사용 (비보안 용도)\n\n**C. bcrypt**\n- 비밀번호 해싱 전용\n- 솔트(Salt) 자동 생성\n- 계산 비용 조절 가능 (무차별 대입 공격 방어)\n\n**D. scrypt**\n- 비밀번호 해싱 전용\n- 메모리 집약적 (ASIC 공격 방어)\n\n**E. Argon2**\n- 최신 비밀번호 해싱 알고리즘\n- Password Hashing Competition 우승\n- CPU와 메모리 모두 집약적\n\n**사용 사례:**\n- 비밀번호 저장 (bcrypt, scrypt, Argon2)\n- 데이터 무결성 검증 (SHA-256)\n- 디지털 서명의 메시지 다이제스트\n- 블록체인 (SHA-256)\n- HMAC (메시지 인증 코드)\n\n---\n\n**4. 하이브리드 암호화**\n\n실제 시스템은 대칭키와 비대칭키를 함께 사용합니다:\n1. 비대칭키로 대칭키를 안전하게 교환\n2. 교환된 대칭키로 실제 데이터를 빠르게 암호화\n\n**예: TLS/SSL**\n- 비대칭키(RSA/ECDHE)로 세션 키 교환\n- 대칭키(AES)로 실제 통신 데이터 암호화\n\n---\n\n**알고리즘 선택 가이드:**\n\n| 용도 | 권장 알고리즘 |\n|------|-------------|\n| 대칭키 암호화 | AES-256 |\n| 비대칭키 암호화 | RSA-2048+, ECC-256 |\n| 비밀번호 해싱 | bcrypt, Argon2 |\n| 데이터 무결성 | SHA-256, SHA-512 |\n| 디지털 서명 | RSA-2048+, ECDSA |\n| 키 교환 | ECDHE, DHE |\n\n---\n\n**보안 고려사항:**\n\n1. **절대 자체 암호화 알고리즘을 만들지 않음**\n2. **검증된 라이브러리 사용** (OpenSSL, libsodium 등)\n3. **정기적인 키 로테이션**\n4. **충분한 키 길이 사용**\n5. **암호화 모드 신중히 선택** (CBC, GCM, CTR 등)\n6. **초기화 벡터(IV), 솔트(Salt), 논스(Nonce) 올바르게 사용**\n\n암호화는 보안의 핵심이지만, 구현이 어렵고 실수하기 쉬우므로 검증된 표준과 라이브러리를 사용하는 것이 중요합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "보안",
        "암호화"
      ],
      "id": "etc-040",
      "createdAt": "2025-11-17T15:00:00.000040",
      "studyCount": 0
    },
    {
      "question": "문자열 인코딩에 대해 설명해 주세요.",
      "answer": "문자열 인코딩(Character Encoding)은 문자를 컴퓨터가 이해할 수 있는 숫자(바이트)로 변환하는 규칙입니다.\n\n---\n\n**핵심 개념:**\n\n**1. 문자 집합(Character Set) vs 인코딩(Encoding)**\n- **문자 집합**: 문자들의 집합과 각 문자에 할당된 숫자(코드 포인트)\n- **인코딩**: 코드 포인트를 실제 바이트로 표현하는 방법\n\n예: Unicode는 문자 집합, UTF-8은 인코딩 방식\n\n---\n\n**주요 인코딩 방식:**\n\n**1. ASCII (American Standard Code for Information Interchange)**\n- 7비트로 128개 문자 표현 (0~127)\n- 영문 알파벳, 숫자, 기본 기호만 포함\n- 한글, 중국어 등 다른 언어는 표현 불가\n- 확장 ASCII: 8비트로 256개 문자 (0~255)\n\n**2. EUC-KR / CP949**\n- 한글 표현을 위한 인코딩\n- EUC-KR: 2바이트로 한글 표현 (완성형)\n- CP949: EUC-KR 확장, 더 많은 한글 표현 가능\n- 단점: 한국어 전용, 다국어 지원 부족\n\n**3. Unicode**\n- 전 세계 모든 문자를 하나의 체계로 표현\n- 코드 포인트: U+0000 ~ U+10FFFF (약 114만 개)\n- 영문 'A': U+0041, 한글 '가': U+AC00\n\n**4. UTF-8 (Unicode Transformation Format - 8bit)**\n- 가장 널리 사용되는 유니코드 인코딩\n- 가변 길이: 1~4바이트\n- ASCII 호환: ASCII 문자는 1바이트로 동일하게 표현\n- 영문: 1바이트, 한글: 3바이트, 이모지: 4바이트\n- 웹의 사실상 표준\n- 장점: 효율적, ASCII 호환, 오류 감지 용이\n\n**5. UTF-16**\n- 2바이트 또는 4바이트 사용\n- BMP(Basic Multilingual Plane) 문자는 2바이트\n- 그 외는 4바이트 (Surrogate Pair)\n- Windows 내부, Java 문자열에서 사용\n- 단점: ASCII 호환 안 됨, 바이트 순서(Endian) 문제\n\n**6. UTF-32**\n- 모든 문자를 4바이트로 표현\n- 고정 길이로 인덱싱이 간단\n- 단점: 메모리 낭비가 심함\n\n---\n\n**인코딩 문제 (Mojibake / 깨진 글자):**\n\n**발생 원인:**\n- 인코딩과 디코딩 방식이 일치하지 않을 때\n- UTF-8로 저장된 텍스트를 EUC-KR로 읽을 때 등\n\n**예시:**\n- \"안녕하세요\"를 UTF-8로 저장 후 EUC-KR로 읽으면 → \"안녕하세요\" (깨짐)\n\n**해결 방법:**\n- 일관된 인코딩 사용 (UTF-8 권장)\n- 파일 시작에 BOM (Byte Order Mark) 추가 (선택적)\n- 명시적 인코딩 지정\n\n---\n\n**BOM (Byte Order Mark):**\n- 파일 시작 부분에 삽입되는 특수 바이트 시퀀스\n- 인코딩 방식과 바이트 순서를 표시\n- UTF-8 BOM: EF BB BF\n- UTF-16 BE BOM: FE FF\n- UTF-16 LE BOM: FF FE\n- UTF-8에서는 일반적으로 BOM 사용 안 함 (권장)\n\n---\n\n**Endianness (바이트 순서):**\n- **Big-Endian (BE)**: 높은 자리 바이트를 먼저 저장\n- **Little-Endian (LE)**: 낮은 자리 바이트를 먼저 저장\n- UTF-16, UTF-32에서 중요\n- 네트워크는 Big-Endian (Network Byte Order)\n\n---\n\n**URL 인코딩 (Percent Encoding):**\n- URL에서 특수 문자를 안전하게 전송하기 위한 인코딩\n- 문자를 % + 16진수 코드로 변환\n- 예: 공백 → %20, 한글 '가' (UTF-8) → %EA%B0%80\n\n---\n\n**인코딩 선택 가이드:**\n\n| 용도 | 권장 인코딩 |\n|------|-----------|\n| 웹 페이지 | UTF-8 |\n| API 응답 | UTF-8 |\n| 데이터베이스 | UTF-8 (utf8mb4) |\n| JSON | UTF-8 (강제) |\n| XML | UTF-8 또는 UTF-16 |\n| 레거시 한글 시스템 | EUC-KR (마이그레이션 권장) |\n\n---\n\n**프로그래밍에서의 주의사항:**\n\n1. **파일 읽기/쓰기 시 인코딩 명시**\n   - 기본 인코딩에 의존하지 말고 명시적으로 지정\n\n2. **데이터베이스 인코딩**\n   - MySQL: utf8mb4 사용 (이모지 지원)\n   - 잘못된 utf8은 3바이트만 지원하여 이모지 깨짐\n\n3. **HTTP 헤더**\n   - Content-Type: text/html; charset=UTF-8\n\n4. **HTML meta 태그**\n   - <meta charset=\"UTF-8\">\n\n5. **문자열 길이 계산**\n   - 바이트 길이 vs 문자 길이 구분\n   - UTF-8에서 \"한글\"은 6바이트지만 2문자\n\n---\n\n**현대적 Best Practice:**\n\n1. **UTF-8을 기본으로 사용**\n2. **인코딩을 항상 명시적으로 지정**\n3. **데이터 입력 시점에 인코딩 검증**\n4. **국제화(i18n) 고려**\n\n문자열 인코딩은 전 세계 사용자를 대상으로 하는 현대 애플리케이션에서 필수적으로 이해해야 하는 개념입니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "인코딩",
        "문자열"
      ],
      "id": "etc-041",
      "createdAt": "2025-11-17T15:00:00.000041",
      "studyCount": 0
    },
    {
      "question": "Base64 인코딩은 일반적인 문자열 인코딩과는 달리, 사용자가 읽기 어려운 알파벳과 숫자 조합으로 변경합니다. 이를 사용하는 이유는 무엇일까요?",
      "answer": "Base64 인코딩을 사용하는 이유는 **바이너리 데이터를 텍스트 전용 시스템에서 안전하게 전송하기 위함**입니다. 암호화가 아닌 **인코딩 방식**입니다.\n\n---\n\n**Base64의 목적과 특징:**\n\n**1. 바이너리-텍스트 변환**\n- 바이너리 데이터(이미지, 파일 등)를 ASCII 텍스트로 변환합니다.\n- 64개의 안전한 문자만 사용: A-Z, a-z, 0-9, +, /\n\n**2. 8비트 → 6비트 변환**\n- 3바이트(24비트)를 4개의 6비트 단위로 분할\n- 각 6비트를 64개 문자 중 하나로 매핑\n- 결과적으로 데이터 크기가 약 33% 증가\n\n---\n\n**Base64를 사용하는 주요 이유:**\n\n**1. 텍스트 전용 프로토콜 호환성**\n\n많은 시스템이 텍스트만 처리하도록 설계되었습니다:\n- **이메일 (SMTP)**: 원래 7비트 ASCII만 지원\n- **JSON**: 바이너리 데이터 직접 포함 불가\n- **XML**: 텍스트 형식\n- **URL**: 특정 문자만 허용\n\n**예시:**\n- 이메일 첨부파일을 MIME 형식으로 전송할 때\n- JSON API에서 이미지를 Base64로 인코딩하여 전송\n\n**2. 특수 문자 문제 회피**\n\n바이너리 데이터에는 다음과 같은 문제가 있습니다:\n- 제어 문자(0x00-0x1F)가 포함될 수 있음\n- 개행 문자가 데이터로 해석될 수 있음\n- 시스템마다 개행 문자 처리가 다름 (\\n vs \\r\\n)\n\nBase64는 이러한 문제가 없는 안전한 문자만 사용합니다.\n\n**3. 데이터 무결성 보장**\n\n텍스트 처리 시스템을 거치면서:\n- 개행 문자 변환 (LF ↔ CRLF)\n- 문자 인코딩 변환\n- Trailing whitespace 제거\n\n등의 변경이 발생할 수 있는데, Base64는 이런 변경에 안전합니다.\n\n**4. 단일 문자열로 표현**\n\n바이너리 데이터를 하나의 문자열로 표현할 수 있어:\n- HTML/XML 속성에 포함 가능\n- 데이터베이스 TEXT 필드에 저장 가능\n- 로그 파일에 안전하게 기록 가능\n\n---\n\n**Base64 사용 사례:**\n\n**1. 이메일 첨부파일**\n- MIME (Multipurpose Internet Mail Extensions)에서 사용\n- Content-Transfer-Encoding: base64\n\n**2. 데이터 URL (Data URI)**\n- HTML/CSS에서 이미지를 직접 임베드\n- 형식: data:image/png;base64,iVBORw0KGgoAAAANS...\n\n**3. HTTP Basic Authentication**\n- Authorization 헤더에 인코딩된 자격 증명 전송\n- Authorization: Basic dXNlcjpwYXNzd29yZA==\n- 주의: 암호화 아님, HTTPS 필수\n\n**4. JWT (JSON Web Token)**\n- Header와 Payload를 Base64URL로 인코딩\n\n**5. 웹 API**\n- JSON 응답에 바이너리 데이터 포함\n- 파일 업로드 시 Base64로 인코딩하여 전송\n\n**6. 데이터베이스 저장**\n- BLOB 대신 TEXT 필드에 저장할 때\n\n**7. XML/HTML**\n- 바이너리 데이터를 문서에 임베드\n\n---\n\n**Base64의 특징:**\n\n**장점:**\n- 텍스트 전용 시스템과 호환\n- 플랫폼 독립적\n- 단순하고 표준화됨\n- 구현이 쉬움\n\n**단점:**\n- 데이터 크기 33% 증가 (3바이트 → 4문자)\n- CPU 오버헤드 (인코딩/디코딩 비용)\n- 암호화가 아님 (누구나 디코딩 가능)\n- 검색/인덱싱 불가\n\n---\n\n**Base64 vs Base64URL:**\n\n**Base64 (표준):**\n- 64개 문자: A-Z, a-z, 0-9, +, /\n- 패딩: = 또는 ==\n\n**Base64URL (URL-safe):**\n- 64개 문자: A-Z, a-z, 0-9, -, _\n- + → -, / → _ (URL에서 특수 의미가 없는 문자로 대체)\n- 패딩 생략 가능\n- JWT, URL 파라미터에서 사용\n\n---\n\n**Base64 인코딩 과정 (예시):**\n\n원본 텍스트: \"Man\"\n1. ASCII 코드: M=77, a=97, n=110\n2. 바이너리: 01001101 01100001 01101110\n3. 6비트씩 분할: 010011 010110 000101 101110\n4. 10진수: 19, 22, 5, 46\n5. Base64 문자: T, W, F, u\n6. 결과: \"TWFu\"\n\n---\n\n**주의사항:**\n\n**1. 암호화가 아님**\n- Base64는 단순 인코딩으로 쉽게 디코딩 가능\n- 민감한 데이터는 암호화 후 Base64로 인코딩해야 함\n\n**2. 크기 증가**\n- 대용량 파일은 Base64보다 바이너리 전송이 효율적\n- 가능하면 multipart/form-data 사용 권장\n\n**3. 성능 고려**\n- 인코딩/디코딩 CPU 비용\n- 큰 파일은 스트리밍 방식 사용\n\n**4. 적절한 사용**\n- 작은 데이터 (아이콘, 썸네일): 적합\n- 큰 파일 (동영상, 대용량 이미지): 부적합\n\n---\n\n**결론:**\n\nBase64는 바이너리 데이터를 텍스트 전용 시스템에서 안전하게 전송하기 위한 실용적인 방법입니다. 보안을 위한 암호화가 아니라 **호환성과 안전한 전송**을 위한 인코딩 방식임을 이해해야 합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "인코딩",
        "Base64"
      ],
      "id": "etc-042",
      "createdAt": "2025-11-17T15:00:00.000042",
      "studyCount": 0
    },
    {
      "question": "Git에 대해 설명해 주세요.",
      "answer": "Git은 소프트웨어 개발에서 소스 코드의 변경 이력을 관리하는 **분산 버전 관리 시스템(Distributed Version Control System, DVCS)**입니다.\n\n---\n\n**Git의 핵심 특징:**\n\n**1. 분산 시스템 (Distributed)**\n- 모든 개발자가 전체 저장소의 복사본을 가집니다.\n- 중앙 서버 없이도 작업 가능합니다.\n- 로컬에서 대부분의 작업 수행 (빠른 성능).\n- 네트워크 연결 없이도 버전 관리 가능합니다.\n\n**2. 스냅샷 방식**\n- 차이점(diff)이 아닌 전체 파일의 스냅샷을 저장합니다.\n- 변경되지 않은 파일은 이전 스냅샷을 참조합니다.\n- 빠른 브랜치 전환과 병합이 가능합니다.\n\n**3. 데이터 무결성**\n- 모든 데이터를 SHA-1 해시로 체크섬 관리합니다.\n- 데이터 손상이나 변조를 즉시 감지할 수 있습니다.\n\n**4. 브랜치 중심 개발**\n- 브랜치 생성과 병합이 매우 빠르고 쉽습니다.\n- 실험적 기능 개발, 버그 수정 등을 독립적으로 수행할 수 있습니다.\n\n---\n\n**Git의 주요 개념:**\n\n**1. Repository (저장소)**\n- 프로젝트의 모든 파일과 변경 이력을 저장하는 공간\n- **로컬 저장소**: 개발자의 컴퓨터에 있는 저장소\n- **원격 저장소**: GitHub, GitLab 등의 서버에 있는 저장소\n\n**2. Commit (커밋)**\n- 특정 시점의 파일 스냅샷\n- 고유한 SHA-1 해시로 식별\n- 작성자, 날짜, 메시지 포함\n- 부모 커밋을 가리켜 이력 형성\n\n**3. Branch (브랜치)**\n- 독립적인 개발 라인\n- 커밋을 가리키는 포인터\n- 생성과 전환이 매우 빠름 (단순한 포인터 이동)\n- main/master: 기본 브랜치\n\n**4. Merge (병합)**\n- 여러 브랜치의 변경사항을 합치는 작업\n- Fast-forward 병합, 3-way 병합 등\n\n**5. Remote (원격)**\n- 원격 저장소를 가리키는 참조\n- origin: 기본 원격 저장소 이름\n\n---\n\n**Git의 세 가지 영역:**\n\n**1. Working Directory (작업 디렉토리)**\n- 실제 파일이 있는 공간\n- 수정 작업이 이루어지는 곳\n\n**2. Staging Area (스테이징 영역 / Index)**\n- 다음 커밋에 포함될 변경사항을 준비하는 공간\n- git add로 파일을 추가\n\n**3. Repository (저장소 / .git 디렉토리)**\n- 커밋된 스냅샷이 영구적으로 저장되는 공간\n- git commit으로 스테이징된 변경사항을 저장\n\n---\n\n**Git의 파일 상태:**\n\n1. **Untracked**: Git이 추적하지 않는 새 파일\n2. **Unmodified**: 마지막 커밋 이후 변경되지 않은 파일\n3. **Modified**: 변경되었지만 스테이징되지 않은 파일\n4. **Staged**: 스테이징되어 다음 커밋 대기 중인 파일\n\n---\n\n**주요 Git 명령어:**\n\n**초기화 및 복제:**\n- git init: 새 저장소 초기화\n- git clone <url>: 원격 저장소 복제\n\n**변경 관리:**\n- git status: 파일 상태 확인\n- git add <file>: 스테이징\n- git commit -m \"message\": 커밋\n- git diff: 변경사항 확인\n\n**브랜치:**\n- git branch: 브랜치 목록\n- git branch <name>: 새 브랜치 생성\n- git checkout <branch>: 브랜치 전환\n- git merge <branch>: 브랜치 병합\n\n**원격 저장소:**\n- git remote add origin <url>: 원격 저장소 추가\n- git push: 원격 저장소로 푸시\n- git pull: 원격 저장소에서 가져오기 및 병합\n- git fetch: 원격 저장소에서 가져오기 (병합 없이)\n\n**이력 확인:**\n- git log: 커밋 이력 확인\n- git show <commit>: 특정 커밋 확인\n\n---\n\n**Git Workflow (일반적인 작업 흐름):**\n\n1. **로컬 작업**\n   - 파일 수정\n   - git add로 스테이징\n   - git commit으로 로컬 저장소에 커밋\n\n2. **원격 동기화**\n   - git pull로 원격 변경사항 가져오기\n   - 충돌 해결 (필요 시)\n   - git push로 로컬 커밋을 원격에 업로드\n\n3. **브랜치 작업**\n   - 새 기능 개발을 위한 브랜치 생성\n   - 해당 브랜치에서 작업 및 커밋\n   - main 브랜치로 병합\n   - 원격 저장소에 푸시\n\n---\n\n**Git의 장점:**\n\n1. **속도**: 로컬에서 대부분의 작업 수행\n2. **오프라인 작업**: 네트워크 없이도 버전 관리 가능\n3. **강력한 브랜치 기능**: 실험적 개발과 기능 격리\n4. **협업**: 여러 개발자가 동시에 작업 가능\n5. **이력 관리**: 모든 변경사항 추적 및 복구 가능\n6. **안정성**: 분산 구조로 데이터 손실 위험 최소화\n7. **유연성**: 다양한 워크플로우 지원\n\n---\n\n**Git을 사용하는 플랫폼:**\n\n- **GitHub**: 가장 널리 사용되는 Git 호스팅 서비스\n- **GitLab**: CI/CD 통합, 자체 호스팅 가능\n- **Bitbucket**: Atlassian 제품과 통합\n- **Azure DevOps**: Microsoft의 Git 서비스\n\n---\n\n**Git vs SVN (중앙집중식 VCS):**\n\n| 특징 | Git (분산) | SVN (중앙집중) |\n|------|-----------|--------------|\n| 구조 | 분산형 | 중앙 서버 |\n| 속도 | 빠름 (로컬) | 느림 (네트워크) |\n| 오프라인 | 가능 | 불가능 |\n| 브랜치 | 빠르고 쉬움 | 무겁고 복잡함 |\n| 저장 방식 | 스냅샷 | 차이점(diff) |\n\n---\n\n**Best Practices:**\n\n1. **의미 있는 커밋 메시지 작성**\n2. **작은 단위로 자주 커밋**\n3. **기능별로 브랜치 분리**\n4. **main 브랜치는 항상 안정적으로 유지**\n5. **정기적으로 pull하여 최신 상태 유지**\n6. **민감한 정보는 .gitignore로 제외**\n\nGit은 현대 소프트웨어 개발에서 필수적인 도구이며, 팀 협업과 코드 관리의 표준이 되었습니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "Git",
        "버전관리"
      ],
      "id": "etc-043",
      "createdAt": "2025-11-17T15:00:00.000043",
      "studyCount": 0
    },
    {
      "question": "여러 브랜치를 합쳐야 할 때, 어떤 방법을 사용할 수 있는지 모두 설명해 주세요.",
      "answer": "Git에서 여러 브랜치를 합치는 방법은 크게 다음과 같습니다:\n\n---\n\n**1. Git Merge (병합)**\n\n**정의:**\n두 개 이상의 브랜치를 하나로 합치는 가장 기본적인 방법입니다.\n\n**종류:**\n\n**A. Fast-Forward Merge (빠른 감기 병합)**\n- 현재 브랜치가 대상 브랜치의 직접적인 조상일 때 발생\n- 단순히 브랜치 포인터를 앞으로 이동\n- 병합 커밋이 생성되지 않음\n- 히스토리가 선형으로 유지됨\n\n**시나리오:**\nmain 브랜치에서 feature 브랜치 분기 후, main에 새 커밋이 없을 때\n\n**명령어:**\n- git merge feature (main에서 실행)\n\n**B. 3-Way Merge (3방향 병합)**\n- 두 브랜치가 분기된 후 각각 독립적으로 커밋이 발생했을 때\n- 공통 조상, 두 브랜치의 최신 커밋을 비교하여 병합\n- 새로운 병합 커밋(merge commit)이 생성됨\n- 두 부모 커밋을 가짐\n\n**명령어:**\n- git merge feature\n\n**C. Recursive Merge**\n- 여러 공통 조상이 있을 때 사용하는 3-way merge의 확장\n- Git의 기본 병합 전략\n\n**D. Octopus Merge (문어 병합)**\n- 3개 이상의 브랜치를 한 번에 병합\n- 충돌이 없을 때만 사용 가능\n- 주로 여러 feature 브랜치를 한 번에 통합할 때\n\n**명령어:**\n- git merge branch1 branch2 branch3\n\n**장점:**\n- 브랜치의 전체 히스토리 보존\n- 언제 병합되었는지 명확함\n- 안전하고 이해하기 쉬움\n\n**단점:**\n- 병합 커밋으로 히스토리가 복잡해질 수 있음\n- 시각적으로 지저분할 수 있음\n\n---\n\n**2. Git Rebase (리베이스)**\n\n**정의:**\n한 브랜치의 변경사항을 다른 브랜치의 최신 커밋 위에 재적용하는 방법입니다.\n\n**동작 방식:**\n1. 현재 브랜치의 커밋들을 임시 저장\n2. 현재 브랜치를 대상 브랜치의 최신 커밋으로 이동\n3. 저장된 커밋들을 하나씩 재적용\n4. 결과적으로 선형 히스토리 생성\n\n**명령어:**\n- git rebase main (feature 브랜치에서 실행)\n- git rebase main feature (어디서나 실행 가능)\n\n**Interactive Rebase:**\n- git rebase -i HEAD~3\n- 커밋 순서 변경, 합치기, 수정, 삭제 가능\n- pick, reword, edit, squash, fixup, drop 등\n\n**장점:**\n- 깔끔하고 선형적인 히스토리\n- 이해하기 쉬운 커밋 이력\n- 시각적으로 단순함\n\n**단점:**\n- 기존 커밋의 SHA가 변경됨 (새로운 커밋 생성)\n- 이미 push한 커밋을 rebase하면 협업 시 문제 발생\n- 충돌 해결이 여러 번 필요할 수 있음\n\n**황금률:**\n\"이미 공개된(push된) 커밋은 rebase하지 않는다\"\n\n---\n\n**3. Git Cherry-Pick (체리픽)**\n\n**정의:**\n특정 커밋만 선택적으로 다른 브랜치에 적용하는 방법입니다.\n\n**사용 사례:**\n- 특정 버그 수정만 다른 브랜치에 적용\n- 잘못된 브랜치에 커밋한 경우\n- 일부 기능만 선택적으로 가져올 때\n\n**명령어:**\n- git cherry-pick <commit-hash>\n- git cherry-pick <commit1> <commit2> (여러 커밋)\n- git cherry-pick <start-commit>..<end-commit> (범위)\n\n**장점:**\n- 필요한 변경사항만 선택적으로 적용\n- 유연성\n\n**단점:**\n- 중복 커밋이 생성될 수 있음\n- 히스토리가 복잡해질 수 있음\n- 전체 브랜치 병합보다 불완전할 수 있음\n\n---\n\n**4. Git Merge --squash (스쿼시 병합)**\n\n**정의:**\n여러 커밋을 하나의 커밋으로 합쳐서 병합하는 방법입니다.\n\n**동작 방식:**\n1. 브랜치의 모든 변경사항을 스테이징\n2. 병합 커밋은 생성하지 않음\n3. 수동으로 커밋 필요\n\n**명령어:**\n- git merge --squash feature\n- git commit -m \"Add feature\"\n\n**장점:**\n- 깔끔한 히스토리 (하나의 커밋으로)\n- 실험적 커밋들을 숨길 수 있음\n- main 브랜치가 깔끔하게 유지됨\n\n**단점:**\n- 브랜치의 세부 히스토리 손실\n- 원래 커밋들과의 연결 끊김\n\n**사용 사례:**\n- PR(Pull Request) 병합 시\n- Feature 브랜치의 여러 작업 커밋을 하나로 정리\n\n---\n\n**5. Git Rebase --onto (고급 리베이스)**\n\n**정의:**\n커밋들을 원하는 위치로 정확하게 이동시키는 방법입니다.\n\n**명령어:**\n- git rebase --onto <new-base> <old-base> <branch>\n\n**사용 사례:**\n- 브랜치의 일부만 다른 위치로 이동\n- 잘못된 기준 브랜치에서 생성된 브랜치 수정\n\n---\n\n**6. Git Merge --no-ff (No Fast-Forward 병합)**\n\n**정의:**\nFast-forward 가능한 상황에서도 강제로 병합 커밋을 생성합니다.\n\n**명령어:**\n- git merge --no-ff feature\n\n**장점:**\n- 브랜치가 존재했다는 정보 보존\n- 기능 단위 구분이 명확함\n- 롤백이 쉬움 (하나의 병합 커밋만 되돌리면 됨)\n\n**사용 사례:**\n- 기능 브랜치를 명확히 구분하고 싶을 때\n- Git Flow 같은 브랜치 전략\n\n---\n\n**방법 선택 가이드:**\n\n| 상황 | 권장 방법 |\n|------|---------|\n| 공개 브랜치 병합 | Merge |\n| 로컬 작업 정리 | Rebase (Interactive) |\n| 히스토리 보존 중요 | Merge |\n| 선형 히스토리 선호 | Rebase |\n| 특정 커밋만 필요 | Cherry-pick |\n| PR 병합 (깔끔한 히스토리) | Merge --squash |\n| 기능 단위 구분 | Merge --no-ff |\n| 여러 브랜치 한번에 | Octopus merge |\n\n---\n\n**충돌 해결:**\n\n모든 방법에서 충돌이 발생할 수 있습니다:\n\n1. 충돌 파일 확인: git status\n2. 파일을 열어 충돌 마커 해결 (<<<<, ====, >>>>)\n3. git add로 해결된 파일 스테이징\n4. 병합/리베이스 계속: git merge --continue 또는 git rebase --continue\n5. 취소: git merge --abort 또는 git rebase --abort\n\n---\n\n**Best Practices:**\n\n1. **Feature 브랜치**: Merge 또는 Squash merge\n2. **로컬 정리**: Interactive rebase\n3. **공개된 커밋**: 절대 rebase하지 않기\n4. **핫픽스**: Cherry-pick\n5. **일관된 전략 사용**: 팀 내 합의된 방법 사용\n\n각 방법은 상황에 따라 장단점이 있으므로, 프로젝트의 워크플로우와 팀 정책에 맞게 선택해야 합니다.",
      "type": "essay",
      "tags": [
        "CS",
        "개발상식",
        "Git",
        "브랜치병합"
      ],
      "id": "etc-044",
      "createdAt": "2025-11-17T15:00:00.000044",
      "studyCount": 0
    }
  ]
}