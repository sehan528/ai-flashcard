{
  "name": "개발상식 (CS 기타)",
  "description": "가상화, Docker, CI/CD, static 등 개발 필수 지식",
  "cards": [
    {
      "question": "가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.",
      "answer": "**가상화 (Virtualization):**\n\n**개념:**\n- 물리적 하드웨어 리소스를 논리적으로 추상화하여 여러 개의 독립적인 환경을 만드는 기술\n- 하나의 물리 서버에서 여러 개의 가상 환경을 실행\n\n**핵심 목표:**\n- 리소스 효율성 향상\n- 격리된 실행 환경 제공\n- 유연한 인프라 관리\n\n---\n\n**가상머신 (Virtual Machine):**\n\n**개념:**\n- 가상화 기술의 한 구현 방식\n- 하이퍼바이저(Hypervisor)를 통해 완전한 운영체제를 가상화\n\n**구조:**\n- Host OS (물리 서버 운영체제)\n- Hypervisor (VMware, VirtualBox, Hyper-V 등)\n- Guest OS (각 VM의 독립적인 OS)\n- Application\n\n---\n\n**차이점:**\n\n**가상화:**\n- **광범위한 개념**: 하드웨어, OS, 네트워크, 스토리지 등 모든 리소스 가상화 포함\n- **다양한 방식**: VM, 컨테이너, 서버리스 등\n\n**가상머신:**\n- **가상화의 한 방식**: OS 레벨 가상화\n- **완전한 격리**: 각 VM이 독립적인 OS 보유\n- **무거움**: Guest OS 전체를 포함하여 리소스 많이 사용\n\n---\n\n**가상화 방식 비교:**\n\n**1. 가상머신 (VM):**\n- 하이퍼바이저 기반\n- 완전한 OS 격리\n- 무거움 (GB 단위 메모리)\n- 부팅 시간 느림 (분 단위)\n- 강력한 격리\n\n**2. 컨테이너 (Docker 등):**\n- OS 레벨 가상화\n- Host OS 커널 공유\n- 가벼움 (MB 단위 메모리)\n- 부팅 시간 빠름 (초 단위)\n- 프로세스 격리\n\n**3. 서버리스:**\n- 함수 레벨 가상화\n- 인프라 추상화\n- 이벤트 기반 실행\n\n---\n\n**요약:**\n\n- **가상화**: 리소스를 논리적으로 분할하는 기술 전반\n- **가상머신**: 가상화 기술 중 하이퍼바이저를 이용해 완전한 OS를 가상화하는 방식\n\n가상화는 큰 개념이고, 가상머신은 그 구현 방법 중 하나입니다.",
      "type": "essay",
      "tags": [
        "가상화",
        "VM",
        "인프라",
        "클라우드"
      ],
      "id": "etc-001",
      "createdAt": "2025-11-17T15:00:00.000000",
      "studyCount": 0
    },
    {
      "question": "그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?",
      "answer": "**Docker의 분류:**\n\nDocker는 **컨테이너 기반 가상화**에 속합니다.\n\n- **가상화 기술**의 한 방식\n- **가상머신(VM)이 아님**\n- OS 레벨 가상화 (프로세스 격리)\n\n---\n\n**Docker 특징:**\n\n**구조:**\n- Host OS\n- Docker Engine\n- 컨테이너 (독립 실행 환경)\n- Application\n\n**차이점:**\n- Guest OS 없음 (Host OS 커널 공유)\n- 경량화 (MB 단위)\n- 빠른 시작 (초 단위)\n\n---\n\n**VM vs Docker:**\n\n| 항목 | VM | Docker |\n|------|----|----|\n| OS | Guest OS 전체 포함 | Host OS 커널 공유 |\n| 크기 | GB 단위 | MB 단위 |\n| 부팅 | 분 단위 | 초 단위 |\n| 리소스 | 많이 사용 | 적게 사용 |\n| 격리 | 강력 (하드웨어 레벨) | 프로세스 레벨 |\n| 성능 | 오버헤드 있음 | 네이티브에 가까움 |\n\n---\n\n**Docker를 많이 채택하는 이유:**\n\n---\n\n**1. 경량성:**\n- Guest OS 불필요 → 메모리 절약\n- 수십 개 컨테이너를 하나의 호스트에서 실행 가능\n- VM은 수 개만 가능\n\n**2. 빠른 시작/종료:**\n- 초 단위 시작\n- 배포 속도 향상\n- CI/CD 파이프라인에 적합\n\n**3. 이식성 (Portability):**\n- \"Build once, run anywhere\"\n- 동일한 컨테이너 이미지를 어디서나 실행\n- 개발/스테이징/프로덕션 환경 일관성\n\n**4. 개발 환경 일치:**\n- \"내 컴퓨터에서는 되는데...\" 문제 해결\n- 모든 개발자가 동일한 환경\n- 의존성 충돌 방지\n\n**5. 마이크로서비스 아키텍처:**\n- 서비스별 독립 컨테이너\n- 쉬운 스케일링\n- 서비스 간 격리\n\n**6. 버전 관리:**\n- Docker 이미지 버전 관리\n- 롤백 용이\n- 이미지 레이어 캐싱\n\n**7. 리소스 효율:**\n- 동일 하드웨어에 더 많은 애플리케이션\n- 클라우드 비용 절감\n\n**8. DevOps 문화:**\n- Infrastructure as Code\n- 자동화된 배포\n- 컨테이너 오케스트레이션 (Kubernetes)\n\n**9. 생태계:**\n- Docker Hub (공개 이미지 저장소)\n- 수많은 공식/커뮤니티 이미지\n- 쉬운 시작\n\n**10. 격리:**\n- 애플리케이션 간 의존성 충돌 방지\n- 보안 향상 (제한적이지만)\n\n---\n\n**실제 사용 예:**\n\n**개발:**\n- 로컬에서 MySQL, Redis, Kafka 등을 컨테이너로 실행\n- 프로젝트별 독립 환경\n\n**배포:**\n- 동일한 이미지를 개발/스테이징/프로덕션에 배포\n- 일관성 보장\n\n**마이크로서비스:**\n- 각 서비스를 독립 컨테이너로\n- Kubernetes로 오케스트레이션\n\n---\n\n**한계:**\n\n**1. 보안:**\n- Host OS 커널 공유 → 커널 취약점 영향\n- VM보다 격리 약함\n\n**2. OS 제약:**\n- Linux 컨테이너는 Linux에서만 (Windows는 WSL2 필요)\n- 다른 OS 커널 불가\n\n**3. 상태 관리:**\n- 컨테이너는 기본적으로 stateless\n- 영구 데이터는 볼륨 필요\n\n---\n\n**결론:**\n\nDocker는 **컨테이너 기반 가상화**로, VM보다 경량하고 빠르며 이식성이 뛰어납니다. 마이크로서비스, DevOps, 클라우드 네이티브 환경에서 사실상 표준이 되었습니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "컨테이너",
        "가상화",
        "DevOps"
      ],
      "id": "etc-002",
      "createdAt": "2025-11-17T15:00:00.000001",
      "studyCount": 0
    },
    {
      "question": "하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?",
      "answer": "**위험성:**\n\n맞습니다. Docker 컨테이너는 Host OS 커널을 공유하므로 다음 위험이 있습니다:\n\n**1. 리소스 고갈:**\n- 한 컨테이너가 CPU/메모리 독점\n- 다른 컨테이너 성능 저하 또는 중단\n\n**2. 커널 취약점:**\n- 컨테이너에서 커널 익스플로잇\n- Host 및 다른 컨테이너 침해\n\n**3. 네트워크 간섭:**\n- 같은 네트워크의 컨테이너 간 통신\n- 의도치 않은 접근\n\n**4. 파일시스템 접근:**\n- 볼륨 마운트 오용\n- Host 파일시스템 접근\n\n---\n\n**방어 메커니즘:**\n\nDocker와 Linux는 여러 격리 기술을 제공합니다:\n\n---\n\n**1. Namespace (네임스페이스):**\n\n**개념:**\n- 프로세스, 네트워크, 파일시스템 등을 격리\n- 각 컨테이너가 독립된 뷰를 가짐\n\n**종류:**\n\n**PID Namespace:**\n- 프로세스 ID 격리\n- 컨테이너 내부에서 PID 1부터 시작\n- 다른 컨테이너 프로세스 보이지 않음\n\n**Network Namespace:**\n- 네트워크 인터페이스 격리\n- 각 컨테이너가 독립 IP, 포트\n- 브리지 네트워크로 연결\n\n**Mount Namespace:**\n- 파일시스템 격리\n- 각 컨테이너가 독립 루트 파일시스템\n- Host 파일시스템 보이지 않음\n\n**UTS Namespace:**\n- 호스트명, 도메인명 격리\n\n**IPC Namespace:**\n- 프로세스 간 통신 격리\n\n**User Namespace:**\n- UID/GID 매핑\n- 컨테이너 내부 root가 Host에서는 일반 사용자\n\n---\n\n**2. Cgroups (Control Groups):**\n\n**개념:**\n- 리소스 사용량 제한 및 격리\n\n**제한 항목:**\n\n**CPU:**\n- --cpus 옵션\n- CPU 사용률 제한\n\n**메모리:**\n- --memory 옵션\n- 메모리 한계 설정\n- OOM Killer 방지\n\n**I/O:**\n- 디스크 읽기/쓰기 속도 제한\n\n**네트워크:**\n- 대역폭 제한\n\n**효과:**\n- 한 컨테이너의 리소스 독점 방지\n- 다른 컨테이너 영향 최소화\n\n---\n\n**3. Seccomp (Secure Computing Mode):**\n\n**개념:**\n- 시스템 콜 필터링\n- 위험한 시스템 콜 차단\n\n**기본 프로필:**\n- Docker 기본 seccomp 프로필\n- 300개 이상 시스템 콜 중 일부만 허용\n- reboot, mount 등 위험한 콜 차단\n\n**커스텀 프로필:**\n- JSON으로 허용/차단 시스템 콜 정의\n\n---\n\n**4. AppArmor / SELinux:**\n\n**개념:**\n- 강제 접근 제어 (MAC)\n- 프로세스별 권한 정의\n\n**AppArmor:**\n- Ubuntu/Debian에서 사용\n- 프로파일로 파일/네트워크 접근 제어\n\n**SELinux:**\n- RHEL/CentOS에서 사용\n- 레이블 기반 접근 제어\n\n---\n\n**5. Capabilities:**\n\n**개념:**\n- root 권한을 세분화\n- 필요한 권한만 부여\n\n**예시:**\n- CAP_NET_BIND_SERVICE (1024 미만 포트 바인딩)\n- CAP_SYS_ADMIN (시스템 관리)\n\n**기본:**\n- Docker는 일부 위험한 capabilities 제거\n- --cap-drop, --cap-add로 조정\n\n---\n\n**6. Read-only Root Filesystem:**\n\n**개념:**\n- 컨테이너 루트 파일시스템을 읽기 전용으로\n\n**효과:**\n- 악성 파일 쓰기 방지\n- 불변 인프라\n\n---\n\n**7. User Namespace:**\n\n**개념:**\n- 컨테이너 내부 UID를 Host UID로 매핑\n\n**효과:**\n- 컨테이너 내부 root (UID 0)\n- Host에서는 일반 사용자 (UID 100000 등)\n- Host 파일시스템 접근 제한\n\n---\n\n**8. 네트워크 격리:**\n\n**방법:**\n\n**브리지 네트워크:**\n- 기본 격리\n- 컨테이너끼리 브리지를 통해 통신\n\n**사용자 정의 네트워크:**\n- docker network create mynet\n- 네트워크별 격리\n\n**호스트 네트워크 피하기:**\n- --network host는 격리 없음\n- 필요한 경우만 사용\n\n---\n\n**9. 이미지 보안:**\n\n**신뢰할 수 있는 이미지:**\n- 공식 이미지 사용\n- Docker Content Trust (이미지 서명)\n\n**취약점 스캔:**\n- Trivy, Clair 등으로 이미지 스캔\n- 알려진 CVE 확인\n\n**최소 이미지:**\n- Alpine Linux 등 최소 이미지\n- 공격 표면 축소\n\n---\n\n**10. 런타임 보안:**\n\n**Docker Bench Security:**\n- Docker 보안 Best Practice 검사 도구\n\n**Falco:**\n- 런타임 보안 모니터링\n- 비정상 동작 감지\n\n**gVisor, Kata Containers:**\n- 더 강력한 격리\n- 컨테이너별 경량 커널 (gVisor)\n- 컨테이너별 경량 VM (Kata)\n\n---\n\n**실전 권장사항:**\n\n**1. 리소스 제한:**\n- 모든 컨테이너에 CPU/메모리 제한 설정\n\n**2. 최소 권한:**\n- root로 실행 금지 (USER 지시어)\n- 필요한 capabilities만\n- 읽기 전용 파일시스템\n\n**3. 네트워크 분리:**\n- 서비스별 네트워크 분리\n- 필요한 포트만 노출\n\n**4. 정기 업데이트:**\n- Host OS, Docker, 이미지 최신 유지\n- 보안 패치 적용\n\n**5. 모니터링:**\n- 컨테이너 동작 모니터링\n- 이상 징후 감지\n\n**6. 스캔:**\n- 이미지 취약점 스캔\n- CI/CD에 통합\n\n---\n\n**결론:**\n\nDocker는 Namespace, Cgroups, Seccomp, AppArmor 등 여러 격리 메커니즘을 제공하여 컨테이너 간 간섭을 방지합니다. 하지만 VM보다 격리가 약하므로, 리소스 제한, 최소 권한, 보안 스캔 등의 Best Practice를 따라야 합니다.",
      "type": "essay",
      "tags": [
        "Docker",
        "보안",
        "격리",
        "Namespace",
        "Cgroups"
      ],
      "id": "etc-003",
      "createdAt": "2025-11-17T15:00:00.000002",
      "studyCount": 0
    },
    {
      "question": "Docker 위에 Docker를 올릴 순 없을까요?",
      "answer": "**답변: 가능합니다.**\n\nDocker 위에 Docker를 올리는 것을 **Docker-in-Docker (DinD)**라고 합니다.\n\n---\n\n**구현 방법:**\n\n**1. Docker-in-Docker (DinD):**\n\n**공식 이미지:**\n- docker:dind 이미지 사용\n\n**특징:**\n- 컨테이너 내부에서 Docker daemon 실행\n- 완전히 독립적인 Docker 환경\n- Privileged 모드 필요\n\n**장점:**\n- 완전한 격리\n- 내부 Docker와 외부 Docker 독립\n\n**단점:**\n- 보안 위험 (privileged 모드)\n- 리소스 오버헤드\n- 복잡도 증가\n\n---\n\n**2. Docker Socket 마운트:**\n\n**방법:**\n- Host의 Docker socket을 컨테이너에 마운트\n- /var/run/docker.sock\n\n**특징:**\n- 컨테이너 내부에서 Host의 Docker 제어\n- 실제로는 DinD가 아님 (Host Docker 사용)\n- Privileged 모드 불필요\n\n**장점:**\n- 간단\n- 리소스 효율적\n\n**단점:**\n- Host Docker 접근 (보안 위험)\n- 완전한 격리 아님\n- 컨테이너가 Host Docker 제어 가능\n\n---\n\n**사용 사례:**\n\n**1. CI/CD 파이프라인:**\n\n**목적:**\n- Jenkins, GitLab CI 등에서 Docker 이미지 빌드\n\n**시나리오:**\n- Jenkins 컨테이너 내부에서 Docker 이미지 빌드\n- 빌드된 이미지를 레지스트리에 푸시\n\n**방법:**\n- DinD 또는 Docker socket 마운트\n\n---\n\n**2. Docker 개발/테스트:**\n\n**목적:**\n- Docker 자체 개발 또는 테스트\n\n**시나리오:**\n- 격리된 환경에서 Docker 실험\n\n---\n\n**3. 샌드박스 환경:**\n\n**목적:**\n- 안전하게 Docker 명령 실행\n\n---\n\n**DinD vs Docker Socket 비교:**\n\n| 항목 | DinD | Docker Socket |\n|------|------|---------------|\n| 격리 | 완전 격리 | Host Docker 공유 |\n| Privileged | 필요 | 불필요 |\n| 보안 | 중간 (privileged 위험) | 낮음 (Host 접근) |\n| 리소스 | 높음 (daemon 별도) | 낮음 (Host daemon 공유) |\n| 복잡도 | 높음 | 낮음 |\n| 사용 | 완전한 격리 필요 시 | CI/CD 등 간단한 경우 |\n\n---\n\n**보안 고려사항:**\n\n**DinD:**\n- --privileged 플래그 필요\n- 컨테이너가 Host 커널 전체 접근\n- 보안 위험 높음\n\n**Docker Socket 마운트:**\n- 컨테이너가 Host Docker 제어\n- Host의 모든 컨테이너 제어 가능\n- Host 파일시스템 마운트 가능\n- 사실상 root 권한과 동등\n\n**완화:**\n- 신뢰할 수 있는 이미지만 사용\n- 네트워크 격리\n- 리소스 제한\n- 모니터링\n\n---\n\n**대안:**\n\n**1. Kaniko:**\n- DinD 없이 컨테이너 이미지 빌드\n- Kubernetes에서 사용\n- Privileged 모드 불필요\n\n**2. Buildah:**\n- Rootless 컨테이너 빌드\n- Docker daemon 불필요\n\n**3. BuildKit:**\n- Docker의 차세대 빌드 엔진\n- 더 안전하고 빠름\n\n---\n\n**실전 권장사항:**\n\n**CI/CD:**\n- **단순한 경우**: Docker socket 마운트\n- **격리 필요**: DinD\n- **보안 중요**: Kaniko/Buildah\n\n**개발:**\n- DinD로 실험 환경 구축\n\n**프로덕션:**\n- 가능하면 피하기\n- 대안 도구 사용\n\n---\n\n**예시 시나리오:**\n\n**Jenkins CI:**\n\n**방법 1 (Docker Socket):**\n- Jenkins 컨테이너 실행 시 -v /var/run/docker.sock:/var/run/docker.sock\n- Jenkins job에서 docker build\n- Host Docker 사용하여 빌드\n\n**방법 2 (DinD):**\n- docker:dind 컨테이너 실행\n- Jenkins를 DinD에 연결\n- 완전히 격리된 Docker 환경\n\n---\n\n**한계:**\n\n**1. 성능:**\n- 중첩된 환경으로 오버헤드\n\n**2. 복잡도:**\n- 디버깅 어려움\n- 네트워크 설정 복잡\n\n**3. 이식성:**\n- 환경마다 동작 다를 수 있음\n\n---\n\n**결론:**\n\nDocker 위에 Docker를 올리는 것은 가능하며(DinD) 또는 Host Docker를 공유할 수 있습니다(Socket 마운트). CI/CD에서 유용하지만 보안 위험이 있으므로 신중하게 사용하고, 가능하면 Kaniko 같은 대안을 고려하세요.",
      "type": "essay",
      "tags": [
        "Docker",
        "DinD",
        "Docker-in-Docker",
        "CI/CD"
      ],
      "id": "etc-004",
      "createdAt": "2025-11-17T15:00:00.000003",
      "studyCount": 0
    },
    {
      "question": "CI/CD를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.",
      "answer": "**CI/CD 개념:**\n\n**CI (Continuous Integration):**\n- 지속적 통합\n- 코드 변경을 자주 메인 브랜치에 통합\n- 자동 빌드 및 테스트\n\n**CD (Continuous Delivery/Deployment):**\n- 지속적 배포\n- Delivery: 릴리스 준비 자동화\n- Deployment: 프로덕션 자동 배포\n\n---\n\n**CI/CD 파이프라인 구성 요소:**\n\n**1. 소스 코드 관리:**\n- Git (GitHub, GitLab, Bitbucket)\n- 코드 푸시 시 파이프라인 트리거\n\n**2. 빌드:**\n- 소스 코드 컴파일\n- 의존성 설치\n- Docker 이미지 빌드\n\n**3. 테스트:**\n- 단위 테스트\n- 통합 테스트\n- E2E 테스트\n- 정적 분석, 린트\n\n**4. 배포:**\n- 스테이징 환경 배포\n- 프로덕션 배포\n- 롤백 가능\n\n**5. 모니터링:**\n- 배포 후 헬스 체크\n- 메트릭 수집\n- 알림\n\n---\n\n**일반적인 CI/CD 플로우:**\n\n**1. 코드 푸시:**\n- 개발자가 Git에 코드 푸시\n\n**2. 빌드 트리거:**\n- Webhook으로 CI/CD 서버 알림\n\n**3. 빌드:**\n- 소스 코드 체크아웃\n- 의존성 설치\n- 빌드 (jar, Docker 이미지 등)\n\n**4. 테스트:**\n- 유닛 테스트 실행\n- 테스트 실패 시 파이프라인 중단\n\n**5. 정적 분석:**\n- 코드 품질 검사 (SonarQube 등)\n- 취약점 스캔\n\n**6. 배포 (스테이징):**\n- 스테이징 환경에 배포\n- 통합 테스트\n\n**7. 승인 (선택):**\n- 수동 승인 단계\n- 프로덕션 배포 전 검토\n\n**8. 배포 (프로덕션):**\n- 프로덕션 환경 배포\n- Blue-Green, Canary, Rolling 등\n\n**9. 검증:**\n- 헬스 체크\n- 스모크 테스트\n- 실패 시 자동 롤백\n\n---\n\n**주요 CI/CD 도구:**\n\n**1. Jenkins:**\n- 오픈소스, 가장 널리 사용\n- 플러그인 생태계\n- Jenkinsfile (Pipeline as Code)\n\n**2. GitLab CI/CD:**\n- GitLab 통합\n- .gitlab-ci.yml\n- 간편한 설정\n\n**3. GitHub Actions:**\n- GitHub 통합\n- YAML 기반 워크플로우\n- 무료 티어 제공\n\n**4. CircleCI:**\n- 클라우드 기반\n- 빠른 빌드\n- Docker 지원\n\n**5. Travis CI:**\n- GitHub 통합\n- 오픈소스 무료\n\n**6. AWS CodePipeline, Azure DevOps, Google Cloud Build:**\n- 클라우드 네이티브\n- 각 클라우드 플랫폼 통합\n\n---\n\n**실전 예시 (GitHub Actions):**\n\n**시나리오:**\n- Node.js 애플리케이션\n- main 브랜치 푸시 시 자동 배포\n\n**파이프라인:**\n\n**1. Trigger:**\n- main 브랜치 push\n\n**2. 빌드:**\n- Node.js 설치\n- npm install\n- npm run build\n\n**3. 테스트:**\n- npm test\n\n**4. Docker 이미지 빌드:**\n- docker build\n- Docker Hub에 푸시\n\n**5. 배포:**\n- SSH로 서버 접속\n- docker pull\n- docker-compose up -d\n\n**6. 알림:**\n- Slack 알림 (성공/실패)\n\n---\n\n**장점:**\n\n**1. 빠른 피드백:**\n- 코드 푸시 후 즉시 테스트 결과\n- 문제 조기 발견\n\n**2. 자동화:**\n- 수동 배포 없음\n- 반복 작업 제거\n\n**3. 일관성:**\n- 동일한 프로세스로 빌드/배포\n- 환경 차이 최소화\n\n**4. 품질 향상:**\n- 모든 변경에 자동 테스트\n- 코드 품질 유지\n\n**5. 빠른 배포:**\n- 기능 빠르게 출시\n- 버그 수정 신속 배포\n\n**6. 롤백 용이:**\n- 이전 버전으로 쉽게 롤백\n\n---\n\n**Best Practices:**\n\n**1. Pipeline as Code:**\n- Jenkinsfile, .gitlab-ci.yml 등\n- 버전 관리\n- 코드 리뷰\n\n**2. 작은 변경, 자주 통합:**\n- Feature branch는 짧게\n- 자주 merge\n\n**3. 빠른 빌드:**\n- 병렬 실행\n- 캐싱 활용\n- 10분 이내 목표\n\n**4. 포괄적 테스트:**\n- 유닛, 통합, E2E\n- 충분한 커버리지\n\n**5. 환경 분리:**\n- Dev, Staging, Production\n- 환경별 설정 관리\n\n**6. 보안:**\n- 시크릿 관리 (환경 변수, Vault)\n- 취약점 스캔\n- 이미지 스캔\n\n**7. 모니터링:**\n- 파이프라인 메트릭\n- 실패 알림\n- 배포 후 모니터링\n\n**8. 롤백 전략:**\n- 자동 롤백 조건\n- 빠른 롤백 절차\n\n---\n\n**일반적인 문제와 해결:**\n\n**1. 느린 빌드:**\n- 병렬화\n- 캐싱 (의존성, Docker 레이어)\n- 불필요한 단계 제거\n\n**2. Flaky 테스트:**\n- 불안정한 테스트 수정\n- Retry 로직 (신중히)\n\n**3. 환경 차이:**\n- Docker로 일관된 환경\n- Infrastructure as Code\n\n**4. 시크릿 관리:**\n- 환경 변수\n- AWS Secrets Manager, HashiCorp Vault\n\n---\n\n**배포 전략:**\n\n**1. Blue-Green:**\n- 두 개 환경 유지\n- 새 버전을 Green에 배포\n- 트래픽 전환\n- 롤백 빠름\n\n**2. Canary:**\n- 일부 트래픽만 새 버전으로\n- 점진적 확대\n- 문제 조기 감지\n\n**3. Rolling:**\n- 인스턴스를 하나씩 업데이트\n- 무중단 배포\n\n**4. Feature Flag:**\n- 코드는 배포, 기능은 비활성화\n- 런타임에 토글\n\n---\n\n**결론:**\n\nCI/CD는 현대 소프트웨어 개발의 필수 요소로, 코드 변경을 자동으로 빌드, 테스트, 배포하여 개발 속도와 품질을 향상시킵니다. Jenkins, GitHub Actions, GitLab CI 등 다양한 도구가 있으며, Pipeline as Code로 관리하는 것이 Best Practice입니다.",
      "type": "essay",
      "tags": [
        "CI/CD",
        "DevOps",
        "자동화",
        "배포"
      ],
      "id": "etc-005",
      "createdAt": "2025-11-17T15:00:00.000004",
      "studyCount": 0
    },
    {
      "question": "static 키워드는 어떤 의미를 갖나요?",
      "answer": "**static 키워드 개념:**\n\n**핵심 의미:**\n- **정적 (Static)**: 프로그램 실행 시 메모리에 고정 할당\n- **클래스 레벨**: 인스턴스가 아닌 클래스에 속함\n- **공유**: 모든 인스턴스가 같은 값 공유\n\n---\n\n**언어별 static 의미:**\n\n---\n\n**Java/C#:**\n\n**1. Static 변수 (클래스 변수):**\n\n**특징:**\n- 클래스에 속함 (인스턴스와 무관)\n- 모든 객체가 공유\n- 메모리에 한 번만 할당\n- 프로그램 시작 시 생성, 종료 시 소멸\n\n**사용:**\n- 클래스명.변수명으로 접근\n- 인스턴스 생성 없이 사용 가능\n\n**예시 용도:**\n- 상수 (static final)\n- 카운터 (객체 생성 횟수)\n- 공유 자원\n\n**2. Static 메서드 (클래스 메서드):**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출 가능\n- 인스턴스 변수/메서드 접근 불가\n- this 키워드 사용 불가\n\n**사용:**\n- 유틸리티 함수 (Math.max, Collections.sort)\n- 팩토리 메서드\n\n**3. Static 블록:**\n\n**특징:**\n- 클래스 로딩 시 한 번 실행\n- 초기화 코드\n\n**4. Static 내부 클래스:**\n\n**특징:**\n- 외부 클래스 인스턴스 없이 생성 가능\n- 외부 인스턴스 변수 접근 불가\n\n---\n\n**C/C++:**\n\n**1. Static 지역 변수:**\n\n**특징:**\n- 함수 내부 변수이지만 메모리에 계속 유지\n- 함수 종료 후에도 값 유지\n- 다음 호출 시 이전 값 사용\n\n**사용:**\n- 호출 횟수 카운터\n\n**2. Static 전역 변수/함수:**\n\n**특징:**\n- 파일 스코프 제한\n- 다른 파일에서 접근 불가\n- 내부 링크 (Internal Linkage)\n\n**사용:**\n- 파일 내부 헬퍼 함수\n- 캡슐화\n\n---\n\n**JavaScript (ES6+):**\n\n**Static 메서드:**\n\n**특징:**\n- 클래스에 속함\n- 인스턴스 없이 호출\n- this는 클래스 자체\n\n**사용:**\n- 유틸리티 메서드\n\n---\n\n**Python:**\n\n**Static 메서드 (@staticmethod):**\n\n**특징:**\n- 클래스/인스턴스와 무관\n- self, cls 인자 없음\n- 순수 함수처럼 동작\n\n**vs 클래스 메서드 (@classmethod):**\n- classmethod는 cls 인자 받음\n- staticmethod는 인자 없음\n\n---\n\n**static의 주요 특징:**\n\n**1. 메모리:**\n- 힙이 아닌 데이터 영역 (또는 BSS)\n- 프로그램 시작 시 할당\n- 프로그램 종료 시 해제\n- 인스턴스마다 복사 안 됨\n\n**2. 생명주기:**\n- 프로그램 전체 수명\n- 인스턴스 생명주기와 무관\n\n**3. 접근:**\n- 클래스명으로 접근\n- 인스턴스로도 접근 가능 (권장 안 함)\n\n**4. 공유:**\n- 모든 인스턴스가 공유\n- 한 곳에서 변경하면 모든 곳에 반영\n\n**5. 오버라이딩:**\n- 불가 (대부분 언어)\n- 상속되지만 오버라이딩 안 됨\n\n---\n\n**장점:**\n\n**1. 메모리 효율:**\n- 인스턴스마다 복사 안 됨\n- 한 번만 할당\n\n**2. 유틸리티 함수:**\n- 인스턴스 생성 없이 사용\n- Math.sqrt, Integer.parseInt 등\n\n**3. 공유 데이터:**\n- 모든 인스턴스가 공유할 데이터\n\n**4. 싱글톤:**\n- static 변수로 인스턴스 관리\n\n---\n\n**단점:**\n\n**1. 전역 상태:**\n- 테스트 어려움\n- 예측 어려움\n\n**2. 멀티스레딩:**\n- 동시성 문제\n- 동기화 필요\n\n**3. 의존성:**\n- 강한 결합\n- Mock 어려움\n\n**4. OOP 위반:**\n- 객체 지향 원칙에 어긋남\n- 상태 공유\n\n---\n\n**사용 가이드:**\n\n**적합한 사용:**\n- 상수\n- 유틸리티 함수 (순수 함수)\n- 싱글톤 (신중히)\n- 팩토리 메서드\n\n**피해야 할 사용:**\n- 가변 전역 상태\n- 인스턴스 메서드를 static으로\n- 테스트 어려운 코드\n\n---\n\n**예시 시나리오:**\n\n**카운터:**\n- static 변수로 생성된 객체 수 추적\n- 생성자에서 증가\n\n**싱글톤:**\n- private static 인스턴스\n- public static getInstance()\n\n**유틸리티 클래스:**\n- 모든 메서드가 static\n- 인스턴스 생성 방지 (private 생성자)\n\n**상수:**\n- public static final\n- 변경 불가 공유 값\n\n---\n\n**멀티스레딩 주의:**\n\n**문제:**\n- 여러 스레드가 static 변수 동시 수정\n- Race condition\n\n**해결:**\n- synchronized\n- Atomic 클래스\n- ThreadLocal\n\n---\n\n**결론:**\n\nstatic 키워드는 **클래스 레벨의 정적 멤버**를 정의하며, 모든 인스턴스가 공유합니다. 유틸리티 함수와 상수에 유용하지만, 전역 상태로 인한 테스트와 동시성 문제에 주의해야 합니다.",
      "type": "essay",
      "tags": [
        "static",
        "Java",
        "메모리",
        "OOP"
      ],
      "id": "etc-006",
      "createdAt": "2025-11-17T15:00:00.000005",
      "studyCount": 0
    },
    {
      "question": "컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?",
      "answer": "**컴파일 및 런타임 처리:**\n\nstatic 키워드가 붙은 변수와 함수는 컴파일 시점과 런타임 시점에 특별하게 처리됩니다.\n\n---\n\n**1. 메모리 할당:**\n\n**데이터 영역 (또는 BSS 영역):**\n- static 변수는 스택이나 힙이 아닌 **데이터 영역**에 할당\n- 프로그램 시작 시 메모리 할당\n- 프로그램 종료 시 해제\n\n**영역 구분:**\n\n**Data 영역:**\n- 초기화된 static 변수\n- 컴파일 시 값 결정\n\n**BSS 영역 (Block Started by Symbol):**\n- 초기화되지 않은 static 변수\n- 0으로 초기화\n\n**vs 인스턴스 변수:**\n- 인스턴스 변수: 힙 (객체 생성 시 할당)\n- static 변수: 데이터 영역 (프로그램 시작 시 할당)\n\n**vs 지역 변수:**\n- 지역 변수: 스택 (함수 호출 시 할당)\n- static 변수: 데이터 영역 (계속 유지)\n\n---\n\n**2. 초기화:**\n\n**컴파일 타임:**\n- static 변수의 초기값이 컴파일 시 결정됨\n- 상수 표현식만 가능\n\n**런타임:**\n\n**Java:**\n- 클래스 로딩 시 static 변수 초기화\n- static 블록 실행\n- 클래스가 처음 사용될 때 (lazy)\n\n**C/C++:**\n- 프로그램 시작 시 초기화\n- main() 실행 전\n\n**순서:**\n- 선언 순서대로 초기화\n- static 블록 순서대로 실행\n\n---\n\n**3. 링크:**\n\n**C/C++에서:**\n\n**External Linkage (기본):**\n- 다른 파일에서 접근 가능\n- extern 키워드로 선언\n\n**Internal Linkage (static):**\n- 파일 내부로 제한\n- 다른 파일에서 접근 불가\n- 이름 충돌 방지\n\n**컴파일러 처리:**\n- static 함수/변수는 심볼 테이블에 파일 스코프로 표시\n- 링커가 외부 참조 허용 안 함\n\n---\n\n**4. 메서드 바인딩:**\n\n**Java:**\n\n**Static 메서드:**\n- **정적 바인딩 (Static Binding)**\n- 컴파일 타임에 호출 대상 결정\n- 오버라이딩 불가\n- vtable 사용 안 함\n\n**인스턴스 메서드:**\n- **동적 바인딩 (Dynamic Binding)**\n- 런타임에 호출 대상 결정 (다형성)\n- 오버라이딩 가능\n- vtable 사용\n\n**성능:**\n- static 메서드가 약간 더 빠름 (동적 디스패치 없음)\n- 실제로는 미미한 차이\n\n---\n\n**5. 메모리 레이아웃:**\n\n**프로그램 메모리 구조:**\n\n```\n+------------------+\n| Code (Text)      | ← 실행 코드\n+------------------+\n| Data             | ← 초기화된 static 변수\n+------------------+\n| BSS              | ← 초기화 안 된 static 변수\n+------------------+\n| Heap             | ← 동적 할당 (new)\n+------------------+\n| Stack            | ← 지역 변수, 함수 호출\n+------------------+\n```\n\n**static 변수:**\n- Data 또는 BSS 영역\n- 주소 고정 (컴파일 시 결정 가능)\n\n**인스턴스 변수:**\n- Heap 영역\n- 주소 런타임에 결정\n\n---\n\n**6. 컴파일러 최적화:**\n\n**인라이닝:**\n- static 함수는 인라이닝 후보\n- 파일 내부로 제한되므로 안전하게 인라인 가능\n\n**상수 전파:**\n- static final (Java) 또는 const static (C++)는 컴파일 시 값 대체\n\n**Dead Code Elimination:**\n- 사용되지 않는 static 함수 제거\n\n---\n\n**7. 클래스 로딩 (Java):**\n\n**단계:**\n\n**1. Loading:**\n- .class 파일을 메모리에 로드\n\n**2. Linking:**\n- Verification: 바이트코드 검증\n- Preparation: static 변수 메모리 할당 및 기본값 초기화\n- Resolution: 심볼릭 참조를 실제 메모리 주소로\n\n**3. Initialization:**\n- static 변수 초기화 (명시적 값)\n- static 블록 실행\n\n**시점:**\n- 클래스가 처음 사용될 때\n- 인스턴스 생성, static 멤버 접근, main() 포함 클래스 등\n\n**한 번만:**\n- 클래스 로딩은 JVM에서 한 번만\n- static 초기화도 한 번만\n\n---\n\n**8. ABI (Application Binary Interface):**\n\n**C/C++:**\n- static 함수는 외부 심볼 테이블에 노출 안 됨\n- 바이너리 크기 감소\n- 이름 충돌 방지\n\n---\n\n**9. 재배치 (Relocation):**\n\n**컴파일 시:**\n- static 변수 주소는 상대 주소\n\n**링크 시:**\n- 실제 메모리 주소로 재배치\n- 고정 주소\n\n---\n\n**10. 스레드 안전성:**\n\n**초기화:**\n- Java는 클래스 로딩 시 스레드 안전하게 초기화\n- JVM이 동기화 보장\n\n**사용:**\n- static 변수 접근은 동기화 안 됨\n- 멀티스레딩 시 명시적 동기화 필요\n\n---\n\n**성능 영향:**\n\n**메모리:**\n- 인스턴스 변수보다 메모리 효율적 (한 번만 할당)\n- 하지만 프로그램 전체 수명 동안 유지 (해제 안 됨)\n\n**접근 속도:**\n- 고정 주소 → 빠른 접근\n- 인스턴스 변수는 포인터 역참조 필요\n\n**메서드 호출:**\n- static 메서드는 정적 바인딩 → 약간 빠름\n- 실제로는 미미한 차이\n\n---\n\n**컴파일러별 차이:**\n\n**GCC (C/C++):**\n- static 함수는 .o 파일 내부 심볼\n- nm 명령으로 't' (로컬 텍스트) 표시\n\n**Java Compiler (javac):**\n- static 멤버는 바이트코드에서 ACC_STATIC 플래그\n- invokestatic 명령으로 호출\n\n---\n\n**결론:**\n\nstatic 변수는 컴파일 시 데이터/BSS 영역에 할당되고, 프로그램 시작 시 초기화됩니다. static 함수는 정적 바인딩으로 컴파일 타임에 호출 대상이 결정되며, 파일 스코프로 제한될 수 있습니다. 메모리 효율적이지만 프로그램 전체 수명 동안 유지됩니다.",
      "type": "essay",
      "tags": [
        "static",
        "컴파일",
        "메모리",
        "링크"
      ],
      "id": "etc-007",
      "createdAt": "2025-11-17T15:00:00.000006",
      "studyCount": 0
    },
    {
      "question": "Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요?",
      "answer": "**키워드별 차이:**\n\n---\n\n**1. static:**\n\n**의미:**\n- 클래스 레벨 변수\n- 모든 인스턴스가 공유\n- 변경 가능\n\n**특징:**\n- 값 수정 가능\n- 인스턴스와 무관\n- 메모리에 한 번만 할당\n\n**사용:**\n- 공유 데이터\n- 카운터\n\n---\n\n**2. static final:**\n\n**의미:**\n- 클래스 레벨 상수\n- 모든 인스턴스가 공유\n- **변경 불가**\n\n**특징:**\n- 선언 시 또는 static 블록에서 초기화\n- 재할당 불가\n- 컴파일 타임 상수 (원시 타입/String)\n\n**사용:**\n- 상수 (PI, MAX_VALUE)\n- 설정값\n\n---\n\n**3. final:**\n\n**의미:**\n- 인스턴스 레벨 상수\n- 인스턴스마다 값이 다를 수 있음\n- **변경 불가**\n\n**특징:**\n- 생성자에서 초기화\n- 인스턴스마다 별도 메모리\n- 재할당 불가\n\n**사용:**\n- 불변 객체의 필드\n- 생성 시 결정되는 값\n\n---\n\n**비교표:**\n\n| 특성 | static | static final | final |\n|------|--------|--------------|-------|\n| **수준** | 클래스 | 클래스 | 인스턴스 |\n| **공유** | 모든 인스턴스 | 모든 인스턴스 | 개별 인스턴스 |\n| **변경** | 가능 | 불가 | 불가 |\n| **메모리** | 한 번 할당 | 한 번 할당 | 인스턴스마다 |\n| **초기화** | 선언 시/static 블록 | 선언 시/static 블록 | 선언 시/생성자 |\n| **컴파일 상수** | X | O (원시/String) | X |\n\n---\n\n**static vs static final:**\n\n**공통점:**\n- 클래스 레벨\n- 모든 인스턴스 공유\n- 메모리 한 번 할당\n\n**차이점:**\n\n**static:**\n- 값 변경 가능\n- 가변 공유 상태\n\n**static final:**\n- 값 변경 불가\n- 상수\n\n**언제 사용:**\n\n**static:**\n- 공유 카운터\n- 싱글톤 인스턴스\n\n**static final:**\n- 상수 (Math.PI)\n- 설정값\n- 열거형 대안\n\n---\n\n**final vs static final:**\n\n**공통점:**\n- 값 변경 불가 (재할당 불가)\n\n**차이점:**\n\n**final:**\n- 인스턴스마다 별도 값\n- 생성자에서 초기화 가능\n- 인스턴스마다 메모리 할당\n\n**static final:**\n- 모든 인스턴스 같은 값\n- 선언 시 또는 static 블록에서만 초기화\n- 메모리 한 번만 할당\n\n**언제 사용:**\n\n**final:**\n- 생성 시 결정되는 불변 값\n- 인스턴스별로 다를 수 있음\n\n**static final:**\n- 모든 인스턴스에 동일한 상수\n- 컴파일 타임 상수\n\n---\n\n**컴파일 타임 상수:**\n\n**static final (원시 타입/String):**\n- 컴파일러가 값을 코드에 직접 삽입\n- 성능 최적화\n- 클래스 로딩 없이 사용 가능\n\n**final (인스턴스):**\n- 런타임에 값 결정\n- 컴파일 타임 상수 아님\n\n---\n\n**메모리 효율:**\n\n**static final:**\n- 한 번만 할당\n- 모든 인스턴스가 참조\n- 메모리 효율적\n\n**final:**\n- 인스턴스마다 할당\n- 메모리 더 사용\n\n**예:**\n- 100개 인스턴스\n- static final: 1개 메모리\n- final: 100개 메모리\n\n---\n\n**초기화 시점:**\n\n**static:**\n- 클래스 로딩 시\n- static 블록에서도 가능\n- 여러 번 변경 가능\n\n**static final:**\n- 클래스 로딩 시 한 번만\n- 선언 시 또는 static 블록\n- 이후 변경 불가\n\n**final:**\n- 인스턴스 생성 시\n- 선언 시 또는 생성자\n- 이후 변경 불가\n\n---\n\n**참조 타입에서의 차이:**\n\n**주의:**\n- final은 재할당만 방지\n- 객체 내부 상태는 변경 가능\n\n**static final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**final:**\n- 참조 재할당 불가\n- 객체 내부는 변경 가능\n\n**진짜 불변:**\n- 참조를 final로\n- 객체도 불변으로 설계 (모든 필드 final, setter 없음)\n\n---\n\n**사용 패턴:**\n\n**static final 상수:**\n- public static final double PI = 3.14159;\n- public static final int MAX_USERS = 1000;\n\n**static 싱글톤:**\n- private static instance;\n- public static getInstance()\n\n**final 불변 필드:**\n- private final String id;\n- 생성자에서 초기화\n\n---\n\n**성능:**\n\n**static final 상수:**\n- 컴파일 타임 인라인\n- 가장 빠름\n\n**static:**\n- 고정 주소\n- 빠른 접근\n\n**final:**\n- 인스턴스 필드 접근\n- 약간 느림 (포인터 역참조)\n\n---\n\n**Thread Safety:**\n\n**static:**\n- 공유 상태 → 동기화 필요\n\n**static final (불변 객체):**\n- 스레드 안전 (값 변경 안 됨)\n\n**final:**\n- 객체가 불변이면 스레드 안전\n- 가변 객체면 동기화 필요\n\n---\n\n**Best Practices:**\n\n**1. 상수는 static final:**\n- public static final로 선언\n- 대문자 + 언더스코어 (UPPER_CASE)\n\n**2. 가변 공유 상태는 주의:**\n- static 변수는 최소화\n- 동기화 고려\n\n**3. 불변 객체는 final:**\n- 모든 필드 final\n- setter 없음\n- 방어적 복사\n\n**4. 싱글톤은 static:**\n- private static instance\n- enum 싱글톤 권장\n\n---\n\n**결론:**\n\n- **static**: 클래스 레벨 가변 변수\n- **static final**: 클래스 레벨 상수 (컴파일 타임 상수 가능)\n- **final**: 인스턴스 레벨 상수 (생성 시 결정)\n\n용도에 맞게 선택하되, 상수는 static final, 불변 필드는 final, 공유 가변 상태는 신중히 사용하세요.",
      "type": "essay",
      "tags": [
        "Java",
        "static",
        "final",
        "상수"
      ],
      "id": "etc-008",
      "createdAt": "2025-11-17T15:00:00.000007",
      "studyCount": 0
    },
    {
      "question": "객체지향 프로그래밍이 무엇인가요?",
      "answer": "**객체지향 프로그래밍 (OOP: Object-Oriented Programming):**\n\n**정의:**\n- 프로그램을 **객체(Object)**들의 모음으로 구성하는 프로그래밍 패러다임\n- 객체는 데이터(속성)와 행동(메서드)을 하나로 묶은 단위\n- 현실 세계의 개념을 모델링\n\n---\n\n**핵심 개념:**\n\n**1. 객체 (Object):**\n- 데이터와 기능을 함께 캡슐화한 단위\n- 상태(속성)와 행동(메서드) 포함\n\n**2. 클래스 (Class):**\n- 객체를 생성하기 위한 설계도/템플릿\n- 공통 속성과 메서드 정의\n\n**3. 인스턴스 (Instance):**\n- 클래스로부터 생성된 실제 객체\n\n---\n\n**OOP의 4대 특징:**\n\n**1. 캡슐화 (Encapsulation):**\n\n**개념:**\n- 데이터와 메서드를 하나로 묶음\n- 내부 구현을 숨기고 인터페이스만 노출\n\n**목적:**\n- 정보 은닉\n- 무결성 보호\n- 변경 영향 최소화\n\n**구현:**\n- private 필드\n- public getter/setter\n- 직접 접근 차단\n\n---\n\n**2. 상속 (Inheritance):**\n\n**개념:**\n- 기존 클래스의 속성과 메서드를 물려받음\n- 코드 재사용\n\n**장점:**\n- 중복 코드 감소\n- 계층 구조 표현\n- 확장 용이\n\n**주의:**\n- 과도한 상속은 복잡도 증가\n- 구성(Composition) 우선 고려\n\n---\n\n**3. 다형성 (Polymorphism):**\n\n**개념:**\n- 같은 인터페이스로 다른 동작\n- 하나의 타입으로 여러 객체 다룸\n\n**종류:**\n- 오버로딩 (컴파일 타임)\n- 오버라이딩 (런타임)\n\n**장점:**\n- 유연성\n- 확장성\n- 코드 간결\n\n---\n\n**4. 추상화 (Abstraction):**\n\n**개념:**\n- 복잡한 세부사항 숨김\n- 핵심 개념만 표현\n\n**구현:**\n- 추상 클래스\n- 인터페이스\n\n**목적:**\n- 복잡도 관리\n- 공통 기능 정의\n- 구현 분리\n\n---\n\n**장점:**\n\n**1. 코드 재사용:**\n- 상속, 다형성으로 중복 감소\n\n**2. 유지보수:**\n- 캡슐화로 변경 영향 최소화\n- 모듈화\n\n**3. 확장성:**\n- 새로운 클래스 추가 용이\n- 기존 코드 수정 최소\n\n**4. 모델링:**\n- 현실 세계 직관적 표현\n- 이해하기 쉬움\n\n**5. 협업:**\n- 명확한 인터페이스\n- 역할 분담\n\n---\n\n**단점:**\n\n**1. 복잡도:**\n- 작은 프로그램에는 과도\n- 학습 곡선\n\n**2. 성능:**\n- 간접 호출 (vtable)\n- 메모리 오버헤드\n\n**3. 설계:**\n- 초기 설계 중요\n- 잘못된 설계는 오히려 복잡\n\n---\n\n**vs 절차적 프로그래밍:**\n\n| 항목 | 절차적 | 객체지향 |\n|------|--------|----------|\n| 중심 | 함수 | 객체 |\n| 데이터 | 전역/지역 변수 | 객체 내부 캡슐화 |\n| 재사용 | 함수 재사용 | 상속, 다형성 |\n| 확장 | 어려움 | 용이 |\n| 복잡도 | 낮음 (작은 프로그램) | 높음 (큰 프로그램에 유리) |\n\n---\n\n**vs 함수형 프로그래밍:**\n\n| 항목 | 객체지향 | 함수형 |\n|------|----------|--------|\n| 상태 | 객체 내부 상태 | 불변 |\n| 부수효과 | 허용 | 최소화 |\n| 데이터 | 캡슐화 | 변환 |\n| 재사용 | 상속, 다형성 | 고차 함수, 합성 |\n\n---\n\n**설계 원칙:**\n\n**SOLID:**\n- 단일 책임 원칙\n- 개방-폐쇄 원칙\n- 리스코프 치환 원칙\n- 인터페이스 분리 원칙\n- 의존관계 역전 원칙\n\n**DRY (Don't Repeat Yourself):**\n- 중복 제거\n\n**KISS (Keep It Simple, Stupid):**\n- 단순하게\n\n**YAGNI (You Aren't Gonna Need It):**\n- 필요한 것만 구현\n\n---\n\n**적용 시나리오:**\n\n**적합:**\n- 대규모 프로젝트\n- 복잡한 도메인\n- 팀 협업\n- 장기 유지보수\n- GUI 애플리케이션\n\n**부적합:**\n- 간단한 스크립트\n- 성능 크리티컬\n- 함수형 패러다임 더 적합한 경우\n\n---\n\n**주요 언어:**\n\n**순수 OOP:**\n- Java, C#, Smalltalk\n\n**멀티 패러다임:**\n- Python, C++, JavaScript, Kotlin\n\n---\n\n**결론:**\n\n객체지향 프로그래밍은 **캡슐화, 상속, 다형성, 추상화**를 통해 현실 세계를 모델링하고 코드 재사용과 유지보수성을 향상시키는 패러다임입니다. 대규모 프로젝트와 팀 협업에 유리하지만, 적절한 설계가 중요합니다.",
      "type": "essay",
      "tags": [
        "OOP",
        "객체지향",
        "캡슐화",
        "상속",
        "다형성"
      ],
      "id": "etc-009",
      "createdAt": "2025-11-17T15:00:00.000008",
      "studyCount": 0
    },
    {
      "question": "SOLID 원칙에 대해 설명해 주세요.",
      "answer": "**SOLID 원칙:**\n\n객체지향 설계의 5가지 기본 원칙으로, 유지보수와 확장이 쉬운 소프트웨어를 만들기 위한 가이드라인입니다.\n\n---\n\n**1. SRP (Single Responsibility Principle) - 단일 책임 원칙:**\n\n**정의:**\n- 클래스는 하나의 책임만 가져야 함\n- 변경 이유가 하나여야 함\n\n**의미:**\n- 한 클래스는 한 가지 일만\n- 여러 기능을 하나에 넣지 않음\n\n**위반 예:**\n- User 클래스가 DB 저장, 이메일 전송, 로깅 모두 수행\n\n**준수:**\n- User 클래스: 사용자 데이터만\n- UserRepository: DB 저장\n- EmailService: 이메일 전송\n- Logger: 로깅\n\n**장점:**\n- 변경 영향 최소화\n- 테스트 용이\n- 이해하기 쉬움\n\n---\n\n**2. OCP (Open-Closed Principle) - 개방-폐쇄 원칙:**\n\n**정의:**\n- 확장에는 열려 있고, 수정에는 닫혀 있어야 함\n- 기존 코드 수정 없이 기능 추가\n\n**의미:**\n- 새 기능 추가 시 기존 코드 변경 최소화\n- 인터페이스, 추상 클래스 활용\n\n**위반 예:**\n- 결제 방법 추가할 때마다 결제 클래스 수정\n\n**준수:**\n- Payment 인터페이스 정의\n- CreditCardPayment, PayPalPayment 구현\n- 새 결제 방법은 새 클래스 추가만\n\n**구현:**\n- 인터페이스/추상 클래스\n- 전략 패턴\n- 템플릿 메서드 패턴\n\n**장점:**\n- 기존 코드 안정성\n- 확장 용이\n\n---\n\n**3. LSP (Liskov Substitution Principle) - 리스코프 치환 원칙:**\n\n**정의:**\n- 서브타입은 기반타입으로 교체 가능해야 함\n- 부모 클래스 대신 자식 클래스 사용해도 문제없어야 함\n\n**의미:**\n- 상속 시 부모의 동작을 완전히 대체\n- 자식이 부모의 계약 위반하면 안 됨\n\n**위반 예:**\n- Rectangle (직사각형) → Square (정사각형) 상속\n- Square는 width와 height가 같아야 함\n- setWidth 호출 시 예상과 다르게 동작\n\n**준수:**\n- 올바른 추상화\n- is-a 관계 재검토\n- 계약(contract) 준수\n\n**장점:**\n- 다형성 안전\n- 예측 가능\n\n---\n\n**4. ISP (Interface Segregation Principle) - 인터페이스 분리 원칙:**\n\n**정의:**\n- 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함\n- 인터페이스를 작고 구체적으로\n\n**의미:**\n- 큰 인터페이스를 여러 작은 인터페이스로 분리\n- 필요한 것만 구현\n\n**위반 예:**\n- Printer 인터페이스: print, scan, fax\n- 단순 프린터는 scan, fax 불필요\n\n**준수:**\n- Printable 인터페이스: print\n- Scannable 인터페이스: scan\n- Faxable 인터페이스: fax\n- 필요한 인터페이스만 구현\n\n**장점:**\n- 불필요한 의존성 제거\n- 인터페이스 명확\n- 변경 영향 최소\n\n---\n\n**5. DIP (Dependency Inversion Principle) - 의존관계 역전 원칙:**\n\n**정의:**\n- 고수준 모듈은 저수준 모듈에 의존하지 않아야 함\n- 둘 다 추상화에 의존\n\n**의미:**\n- 구체 클래스가 아닌 인터페이스에 의존\n- 의존성 주입 (Dependency Injection)\n\n**위반 예:**\n- UserService가 MySQLUserRepository에 직접 의존\n\n**준수:**\n- UserService가 UserRepository 인터페이스에 의존\n- MySQLUserRepository, MongoUserRepository 모두 구현 가능\n- 의존성 주입으로 구현체 전달\n\n**장점:**\n- 결합도 낮춤\n- 테스트 용이 (Mock 가능)\n- 유연성\n\n---\n\n**SOLID 종합 효과:**\n\n**1. 유지보수성:**\n- 변경 영향 최소화\n- 이해하기 쉬움\n\n**2. 확장성:**\n- 새 기능 추가 용이\n- 기존 코드 수정 최소\n\n**3. 테스트:**\n- 단위 테스트 작성 쉬움\n- Mock 가능\n\n**4. 재사용:**\n- 모듈화\n- 다른 프로젝트에 재사용\n\n**5. 유연성:**\n- 요구사항 변경에 대응\n\n---\n\n**적용 가이드:**\n\n**균형:**\n- 모든 원칙을 항상 완벽히 지킬 필요 없음\n- 과도한 추상화는 복잡도 증가\n- 실용성과 원칙의 균형\n\n**점진적:**\n- 처음부터 완벽한 설계 어려움\n- 리팩토링으로 점진적 개선\n\n**상황 판단:**\n- 프로젝트 규모와 복잡도 고려\n- 작은 프로젝트는 간단하게\n\n---\n\n**실전 적용:**\n\n**의존성 주입:**\n- DIP 구현\n- Spring, Dagger 등 프레임워크 활용\n\n**인터페이스 설계:**\n- ISP 고려\n- 작고 명확한 인터페이스\n\n**리팩토링:**\n- 코드 스멜 발견 시 SOLID 검토\n- 지속적 개선\n\n---\n\n**결론:**\n\nSOLID 원칙은 **단일 책임, 개방-폐쇄, 리스코프 치환, 인터페이스 분리, 의존관계 역전**으로, 유지보수와 확장이 쉬운 객체지향 설계를 위한 핵심 가이드라인입니다. 실용성과 균형을 유지하며 적용하세요.",
      "type": "essay",
      "tags": [
        "SOLID",
        "설계원칙",
        "OOP",
        "SRP",
        "OCP",
        "LSP",
        "ISP",
        "DIP"
      ],
      "id": "etc-010",
      "createdAt": "2025-11-17T15:00:00.000009",
      "studyCount": 0
    },
    {
      "question": "다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.",
      "answer": "**다형성 (Polymorphism):**\n\n**정의:**\n- \"여러 형태\" (poly: 여러, morph: 형태)\n- 같은 인터페이스로 다른 동작을 수행\n- 하나의 타입으로 여러 객체를 다룸\n\n**핵심:**\n- 동일한 메서드 호출이 객체에 따라 다르게 동작\n\n---\n\n**정적 다형성 (Static/Compile-time Polymorphism):**\n\n**정의:**\n- 컴파일 타임에 결정\n- 컴파일러가 어떤 메서드 호출할지 결정\n\n**구현 방법:**\n\n**1. 오버로딩 (Overloading):**\n\n**메서드 오버로딩:**\n- 같은 이름, 다른 파라미터\n- 컴파일러가 파라미터로 구분\n\n**특징:**\n- 같은 클래스 내\n- 파라미터 타입/개수/순서 다름\n- 리턴 타입만 다른 것은 안 됨\n\n**연산자 오버로딩 (C++):**\n- 연산자 동작 재정의\n- Java는 미지원\n\n**2. 템플릿/제네릭:**\n- 타입을 파라미터로\n- 컴파일 시 타입 결정\n\n**장점:**\n- 빠름 (런타임 오버헤드 없음)\n- 타입 안전\n\n**단점:**\n- 유연성 부족\n- 컴파일 시 결정되어 변경 불가\n\n---\n\n**동적 다형성 (Dynamic/Runtime Polymorphism):**\n\n**정의:**\n- 런타임에 결정\n- 실제 객체 타입에 따라 메서드 결정\n\n**구현 방법:**\n\n**1. 오버라이딩 (Overriding):**\n\n**메서드 오버라이딩:**\n- 부모 클래스 메서드를 자식이 재정의\n- 같은 시그니처\n\n**특징:**\n- 상속 관계\n- 메서드 이름, 파라미터, 리턴 타입 동일\n- @Override 어노테이션 (Java)\n\n**2. 인터페이스 구현:**\n- 인터페이스 메서드 구현\n- 여러 구현체\n\n**메커니즘:**\n\n**가상 함수 테이블 (vtable):**\n- 각 클래스가 가상 함수 포인터 테이블 보유\n- 런타임에 vtable 참조하여 실제 메서드 호출\n- 약간의 성능 오버헤드\n\n**장점:**\n- 유연성 (런타임 결정)\n- 확장성 (새 클래스 추가)\n- 다형성의 진정한 힘\n\n**단점:**\n- 런타임 오버헤드 (vtable 참조)\n- 약간 느림\n\n---\n\n**비교:**\n\n| 항목 | 정적 다형성 | 동적 다형성 |\n|------|-------------|-------------|\n| **결정 시점** | 컴파일 타임 | 런타임 |\n| **구현** | 오버로딩, 템플릿 | 오버라이딩, 인터페이스 |\n| **바인딩** | 정적 바인딩 | 동적 바인딩 |\n| **성능** | 빠름 | 약간 느림 (vtable) |\n| **유연성** | 낮음 | 높음 |\n| **확장** | 컴파일 시 결정 | 런타임 확장 가능 |\n| **예** | print(int), print(String) | Animal.speak() → Dog, Cat |\n\n---\n\n**동적 다형성 예시:**\n\n**시나리오:**\n- Animal 부모 클래스\n- Dog, Cat 자식 클래스\n- speak() 메서드 오버라이딩\n\n**효과:**\n- Animal 타입으로 Dog, Cat 다룸\n- speak() 호출 시 실제 객체에 따라 다르게 동작\n- Dog: \"멍멍\", Cat: \"야옹\"\n\n**장점:**\n- 새 동물 추가 시 Animal 타입으로 다룸\n- 기존 코드 수정 불필요\n- 확장에 열려 있음 (OCP)\n\n---\n\n**정적 다형성 예시:**\n\n**메서드 오버로딩:**\n- print(int x)\n- print(String s)\n- print(double d)\n\n**효과:**\n- 같은 이름 print\n- 파라미터 타입에 따라 다른 메서드 호출\n- 컴파일러가 결정\n\n---\n\n**다형성의 장점:**\n\n**1. 코드 재사용:**\n- 공통 인터페이스로 여러 구현\n\n**2. 확장성:**\n- 새 클래스 추가 용이\n- 기존 코드 수정 최소\n\n**3. 유지보수:**\n- 변경 영향 최소화\n\n**4. 유연성:**\n- 런타임에 동작 변경\n\n**5. 간결함:**\n- 타입별 분기 불필요\n\n---\n\n**다형성 활용 패턴:**\n\n**1. 전략 패턴 (Strategy):**\n- 알고리즘을 인터페이스로\n- 런타임에 전략 교체\n\n**2. 템플릿 메서드 (Template Method):**\n- 골격은 부모가 정의\n- 세부는 자식이 구현\n\n**3. 팩토리 (Factory):**\n- 인터페이스 타입 반환\n- 실제 구현체는 숨김\n\n**4. 의존성 주입 (DI):**\n- 인터페이스에 의존\n- 구현체는 주입\n\n---\n\n**주의사항:**\n\n**1. 오버라이딩 규칙:**\n- 접근 제어자: 더 넓게 또는 같게\n- 예외: 더 좁게 또는 같게\n- 리턴 타입: 공변 반환 타입 가능\n\n**2. final 메서드:**\n- 오버라이딩 불가\n\n**3. static 메서드:**\n- 오버라이딩 불가\n- 정적 바인딩\n\n**4. private 메서드:**\n- 오버라이딩 불가 (접근 불가)\n\n---\n\n**언어별 차이:**\n\n**Java:**\n- 기본적으로 모든 메서드가 가상 (오버라이딩 가능)\n- final로 방지\n\n**C++:**\n- virtual 키워드 명시 필요\n- 명시하지 않으면 정적 바인딩\n\n**Python:**\n- 모든 메서드가 가상\n- 덕 타이핑\n\n---\n\n**결론:**\n\n다형성은 **같은 인터페이스로 다른 동작**을 수행하는 OOP의 핵심입니다. **정적 다형성**(오버로딩, 컴파일 타임)은 빠르고, **동적 다형성**(오버라이딩, 런타임)은 유연합니다. 상황에 맞게 활용하세요.",
      "type": "essay",
      "tags": [
        "다형성",
        "Polymorphism",
        "오버로딩",
        "오버라이딩",
        "OOP"
      ],
      "id": "etc-011",
      "createdAt": "2025-11-17T15:00:00.000010",
      "studyCount": 0
    },
    {
      "question": "오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.",
      "answer": "**오버로딩 (Overloading):**\n\n**정의:**\n- 같은 이름의 메서드를 여러 개 정의\n- 파라미터가 다름 (타입, 개수, 순서)\n\n**조건:**\n- 메서드 이름: 동일\n- 파라미터: 타입, 개수, 순서 중 하나 이상 다름\n- 리턴 타입: 무관 (리턴 타입만 다른 것은 불가)\n- 접근 제어자: 무관\n\n**위치:**\n- 같은 클래스 내\n\n**바인딩:**\n- 정적 바인딩 (컴파일 타임)\n- 컴파일러가 파라미터로 구분\n\n**목적:**\n- 같은 기능을 다양한 파라미터로 제공\n- 편의성\n\n**다형성:**\n- 정적 다형성 (Compile-time Polymorphism)\n\n---\n\n**오버라이딩 (Overriding):**\n\n**정의:**\n- 부모 클래스의 메서드를 자식 클래스에서 재정의\n- 같은 시그니처\n\n**조건:**\n- 메서드 이름: 동일\n- 파라미터: 완전히 동일 (타입, 개수, 순서)\n- 리턴 타입: 동일 (또는 공변 반환 타입)\n- 접근 제어자: 같거나 더 넓게\n- 예외: 같거나 더 좁게\n\n**위치:**\n- 상속 관계 (부모-자식)\n\n**바인딩:**\n- 동적 바인딩 (런타임)\n- 실제 객체 타입으로 결정\n\n**목적:**\n- 부모 메서드 동작을 변경\n- 자식마다 다른 구현\n\n**다형성:**\n- 동적 다형성 (Runtime Polymorphism)\n\n**어노테이션:**\n- @Override (Java, 권장)\n\n---\n\n**비교표:**\n\n| 항목 | 오버로딩 | 오버라이딩 |\n|------|----------|-----------|\n| **정의** | 같은 이름, 다른 파라미터 | 부모 메서드 재정의 |\n| **위치** | 같은 클래스 | 상속 관계 |\n| **파라미터** | 다름 | 동일 |\n| **리턴 타입** | 무관 | 동일 (공변 가능) |\n| **접근 제어자** | 무관 | 같거나 넓게 |\n| **바인딩** | 정적 (컴파일 타임) | 동적 (런타임) |\n| **다형성** | 정적 다형성 | 동적 다형성 |\n| **목적** | 편의성 | 기능 변경 |\n| **키워드** | 없음 | @Override (권장) |\n\n---\n\n**오버로딩 예시:**\n\n**시나리오:**\n- print 메서드를 다양한 타입으로\n\n**구현:**\n- print(int x)\n- print(String s)\n- print(int x, int y)\n\n**효과:**\n- 같은 이름 print\n- 파라미터에 따라 다른 메서드 호출\n- 컴파일러가 자동 선택\n\n**장점:**\n- 일관된 메서드 이름\n- 사용 편의\n\n---\n\n**오버라이딩 예시:**\n\n**시나리오:**\n- Animal 부모 클래스의 speak() 메서드\n- Dog, Cat 자식 클래스에서 재정의\n\n**구현:**\n- Animal: speak() → \"소리\"\n- Dog: speak() → \"멍멍\" (오버라이딩)\n- Cat: speak() → \"야옹\" (오버라이딩)\n\n**효과:**\n- Animal 타입으로 Dog, Cat 다룸\n- speak() 호출 시 실제 객체에 따라 다르게 동작\n- 런타임에 결정\n\n**장점:**\n- 다형성\n- 확장성\n\n---\n\n**주의사항:**\n\n**오버로딩:**\n\n**1. 리턴 타입만 다른 것은 불가:**\n- 오류 발생\n- 파라미터가 달라야 함\n\n**2. 가변 인자 (Varargs):**\n- 가장 낮은 우선순위\n- 정확히 맞는 메서드가 없을 때 선택\n\n**3. 자동 형변환:**\n- 작은 타입 → 큰 타입 자동 변환\n- int → long 가능\n\n---\n\n**오버라이딩:**\n\n**1. 접근 제어자:**\n- 더 좁게 불가\n- protected → public (가능)\n- public → protected (불가)\n\n**2. 예외:**\n- 더 넓은 예외 불가\n- IOException → Exception (불가)\n- Exception → IOException (가능)\n\n**3. 리턴 타입 (공변 반환 타입):**\n- 자식 타입 가능\n- Animal → Dog (가능, Java 5+)\n\n**4. final 메서드:**\n- 오버라이딩 불가\n\n**5. static 메서드:**\n- 오버라이딩 불가 (숨김, Hiding)\n\n**6. private 메서드:**\n- 오버라이딩 불가 (접근 불가)\n\n---\n\n**오버라이딩 규칙 위반:**\n\n**시그니처 다름:**\n- 오버라이딩 아님\n- 별개 메서드 (오버로딩도 아님)\n\n**접근 제어자 좁힘:**\n- 컴파일 에러\n\n**더 넓은 예외:**\n- 컴파일 에러\n\n---\n\n**@Override 어노테이션:**\n\n**역할:**\n- 오버라이딩 의도 명시\n- 컴파일러가 검증\n\n**장점:**\n- 실수 방지 (오타, 시그니처 불일치)\n- 가독성\n\n**권장:**\n- 항상 사용\n\n---\n\n**언어별 차이:**\n\n**Java:**\n- 모든 메서드 기본적으로 가상 (오버라이딩 가능)\n- final로 방지\n\n**C++:**\n- virtual 키워드 명시 필요\n- 명시 안 하면 오버라이딩 안 됨 (숨김)\n\n**Python:**\n- 모든 메서드 가상\n- 별도 키워드 없음\n\n---\n\n**실전 사용:**\n\n**오버로딩:**\n- 생성자 오버로딩 (다양한 초기화 방법)\n- 유틸리티 메서드 (다양한 입력 처리)\n\n**오버라이딩:**\n- 템플릿 메서드 패턴\n- 전략 패턴\n- 다형성 활용\n\n---\n\n**성능:**\n\n**오버로딩:**\n- 정적 바인딩 → 빠름\n- 컴파일 시 결정되어 오버헤드 없음\n\n**오버라이딩:**\n- 동적 바인딩 → 약간 느림\n- vtable 참조 오버헤드 (미미)\n\n---\n\n**결론:**\n\n**오버로딩:**\n- 같은 이름, 다른 파라미터\n- 같은 클래스 내\n- 정적 바인딩\n- 편의성\n\n**오버라이딩:**\n- 부모 메서드 재정의\n- 상속 관계\n- 동적 바인딩\n- 다형성\n\n두 개념은 이름만 비슷하고 완전히 다른 개념입니다.",
      "type": "essay",
      "tags": [
        "오버로딩",
        "오버라이딩",
        "Overloading",
        "Overriding",
        "OOP"
      ],
      "id": "etc-012",
      "createdAt": "2025-11-17T15:00:00.000011",
      "studyCount": 0
    }
  ]
}