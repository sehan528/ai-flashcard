{
  "name": "리액트 (간략버전)",
  "description": "React 핵심 개념을 간결하게 정리한 버전",
  "cards": [
    {
      "question": "React의 핵심 특징 4가지는?",
      "answer": "1. **Virtual DOM** - 빠른 렌더링\n2. **컴포넌트 기반** - 재사용 가능한 UI\n3. **단방향 데이터 흐름** - 예측 가능한 상태 관리\n4. **선언적 프로그래밍** - 명령형 대비 간결",
      "type": "essay",
      "tags": [
        "React"
      ]
    },
    {
      "question": "Virtual DOM의 동작 원리 3단계는?",
      "answer": "1. **변경 감지** - 상태 변화 시 새 Virtual DOM 생성\n2. **Diffing** - 이전 VDOM과 비교\n3. **Reconciliation** - 변경된 부분만 실제 DOM 업데이트",
      "type": "essay",
      "tags": [
        "React",
        "VirtualDOM"
      ]
    },
    {
      "question": "useState의 특징과 주의사항은?",
      "answer": "**특징:**\n- 함수 컴포넌트에서 상태 관리\n- 상태 변경 시 리렌더링\n\n**주의사항:**\n- 비동기 업데이트 (배칭)\n- 이전 state 기반 업데이트는 함수형으로\n- 객체/배열은 불변성 유지 필요",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "useEffect의 dependency array 3가지 케이스는?",
      "answer": "1. **없음** - 매 렌더링마다 실행\n2. **빈 배열 []** - mount 시 1회만\n3. **[dep1, dep2]** - 의존성 변경 시에만",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "useCallback과 useMemo의 차이는?",
      "answer": "- **useCallback**: 함수를 메모이제이션\n- **useMemo**: 값을 메모이제이션\n\n둘 다 의존성 배열 기반으로 재생성 여부 결정",
      "type": "essay",
      "tags": [
        "React",
        "Hooks",
        "최적화"
      ]
    },
    {
      "question": "React.memo의 동작 원리와 사용 시기는?",
      "answer": "**동작:** props가 변경되지 않으면 리렌더링 스킵 (얕은 비교)\n\n**사용 시기:**\n- 무거운 컴포넌트\n- props 변경이 적은 경우\n- Pure 컴포넌트",
      "type": "essay",
      "tags": [
        "React",
        "최적화"
      ]
    },
    {
      "question": "useContext의 장점과 단점은?",
      "answer": "**장점:**\n- Props drilling 해결\n- 전역 상태 공유\n\n**단점:**\n- Context 변경 시 모든 구독 컴포넌트 리렌더링\n- 과도한 사용 시 성능 저하",
      "type": "essay",
      "tags": [
        "React",
        "Context"
      ]
    },
    {
      "question": "useReducer를 사용해야 하는 경우 3가지는?",
      "answer": "1. 복잡한 상태 로직\n2. 다음 state가 이전 state에 의존\n3. 여러 하위 값을 포함하는 객체",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "key prop의 역할과 주의사항은?",
      "answer": "**역할:** React가 어떤 항목이 변경/추가/삭제되었는지 식별\n\n**주의사항:**\n- 고유해야 함\n- 안정적이어야 함 (index 사용 지양)\n- 형제 사이에서만 고유하면 됨",
      "type": "essay",
      "tags": [
        "React",
        "Key"
      ]
    },
    {
      "question": "제어 컴포넌트와 비제어 컴포넌트의 차이는?",
      "answer": "**제어 컴포넌트:**\n- React state로 값 관리\n- onChange로 동기화\n\n**비제어 컴포넌트:**\n- DOM이 직접 값 관리\n- ref로 접근",
      "type": "essay",
      "tags": [
        "React",
        "Form"
      ]
    },
    {
      "question": "useRef의 2가지 주요 사용 용도는?",
      "answer": "1. **DOM 접근** - 직접 DOM 조작 필요 시\n2. **값 저장** - 리렌더링 없이 값 유지 (이전 값 저장 등)",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "Portal의 사용 사례 3가지는?",
      "answer": "1. **Modal** - 부모 DOM 외부 렌더링\n2. **Tooltip/Popup** - z-index 문제 해결\n3. **Overlay** - 전체 화면 위에 렌더링",
      "type": "essay",
      "tags": [
        "React",
        "Portal"
      ]
    },
    {
      "question": "Error Boundary의 제약사항 3가지는?",
      "answer": "1. 이벤트 핸들러 에러는 잡지 못함\n2. 비동기 코드 에러는 잡지 못함\n3. 자기 자신의 에러는 잡지 못함",
      "type": "essay",
      "tags": [
        "React",
        "ErrorBoundary"
      ]
    },
    {
      "question": "React 18의 주요 변경사항 3가지는?",
      "answer": "1. **Automatic Batching** - 모든 업데이트 자동 배칭\n2. **Transitions** - 긴급/비긴급 업데이트 구분\n3. **Suspense 개선** - SSR 지원 강화",
      "type": "essay",
      "tags": [
        "React",
        "React18"
      ]
    },
    {
      "question": "useTransition과 useDeferredValue의 차이는?",
      "answer": "**useTransition:**\n- 상태 업데이트를 지연\n- isPending 제공\n\n**useDeferredValue:**\n- 값 자체를 지연\n- prop 지연에 적합",
      "type": "essay",
      "tags": [
        "React",
        "React18"
      ]
    },
    {
      "question": "Props vs State의 차이는?",
      "answer": "**Props:**\n- 부모가 전달\n- 읽기 전용\n- 불변\n\n**State:**\n- 컴포넌트가 소유\n- 변경 가능\n- setState로 업데이트",
      "type": "essay",
      "tags": [
        "React"
      ]
    },
    {
      "question": "제어 컴포넌트의 장점 3가지는?",
      "answer": "1. **실시간 유효성 검사**\n2. **조건부 버튼 활성화**\n3. **입력 형식 강제**",
      "type": "essay",
      "tags": [
        "React",
        "Form"
      ]
    },
    {
      "question": "useState의 함수형 업데이트는 언제 사용하나요?",
      "answer": "**이전 state 기반 업데이트 시:**\n```js\nsetCount(prev => prev + 1)\n```\n\n**이유:** 최신 state 보장, 배칭 시에도 정확",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "useEffect의 cleanup 함수는 언제 실행되나요?",
      "answer": "**실행 시점:**\n1. 컴포넌트 언마운트 시\n2. 다음 effect 실행 전\n\n**용도:** 구독 해제, 타이머 정리 등",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "useLayoutEffect vs useEffect의 차이는?",
      "answer": "**useLayoutEffect:**\n- DOM 업데이트 직후 동기 실행\n- 화면 렌더링 전\n- DOM 측정 시 사용\n\n**useEffect:**\n- 화면 렌더링 후 비동기 실행\n- 대부분의 경우 사용",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "Custom Hook 작성 규칙 3가지는?",
      "answer": "1. **use로 시작** - useCustom\n2. **Hook 규칙 준수** - 조건문 안 X\n3. **재사용 로직 추출**",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "useMemo의 적절한 사용 시기는?",
      "answer": "**사용:**\n- 계산 비용이 큰 연산\n- 참조 동일성 필요 시\n- 자식 컴포넌트 props\n\n**미사용:**\n- 간단한 계산\n- 모든 값에 남용",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "useCallback의 의존성 배열 관리 팁은?",
      "answer": "**팁:**\n1. 필요한 의존성만 포함\n2. 함수 내부에서만 사용되는 값은 제외\n3. ESLint exhaustive-deps 규칙 활용\n4. useRef로 최신 값 참조 (고급)",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "React.memo의 두 번째 인자는 언제 사용하나요?",
      "answer": "**사용:** 커스텀 비교 함수\n\n```js\nReact.memo(Component, (prevProps, nextProps) => {\n  return prevProps.id === nextProps.id;\n});\n```\n\ntrue 반환 시 리렌더링 스킵",
      "type": "essay",
      "tags": [
        "React",
        "Optimization"
      ]
    },
    {
      "question": "PureComponent vs React.memo의 차이는?",
      "answer": "**PureComponent:**\n- 클래스 컴포넌트용\n- props와 state 얕은 비교\n\n**React.memo:**\n- 함수 컴포넌트용\n- props만 비교",
      "type": "essay",
      "tags": [
        "React",
        "Optimization"
      ]
    },
    {
      "question": "shouldComponentUpdate vs React.memo의 차이는?",
      "answer": "**shouldComponentUpdate:**\n- 클래스 컴포넌트 라이프사이클\n- 수동 비교 로직\n\n**React.memo:**\n- 함수 컴포넌트 HOC\n- 자동 얕은 비교",
      "type": "essay",
      "tags": [
        "React",
        "Optimization"
      ]
    },
    {
      "question": "React의 리렌더링 조건 3가지는?",
      "answer": "1. **State 변경**\n2. **Props 변경**\n3. **부모 컴포넌트 리렌더링**\n\n(Context 변경도 포함)",
      "type": "essay",
      "tags": [
        "React"
      ]
    },
    {
      "question": "리렌더링 최적화 방법 5가지는?",
      "answer": "1. **React.memo** - 불필요한 리렌더링 방지\n2. **useCallback** - 함수 재생성 방지\n3. **useMemo** - 값 재계산 방지\n4. **코드 스플리팅** - lazy + Suspense\n5. **가상화** - react-window",
      "type": "essay",
      "tags": [
        "React",
        "Optimization"
      ]
    },
    {
      "question": "Lazy Loading 구현 방법은?",
      "answer": "```js\nconst Component = React.lazy(() => import('./Component'));\n\n<Suspense fallback={<Loading />}>\n  <Component />\n</Suspense>\n```\n\n동적 import + Suspense",
      "type": "essay",
      "tags": [
        "React",
        "Optimization"
      ]
    },
    {
      "question": "Code Splitting의 장점 3가지는?",
      "answer": "1. **초기 로딩 속도** - 필요한 것만 로드\n2. **번들 크기 감소** - 청크 분리\n3. **캐싱 효율** - 변경 없는 청크 재사용",
      "type": "essay",
      "tags": [
        "React",
        "Optimization"
      ]
    },
    {
      "question": "Context API의 단점 2가지는?",
      "answer": "1. **과도한 리렌더링** - Provider 값 변경 시 모든 Consumer 렌더링\n2. **디버깅 어려움** - props drilling보다 추적 복잡\n\n**해결:** 여러 Context 분리, useMemo 활용",
      "type": "essay",
      "tags": [
        "React",
        "Context"
      ]
    },
    {
      "question": "Context 성능 최적화 방법 3가지는?",
      "answer": "1. **Context 분리** - 자주 변경되는 것과 분리\n2. **useMemo로 value 감싸기**\n3. **Provider 위치 최적화**",
      "type": "essay",
      "tags": [
        "React",
        "Context"
      ]
    },
    {
      "question": "useReducer를 선택하는 기준은?",
      "answer": "**useReducer 선택:**\n- 복잡한 상태 로직\n- 다음 state가 이전 state 의존\n- state 업데이트 로직 재사용\n- 여러 하위 값\n\n**useState 선택:**\n- 간단한 상태",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "Reducer 작성 규칙 2가지는?",
      "answer": "1. **순수 함수** - 부수 효과 없음\n2. **불변성 유지** - 새 state 반환\n\n(state, action) => newState",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "useImperativeHandle의 용도는?",
      "answer": "**용도:** 부모에게 노출할 ref 커스터마이징\n\n```js\nuseImperativeHandle(ref, () => ({\n  focus: () => inputRef.current.focus()\n}));\n```\n\nforwardRef와 함께 사용",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "forwardRef의 사용 목적은?",
      "answer": "**목적:** 자식 컴포넌트의 DOM에 접근\n\n```js\nconst Input = forwardRef((props, ref) => (\n  <input ref={ref} {...props} />\n));\n```",
      "type": "essay",
      "tags": [
        "React",
        "Ref"
      ]
    },
    {
      "question": "Controlled vs Uncontrolled Input의 선택 기준은?",
      "answer": "**Controlled (권장):**\n- 실시간 유효성 검사\n- 조건부 활성화\n- 동적 입력 제어\n\n**Uncontrolled:**\n- 간단한 폼\n- 파일 입력",
      "type": "essay",
      "tags": [
        "React",
        "Form"
      ]
    },
    {
      "question": "ref를 사용하는 적절한 경우 3가지는?",
      "answer": "1. **DOM 접근** - focus(), scroll()\n2. **값 저장** - 렌더링 없이 유지\n3. **외부 라이브러리** - 명령형 API 사용",
      "type": "essay",
      "tags": [
        "React",
        "Ref"
      ]
    },
    {
      "question": "Fragment(<>)의 용도는?",
      "answer": "**용도:** 불필요한 div 제거\n\n**장점:**\n- DOM 구조 간결\n- key prop 필요 시 <Fragment>\n\n**사용:** <> </> 또는 <Fragment>",
      "type": "essay",
      "tags": [
        "React"
      ]
    },
    {
      "question": "Portal의 주요 사용 사례 3가지는?",
      "answer": "1. **Modal** - body에 직접 렌더링\n2. **Tooltip/Dropdown** - z-index 문제 해결\n3. **Notification** - 고정 위치",
      "type": "essay",
      "tags": [
        "React",
        "Portal"
      ]
    },
    {
      "question": "StrictMode의 기능 3가지는?",
      "answer": "1. **안전하지 않은 라이프사이클 경고**\n2. **레거시 API 경고**\n3. **예상치 못한 부작용 감지** (이중 렌더링)\n\n개발 모드에서만 동작",
      "type": "essay",
      "tags": [
        "React"
      ]
    },
    {
      "question": "ErrorBoundary가 잡지 못하는 에러 4가지는?",
      "answer": "1. **이벤트 핸들러** - try-catch 사용\n2. **비동기 코드** - Promise, setTimeout\n3. **서버 사이드 렌더링**\n4. **자기 자신의 에러**",
      "type": "essay",
      "tags": [
        "React",
        "Error"
      ]
    },
    {
      "question": "getDerivedStateFromError vs componentDidCatch의 차이는?",
      "answer": "**getDerivedStateFromError:**\n- 렌더링 단계\n- state 업데이트\n- Fallback UI 표시\n\n**componentDidCatch:**\n- 커밋 단계\n- 에러 로깅",
      "type": "essay",
      "tags": [
        "React",
        "Error"
      ]
    },
    {
      "question": "HOC(Higher-Order Component)의 주의사항 3가지는?",
      "answer": "1. **displayName 설정** - 디버깅 용이\n2. **ref 전달 불가** - forwardRef 필요\n3. **static 메서드 복사** - hoistNonReactStatics\n\n현대에는 Hook 선호",
      "type": "essay",
      "tags": [
        "React",
        "HOC"
      ]
    },
    {
      "question": "Render Props 패턴의 장단점은?",
      "answer": "**장점:**\n- 로직 재사용\n- 유연성\n\n**단점:**\n- Wrapper Hell\n- 복잡한 구조\n\n현대에는 Custom Hook 선호",
      "type": "essay",
      "tags": [
        "React",
        "Pattern"
      ]
    },
    {
      "question": "Compound Components 패턴이란?",
      "answer": "**개념:** 서로 협력하는 컴포넌트 그룹\n\n**예:** Select + Option\n\n**장점:**\n- 유연한 구조\n- 암묵적 상태 공유",
      "type": "essay",
      "tags": [
        "React",
        "Pattern"
      ]
    },
    {
      "question": "Container/Presentational 패턴의 차이는?",
      "answer": "**Container:**\n- 로직 담당\n- 상태 관리\n- HOC, Custom Hook\n\n**Presentational:**\n- UI 담당\n- Props 받아 렌더링\n- 재사용 가능",
      "type": "essay",
      "tags": [
        "React",
        "Pattern"
      ]
    },
    {
      "question": "React DevTools의 주요 기능 4가지는?",
      "answer": "1. **컴포넌트 트리** - 구조 확인\n2. **Props/State 조회** - 실시간 값\n3. **Profiler** - 성능 측정\n4. **Highlight Updates** - 리렌더링 시각화",
      "type": "essay",
      "tags": [
        "React",
        "DevTools"
      ]
    },
    {
      "question": "Profiler로 측정하는 항목 3가지는?",
      "answer": "1. **렌더링 시간** - duration\n2. **렌더링 이유** - phase (mount/update)\n3. **커밋 시간** - 실제 DOM 업데이트",
      "type": "essay",
      "tags": [
        "React",
        "Profiler"
      ]
    },
    {
      "question": "SSR의 장점 3가지는?",
      "answer": "1. **SEO** - 검색 엔진 최적화\n2. **초기 로딩 속도** - 서버에서 렌더링\n3. **소셜 미디어 미리보기**",
      "type": "essay",
      "tags": [
        "React",
        "SSR"
      ]
    },
    {
      "question": "CSR vs SSR vs SSG의 차이는?",
      "answer": "**CSR:**\n- 클라이언트 렌더링\n- SPA\n\n**SSR:**\n- 서버 렌더링\n- 요청마다 생성\n\n**SSG:**\n- 빌드 시 생성\n- 정적 파일",
      "type": "essay",
      "tags": [
        "React",
        "Rendering"
      ]
    },
    {
      "question": "Hydration이란?",
      "answer": "**개념:** SSR된 HTML에 JS 연결\n\n**과정:**\n1. 서버에서 HTML 생성\n2. 클라이언트로 전송\n3. React가 이벤트 핸들러 부착\n\nHTML 구조는 유지",
      "type": "essay",
      "tags": [
        "React",
        "SSR"
      ]
    },
    {
      "question": "ConcurrentMode의 특징 3가지는?",
      "answer": "1. **중단 가능한 렌더링** - 우선순위 관리\n2. **Suspense** - 비동기 처리\n3. **자동 배칭** - 성능 향상\n\nReact 18부터 기본",
      "type": "essay",
      "tags": [
        "React",
        "Concurrent"
      ]
    },
    {
      "question": "Suspense의 주요 용도 2가지는?",
      "answer": "1. **Code Splitting** - React.lazy\n2. **Data Fetching** - 비동기 데이터\n\nfallback으로 로딩 UI 표시",
      "type": "essay",
      "tags": [
        "React",
        "Suspense"
      ]
    },
    {
      "question": "React Testing Library의 핵심 원칙은?",
      "answer": "**원칙:** 사용자처럼 테스트\n\n- 구현 세부사항 테스트 X\n- 화면에 보이는 것 테스트\n- getByRole, getByText 등 사용",
      "type": "essay",
      "tags": [
        "React",
        "Test"
      ]
    },
    {
      "question": "Jest의 주요 매처 5가지는?",
      "answer": "1. **toBe** - 일치 (===)\n2. **toEqual** - 깊은 비교\n3. **toBeInTheDocument** - DOM 존재\n4. **toHaveBeenCalled** - 함수 호출 여부\n5. **toMatchSnapshot** - 스냅샷 비교",
      "type": "essay",
      "tags": [
        "React",
        "Test"
      ]
    },
    {
      "question": "Mock vs Stub vs Spy의 차이는?",
      "answer": "**Mock:**\n- 가짜 객체\n- 동작 검증\n\n**Stub:**\n- 미리 정의된 응답\n- 상태 검증\n\n**Spy:**\n- 실제 객체 감시\n- 호출 기록",
      "type": "essay",
      "tags": [
        "React",
        "Test"
      ]
    },
    {
      "question": "Integration Test vs Unit Test의 차이는?",
      "answer": "**Unit Test:**\n- 개별 함수/컴포넌트\n- 격리 테스트\n\n**Integration Test:**\n- 여러 컴포넌트 조합\n- 상호작용 테스트",
      "type": "essay",
      "tags": [
        "React",
        "Test"
      ]
    },
    {
      "question": "렌더링 테스트의 주요 메서드 4가지는?",
      "answer": "1. **render** - 컴포넌트 렌더링\n2. **screen** - 쿼리 접근\n3. **fireEvent** - 이벤트 발생\n4. **waitFor** - 비동기 대기",
      "type": "essay",
      "tags": [
        "React",
        "Test"
      ]
    },
    {
      "question": "Accessibility 테스트 방법 3가지는?",
      "answer": "1. **getByRole** - 역할 기반 쿼리\n2. **getByLabelText** - 레이블 연결\n3. **jest-axe** - a11y 규칙 검증",
      "type": "essay",
      "tags": [
        "React",
        "Test",
        "A11y"
      ]
    },
    {
      "question": "useSyncExternalStore의 용도는?",
      "answer": "**용도:** 외부 스토어 구독\n\n**사용 사례:**\n- Redux, Zustand 등\n- 브라우저 API (localStorage)\n- WebSocket\n\nConcurrent Mode 안전",
      "type": "essay",
      "tags": [
        "React",
        "Hooks"
      ]
    },
    {
      "question": "React 18의 성능 개선 3가지는?",
      "answer": "1. **Automatic Batching** - 불필요한 렌더링 50% 감소\n2. **Transitions** - 인터랙션 응답성 향상\n3. **SSR Streaming** - 초기 로딩 개선",
      "type": "essay",
      "tags": [
        "React",
        "Performance"
      ]
    }
  ]
}