{
  "name": "자료구조",
  "description": "자료구조 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "스택 2개로 큐 만들기",
      "answer": "**두 개의 스택으로 큐를 구현하는 방법:**\n\n스택은 LIFO (Last In First Out), 큐는 FIFO (First In First Out) 구조입니다.\n\n**구현 방법:**\n\n```java\nclass QueueUsingTwoStacks {\n    Stack<Integer> inbox = new Stack<>();   // 입력용\n    Stack<Integer> outbox = new Stack<>();  // 출력용\n    \n    // Enqueue: O(1)\n    public void enqueue(int x) {\n        inbox.push(x);\n    }\n    \n    // Dequeue: Amortized O(1)\n    public int dequeue() {\n        if (outbox.isEmpty()) {\n            // inbox의 모든 원소를 outbox로 이동\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.pop();\n    }\n    \n    public int peek() {\n        if (outbox.isEmpty()) {\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// enqueue(1, 2, 3, 4)\ninbox: [1, 2, 3, 4] (top)\noutbox: []\n\n// dequeue() 호출\ninbox → outbox 이동:\ninbox: []\noutbox: [4, 3, 2, 1] (top)\n\n// dequeue() 반환값: 1 (FIFO)\noutbox: [4, 3, 2]\n```\n\n**시간복잡도:**\n- Enqueue: O(1)\n- Dequeue: Amortized O(1) (최악 O(n), 평균 O(1))\n\n**JavaScript 구현:**\n\n```javascript\nclass QueueUsingStacks {\n    constructor() {\n        this.inbox = [];\n        this.outbox = [];\n    }\n    \n    enqueue(x) {\n        this.inbox.push(x);\n    }\n    \n    dequeue() {\n        if (this.outbox.length === 0) {\n            while (this.inbox.length > 0) {\n                this.outbox.push(this.inbox.pop());\n            }\n        }\n        return this.outbox.pop();\n    }\n}\n```",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "큐 2개로 스택 만들기",
      "answer": "**두 개의 큐로 스택을 구현하는 방법:**\n\n스택은 LIFO, 큐는 FIFO 구조입니다.\n\n**구현 방법 1: Push가 O(n)**\n\n```java\nclass StackUsingTwoQueues {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        // 새 원소를 q2에 추가\n        q2.offer(x);\n        \n        // q1의 모든 원소를 q2로 이동\n        while (!q1.isEmpty()) {\n            q2.offer(q1.poll());\n        }\n        \n        // q1과 q2를 교환\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return q1.poll();\n    }\n    \n    // Top: O(1)\n    public int top() {\n        return q1.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// push(1)\nq1: [1]\nq2: []\n\n// push(2)\nq2: [2] → q1의 원소 이동 → [2, 1]\nq1과 q2 교환\nq1: [2, 1] (front가 top)\n\n// push(3)\nq2: [3] → [3, 2, 1]\nq1: [3, 2, 1]\n\n// pop() → 3 반환\n```\n\n**구현 방법 2: 하나의 큐만 사용 (더 효율적)**\n\n```java\nclass StackUsingOneQueue {\n    Queue<Integer> queue = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        queue.offer(x);\n        int size = queue.size();\n        \n        // 새 원소를 맨 앞으로 이동\n        for (int i = 0; i < size - 1; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return queue.poll();\n    }\n}\n```\n\n**JavaScript 구현:**\n\n```javascript\nclass StackUsingQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    push(x) {\n        this.queue.push(x);\n        // 새 원소를 맨 앞으로 회전\n        for (let i = 0; i < this.queue.length - 1; i++) {\n            this.queue.push(this.queue.shift());\n        }\n    }\n    \n    pop() {\n        return this.queue.shift();\n    }\n}\n```\n\n**시간복잡도:**\n- Push: O(n)\n- Pop: O(1)\n- Top: O(1)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법에 대해 설명해 주세요.",
      "answer": "**표기법 종류:**\n\n1. **Infix (중위 표기법)**: 연산자가 피연산자 사이에 위치\n   - 예: `3 + 4 * 2`\n   - 사람이 읽기 쉽지만 우선순위 처리 복잡\n\n2. **Prefix (전위 표기법)**: 연산자가 피연산자 앞에 위치\n   - 예: `+ 3 * 4 2` → `3 + (4 * 2)`\n   - 괄호 불필요\n\n3. **Postfix (후위 표기법)**: 연산자가 피연산자 뒤에 위치\n   - 예: `3 4 2 * +` → `3 + (4 * 2)`\n   - 스택으로 계산이 가장 쉬움\n\n---\n\n**Postfix 계산 (스택 사용):**\n\n```java\npublic int evaluatePostfix(String expression) {\n    Stack<Integer> stack = new Stack<>();\n    String[] tokens = expression.split(\" \");\n    \n    for (String token : tokens) {\n        if (isOperator(token)) {\n            int b = stack.pop();\n            int a = stack.pop();\n            \n            switch (token) {\n                case \"+\": stack.push(a + b); break;\n                case \"-\": stack.push(a - b); break;\n                case \"*\": stack.push(a * b); break;\n                case \"/\": stack.push(a / b); break;\n            }\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    \n    return stack.pop();\n}\n```\n\n**동작 과정 예시: `3 4 2 * +`**\n\n```\n토큰: 3 → stack: [3]\n토큰: 4 → stack: [3, 4]\n토큰: 2 → stack: [3, 4, 2]\n토큰: * → pop 2, 4 → 4*2=8 → stack: [3, 8]\n토큰: + → pop 8, 3 → 3+8=11 → stack: [11]\n결과: 11\n```\n\n---\n\n**Infix → Postfix 변환 (Shunting Yard Algorithm):**\n\n```java\npublic String infixToPostfix(String infix) {\n    StringBuilder result = new StringBuilder();\n    Stack<Character> stack = new Stack<>();\n    \n    for (char c : infix.toCharArray()) {\n        if (Character.isDigit(c)) {\n            result.append(c).append(' ');\n        } else if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            while (!stack.isEmpty() && stack.peek() != '(') {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.pop(); // '(' 제거\n        } else if (isOperator(c)) {\n            while (!stack.isEmpty() && precedence(stack.peek()) >= precedence(c)) {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.push(c);\n        }\n    }\n    \n    while (!stack.isEmpty()) {\n        result.append(stack.pop()).append(' ');\n    }\n    \n    return result.toString().trim();\n}\n\nprivate int precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n```\n\n**예시: `3 + 4 * 2` → `3 4 2 * +`**\n\n```\n토큰: 3 → result: \"3 \", stack: []\n토큰: + → result: \"3 \", stack: [+]\n토큰: 4 → result: \"3 4 \", stack: [+]\n토큰: * → result: \"3 4 \", stack: [+, *] (우선순위 * > +)\n토큰: 2 → result: \"3 4 2 \", stack: [+, *]\n종료  → result: \"3 4 2 * +\", stack: []\n```\n\n**시간복잡도:** O(n)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Expression", "알고리즘"]
    },
    {
      "question": "(C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?",
      "answer": "**C++ `std::deque`의 내부 구조:**\n\nDeque는 \"Double-Ended Queue\"로, 양쪽 끝에서 삽입/삭제가 O(1)이면서도 Random Access가 O(1)인 자료구조입니다.\n\n**구현 방식: Map of Chunks (청크 배열)**\n\n```\n         Map (중앙 관리 배열)\n         ┌───┬───┬───┬───┬───┐\n         │ 0 │ 1 │ 2 │ 3 │ 4 │\n         └─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘\n           │   │   │   │   │\n           ↓   ↓   ↓   ↓   ↓\n        Chunk1 Chunk2 Chunk3 ... (고정 크기 배열들)\n        [][][]  [][][]  [][][]\n```\n\n**핵심 아이디어:**\n\n1. **Map (중앙 배열)**:\n   - 포인터 배열로, 각 포인터는 고정 크기 청크를 가리킴\n   - 청크 크기는 보통 512 bytes (원소 크기에 따라 다름)\n\n2. **Chunk (데이터 블록)**:\n   - 실제 데이터가 저장되는 고정 크기 배열\n   - 예: `sizeof(T) = 4` bytes → 청크당 128개 원소\n\n**Random Access 계산:**\n\n```cpp\n// index 번째 원소 접근: O(1)\nT& operator[](size_t index) {\n    size_t chunk_index = index / CHUNK_SIZE;  // 어느 청크?\n    size_t offset = index % CHUNK_SIZE;       // 청크 내 위치?\n    \n    return map[chunk_index][offset];\n}\n```\n\n**예시:**\n\n```\nCHUNK_SIZE = 4라고 가정\ndeque에 [0, 1, 2, 3, 4, 5, 6, 7, 8] 저장\n\nMap:      [0]  [1]  [2]\n           ↓    ↓    ↓\nChunk 0: [0 1 2 3]\nChunk 1: [4 5 6 7]\nChunk 2: [8 _ _ _]\n\n// deque[6] 접근\nchunk_index = 6 / 4 = 1\noffset = 6 % 4 = 2\n→ map[1][2] = 6\n```\n\n**양쪽 삽입/삭제가 O(1)인 이유:**\n\n```cpp\n// push_back\nvoid push_back(T value) {\n    if (마지막 청크가 가득 참) {\n        map에 새 청크 포인터 추가;  // Map 재할당 가능 (Amortized O(1))\n    }\n    마지막 청크에 추가;\n}\n\n// push_front\nvoid push_front(T value) {\n    if (첫 청크가 가득 참) {\n        map 앞에 새 청크 포인터 추가;\n    }\n    첫 청크에 추가;\n}\n```\n\n**Vector vs Deque 비교:**\n\n| 연산 | Vector | Deque |\n|------|--------|-------|\n| Random Access | O(1) | O(1) |\n| push_back | Amortized O(1) | Amortized O(1) |\n| push_front | O(n) | Amortized O(1) |\n| 메모리 연속성 | 연속 | 비연속 (청크 단위) |\n| 캐시 효율 | 높음 | 낮음 |\n\n**단점:**\n\n- 청크 간 이동 시 캐시 미스 발생 가능\n- Vector보다 메모리 오버헤드 큼 (Map 관리 비용)\n\n**사용 예시:**\n\n```cpp\nstd::deque<int> dq;\n\n// 양쪽 삽입 O(1)\ndq.push_back(1);   // [1]\ndq.push_front(0);  // [0, 1]\n\n// Random Access O(1)\nint x = dq[0];     // 0\nint y = dq[1];     // 1\n```",
      "type": "essay",
      "tags": ["자료구조", "Deque", "C++", "Random Access"]
    },
    {
      "question": "해시 자료구조에 대해 설명해 주세요.",
      "answer": "**해시 테이블 (Hash Table):**\n\nKey-Value 쌍을 저장하는 자료구조로, **평균 O(1) 시간복잡도**로 삽입, 삭제, 검색이 가능합니다.\n\n**핵심 구성 요소:**\n\n1. **해시 함수 (Hash Function)**\n   - Key → Index 변환\n   - 예: `hash(key) % table_size`\n\n2. **버킷 배열 (Bucket Array)**\n   - 실제 데이터를 저장하는 배열\n\n3. **충돌 해결 방법 (Collision Resolution)**\n   - Chaining: 연결 리스트로 충돌 처리\n   - Open Addressing: 빈 슬롯 찾기\n\n---\n\n**동작 원리:**\n\n```java\nclass HashTable<K, V> {\n    private static class Entry<K, V> {\n        K key;\n        V value;\n        Entry<K, V> next;  // Chaining\n    }\n    \n    private Entry<K, V>[] table;\n    private int size;\n    \n    public HashTable(int capacity) {\n        table = new Entry[capacity];\n    }\n    \n    // 삽입: O(1) 평균\n    public void put(K key, V value) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        // 중복 키 확인\n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                entry.value = value;  // 업데이트\n                return;\n            }\n            entry = entry.next;\n        }\n        \n        // 새 엔트리 추가 (체이닝)\n        Entry<K, V> newEntry = new Entry<>(key, value);\n        newEntry.next = table[index];\n        table[index] = newEntry;\n        size++;\n    }\n    \n    // 검색: O(1) 평균\n    public V get(K key) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                return entry.value;\n            }\n            entry = entry.next;\n        }\n        \n        return null;\n    }\n    \n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % table.length;\n    }\n}\n```\n\n---\n\n**충돌 해결 방법:**\n\n**1. Chaining (체이닝):**\n\n```\nIndex  Bucket\n  0  → [key1, val1] → [key2, val2] → null\n  1  → null\n  2  → [key3, val3] → null\n  3  → [key4, val4] → [key5, val5] → null\n```\n\n**2. Open Addressing (개방 주소법):**\n\n- **Linear Probing**: `(h(k) + i) % m`\n- **Quadratic Probing**: `(h(k) + i²) % m`\n- **Double Hashing**: `(h1(k) + i * h2(k)) % m`\n\n---\n\n**시간복잡도:**\n\n| 연산 | 평균 | 최악 |\n|------|------|------|\n| 삽입 | O(1) | O(n) |\n| 삭제 | O(1) | O(n) |\n| 검색 | O(1) | O(n) |\n\n**최악의 경우**: 모든 키가 같은 인덱스로 해싱 → 연결 리스트처럼 동작\n\n---\n\n**Load Factor (적재율):**\n\n```\nLoad Factor = 저장된 원소 개수 / 테이블 크기\n```\n\n- Java HashMap: Load Factor 0.75 초과 시 리사이징\n- 적재율이 높을수록 충돌 증가 → 성능 저하\n\n**리사이징 (Rehashing):**\n\n```java\nprivate void resize() {\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[oldTable.length * 2];\n    \n    // 모든 엔트리 재배치\n    for (Entry<K, V> entry : oldTable) {\n        while (entry != null) {\n            put(entry.key, entry.value);\n            entry = entry.next;\n        }\n    }\n}\n```\n\n---\n\n**JavaScript 예시:**\n\n```javascript\nconst map = new Map();\nmap.set('name', 'Alice');  // O(1)\nmap.get('name');           // O(1) → 'Alice'\nmap.has('name');           // O(1) → true\nmap.delete('name');        // O(1)\n```\n\n**Java 예시:**\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"apple\", 100);   // O(1)\nint price = map.get(\"apple\");  // O(1)\nmap.containsKey(\"apple\");      // O(1)\n```\n\n**장점:**\n- 빠른 검색, 삽입, 삭제 (평균 O(1))\n- 유연한 키 타입\n\n**단점:**\n- 순서 보장 안 됨 (LinkedHashMap으로 해결)\n- 해시 충돌 가능성\n- 메모리 오버헤드 (빈 공간 존재)",
      "type": "essay",
      "tags": ["자료구조", "Hash Table", "HashMap", "시간복잡도"]
    },
    {
      "question": "값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?",
      "answer": "**좋은 해시 함수의 조건:**\n\n1. **균등 분포 (Uniform Distribution)**\n   - 모든 버킷에 데이터가 고르게 분산\n   - 충돌 최소화\n\n2. **빠른 계산**\n   - O(1) 시간에 해시값 계산\n\n3. **결정적 (Deterministic)**\n   - 같은 입력 → 항상 같은 출력\n\n---\n\n**해시 함수 설계 기법:**\n\n**1. Division Method (나눗셈)**\n\n```java\nint hash(int key, int tableSize) {\n    return key % tableSize;\n}\n```\n\n**주의사항:**\n- 테이블 크기는 **소수(prime number)** 사용 권장\n- 2의 거듭제곱은 피하기 (하위 비트만 사용되어 편향 발생)\n\n**2. Multiplication Method (곱셈)**\n\n```java\nint hash(int key, int tableSize) {\n    double A = (Math.sqrt(5) - 1) / 2;  // 황금비의 역수\n    double fractional = (key * A) % 1;  // 소수 부분만 추출\n    return (int)(tableSize * fractional);\n}\n```\n\n**3. Universal Hashing**\n\n```java\nclass UniversalHash {\n    private int a, b, p, m;\n    \n    public UniversalHash(int tableSize) {\n        this.m = tableSize;\n        this.p = nextPrime(tableSize * 2);  // tableSize보다 큰 소수\n        this.a = random(1, p);  // 랜덤 계수\n        this.b = random(0, p);\n    }\n    \n    int hash(int key) {\n        return ((a * key + b) % p) % m;\n    }\n}\n```\n\n**장점**: 최악의 경우 공격 방지 (랜덤성)\n\n---\n\n**문자열 해시:**\n\n**Polynomial Rolling Hash:**\n\n```java\nint hash(String s, int tableSize) {\n    final int p = 31;  // 소수 (알파벳 크기보다 큰)\n    final int m = 1_000_000_009;  // 큰 소수\n    \n    long hashValue = 0;\n    long pPow = 1;\n    \n    for (char c : s.toCharArray()) {\n        hashValue = (hashValue + (c - 'a' + 1) * pPow) % m;\n        pPow = (pPow * p) % m;\n    }\n    \n    return (int)(hashValue % tableSize);\n}\n```\n\n**예시:**\n```\n\"abc\" 해시값\n= (1 * 31^0 + 2 * 31^1 + 3 * 31^2) % m\n= (1 + 62 + 2883) % m\n```\n\n---\n\n**Java의 String.hashCode():**\n\n```java\npublic int hashCode() {\n    int h = 0;\n    for (char c : value) {\n        h = 31 * h + c;\n    }\n    return h;\n}\n```\n\n**왜 31을 사용?**\n- 소수라서 분포가 좋음\n- `31 * i == (i << 5) - i` (비트 연산으로 최적화 가능)\n\n---\n\n**충돌 최소화 전략:**\n\n**1. 비트 연산 활용:**\n\n```java\nint hash(int key) {\n    key ^= (key >>> 20) ^ (key >>> 12);\n    return key ^ (key >>> 7) ^ (key >>> 4);\n}\n```\n\n**2. MurmurHash (빠르고 품질 좋음):**\n\n```java\nint murmurhash(int key) {\n    key ^= key >>> 16;\n    key *= 0x85ebca6b;\n    key ^= key >>> 13;\n    key *= 0xc2b2ae35;\n    key ^= key >>> 16;\n    return key;\n}\n```\n\n---\n\n**실전 예시:**\n\n```java\n// 나쁜 예: 2의 거듭제곱 테이블 크기\nint badHash(int key) {\n    return key % 1024;  // 하위 10비트만 사용 → 편향\n}\n\n// 좋은 예: 소수 테이블 크기\nint goodHash(int key) {\n    return key % 1009;  // 균등 분포\n}\n```\n\n**테스트:**\n\n```java\n// 해시 함수 품질 테스트\nvoid testHashDistribution(HashFunction h, int[] keys) {\n    int[] buckets = new int[tableSize];\n    \n    for (int key : keys) {\n        buckets[h.hash(key)]++;\n    }\n    \n    // 표준편차 계산 (낮을수록 균등 분포)\n    double stdDev = calculateStdDev(buckets);\n}\n```",
      "type": "essay",
      "tags": ["해시", "해시 함수", "설계", "충돌"]
    },
    {
      "question": "해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?",
      "answer": "**충돌 해결 방법:**\n\n## 1. Chaining (체이닝)\n\n각 버킷을 연결 리스트로 구현하여 같은 인덱스의 원소들을 체인으로 연결\n\n```java\nclass HashTableChaining<K, V> {\n    class Node {\n        K key;\n        V value;\n        Node next;\n    }\n    \n    Node[] table;\n    \n    void put(K key, V value) {\n        int index = hash(key);\n        Node node = table[index];\n        \n        // 기존 키 업데이트\n        while (node != null) {\n            if (node.key.equals(key)) {\n                node.value = value;\n                return;\n            }\n            node = node.next;\n        }\n        \n        // 새 노드 추가 (맨 앞에)\n        Node newNode = new Node(key, value);\n        newNode.next = table[index];\n        table[index] = newNode;\n    }\n}\n```\n\n**장점:**\n- 구현 간단\n- 삭제 쉬움\n- Load Factor > 1 가능\n\n**단점:**\n- 추가 메모리 (포인터)\n- 캐시 효율 낮음\n\n---\n\n## 2. Open Addressing (개방 주소법)\n\n충돌 시 다른 빈 슬롯을 찾아 저장\n\n### 2-1. Linear Probing (선형 조사)\n\n```java\nvoid put(K key, V value) {\n    int index = hash(key);\n    \n    // 빈 슬롯 찾을 때까지\n    while (table[index] != null && !table[index].key.equals(key)) {\n        index = (index + 1) % table.length;\n    }\n    \n    table[index] = new Entry(key, value);\n}\n\nV get(K key) {\n    int index = hash(key);\n    \n    while (table[index] != null) {\n        if (table[index].key.equals(key)) {\n            return table[index].value;\n        }\n        index = (index + 1) % table.length;\n    }\n    \n    return null;\n}\n```\n\n**문제: Primary Clustering (1차 군집화)**\n- 연속된 슬롯들이 채워지면 더 긴 체인 형성\n\n### 2-2. Quadratic Probing (이차 조사)\n\n```java\nint probe(int hash, int i) {\n    return (hash + i * i) % table.length;\n}\n```\n\n**예시:**\n```\ni=0: hash\ni=1: hash + 1\ni=2: hash + 4\ni=3: hash + 9\n```\n\n**문제: Secondary Clustering (2차 군집화)**\n- 같은 해시값을 가진 키들이 같은 조사 순서\n\n### 2-3. Double Hashing (이중 해싱)\n\n```java\nint hash1(K key) {\n    return key.hashCode() % table.length;\n}\n\nint hash2(K key) {\n    return 1 + (key.hashCode() % (table.length - 1));\n}\n\nint probe(K key, int i) {\n    return (hash1(key) + i * hash2(key)) % table.length;\n}\n```\n\n**예시:**\n```\nkey = 10, table.length = 7\nhash1(10) = 3\nhash2(10) = 1 + (10 % 6) = 5\n\ni=0: 3\ni=1: (3 + 5) % 7 = 1\ni=2: (3 + 10) % 7 = 6\ni=3: (3 + 15) % 7 = 4\n```\n\n**장점:**\n- Clustering 문제 해결\n- 좋은 분포\n\n---\n\n## 3. Separate Chaining vs Open Addressing\n\n| 특성 | Chaining | Open Addressing |\n|------|----------|------------------|\n| 메모리 | 포인터 오버헤드 | 고정 크기 테이블 |\n| Load Factor | > 1 가능 | < 1 제한 |\n| 캐시 효율 | 낮음 | 높음 |\n| 삭제 | 쉬움 | 복잡 (Lazy Deletion) |\n| 성능 | 균등 | Load Factor 의존 |\n\n---\n\n**삭제 처리 (Open Addressing):**\n\n```java\nclass Entry<K, V> {\n    K key;\n    V value;\n    boolean deleted;  // Lazy deletion flag\n}\n\nvoid remove(K key) {\n    int index = findIndex(key);\n    if (index != -1) {\n        table[index].deleted = true;  // 삭제 표시\n    }\n}\n\nV get(K key) {\n    int index = hash(key);\n    \n    while (table[index] != null) {\n        if (!table[index].deleted && table[index].key.equals(key)) {\n            return table[index].value;\n        }\n        index = (index + 1) % table.length;\n    }\n    \n    return null;\n}\n```",
      "type": "essay",
      "tags": ["해시", "충돌 해결", "Chaining", "Open Addressing"]
    },
    {
      "question": "본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?",
      "answer": "## Java HashMap\n\n**충돌 처리: Separate Chaining + Tree화**\n\n```java\n// Java 8 이전: 순수 Chaining\nNode<K,V>[] table;\n\nstatic class Node<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;  // 연결 리스트\n}\n\n// Java 8+: Chaining + Red-Black Tree\n// 버킷의 원소가 8개 초과 시 Tree로 변환\n// 6개 이하로 줄면 다시 List로 변환\n```\n\n**왜 Tree로 변환?**\n- 최악의 경우 O(n) → O(log n)으로 개선\n- DoS 공격 방어 (의도적 충돌 공격)\n\n**Load Factor: 0.75**\n```java\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// 75% 차면 2배로 리사이징\nif (size > capacity * loadFactor) {\n    resize();  // capacity *= 2\n}\n```\n\n---\n\n## Python dict\n\n**충돌 처리: Open Addressing (Pseudo-random probing)**\n\n```python\n# CPython 3.6+: 순서 유지 딕셔너리\n# 내부적으로 두 배열 사용:\n# 1. indices: 해시 테이블 (Open Addressing)\n# 2. entries: 실제 키-값 쌍 배열 (삽입 순서대로)\n\nclass dict:\n    indices = [None] * capacity  # 해시 테이블\n    entries = []  # [(hash, key, value), ...]\n```\n\n**Probing 방식:**\n```python\n# Linear probing의 변형\nperturb = hash(key)\nindex = hash(key) % capacity\n\nwhile indices[index] is not None:\n    index = (5*index + 1 + perturb) % capacity\n    perturb >>= 5  # 점점 랜덤하게\n```\n\n**Load Factor: 2/3 (약 0.67)**\n```python\n# 66% 차면 2배로 리사이징\nif used > capacity * 2/3:\n    resize()\n```\n\n---\n\n## JavaScript Map/Object\n\n**Object (레거시):**\n- 구현체마다 다름 (V8, SpiderMonkey 등)\n- 주로 Hash Table + Hidden Class 최적화\n\n**Map (ES6+):**\n```javascript\nconst map = new Map();\nmap.set(key, value);  // O(1)\n\n// V8 엔진: Chaining 방식\n// 내부적으로 OrderedHashTable 사용\n// 삽입 순서 유지 + 해시 충돌 처리\n```\n\n**특징:**\n- 삽입 순서 보장\n- 모든 타입을 키로 사용 가능\n\n---\n\n## C++ std::unordered_map\n\n**충돌 처리: Separate Chaining**\n\n```cpp\ntemplate<typename Key, typename T>\nclass unordered_map {\n    vector<list<pair<Key, T>>> buckets;\n    // 각 버킷은 연결 리스트\n};\n```\n\n**Load Factor: 1.0 (기본값)**\n```cpp\nunordered_map<int, string> map;\nmap.max_load_factor();  // 1.0\n\n// 100% 차면 리사이징\nif (size() > bucket_count() * max_load_factor()) {\n    rehash();\n}\n```\n\n**사용자 정의 Load Factor:**\n```cpp\nmap.max_load_factor(0.75);  // Java처럼 0.75로 설정\n```\n\n---\n\n## 비교 표\n\n| 언어 | 충돌 처리 | Load Factor | 순서 보장 |\n|------|-----------|-------------|----------|\n| Java HashMap | Chaining + Tree | 0.75 | X |\n| Python dict | Open Addressing | 0.67 | O (3.6+) |\n| JavaScript Map | Chaining | 가변 | O |\n| C++ unordered_map | Chaining | 1.0 | X |\n\n---\n\n**각 언어의 특징:**\n\n**Java:**\n- Tree화로 최악의 경우 성능 보장\n- LinkedHashMap으로 순서 유지 가능\n\n**Python:**\n- 메모리 효율적 (Open Addressing)\n- 기본적으로 삽입 순서 유지\n\n**JavaScript:**\n- Map은 항상 삽입 순서 유지\n- Object는 숫자 키 먼저 정렬\n\n**C++:**\n- 가장 빠른 성능 (포인터 직접 제어)\n- 순서가 필요하면 `std::map` 사용",
      "type": "essay",
      "tags": ["해시", "언어별 구현", "Java", "Python", "JavaScript", "C++"]
    },
    {
      "question": "Double Hashing의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.",
      "answer": "## Double Hashing\n\n**개념:**\n```java\nint h1(K key) { return key.hashCode() % M; }\nint h2(K key) { return 1 + (key.hashCode() % (M - 1)); }\n\nint probe(K key, int i) {\n    return (h1(key) + i * h2(key)) % M;\n}\n```\n\n---\n\n## 장점\n\n**1. Clustering 문제 해결**\n\nLinear Probing의 Primary Clustering 방지:\n```\nLinear Probing:\n[X] [X] [X] [_] [_]  // 연속된 군집 발생\n     ↑\n   충돌 시 바로 옆 슬롯 사용\n\nDouble Hashing:\n[X] [_] [X] [_] [X]  // 분산된 배치\n     ↑       ↑\n   h2(key)만큼 점프\n```\n\n**2. 균등한 분포**\n\n각 키마다 다른 조사 순서:\n```java\nkey1: h2 = 3 → 3, 6, 9, 12, ...\nkey2: h2 = 5 → 5, 10, 15, 20, ...\n```\n\n**3. 캐시 효율**\n\nOpen Addressing이므로:\n- 연속된 메모리 사용\n- Chaining보다 캐시 친화적\n\n---\n\n## 단점\n\n**1. 해시 함수 계산 비용**\n\n```java\n// 두 개의 해시 함수 계산 필요\nint index = h1(key);  // 첫 번째 계산\nint step = h2(key);   // 두 번째 계산\n```\n\n**해결책:**\n```java\n// 한 번만 계산하고 재사용\nint hashCode = key.hashCode();\nint h1 = hashCode % M;\nint h2 = 1 + (hashCode % (M - 1));\n```\n\n**2. 테이블 크기 제약**\n\n**문제:** h2(key)와 M이 서로소가 아니면 모든 슬롯 방문 불가\n\n```\nM = 10, h2(key) = 2\n시작 = 3\n조사 순서: 3, 5, 7, 9, 1, 3, ... (무한 루프)\n// 0, 2, 4, 6, 8은 절대 방문 안 됨!\n```\n\n**해결책 1: M을 소수로**\n```java\n// M이 소수면 h2 값과 항상 서로소\nint M = 1009;  // 소수\nint h2 = 1 + (hashCode % (M - 1));  // 1 ~ M-1\n// gcd(h2, M) = 1 보장\n```\n\n**해결책 2: h2 범위 조정**\n```java\n// h2가 1 이상이 되도록 보장\nint h2(K key) {\n    int h = key.hashCode() % (M - 1);\n    return h == 0 ? 1 : h;  // 0 방지\n}\n```\n\n**3. 삭제 복잡도**\n\n**문제:** Lazy Deletion 필요\n\n```java\nenum State { EMPTY, OCCUPIED, DELETED }\n\nclass Entry<K, V> {\n    K key;\n    V value;\n    State state;\n}\n\n// 검색 시 DELETED는 건너뛰되 계속 탐색\nV get(K key) {\n    int i = 0;\n    while (true) {\n        int index = probe(key, i++);\n        \n        if (table[index].state == EMPTY) {\n            return null;  // 못 찾음\n        }\n        \n        if (table[index].state == DELETED) {\n            continue;  // 건너뛰고 계속\n        }\n        \n        if (table[index].key.equals(key)) {\n            return table[index].value;\n        }\n    }\n}\n```\n\n**해결책: 주기적 재해싱**\n```java\nvoid compactTable() {\n    // DELETED 상태 제거하고 재배치\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[capacity];\n    \n    for (Entry<K, V> entry : oldTable) {\n        if (entry.state == OCCUPIED) {\n            put(entry.key, entry.value);\n        }\n    }\n}\n```\n\n**4. Load Factor 제한**\n\n**문제:** Load Factor가 높으면 성능 급격히 저하\n\n```java\n// Load Factor > 0.7 이면 성능 나쁨\nif (size > capacity * 0.7) {\n    resize();  // 2배로 확장\n}\n```\n\n**해결책: 동적 리사이징**\n```java\nvoid resize() {\n    int newCapacity = nextPrime(capacity * 2);\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[newCapacity];\n    \n    for (Entry<K, V> entry : oldTable) {\n        if (entry != null && entry.state == OCCUPIED) {\n            put(entry.key, entry.value);  // 재해싱\n        }\n    }\n}\n```\n\n---\n\n## 최적화된 구현 예시\n\n```java\nclass DoubleHashMap<K, V> {\n    private static final double MAX_LOAD_FACTOR = 0.7;\n    private int capacity;  // 항상 소수\n    private Entry<K, V>[] table;\n    \n    private int h1(K key) {\n        return Math.abs(key.hashCode()) % capacity;\n    }\n    \n    private int h2(K key) {\n        int h = Math.abs(key.hashCode()) % (capacity - 1);\n        return h == 0 ? 1 : h;  // 0 방지\n    }\n    \n    public void put(K key, V value) {\n        if (size > capacity * MAX_LOAD_FACTOR) {\n            resize();\n        }\n        \n        int hashCode = key.hashCode();  // 한 번만 계산\n        int h1 = Math.abs(hashCode) % capacity;\n        int h2 = 1 + Math.abs(hashCode) % (capacity - 1);\n        \n        for (int i = 0; i < capacity; i++) {\n            int index = (h1 + i * h2) % capacity;\n            \n            if (table[index] == null || table[index].state != OCCUPIED) {\n                table[index] = new Entry<>(key, value, OCCUPIED);\n                size++;\n                return;\n            }\n        }\n    }\n}\n```\n\n---\n\n## 결론\n\n**Double Hashing 사용 시기:**\n- Open Addressing 필요 (메모리 제약)\n- 높은 성능 필요 (캐시 효율)\n- 삭제 연산 적음\n\n**대안:**\n- 삭제가 많으면: **Chaining**\n- 구현 간단함 우선: **Linear Probing**\n- 최고 성능: **Cuckoo Hashing**",
      "type": "essay",
      "tags": ["Double Hashing", "해시", "충돌 해결", "성능 최적화"]
    },
    {
      "question": "Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?",
      "answer": "## Load Factor (적재율)\n\n**정의:**\n```\nLoad Factor (α) = 저장된 원소 개수 / 테이블 크기\n                = n / m\n```\n\n**의미:**\n- 해시 테이블이 얼마나 차 있는지를 나타내는 지표\n- 충돌 확률과 직접적으로 연관\n\n---\n\n## Load Factor와 성능\n\n**Chaining 방식:**\n```\nα = 0.5  → 평균 체인 길이: 0.5\nα = 1.0  → 평균 체인 길이: 1.0\nα = 2.0  → 평균 체인 길이: 2.0\n\n검색 시간: O(1 + α)\n```\n\n**Open Addressing 방식:**\n```\nα = 0.5  → 평균 조사 횟수: ~1.5\nα = 0.7  → 평균 조사 횟수: ~2.5\nα = 0.9  → 평균 조사 횟수: ~5.5\nα = 0.99 → 평균 조사 횟수: ~50\n\n// α가 1에 가까워질수록 급격히 느려짐\n```\n\n---\n\n## Java HashMap\n\n**기본 Load Factor: 0.75**\n\n```java\npublic class HashMap<K,V> {\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    static final int DEFAULT_INITIAL_CAPACITY = 16;\n    \n    // threshold = capacity * loadFactor\n    int threshold;\n    \n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        this.threshold = (int)(16 * 0.75);  // 12\n    }\n}\n```\n\n**리사이징 정책:**\n```java\npublic V put(K key, V value) {\n    // ...\n    if (++size > threshold) {\n        resize();  // 2배로 확장\n    }\n    return null;\n}\n\nfinal Node<K,V>[] resize() {\n    int oldCap = table.length;\n    int newCap = oldCap << 1;  // 2배\n    threshold = (int)(newCap * loadFactor);\n    \n    // 모든 원소 재해싱\n    Node<K,V>[] newTab = new Node[newCap];\n    // ... rehashing logic\n    return newTab;\n}\n```\n\n**왜 0.75?**\n- 0.75는 시간-공간 트레이드오프의 최적값\n- 너무 낮으면: 메모리 낭비\n- 너무 높으면: 충돌 증가, 성능 저하\n\n**사용자 정의 Load Factor:**\n```java\n// 메모리 중요 시\nMap<K,V> map = new HashMap<>(16, 0.9f);\n\n// 성능 중요 시\nMap<K,V> map = new HashMap<>(16, 0.5f);\n```\n\n---\n\n## Python dict\n\n**Load Factor: 2/3 (약 0.67)**\n\n```python\n# CPython 내부 구현\n#define USABLE_FRACTION(n) (((n) << 1) / 3)\n\n# 66.7% 차면 리사이징\nif (mp->ma_used > mp->ma_mask * 2/3):\n    dictresize(mp)\n```\n\n**리사이징 정책:**\n```python\n# 크기에 따라 증가 배수 다름\nif size < 50000:\n    new_size = size * 4  # 4배\nelse:\n    new_size = size * 2  # 2배\n```\n\n**특징:**\n- Java보다 낮은 Load Factor (더 공격적)\n- 메모리보다 속도 우선\n- 삽입 순서 유지를 위한 추가 구조\n\n---\n\n## JavaScript (V8 Engine)\n\n**Object:**\n```javascript\n// Hidden Class 최적화\n// Load Factor 정책은 엔진마다 다름\n// V8: 대략 0.75 사용\n```\n\n**Map:**\n```javascript\nconst map = new Map();\n\n// OrderedHashTable 사용\n// Load Factor: 약 1.0\n// 100% 차면 리사이징\n```\n\n---\n\n## C++ std::unordered_map\n\n**기본 Load Factor: 1.0**\n\n```cpp\nstd::unordered_map<int, string> map;\n\nstd::cout << map.max_load_factor();  // 1.0\nstd::cout << map.load_factor();      // 현재 적재율\n\n// 현재 상태\nstd::cout << map.size();             // 원소 개수\nstd::cout << map.bucket_count();     // 버킷 개수\n```\n\n**사용자 정의:**\n```cpp\nmap.max_load_factor(0.75);  // Java처럼 설정\n\n// 수동 리사이징\nmap.reserve(1000);  // 최소 1000개 수용 가능하도록\nmap.rehash(100);    // 버킷 개수를 100개로\n```\n\n**리사이징 정책:**\n```cpp\n// GCC libstdc++ 구현\nif (size() > bucket_count() * max_load_factor()) {\n    rehash(bucket_count() * 2);  // 2배\n}\n```\n\n---\n\n## 언어별 비교\n\n| 언어 | Load Factor | 리사이징 배수 | 비고 |\n|------|-------------|---------------|------|\n| Java | 0.75 | 2배 | 균형잡힌 설정 |\n| Python | 0.67 | 4배 (작을 때), 2배 (클 때) | 속도 우선 |\n| C++ | 1.0 | 2배 | 메모리 효율 |\n| JavaScript | ~0.75 ~ 1.0 | 엔진마다 다름 | 구현체 의존 |\n\n---\n\n## 최적 Load Factor 선택\n\n**Chaining 방식:**\n```java\n// 일반적으로 0.75 ~ 1.0\n// α = 1.0이어도 성능 괜찮음\nLoadFactor = 0.75;  // 추천\n```\n\n**Open Addressing 방식:**\n```java\n// 반드시 < 1.0\n// 0.5 ~ 0.7 추천\nLoadFactor = 0.6;  // 안정적\n```\n\n**성능 테스트 예시:**\n```java\n// 100만 개 삽입 테스트\nLoadFactor 0.5: 150ms, 메모리 20MB\nLoadFactor 0.75: 180ms, 메모리 15MB  // 균형\nLoadFactor 0.9: 250ms, 메모리 12MB\nLoadFactor 1.0: 400ms, 메모리 10MB\n```",
      "type": "essay",
      "tags": ["Load Factor", "해시", "성능", "메모리"]
    }
  ]
}
