{
  "name": "자료구조",
  "description": "자료구조 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "스택 2개로 큐 만들기",
      "answer": "**두 개의 스택으로 큐를 구현하는 방법:**\n\n스택은 LIFO (Last In First Out), 큐는 FIFO (First In First Out) 구조입니다.\n\n**구현 방법:**\n\n```java\nclass QueueUsingTwoStacks {\n    Stack<Integer> inbox = new Stack<>();   // 입력용\n    Stack<Integer> outbox = new Stack<>();  // 출력용\n    \n    // Enqueue: O(1)\n    public void enqueue(int x) {\n        inbox.push(x);\n    }\n    \n    // Dequeue: Amortized O(1)\n    public int dequeue() {\n        if (outbox.isEmpty()) {\n            // inbox의 모든 원소를 outbox로 이동\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.pop();\n    }\n    \n    public int peek() {\n        if (outbox.isEmpty()) {\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// enqueue(1, 2, 3, 4)\ninbox: [1, 2, 3, 4] (top)\noutbox: []\n\n// dequeue() 호출\ninbox → outbox 이동:\ninbox: []\noutbox: [4, 3, 2, 1] (top)\n\n// dequeue() 반환값: 1 (FIFO)\noutbox: [4, 3, 2]\n```\n\n**시간복잡도:**\n- Enqueue: O(1)\n- Dequeue: Amortized O(1) (최악 O(n), 평균 O(1))\n\n**JavaScript 구현:**\n\n```javascript\nclass QueueUsingStacks {\n    constructor() {\n        this.inbox = [];\n        this.outbox = [];\n    }\n    \n    enqueue(x) {\n        this.inbox.push(x);\n    }\n    \n    dequeue() {\n        if (this.outbox.length === 0) {\n            while (this.inbox.length > 0) {\n                this.outbox.push(this.inbox.pop());\n            }\n        }\n        return this.outbox.pop();\n    }\n}\n```",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "큐 2개로 스택 만들기",
      "answer": "**두 개의 큐로 스택을 구현하는 방법:**\n\n스택은 LIFO, 큐는 FIFO 구조입니다.\n\n**구현 방법 1: Push가 O(n)**\n\n```java\nclass StackUsingTwoQueues {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        // 새 원소를 q2에 추가\n        q2.offer(x);\n        \n        // q1의 모든 원소를 q2로 이동\n        while (!q1.isEmpty()) {\n            q2.offer(q1.poll());\n        }\n        \n        // q1과 q2를 교환\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return q1.poll();\n    }\n    \n    // Top: O(1)\n    public int top() {\n        return q1.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// push(1)\nq1: [1]\nq2: []\n\n// push(2)\nq2: [2] → q1의 원소 이동 → [2, 1]\nq1과 q2 교환\nq1: [2, 1] (front가 top)\n\n// push(3)\nq2: [3] → [3, 2, 1]\nq1: [3, 2, 1]\n\n// pop() → 3 반환\n```\n\n**구현 방법 2: 하나의 큐만 사용 (더 효율적)**\n\n```java\nclass StackUsingOneQueue {\n    Queue<Integer> queue = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        queue.offer(x);\n        int size = queue.size();\n        \n        // 새 원소를 맨 앞으로 이동\n        for (int i = 0; i < size - 1; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return queue.poll();\n    }\n}\n```\n\n**JavaScript 구현:**\n\n```javascript\nclass StackUsingQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    push(x) {\n        this.queue.push(x);\n        // 새 원소를 맨 앞으로 회전\n        for (let i = 0; i < this.queue.length - 1; i++) {\n            this.queue.push(this.queue.shift());\n        }\n    }\n    \n    pop() {\n        return this.queue.shift();\n    }\n}\n```\n\n**시간복잡도:**\n- Push: O(n)\n- Pop: O(1)\n- Top: O(1)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법에 대해 설명해 주세요.",
      "answer": "**표기법 종류:**\n\n1. **Infix (중위 표기법)**: 연산자가 피연산자 사이에 위치\n   - 예: `3 + 4 * 2`\n   - 사람이 읽기 쉽지만 우선순위 처리 복잡\n\n2. **Prefix (전위 표기법)**: 연산자가 피연산자 앞에 위치\n   - 예: `+ 3 * 4 2` → `3 + (4 * 2)`\n   - 괄호 불필요\n\n3. **Postfix (후위 표기법)**: 연산자가 피연산자 뒤에 위치\n   - 예: `3 4 2 * +` → `3 + (4 * 2)`\n   - 스택으로 계산이 가장 쉬움\n\n---\n\n**Postfix 계산 (스택 사용):**\n\n```java\npublic int evaluatePostfix(String expression) {\n    Stack<Integer> stack = new Stack<>();\n    String[] tokens = expression.split(\" \");\n    \n    for (String token : tokens) {\n        if (isOperator(token)) {\n            int b = stack.pop();\n            int a = stack.pop();\n            \n            switch (token) {\n                case \"+\": stack.push(a + b); break;\n                case \"-\": stack.push(a - b); break;\n                case \"*\": stack.push(a * b); break;\n                case \"/\": stack.push(a / b); break;\n            }\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    \n    return stack.pop();\n}\n```\n\n**동작 과정 예시: `3 4 2 * +`**\n\n```\n토큰: 3 → stack: [3]\n토큰: 4 → stack: [3, 4]\n토큰: 2 → stack: [3, 4, 2]\n토큰: * → pop 2, 4 → 4*2=8 → stack: [3, 8]\n토큰: + → pop 8, 3 → 3+8=11 → stack: [11]\n결과: 11\n```\n\n---\n\n**Infix → Postfix 변환 (Shunting Yard Algorithm):**\n\n```java\npublic String infixToPostfix(String infix) {\n    StringBuilder result = new StringBuilder();\n    Stack<Character> stack = new Stack<>();\n    \n    for (char c : infix.toCharArray()) {\n        if (Character.isDigit(c)) {\n            result.append(c).append(' ');\n        } else if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            while (!stack.isEmpty() && stack.peek() != '(') {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.pop(); // '(' 제거\n        } else if (isOperator(c)) {\n            while (!stack.isEmpty() && precedence(stack.peek()) >= precedence(c)) {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.push(c);\n        }\n    }\n    \n    while (!stack.isEmpty()) {\n        result.append(stack.pop()).append(' ');\n    }\n    \n    return result.toString().trim();\n}\n\nprivate int precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n```\n\n**예시: `3 + 4 * 2` → `3 4 2 * +`**\n\n```\n토큰: 3 → result: \"3 \", stack: []\n토큰: + → result: \"3 \", stack: [+]\n토큰: 4 → result: \"3 4 \", stack: [+]\n토큰: * → result: \"3 4 \", stack: [+, *] (우선순위 * > +)\n토큰: 2 → result: \"3 4 2 \", stack: [+, *]\n종료  → result: \"3 4 2 * +\", stack: []\n```\n\n**시간복잡도:** O(n)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Expression", "알고리즘"]
    },
    {
      "question": "(C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?",
      "answer": "**C++ `std::deque`의 내부 구조:**\n\nDeque는 \"Double-Ended Queue\"로, 양쪽 끝에서 삽입/삭제가 O(1)이면서도 Random Access가 O(1)인 자료구조입니다.\n\n**구현 방식: Map of Chunks (청크 배열)**\n\n```\n         Map (중앙 관리 배열)\n         ┌───┬───┬───┬───┬───┐\n         │ 0 │ 1 │ 2 │ 3 │ 4 │\n         └─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘\n           │   │   │   │   │\n           ↓   ↓   ↓   ↓   ↓\n        Chunk1 Chunk2 Chunk3 ... (고정 크기 배열들)\n        [][][]  [][][]  [][][]\n```\n\n**핵심 아이디어:**\n\n1. **Map (중앙 배열)**:\n   - 포인터 배열로, 각 포인터는 고정 크기 청크를 가리킴\n   - 청크 크기는 보통 512 bytes (원소 크기에 따라 다름)\n\n2. **Chunk (데이터 블록)**:\n   - 실제 데이터가 저장되는 고정 크기 배열\n   - 예: `sizeof(T) = 4` bytes → 청크당 128개 원소\n\n**Random Access 계산:**\n\n```cpp\n// index 번째 원소 접근: O(1)\nT& operator[](size_t index) {\n    size_t chunk_index = index / CHUNK_SIZE;  // 어느 청크?\n    size_t offset = index % CHUNK_SIZE;       // 청크 내 위치?\n    \n    return map[chunk_index][offset];\n}\n```\n\n**예시:**\n\n```\nCHUNK_SIZE = 4라고 가정\ndeque에 [0, 1, 2, 3, 4, 5, 6, 7, 8] 저장\n\nMap:      [0]  [1]  [2]\n           ↓    ↓    ↓\nChunk 0: [0 1 2 3]\nChunk 1: [4 5 6 7]\nChunk 2: [8 _ _ _]\n\n// deque[6] 접근\nchunk_index = 6 / 4 = 1\noffset = 6 % 4 = 2\n→ map[1][2] = 6\n```\n\n**양쪽 삽입/삭제가 O(1)인 이유:**\n\n```cpp\n// push_back\nvoid push_back(T value) {\n    if (마지막 청크가 가득 참) {\n        map에 새 청크 포인터 추가;  // Map 재할당 가능 (Amortized O(1))\n    }\n    마지막 청크에 추가;\n}\n\n// push_front\nvoid push_front(T value) {\n    if (첫 청크가 가득 참) {\n        map 앞에 새 청크 포인터 추가;\n    }\n    첫 청크에 추가;\n}\n```\n\n**Vector vs Deque 비교:**\n\n| 연산 | Vector | Deque |\n|------|--------|-------|\n| Random Access | O(1) | O(1) |\n| push_back | Amortized O(1) | Amortized O(1) |\n| push_front | O(n) | Amortized O(1) |\n| 메모리 연속성 | 연속 | 비연속 (청크 단위) |\n| 캐시 효율 | 높음 | 낮음 |\n\n**단점:**\n\n- 청크 간 이동 시 캐시 미스 발생 가능\n- Vector보다 메모리 오버헤드 큼 (Map 관리 비용)\n\n**사용 예시:**\n\n```cpp\nstd::deque<int> dq;\n\n// 양쪽 삽입 O(1)\ndq.push_back(1);   // [1]\ndq.push_front(0);  // [0, 1]\n\n// Random Access O(1)\nint x = dq[0];     // 0\nint y = dq[1];     // 1\n```",
      "type": "essay",
      "tags": ["자료구조", "Deque", "C++", "Random Access"]
    },
    {
      "question": "해시 자료구조에 대해 설명해 주세요.",
      "answer": "**해시 테이블 (Hash Table):**\n\nKey-Value 쌍을 저장하는 자료구조로, **평균 O(1) 시간복잡도**로 삽입, 삭제, 검색이 가능합니다.\n\n**핵심 구성 요소:**\n\n1. **해시 함수 (Hash Function)**\n   - Key → Index 변환\n   - 예: `hash(key) % table_size`\n\n2. **버킷 배열 (Bucket Array)**\n   - 실제 데이터를 저장하는 배열\n\n3. **충돌 해결 방법 (Collision Resolution)**\n   - Chaining: 연결 리스트로 충돌 처리\n   - Open Addressing: 빈 슬롯 찾기\n\n---\n\n**동작 원리:**\n\n```java\nclass HashTable<K, V> {\n    private static class Entry<K, V> {\n        K key;\n        V value;\n        Entry<K, V> next;  // Chaining\n    }\n    \n    private Entry<K, V>[] table;\n    private int size;\n    \n    public HashTable(int capacity) {\n        table = new Entry[capacity];\n    }\n    \n    // 삽입: O(1) 평균\n    public void put(K key, V value) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        // 중복 키 확인\n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                entry.value = value;  // 업데이트\n                return;\n            }\n            entry = entry.next;\n        }\n        \n        // 새 엔트리 추가 (체이닝)\n        Entry<K, V> newEntry = new Entry<>(key, value);\n        newEntry.next = table[index];\n        table[index] = newEntry;\n        size++;\n    }\n    \n    // 검색: O(1) 평균\n    public V get(K key) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                return entry.value;\n            }\n            entry = entry.next;\n        }\n        \n        return null;\n    }\n    \n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % table.length;\n    }\n}\n```\n\n---\n\n**충돌 해결 방법:**\n\n**1. Chaining (체이닝):**\n\n```\nIndex  Bucket\n  0  → [key1, val1] → [key2, val2] → null\n  1  → null\n  2  → [key3, val3] → null\n  3  → [key4, val4] → [key5, val5] → null\n```\n\n**2. Open Addressing (개방 주소법):**\n\n- **Linear Probing**: `(h(k) + i) % m`\n- **Quadratic Probing**: `(h(k) + i²) % m`\n- **Double Hashing**: `(h1(k) + i * h2(k)) % m`\n\n---\n\n**시간복잡도:**\n\n| 연산 | 평균 | 최악 |\n|------|------|------|\n| 삽입 | O(1) | O(n) |\n| 삭제 | O(1) | O(n) |\n| 검색 | O(1) | O(n) |\n\n**최악의 경우**: 모든 키가 같은 인덱스로 해싱 → 연결 리스트처럼 동작\n\n---\n\n**Load Factor (적재율):**\n\n```\nLoad Factor = 저장된 원소 개수 / 테이블 크기\n```\n\n- Java HashMap: Load Factor 0.75 초과 시 리사이징\n- 적재율이 높을수록 충돌 증가 → 성능 저하\n\n**리사이징 (Rehashing):**\n\n```java\nprivate void resize() {\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[oldTable.length * 2];\n    \n    // 모든 엔트리 재배치\n    for (Entry<K, V> entry : oldTable) {\n        while (entry != null) {\n            put(entry.key, entry.value);\n            entry = entry.next;\n        }\n    }\n}\n```\n\n---\n\n**JavaScript 예시:**\n\n```javascript\nconst map = new Map();\nmap.set('name', 'Alice');  // O(1)\nmap.get('name');           // O(1) → 'Alice'\nmap.has('name');           // O(1) → true\nmap.delete('name');        // O(1)\n```\n\n**Java 예시:**\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"apple\", 100);   // O(1)\nint price = map.get(\"apple\");  // O(1)\nmap.containsKey(\"apple\");      // O(1)\n```\n\n**장점:**\n- 빠른 검색, 삽입, 삭제 (평균 O(1))\n- 유연한 키 타입\n\n**단점:**\n- 순서 보장 안 됨 (LinkedHashMap으로 해결)\n- 해시 충돌 가능성\n- 메모리 오버헤드 (빈 공간 존재)",
      "type": "essay",
      "tags": ["자료구조", "Hash Table", "HashMap", "시간복잡도"]
    }
  ]
}
