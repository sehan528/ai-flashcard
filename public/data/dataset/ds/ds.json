{
  "name": "자료구조",
  "description": "자료구조 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "스택 2개로 큐 만들기",
      "answer": "**두 개의 스택으로 큐를 구현하는 방법:**\n\n스택은 LIFO (Last In First Out), 큐는 FIFO (First In First Out) 구조입니다.\n\n**구현 방법:**\n\n```java\nclass QueueUsingTwoStacks {\n    Stack<Integer> inbox = new Stack<>();   // 입력용\n    Stack<Integer> outbox = new Stack<>();  // 출력용\n    \n    // Enqueue: O(1)\n    public void enqueue(int x) {\n        inbox.push(x);\n    }\n    \n    // Dequeue: Amortized O(1)\n    public int dequeue() {\n        if (outbox.isEmpty()) {\n            // inbox의 모든 원소를 outbox로 이동\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.pop();\n    }\n    \n    public int peek() {\n        if (outbox.isEmpty()) {\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// enqueue(1, 2, 3, 4)\ninbox: [1, 2, 3, 4] (top)\noutbox: []\n\n// dequeue() 호출\ninbox → outbox 이동:\ninbox: []\noutbox: [4, 3, 2, 1] (top)\n\n// dequeue() 반환값: 1 (FIFO)\noutbox: [4, 3, 2]\n```\n\n**시간복잡도:**\n- Enqueue: O(1)\n- Dequeue: Amortized O(1) (최악 O(n), 평균 O(1))\n\n**JavaScript 구현:**\n\n```javascript\nclass QueueUsingStacks {\n    constructor() {\n        this.inbox = [];\n        this.outbox = [];\n    }\n    \n    enqueue(x) {\n        this.inbox.push(x);\n    }\n    \n    dequeue() {\n        if (this.outbox.length === 0) {\n            while (this.inbox.length > 0) {\n                this.outbox.push(this.inbox.pop());\n            }\n        }\n        return this.outbox.pop();\n    }\n}\n```",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "큐 2개로 스택 만들기",
      "answer": "**두 개의 큐로 스택을 구현하는 방법:**\n\n스택은 LIFO, 큐는 FIFO 구조입니다.\n\n**구현 방법 1: Push가 O(n)**\n\n```java\nclass StackUsingTwoQueues {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        // 새 원소를 q2에 추가\n        q2.offer(x);\n        \n        // q1의 모든 원소를 q2로 이동\n        while (!q1.isEmpty()) {\n            q2.offer(q1.poll());\n        }\n        \n        // q1과 q2를 교환\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return q1.poll();\n    }\n    \n    // Top: O(1)\n    public int top() {\n        return q1.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// push(1)\nq1: [1]\nq2: []\n\n// push(2)\nq2: [2] → q1의 원소 이동 → [2, 1]\nq1과 q2 교환\nq1: [2, 1] (front가 top)\n\n// push(3)\nq2: [3] → [3, 2, 1]\nq1: [3, 2, 1]\n\n// pop() → 3 반환\n```\n\n**구현 방법 2: 하나의 큐만 사용 (더 효율적)**\n\n```java\nclass StackUsingOneQueue {\n    Queue<Integer> queue = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        queue.offer(x);\n        int size = queue.size();\n        \n        // 새 원소를 맨 앞으로 이동\n        for (int i = 0; i < size - 1; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return queue.poll();\n    }\n}\n```\n\n**JavaScript 구현:**\n\n```javascript\nclass StackUsingQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    push(x) {\n        this.queue.push(x);\n        // 새 원소를 맨 앞으로 회전\n        for (let i = 0; i < this.queue.length - 1; i++) {\n            this.queue.push(this.queue.shift());\n        }\n    }\n    \n    pop() {\n        return this.queue.shift();\n    }\n}\n```\n\n**시간복잡도:**\n- Push: O(n)\n- Pop: O(1)\n- Top: O(1)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법에 대해 설명해 주세요.",
      "answer": "**표기법 종류:**\n\n1. **Infix (중위 표기법)**: 연산자가 피연산자 사이에 위치\n   - 예: `3 + 4 * 2`\n   - 사람이 읽기 쉽지만 우선순위 처리 복잡\n\n2. **Prefix (전위 표기법)**: 연산자가 피연산자 앞에 위치\n   - 예: `+ 3 * 4 2` → `3 + (4 * 2)`\n   - 괄호 불필요\n\n3. **Postfix (후위 표기법)**: 연산자가 피연산자 뒤에 위치\n   - 예: `3 4 2 * +` → `3 + (4 * 2)`\n   - 스택으로 계산이 가장 쉬움\n\n---\n\n**Postfix 계산 (스택 사용):**\n\n```java\npublic int evaluatePostfix(String expression) {\n    Stack<Integer> stack = new Stack<>();\n    String[] tokens = expression.split(\" \");\n    \n    for (String token : tokens) {\n        if (isOperator(token)) {\n            int b = stack.pop();\n            int a = stack.pop();\n            \n            switch (token) {\n                case \"+\": stack.push(a + b); break;\n                case \"-\": stack.push(a - b); break;\n                case \"*\": stack.push(a * b); break;\n                case \"/\": stack.push(a / b); break;\n            }\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    \n    return stack.pop();\n}\n```\n\n**동작 과정 예시: `3 4 2 * +`**\n\n```\n토큰: 3 → stack: [3]\n토큰: 4 → stack: [3, 4]\n토큰: 2 → stack: [3, 4, 2]\n토큰: * → pop 2, 4 → 4*2=8 → stack: [3, 8]\n토큰: + → pop 8, 3 → 3+8=11 → stack: [11]\n결과: 11\n```\n\n---\n\n**Infix → Postfix 변환 (Shunting Yard Algorithm):**\n\n```java\npublic String infixToPostfix(String infix) {\n    StringBuilder result = new StringBuilder();\n    Stack<Character> stack = new Stack<>();\n    \n    for (char c : infix.toCharArray()) {\n        if (Character.isDigit(c)) {\n            result.append(c).append(' ');\n        } else if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            while (!stack.isEmpty() && stack.peek() != '(') {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.pop(); // '(' 제거\n        } else if (isOperator(c)) {\n            while (!stack.isEmpty() && precedence(stack.peek()) >= precedence(c)) {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.push(c);\n        }\n    }\n    \n    while (!stack.isEmpty()) {\n        result.append(stack.pop()).append(' ');\n    }\n    \n    return result.toString().trim();\n}\n\nprivate int precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n```\n\n**예시: `3 + 4 * 2` → `3 4 2 * +`**\n\n```\n토큰: 3 → result: \"3 \", stack: []\n토큰: + → result: \"3 \", stack: [+]\n토큰: 4 → result: \"3 4 \", stack: [+]\n토큰: * → result: \"3 4 \", stack: [+, *] (우선순위 * > +)\n토큰: 2 → result: \"3 4 2 \", stack: [+, *]\n종료  → result: \"3 4 2 * +\", stack: []\n```\n\n**시간복잡도:** O(n)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Expression", "알고리즘"]
    },
    {
      "question": "(C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?",
      "answer": "**C++ `std::deque`의 내부 구조:**\n\nDeque는 \"Double-Ended Queue\"로, 양쪽 끝에서 삽입/삭제가 O(1)이면서도 Random Access가 O(1)인 자료구조입니다.\n\n**구현 방식: Map of Chunks (청크 배열)**\n\n```\n         Map (중앙 관리 배열)\n         ┌───┬───┬───┬───┬───┐\n         │ 0 │ 1 │ 2 │ 3 │ 4 │\n         └─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘\n           │   │   │   │   │\n           ↓   ↓   ↓   ↓   ↓\n        Chunk1 Chunk2 Chunk3 ... (고정 크기 배열들)\n        [][][]  [][][]  [][][]\n```\n\n**핵심 아이디어:**\n\n1. **Map (중앙 배열)**:\n   - 포인터 배열로, 각 포인터는 고정 크기 청크를 가리킴\n   - 청크 크기는 보통 512 bytes (원소 크기에 따라 다름)\n\n2. **Chunk (데이터 블록)**:\n   - 실제 데이터가 저장되는 고정 크기 배열\n   - 예: `sizeof(T) = 4` bytes → 청크당 128개 원소\n\n**Random Access 계산:**\n\n```cpp\n// index 번째 원소 접근: O(1)\nT& operator[](size_t index) {\n    size_t chunk_index = index / CHUNK_SIZE;  // 어느 청크?\n    size_t offset = index % CHUNK_SIZE;       // 청크 내 위치?\n    \n    return map[chunk_index][offset];\n}\n```\n\n**예시:**\n\n```\nCHUNK_SIZE = 4라고 가정\ndeque에 [0, 1, 2, 3, 4, 5, 6, 7, 8] 저장\n\nMap:      [0]  [1]  [2]\n           ↓    ↓    ↓\nChunk 0: [0 1 2 3]\nChunk 1: [4 5 6 7]\nChunk 2: [8 _ _ _]\n\n// deque[6] 접근\nchunk_index = 6 / 4 = 1\noffset = 6 % 4 = 2\n→ map[1][2] = 6\n```\n\n**양쪽 삽입/삭제가 O(1)인 이유:**\n\n```cpp\n// push_back\nvoid push_back(T value) {\n    if (마지막 청크가 가득 참) {\n        map에 새 청크 포인터 추가;  // Map 재할당 가능 (Amortized O(1))\n    }\n    마지막 청크에 추가;\n}\n\n// push_front\nvoid push_front(T value) {\n    if (첫 청크가 가득 참) {\n        map 앞에 새 청크 포인터 추가;\n    }\n    첫 청크에 추가;\n}\n```\n\n**Vector vs Deque 비교:**\n\n| 연산 | Vector | Deque |\n|------|--------|-------|\n| Random Access | O(1) | O(1) |\n| push_back | Amortized O(1) | Amortized O(1) |\n| push_front | O(n) | Amortized O(1) |\n| 메모리 연속성 | 연속 | 비연속 (청크 단위) |\n| 캐시 효율 | 높음 | 낮음 |\n\n**단점:**\n\n- 청크 간 이동 시 캐시 미스 발생 가능\n- Vector보다 메모리 오버헤드 큼 (Map 관리 비용)\n\n**사용 예시:**\n\n```cpp\nstd::deque<int> dq;\n\n// 양쪽 삽입 O(1)\ndq.push_back(1);   // [1]\ndq.push_front(0);  // [0, 1]\n\n// Random Access O(1)\nint x = dq[0];     // 0\nint y = dq[1];     // 1\n```",
      "type": "essay",
      "tags": ["자료구조", "Deque", "C++", "Random Access"]
    },
    {
      "question": "해시 자료구조에 대해 설명해 주세요.",
      "answer": "**해시 테이블 (Hash Table):**\n\nKey-Value 쌍을 저장하는 자료구조로, **평균 O(1) 시간복잡도**로 삽입, 삭제, 검색이 가능합니다.\n\n**핵심 구성 요소:**\n\n1. **해시 함수 (Hash Function)**\n   - Key → Index 변환\n   - 예: `hash(key) % table_size`\n\n2. **버킷 배열 (Bucket Array)**\n   - 실제 데이터를 저장하는 배열\n\n3. **충돌 해결 방법 (Collision Resolution)**\n   - Chaining: 연결 리스트로 충돌 처리\n   - Open Addressing: 빈 슬롯 찾기\n\n---\n\n**동작 원리:**\n\n```java\nclass HashTable<K, V> {\n    private static class Entry<K, V> {\n        K key;\n        V value;\n        Entry<K, V> next;  // Chaining\n    }\n    \n    private Entry<K, V>[] table;\n    private int size;\n    \n    public HashTable(int capacity) {\n        table = new Entry[capacity];\n    }\n    \n    // 삽입: O(1) 평균\n    public void put(K key, V value) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        // 중복 키 확인\n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                entry.value = value;  // 업데이트\n                return;\n            }\n            entry = entry.next;\n        }\n        \n        // 새 엔트리 추가 (체이닝)\n        Entry<K, V> newEntry = new Entry<>(key, value);\n        newEntry.next = table[index];\n        table[index] = newEntry;\n        size++;\n    }\n    \n    // 검색: O(1) 평균\n    public V get(K key) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                return entry.value;\n            }\n            entry = entry.next;\n        }\n        \n        return null;\n    }\n    \n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % table.length;\n    }\n}\n```\n\n---\n\n**충돌 해결 방법:**\n\n**1. Chaining (체이닝):**\n\n```\nIndex  Bucket\n  0  → [key1, val1] → [key2, val2] → null\n  1  → null\n  2  → [key3, val3] → null\n  3  → [key4, val4] → [key5, val5] → null\n```\n\n**2. Open Addressing (개방 주소법):**\n\n- **Linear Probing**: `(h(k) + i) % m`\n- **Quadratic Probing**: `(h(k) + i²) % m`\n- **Double Hashing**: `(h1(k) + i * h2(k)) % m`\n\n---\n\n**시간복잡도:**\n\n| 연산 | 평균 | 최악 |\n|------|------|------|\n| 삽입 | O(1) | O(n) |\n| 삭제 | O(1) | O(n) |\n| 검색 | O(1) | O(n) |\n\n**최악의 경우**: 모든 키가 같은 인덱스로 해싱 → 연결 리스트처럼 동작\n\n---\n\n**Load Factor (적재율):**\n\n```\nLoad Factor = 저장된 원소 개수 / 테이블 크기\n```\n\n- Java HashMap: Load Factor 0.75 초과 시 리사이징\n- 적재율이 높을수록 충돌 증가 → 성능 저하\n\n**리사이징 (Rehashing):**\n\n```java\nprivate void resize() {\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[oldTable.length * 2];\n    \n    // 모든 엔트리 재배치\n    for (Entry<K, V> entry : oldTable) {\n        while (entry != null) {\n            put(entry.key, entry.value);\n            entry = entry.next;\n        }\n    }\n}\n```\n\n---\n\n**JavaScript 예시:**\n\n```javascript\nconst map = new Map();\nmap.set('name', 'Alice');  // O(1)\nmap.get('name');           // O(1) → 'Alice'\nmap.has('name');           // O(1) → true\nmap.delete('name');        // O(1)\n```\n\n**Java 예시:**\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"apple\", 100);   // O(1)\nint price = map.get(\"apple\");  // O(1)\nmap.containsKey(\"apple\");      // O(1)\n```\n\n**장점:**\n- 빠른 검색, 삽입, 삭제 (평균 O(1))\n- 유연한 키 타입\n\n**단점:**\n- 순서 보장 안 됨 (LinkedHashMap으로 해결)\n- 해시 충돌 가능성\n- 메모리 오버헤드 (빈 공간 존재)",
      "type": "essay",
      "tags": ["자료구조", "Hash Table", "HashMap", "시간복잡도"]
    },
    {
      "question": "값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?",
      "answer": "**좋은 해시 함수의 조건:**\n\n1. **균등 분포 (Uniform Distribution)**\n   - 모든 버킷에 데이터가 고르게 분산\n   - 충돌 최소화\n\n2. **빠른 계산**\n   - O(1) 시간에 해시값 계산\n\n3. **결정적 (Deterministic)**\n   - 같은 입력 → 항상 같은 출력\n\n---\n\n**해시 함수 설계 기법:**\n\n**1. Division Method (나눗셈)**\n\n```java\nint hash(int key, int tableSize) {\n    return key % tableSize;\n}\n```\n\n**주의사항:**\n- 테이블 크기는 **소수(prime number)** 사용 권장\n- 2의 거듭제곱은 피하기 (하위 비트만 사용되어 편향 발생)\n\n**2. Multiplication Method (곱셈)**\n\n```java\nint hash(int key, int tableSize) {\n    double A = (Math.sqrt(5) - 1) / 2;  // 황금비의 역수\n    double fractional = (key * A) % 1;  // 소수 부분만 추출\n    return (int)(tableSize * fractional);\n}\n```\n\n**3. Universal Hashing**\n\n```java\nclass UniversalHash {\n    private int a, b, p, m;\n    \n    public UniversalHash(int tableSize) {\n        this.m = tableSize;\n        this.p = nextPrime(tableSize * 2);  // tableSize보다 큰 소수\n        this.a = random(1, p);  // 랜덤 계수\n        this.b = random(0, p);\n    }\n    \n    int hash(int key) {\n        return ((a * key + b) % p) % m;\n    }\n}\n```\n\n**장점**: 최악의 경우 공격 방지 (랜덤성)\n\n---\n\n**문자열 해시:**\n\n**Polynomial Rolling Hash:**\n\n```java\nint hash(String s, int tableSize) {\n    final int p = 31;  // 소수 (알파벳 크기보다 큰)\n    final int m = 1_000_000_009;  // 큰 소수\n    \n    long hashValue = 0;\n    long pPow = 1;\n    \n    for (char c : s.toCharArray()) {\n        hashValue = (hashValue + (c - 'a' + 1) * pPow) % m;\n        pPow = (pPow * p) % m;\n    }\n    \n    return (int)(hashValue % tableSize);\n}\n```\n\n**예시:**\n```\n\"abc\" 해시값\n= (1 * 31^0 + 2 * 31^1 + 3 * 31^2) % m\n= (1 + 62 + 2883) % m\n```\n\n---\n\n**Java의 String.hashCode():**\n\n```java\npublic int hashCode() {\n    int h = 0;\n    for (char c : value) {\n        h = 31 * h + c;\n    }\n    return h;\n}\n```\n\n**왜 31을 사용?**\n- 소수라서 분포가 좋음\n- `31 * i == (i << 5) - i` (비트 연산으로 최적화 가능)\n\n---\n\n**충돌 최소화 전략:**\n\n**1. 비트 연산 활용:**\n\n```java\nint hash(int key) {\n    key ^= (key >>> 20) ^ (key >>> 12);\n    return key ^ (key >>> 7) ^ (key >>> 4);\n}\n```\n\n**2. MurmurHash (빠르고 품질 좋음):**\n\n```java\nint murmurhash(int key) {\n    key ^= key >>> 16;\n    key *= 0x85ebca6b;\n    key ^= key >>> 13;\n    key *= 0xc2b2ae35;\n    key ^= key >>> 16;\n    return key;\n}\n```\n\n---\n\n**실전 예시:**\n\n```java\n// 나쁜 예: 2의 거듭제곱 테이블 크기\nint badHash(int key) {\n    return key % 1024;  // 하위 10비트만 사용 → 편향\n}\n\n// 좋은 예: 소수 테이블 크기\nint goodHash(int key) {\n    return key % 1009;  // 균등 분포\n}\n```\n\n**테스트:**\n\n```java\n// 해시 함수 품질 테스트\nvoid testHashDistribution(HashFunction h, int[] keys) {\n    int[] buckets = new int[tableSize];\n    \n    for (int key : keys) {\n        buckets[h.hash(key)]++;\n    }\n    \n    // 표준편차 계산 (낮을수록 균등 분포)\n    double stdDev = calculateStdDev(buckets);\n}\n```",
      "type": "essay",
      "tags": ["해시", "해시 함수", "설계", "충돌"]
    },
    {
      "question": "해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?",
      "answer": "**충돌 해결 방법:**\n\n## 1. Chaining (체이닝)\n\n각 버킷을 연결 리스트로 구현하여 같은 인덱스의 원소들을 체인으로 연결\n\n```java\nclass HashTableChaining<K, V> {\n    class Node {\n        K key;\n        V value;\n        Node next;\n    }\n    \n    Node[] table;\n    \n    void put(K key, V value) {\n        int index = hash(key);\n        Node node = table[index];\n        \n        // 기존 키 업데이트\n        while (node != null) {\n            if (node.key.equals(key)) {\n                node.value = value;\n                return;\n            }\n            node = node.next;\n        }\n        \n        // 새 노드 추가 (맨 앞에)\n        Node newNode = new Node(key, value);\n        newNode.next = table[index];\n        table[index] = newNode;\n    }\n}\n```\n\n**장점:**\n- 구현 간단\n- 삭제 쉬움\n- Load Factor > 1 가능\n\n**단점:**\n- 추가 메모리 (포인터)\n- 캐시 효율 낮음\n\n---\n\n## 2. Open Addressing (개방 주소법)\n\n충돌 시 다른 빈 슬롯을 찾아 저장\n\n### 2-1. Linear Probing (선형 조사)\n\n```java\nvoid put(K key, V value) {\n    int index = hash(key);\n    \n    // 빈 슬롯 찾을 때까지\n    while (table[index] != null && !table[index].key.equals(key)) {\n        index = (index + 1) % table.length;\n    }\n    \n    table[index] = new Entry(key, value);\n}\n\nV get(K key) {\n    int index = hash(key);\n    \n    while (table[index] != null) {\n        if (table[index].key.equals(key)) {\n            return table[index].value;\n        }\n        index = (index + 1) % table.length;\n    }\n    \n    return null;\n}\n```\n\n**문제: Primary Clustering (1차 군집화)**\n- 연속된 슬롯들이 채워지면 더 긴 체인 형성\n\n### 2-2. Quadratic Probing (이차 조사)\n\n```java\nint probe(int hash, int i) {\n    return (hash + i * i) % table.length;\n}\n```\n\n**예시:**\n```\ni=0: hash\ni=1: hash + 1\ni=2: hash + 4\ni=3: hash + 9\n```\n\n**문제: Secondary Clustering (2차 군집화)**\n- 같은 해시값을 가진 키들이 같은 조사 순서\n\n### 2-3. Double Hashing (이중 해싱)\n\n```java\nint hash1(K key) {\n    return key.hashCode() % table.length;\n}\n\nint hash2(K key) {\n    return 1 + (key.hashCode() % (table.length - 1));\n}\n\nint probe(K key, int i) {\n    return (hash1(key) + i * hash2(key)) % table.length;\n}\n```\n\n**예시:**\n```\nkey = 10, table.length = 7\nhash1(10) = 3\nhash2(10) = 1 + (10 % 6) = 5\n\ni=0: 3\ni=1: (3 + 5) % 7 = 1\ni=2: (3 + 10) % 7 = 6\ni=3: (3 + 15) % 7 = 4\n```\n\n**장점:**\n- Clustering 문제 해결\n- 좋은 분포\n\n---\n\n## 3. Separate Chaining vs Open Addressing\n\n| 특성 | Chaining | Open Addressing |\n|------|----------|------------------|\n| 메모리 | 포인터 오버헤드 | 고정 크기 테이블 |\n| Load Factor | > 1 가능 | < 1 제한 |\n| 캐시 효율 | 낮음 | 높음 |\n| 삭제 | 쉬움 | 복잡 (Lazy Deletion) |\n| 성능 | 균등 | Load Factor 의존 |\n\n---\n\n**삭제 처리 (Open Addressing):**\n\n```java\nclass Entry<K, V> {\n    K key;\n    V value;\n    boolean deleted;  // Lazy deletion flag\n}\n\nvoid remove(K key) {\n    int index = findIndex(key);\n    if (index != -1) {\n        table[index].deleted = true;  // 삭제 표시\n    }\n}\n\nV get(K key) {\n    int index = hash(key);\n    \n    while (table[index] != null) {\n        if (!table[index].deleted && table[index].key.equals(key)) {\n            return table[index].value;\n        }\n        index = (index + 1) % table.length;\n    }\n    \n    return null;\n}\n```",
      "type": "essay",
      "tags": ["해시", "충돌 해결", "Chaining", "Open Addressing"]
    }
  ]
}
