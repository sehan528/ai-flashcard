{
  "name": "자료구조",
  "description": "자료구조 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "스택 2개로 큐 만들기",
      "answer": "**두 개의 스택으로 큐를 구현하는 방법:**\n\n스택은 LIFO (Last In First Out), 큐는 FIFO (First In First Out) 구조입니다.\n\n**구현 방법:**\n\n```java\nclass QueueUsingTwoStacks {\n    Stack<Integer> inbox = new Stack<>();   // 입력용\n    Stack<Integer> outbox = new Stack<>();  // 출력용\n    \n    // Enqueue: O(1)\n    public void enqueue(int x) {\n        inbox.push(x);\n    }\n    \n    // Dequeue: Amortized O(1)\n    public int dequeue() {\n        if (outbox.isEmpty()) {\n            // inbox의 모든 원소를 outbox로 이동\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.pop();\n    }\n    \n    public int peek() {\n        if (outbox.isEmpty()) {\n            while (!inbox.isEmpty()) {\n                outbox.push(inbox.pop());\n            }\n        }\n        return outbox.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// enqueue(1, 2, 3, 4)\ninbox: [1, 2, 3, 4] (top)\noutbox: []\n\n// dequeue() 호출\ninbox → outbox 이동:\ninbox: []\noutbox: [4, 3, 2, 1] (top)\n\n// dequeue() 반환값: 1 (FIFO)\noutbox: [4, 3, 2]\n```\n\n**시간복잡도:**\n- Enqueue: O(1)\n- Dequeue: Amortized O(1) (최악 O(n), 평균 O(1))\n\n**JavaScript 구현:**\n\n```javascript\nclass QueueUsingStacks {\n    constructor() {\n        this.inbox = [];\n        this.outbox = [];\n    }\n    \n    enqueue(x) {\n        this.inbox.push(x);\n    }\n    \n    dequeue() {\n        if (this.outbox.length === 0) {\n            while (this.inbox.length > 0) {\n                this.outbox.push(this.inbox.pop());\n            }\n        }\n        return this.outbox.pop();\n    }\n}\n```",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "큐 2개로 스택 만들기",
      "answer": "**두 개의 큐로 스택을 구현하는 방법:**\n\n스택은 LIFO, 큐는 FIFO 구조입니다.\n\n**구현 방법 1: Push가 O(n)**\n\n```java\nclass StackUsingTwoQueues {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        // 새 원소를 q2에 추가\n        q2.offer(x);\n        \n        // q1의 모든 원소를 q2로 이동\n        while (!q1.isEmpty()) {\n            q2.offer(q1.poll());\n        }\n        \n        // q1과 q2를 교환\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return q1.poll();\n    }\n    \n    // Top: O(1)\n    public int top() {\n        return q1.peek();\n    }\n}\n```\n\n**동작 원리:**\n\n```\n// push(1)\nq1: [1]\nq2: []\n\n// push(2)\nq2: [2] → q1의 원소 이동 → [2, 1]\nq1과 q2 교환\nq1: [2, 1] (front가 top)\n\n// push(3)\nq2: [3] → [3, 2, 1]\nq1: [3, 2, 1]\n\n// pop() → 3 반환\n```\n\n**구현 방법 2: 하나의 큐만 사용 (더 효율적)**\n\n```java\nclass StackUsingOneQueue {\n    Queue<Integer> queue = new LinkedList<>();\n    \n    // Push: O(n)\n    public void push(int x) {\n        queue.offer(x);\n        int size = queue.size();\n        \n        // 새 원소를 맨 앞으로 이동\n        for (int i = 0; i < size - 1; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n    \n    // Pop: O(1)\n    public int pop() {\n        return queue.poll();\n    }\n}\n```\n\n**JavaScript 구현:**\n\n```javascript\nclass StackUsingQueue {\n    constructor() {\n        this.queue = [];\n    }\n    \n    push(x) {\n        this.queue.push(x);\n        // 새 원소를 맨 앞으로 회전\n        for (let i = 0; i < this.queue.length - 1; i++) {\n            this.queue.push(this.queue.shift());\n        }\n    }\n    \n    pop() {\n        return this.queue.shift();\n    }\n}\n```\n\n**시간복잡도:**\n- Push: O(n)\n- Pop: O(1)\n- Top: O(1)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Queue", "구현"]
    },
    {
      "question": "Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법에 대해 설명해 주세요.",
      "answer": "**표기법 종류:**\n\n1. **Infix (중위 표기법)**: 연산자가 피연산자 사이에 위치\n   - 예: `3 + 4 * 2`\n   - 사람이 읽기 쉽지만 우선순위 처리 복잡\n\n2. **Prefix (전위 표기법)**: 연산자가 피연산자 앞에 위치\n   - 예: `+ 3 * 4 2` → `3 + (4 * 2)`\n   - 괄호 불필요\n\n3. **Postfix (후위 표기법)**: 연산자가 피연산자 뒤에 위치\n   - 예: `3 4 2 * +` → `3 + (4 * 2)`\n   - 스택으로 계산이 가장 쉬움\n\n---\n\n**Postfix 계산 (스택 사용):**\n\n```java\npublic int evaluatePostfix(String expression) {\n    Stack<Integer> stack = new Stack<>();\n    String[] tokens = expression.split(\" \");\n    \n    for (String token : tokens) {\n        if (isOperator(token)) {\n            int b = stack.pop();\n            int a = stack.pop();\n            \n            switch (token) {\n                case \"+\": stack.push(a + b); break;\n                case \"-\": stack.push(a - b); break;\n                case \"*\": stack.push(a * b); break;\n                case \"/\": stack.push(a / b); break;\n            }\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    \n    return stack.pop();\n}\n```\n\n**동작 과정 예시: `3 4 2 * +`**\n\n```\n토큰: 3 → stack: [3]\n토큰: 4 → stack: [3, 4]\n토큰: 2 → stack: [3, 4, 2]\n토큰: * → pop 2, 4 → 4*2=8 → stack: [3, 8]\n토큰: + → pop 8, 3 → 3+8=11 → stack: [11]\n결과: 11\n```\n\n---\n\n**Infix → Postfix 변환 (Shunting Yard Algorithm):**\n\n```java\npublic String infixToPostfix(String infix) {\n    StringBuilder result = new StringBuilder();\n    Stack<Character> stack = new Stack<>();\n    \n    for (char c : infix.toCharArray()) {\n        if (Character.isDigit(c)) {\n            result.append(c).append(' ');\n        } else if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            while (!stack.isEmpty() && stack.peek() != '(') {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.pop(); // '(' 제거\n        } else if (isOperator(c)) {\n            while (!stack.isEmpty() && precedence(stack.peek()) >= precedence(c)) {\n                result.append(stack.pop()).append(' ');\n            }\n            stack.push(c);\n        }\n    }\n    \n    while (!stack.isEmpty()) {\n        result.append(stack.pop()).append(' ');\n    }\n    \n    return result.toString().trim();\n}\n\nprivate int precedence(char op) {\n    if (op == '+' || op == '-') return 1;\n    if (op == '*' || op == '/') return 2;\n    return 0;\n}\n```\n\n**예시: `3 + 4 * 2` → `3 4 2 * +`**\n\n```\n토큰: 3 → result: \"3 \", stack: []\n토큰: + → result: \"3 \", stack: [+]\n토큰: 4 → result: \"3 4 \", stack: [+]\n토큰: * → result: \"3 4 \", stack: [+, *] (우선순위 * > +)\n토큰: 2 → result: \"3 4 2 \", stack: [+, *]\n종료  → result: \"3 4 2 * +\", stack: []\n```\n\n**시간복잡도:** O(n)",
      "type": "essay",
      "tags": ["자료구조", "Stack", "Expression", "알고리즘"]
    },
    {
      "question": "(C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?",
      "answer": "**C++ `std::deque`의 내부 구조:**\n\nDeque는 \"Double-Ended Queue\"로, 양쪽 끝에서 삽입/삭제가 O(1)이면서도 Random Access가 O(1)인 자료구조입니다.\n\n**구현 방식: Map of Chunks (청크 배열)**\n\n```\n         Map (중앙 관리 배열)\n         ┌───┬───┬───┬───┬───┐\n         │ 0 │ 1 │ 2 │ 3 │ 4 │\n         └─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘\n           │   │   │   │   │\n           ↓   ↓   ↓   ↓   ↓\n        Chunk1 Chunk2 Chunk3 ... (고정 크기 배열들)\n        [][][]  [][][]  [][][]\n```\n\n**핵심 아이디어:**\n\n1. **Map (중앙 배열)**:\n   - 포인터 배열로, 각 포인터는 고정 크기 청크를 가리킴\n   - 청크 크기는 보통 512 bytes (원소 크기에 따라 다름)\n\n2. **Chunk (데이터 블록)**:\n   - 실제 데이터가 저장되는 고정 크기 배열\n   - 예: `sizeof(T) = 4` bytes → 청크당 128개 원소\n\n**Random Access 계산:**\n\n```cpp\n// index 번째 원소 접근: O(1)\nT& operator[](size_t index) {\n    size_t chunk_index = index / CHUNK_SIZE;  // 어느 청크?\n    size_t offset = index % CHUNK_SIZE;       // 청크 내 위치?\n    \n    return map[chunk_index][offset];\n}\n```\n\n**예시:**\n\n```\nCHUNK_SIZE = 4라고 가정\ndeque에 [0, 1, 2, 3, 4, 5, 6, 7, 8] 저장\n\nMap:      [0]  [1]  [2]\n           ↓    ↓    ↓\nChunk 0: [0 1 2 3]\nChunk 1: [4 5 6 7]\nChunk 2: [8 _ _ _]\n\n// deque[6] 접근\nchunk_index = 6 / 4 = 1\noffset = 6 % 4 = 2\n→ map[1][2] = 6\n```\n\n**양쪽 삽입/삭제가 O(1)인 이유:**\n\n```cpp\n// push_back\nvoid push_back(T value) {\n    if (마지막 청크가 가득 참) {\n        map에 새 청크 포인터 추가;  // Map 재할당 가능 (Amortized O(1))\n    }\n    마지막 청크에 추가;\n}\n\n// push_front\nvoid push_front(T value) {\n    if (첫 청크가 가득 참) {\n        map 앞에 새 청크 포인터 추가;\n    }\n    첫 청크에 추가;\n}\n```\n\n**Vector vs Deque 비교:**\n\n| 연산 | Vector | Deque |\n|------|--------|-------|\n| Random Access | O(1) | O(1) |\n| push_back | Amortized O(1) | Amortized O(1) |\n| push_front | O(n) | Amortized O(1) |\n| 메모리 연속성 | 연속 | 비연속 (청크 단위) |\n| 캐시 효율 | 높음 | 낮음 |\n\n**단점:**\n\n- 청크 간 이동 시 캐시 미스 발생 가능\n- Vector보다 메모리 오버헤드 큼 (Map 관리 비용)\n\n**사용 예시:**\n\n```cpp\nstd::deque<int> dq;\n\n// 양쪽 삽입 O(1)\ndq.push_back(1);   // [1]\ndq.push_front(0);  // [0, 1]\n\n// Random Access O(1)\nint x = dq[0];     // 0\nint y = dq[1];     // 1\n```",
      "type": "essay",
      "tags": ["자료구조", "Deque", "C++", "Random Access"]
    },
    {
      "question": "해시 자료구조에 대해 설명해 주세요.",
      "answer": "**해시 테이블 (Hash Table):**\n\nKey-Value 쌍을 저장하는 자료구조로, **평균 O(1) 시간복잡도**로 삽입, 삭제, 검색이 가능합니다.\n\n**핵심 구성 요소:**\n\n1. **해시 함수 (Hash Function)**\n   - Key → Index 변환\n   - 예: `hash(key) % table_size`\n\n2. **버킷 배열 (Bucket Array)**\n   - 실제 데이터를 저장하는 배열\n\n3. **충돌 해결 방법 (Collision Resolution)**\n   - Chaining: 연결 리스트로 충돌 처리\n   - Open Addressing: 빈 슬롯 찾기\n\n---\n\n**동작 원리:**\n\n```java\nclass HashTable<K, V> {\n    private static class Entry<K, V> {\n        K key;\n        V value;\n        Entry<K, V> next;  // Chaining\n    }\n    \n    private Entry<K, V>[] table;\n    private int size;\n    \n    public HashTable(int capacity) {\n        table = new Entry[capacity];\n    }\n    \n    // 삽입: O(1) 평균\n    public void put(K key, V value) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        // 중복 키 확인\n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                entry.value = value;  // 업데이트\n                return;\n            }\n            entry = entry.next;\n        }\n        \n        // 새 엔트리 추가 (체이닝)\n        Entry<K, V> newEntry = new Entry<>(key, value);\n        newEntry.next = table[index];\n        table[index] = newEntry;\n        size++;\n    }\n    \n    // 검색: O(1) 평균\n    public V get(K key) {\n        int index = hash(key);\n        Entry<K, V> entry = table[index];\n        \n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                return entry.value;\n            }\n            entry = entry.next;\n        }\n        \n        return null;\n    }\n    \n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % table.length;\n    }\n}\n```\n\n---\n\n**충돌 해결 방법:**\n\n**1. Chaining (체이닝):**\n\n```\nIndex  Bucket\n  0  → [key1, val1] → [key2, val2] → null\n  1  → null\n  2  → [key3, val3] → null\n  3  → [key4, val4] → [key5, val5] → null\n```\n\n**2. Open Addressing (개방 주소법):**\n\n- **Linear Probing**: `(h(k) + i) % m`\n- **Quadratic Probing**: `(h(k) + i²) % m`\n- **Double Hashing**: `(h1(k) + i * h2(k)) % m`\n\n---\n\n**시간복잡도:**\n\n| 연산 | 평균 | 최악 |\n|------|------|------|\n| 삽입 | O(1) | O(n) |\n| 삭제 | O(1) | O(n) |\n| 검색 | O(1) | O(n) |\n\n**최악의 경우**: 모든 키가 같은 인덱스로 해싱 → 연결 리스트처럼 동작\n\n---\n\n**Load Factor (적재율):**\n\n```\nLoad Factor = 저장된 원소 개수 / 테이블 크기\n```\n\n- Java HashMap: Load Factor 0.75 초과 시 리사이징\n- 적재율이 높을수록 충돌 증가 → 성능 저하\n\n**리사이징 (Rehashing):**\n\n```java\nprivate void resize() {\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[oldTable.length * 2];\n    \n    // 모든 엔트리 재배치\n    for (Entry<K, V> entry : oldTable) {\n        while (entry != null) {\n            put(entry.key, entry.value);\n            entry = entry.next;\n        }\n    }\n}\n```\n\n---\n\n**JavaScript 예시:**\n\n```javascript\nconst map = new Map();\nmap.set('name', 'Alice');  // O(1)\nmap.get('name');           // O(1) → 'Alice'\nmap.has('name');           // O(1) → true\nmap.delete('name');        // O(1)\n```\n\n**Java 예시:**\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"apple\", 100);   // O(1)\nint price = map.get(\"apple\");  // O(1)\nmap.containsKey(\"apple\");      // O(1)\n```\n\n**장점:**\n- 빠른 검색, 삽입, 삭제 (평균 O(1))\n- 유연한 키 타입\n\n**단점:**\n- 순서 보장 안 됨 (LinkedHashMap으로 해결)\n- 해시 충돌 가능성\n- 메모리 오버헤드 (빈 공간 존재)",
      "type": "essay",
      "tags": ["자료구조", "Hash Table", "HashMap", "시간복잡도"]
    },
    {
      "question": "값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?",
      "answer": "**좋은 해시 함수의 조건:**\n\n1. **균등 분포 (Uniform Distribution)**\n   - 모든 버킷에 데이터가 고르게 분산\n   - 충돌 최소화\n\n2. **빠른 계산**\n   - O(1) 시간에 해시값 계산\n\n3. **결정적 (Deterministic)**\n   - 같은 입력 → 항상 같은 출력\n\n---\n\n**해시 함수 설계 기법:**\n\n**1. Division Method (나눗셈)**\n\n```java\nint hash(int key, int tableSize) {\n    return key % tableSize;\n}\n```\n\n**주의사항:**\n- 테이블 크기는 **소수(prime number)** 사용 권장\n- 2의 거듭제곱은 피하기 (하위 비트만 사용되어 편향 발생)\n\n**2. Multiplication Method (곱셈)**\n\n```java\nint hash(int key, int tableSize) {\n    double A = (Math.sqrt(5) - 1) / 2;  // 황금비의 역수\n    double fractional = (key * A) % 1;  // 소수 부분만 추출\n    return (int)(tableSize * fractional);\n}\n```\n\n**3. Universal Hashing**\n\n```java\nclass UniversalHash {\n    private int a, b, p, m;\n    \n    public UniversalHash(int tableSize) {\n        this.m = tableSize;\n        this.p = nextPrime(tableSize * 2);  // tableSize보다 큰 소수\n        this.a = random(1, p);  // 랜덤 계수\n        this.b = random(0, p);\n    }\n    \n    int hash(int key) {\n        return ((a * key + b) % p) % m;\n    }\n}\n```\n\n**장점**: 최악의 경우 공격 방지 (랜덤성)\n\n---\n\n**문자열 해시:**\n\n**Polynomial Rolling Hash:**\n\n```java\nint hash(String s, int tableSize) {\n    final int p = 31;  // 소수 (알파벳 크기보다 큰)\n    final int m = 1_000_000_009;  // 큰 소수\n    \n    long hashValue = 0;\n    long pPow = 1;\n    \n    for (char c : s.toCharArray()) {\n        hashValue = (hashValue + (c - 'a' + 1) * pPow) % m;\n        pPow = (pPow * p) % m;\n    }\n    \n    return (int)(hashValue % tableSize);\n}\n```\n\n**예시:**\n```\n\"abc\" 해시값\n= (1 * 31^0 + 2 * 31^1 + 3 * 31^2) % m\n= (1 + 62 + 2883) % m\n```\n\n---\n\n**Java의 String.hashCode():**\n\n```java\npublic int hashCode() {\n    int h = 0;\n    for (char c : value) {\n        h = 31 * h + c;\n    }\n    return h;\n}\n```\n\n**왜 31을 사용?**\n- 소수라서 분포가 좋음\n- `31 * i == (i << 5) - i` (비트 연산으로 최적화 가능)\n\n---\n\n**충돌 최소화 전략:**\n\n**1. 비트 연산 활용:**\n\n```java\nint hash(int key) {\n    key ^= (key >>> 20) ^ (key >>> 12);\n    return key ^ (key >>> 7) ^ (key >>> 4);\n}\n```\n\n**2. MurmurHash (빠르고 품질 좋음):**\n\n```java\nint murmurhash(int key) {\n    key ^= key >>> 16;\n    key *= 0x85ebca6b;\n    key ^= key >>> 13;\n    key *= 0xc2b2ae35;\n    key ^= key >>> 16;\n    return key;\n}\n```\n\n---\n\n**실전 예시:**\n\n```java\n// 나쁜 예: 2의 거듭제곱 테이블 크기\nint badHash(int key) {\n    return key % 1024;  // 하위 10비트만 사용 → 편향\n}\n\n// 좋은 예: 소수 테이블 크기\nint goodHash(int key) {\n    return key % 1009;  // 균등 분포\n}\n```\n\n**테스트:**\n\n```java\n// 해시 함수 품질 테스트\nvoid testHashDistribution(HashFunction h, int[] keys) {\n    int[] buckets = new int[tableSize];\n    \n    for (int key : keys) {\n        buckets[h.hash(key)]++;\n    }\n    \n    // 표준편차 계산 (낮을수록 균등 분포)\n    double stdDev = calculateStdDev(buckets);\n}\n```",
      "type": "essay",
      "tags": ["해시", "해시 함수", "설계", "충돌"]
    },
    {
      "question": "해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?",
      "answer": "**충돌 해결 방법:**\n\n## 1. Chaining (체이닝)\n\n각 버킷을 연결 리스트로 구현하여 같은 인덱스의 원소들을 체인으로 연결\n\n```java\nclass HashTableChaining<K, V> {\n    class Node {\n        K key;\n        V value;\n        Node next;\n    }\n    \n    Node[] table;\n    \n    void put(K key, V value) {\n        int index = hash(key);\n        Node node = table[index];\n        \n        // 기존 키 업데이트\n        while (node != null) {\n            if (node.key.equals(key)) {\n                node.value = value;\n                return;\n            }\n            node = node.next;\n        }\n        \n        // 새 노드 추가 (맨 앞에)\n        Node newNode = new Node(key, value);\n        newNode.next = table[index];\n        table[index] = newNode;\n    }\n}\n```\n\n**장점:**\n- 구현 간단\n- 삭제 쉬움\n- Load Factor > 1 가능\n\n**단점:**\n- 추가 메모리 (포인터)\n- 캐시 효율 낮음\n\n---\n\n## 2. Open Addressing (개방 주소법)\n\n충돌 시 다른 빈 슬롯을 찾아 저장\n\n### 2-1. Linear Probing (선형 조사)\n\n```java\nvoid put(K key, V value) {\n    int index = hash(key);\n    \n    // 빈 슬롯 찾을 때까지\n    while (table[index] != null && !table[index].key.equals(key)) {\n        index = (index + 1) % table.length;\n    }\n    \n    table[index] = new Entry(key, value);\n}\n\nV get(K key) {\n    int index = hash(key);\n    \n    while (table[index] != null) {\n        if (table[index].key.equals(key)) {\n            return table[index].value;\n        }\n        index = (index + 1) % table.length;\n    }\n    \n    return null;\n}\n```\n\n**문제: Primary Clustering (1차 군집화)**\n- 연속된 슬롯들이 채워지면 더 긴 체인 형성\n\n### 2-2. Quadratic Probing (이차 조사)\n\n```java\nint probe(int hash, int i) {\n    return (hash + i * i) % table.length;\n}\n```\n\n**예시:**\n```\ni=0: hash\ni=1: hash + 1\ni=2: hash + 4\ni=3: hash + 9\n```\n\n**문제: Secondary Clustering (2차 군집화)**\n- 같은 해시값을 가진 키들이 같은 조사 순서\n\n### 2-3. Double Hashing (이중 해싱)\n\n```java\nint hash1(K key) {\n    return key.hashCode() % table.length;\n}\n\nint hash2(K key) {\n    return 1 + (key.hashCode() % (table.length - 1));\n}\n\nint probe(K key, int i) {\n    return (hash1(key) + i * hash2(key)) % table.length;\n}\n```\n\n**예시:**\n```\nkey = 10, table.length = 7\nhash1(10) = 3\nhash2(10) = 1 + (10 % 6) = 5\n\ni=0: 3\ni=1: (3 + 5) % 7 = 1\ni=2: (3 + 10) % 7 = 6\ni=3: (3 + 15) % 7 = 4\n```\n\n**장점:**\n- Clustering 문제 해결\n- 좋은 분포\n\n---\n\n## 3. Separate Chaining vs Open Addressing\n\n| 특성 | Chaining | Open Addressing |\n|------|----------|------------------|\n| 메모리 | 포인터 오버헤드 | 고정 크기 테이블 |\n| Load Factor | > 1 가능 | < 1 제한 |\n| 캐시 효율 | 낮음 | 높음 |\n| 삭제 | 쉬움 | 복잡 (Lazy Deletion) |\n| 성능 | 균등 | Load Factor 의존 |\n\n---\n\n**삭제 처리 (Open Addressing):**\n\n```java\nclass Entry<K, V> {\n    K key;\n    V value;\n    boolean deleted;  // Lazy deletion flag\n}\n\nvoid remove(K key) {\n    int index = findIndex(key);\n    if (index != -1) {\n        table[index].deleted = true;  // 삭제 표시\n    }\n}\n\nV get(K key) {\n    int index = hash(key);\n    \n    while (table[index] != null) {\n        if (!table[index].deleted && table[index].key.equals(key)) {\n            return table[index].value;\n        }\n        index = (index + 1) % table.length;\n    }\n    \n    return null;\n}\n```",
      "type": "essay",
      "tags": ["해시", "충돌 해결", "Chaining", "Open Addressing"]
    },
    {
      "question": "본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?",
      "answer": "## Java HashMap\n\n**충돌 처리: Separate Chaining + Tree화**\n\n```java\n// Java 8 이전: 순수 Chaining\nNode<K,V>[] table;\n\nstatic class Node<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;  // 연결 리스트\n}\n\n// Java 8+: Chaining + Red-Black Tree\n// 버킷의 원소가 8개 초과 시 Tree로 변환\n// 6개 이하로 줄면 다시 List로 변환\n```\n\n**왜 Tree로 변환?**\n- 최악의 경우 O(n) → O(log n)으로 개선\n- DoS 공격 방어 (의도적 충돌 공격)\n\n**Load Factor: 0.75**\n```java\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// 75% 차면 2배로 리사이징\nif (size > capacity * loadFactor) {\n    resize();  // capacity *= 2\n}\n```\n\n---\n\n## Python dict\n\n**충돌 처리: Open Addressing (Pseudo-random probing)**\n\n```python\n# CPython 3.6+: 순서 유지 딕셔너리\n# 내부적으로 두 배열 사용:\n# 1. indices: 해시 테이블 (Open Addressing)\n# 2. entries: 실제 키-값 쌍 배열 (삽입 순서대로)\n\nclass dict:\n    indices = [None] * capacity  # 해시 테이블\n    entries = []  # [(hash, key, value), ...]\n```\n\n**Probing 방식:**\n```python\n# Linear probing의 변형\nperturb = hash(key)\nindex = hash(key) % capacity\n\nwhile indices[index] is not None:\n    index = (5*index + 1 + perturb) % capacity\n    perturb >>= 5  # 점점 랜덤하게\n```\n\n**Load Factor: 2/3 (약 0.67)**\n```python\n# 66% 차면 2배로 리사이징\nif used > capacity * 2/3:\n    resize()\n```\n\n---\n\n## JavaScript Map/Object\n\n**Object (레거시):**\n- 구현체마다 다름 (V8, SpiderMonkey 등)\n- 주로 Hash Table + Hidden Class 최적화\n\n**Map (ES6+):**\n```javascript\nconst map = new Map();\nmap.set(key, value);  // O(1)\n\n// V8 엔진: Chaining 방식\n// 내부적으로 OrderedHashTable 사용\n// 삽입 순서 유지 + 해시 충돌 처리\n```\n\n**특징:**\n- 삽입 순서 보장\n- 모든 타입을 키로 사용 가능\n\n---\n\n## C++ std::unordered_map\n\n**충돌 처리: Separate Chaining**\n\n```cpp\ntemplate<typename Key, typename T>\nclass unordered_map {\n    vector<list<pair<Key, T>>> buckets;\n    // 각 버킷은 연결 리스트\n};\n```\n\n**Load Factor: 1.0 (기본값)**\n```cpp\nunordered_map<int, string> map;\nmap.max_load_factor();  // 1.0\n\n// 100% 차면 리사이징\nif (size() > bucket_count() * max_load_factor()) {\n    rehash();\n}\n```\n\n**사용자 정의 Load Factor:**\n```cpp\nmap.max_load_factor(0.75);  // Java처럼 0.75로 설정\n```\n\n---\n\n## 비교 표\n\n| 언어 | 충돌 처리 | Load Factor | 순서 보장 |\n|------|-----------|-------------|----------|\n| Java HashMap | Chaining + Tree | 0.75 | X |\n| Python dict | Open Addressing | 0.67 | O (3.6+) |\n| JavaScript Map | Chaining | 가변 | O |\n| C++ unordered_map | Chaining | 1.0 | X |\n\n---\n\n**각 언어의 특징:**\n\n**Java:**\n- Tree화로 최악의 경우 성능 보장\n- LinkedHashMap으로 순서 유지 가능\n\n**Python:**\n- 메모리 효율적 (Open Addressing)\n- 기본적으로 삽입 순서 유지\n\n**JavaScript:**\n- Map은 항상 삽입 순서 유지\n- Object는 숫자 키 먼저 정렬\n\n**C++:**\n- 가장 빠른 성능 (포인터 직접 제어)\n- 순서가 필요하면 `std::map` 사용",
      "type": "essay",
      "tags": ["해시", "언어별 구현", "Java", "Python", "JavaScript", "C++"]
    },
    {
      "question": "Double Hashing의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.",
      "answer": "## Double Hashing\n\n**개념:**\n```java\nint h1(K key) { return key.hashCode() % M; }\nint h2(K key) { return 1 + (key.hashCode() % (M - 1)); }\n\nint probe(K key, int i) {\n    return (h1(key) + i * h2(key)) % M;\n}\n```\n\n---\n\n## 장점\n\n**1. Clustering 문제 해결**\n\nLinear Probing의 Primary Clustering 방지:\n```\nLinear Probing:\n[X] [X] [X] [_] [_]  // 연속된 군집 발생\n     ↑\n   충돌 시 바로 옆 슬롯 사용\n\nDouble Hashing:\n[X] [_] [X] [_] [X]  // 분산된 배치\n     ↑       ↑\n   h2(key)만큼 점프\n```\n\n**2. 균등한 분포**\n\n각 키마다 다른 조사 순서:\n```java\nkey1: h2 = 3 → 3, 6, 9, 12, ...\nkey2: h2 = 5 → 5, 10, 15, 20, ...\n```\n\n**3. 캐시 효율**\n\nOpen Addressing이므로:\n- 연속된 메모리 사용\n- Chaining보다 캐시 친화적\n\n---\n\n## 단점\n\n**1. 해시 함수 계산 비용**\n\n```java\n// 두 개의 해시 함수 계산 필요\nint index = h1(key);  // 첫 번째 계산\nint step = h2(key);   // 두 번째 계산\n```\n\n**해결책:**\n```java\n// 한 번만 계산하고 재사용\nint hashCode = key.hashCode();\nint h1 = hashCode % M;\nint h2 = 1 + (hashCode % (M - 1));\n```\n\n**2. 테이블 크기 제약**\n\n**문제:** h2(key)와 M이 서로소가 아니면 모든 슬롯 방문 불가\n\n```\nM = 10, h2(key) = 2\n시작 = 3\n조사 순서: 3, 5, 7, 9, 1, 3, ... (무한 루프)\n// 0, 2, 4, 6, 8은 절대 방문 안 됨!\n```\n\n**해결책 1: M을 소수로**\n```java\n// M이 소수면 h2 값과 항상 서로소\nint M = 1009;  // 소수\nint h2 = 1 + (hashCode % (M - 1));  // 1 ~ M-1\n// gcd(h2, M) = 1 보장\n```\n\n**해결책 2: h2 범위 조정**\n```java\n// h2가 1 이상이 되도록 보장\nint h2(K key) {\n    int h = key.hashCode() % (M - 1);\n    return h == 0 ? 1 : h;  // 0 방지\n}\n```\n\n**3. 삭제 복잡도**\n\n**문제:** Lazy Deletion 필요\n\n```java\nenum State { EMPTY, OCCUPIED, DELETED }\n\nclass Entry<K, V> {\n    K key;\n    V value;\n    State state;\n}\n\n// 검색 시 DELETED는 건너뛰되 계속 탐색\nV get(K key) {\n    int i = 0;\n    while (true) {\n        int index = probe(key, i++);\n        \n        if (table[index].state == EMPTY) {\n            return null;  // 못 찾음\n        }\n        \n        if (table[index].state == DELETED) {\n            continue;  // 건너뛰고 계속\n        }\n        \n        if (table[index].key.equals(key)) {\n            return table[index].value;\n        }\n    }\n}\n```\n\n**해결책: 주기적 재해싱**\n```java\nvoid compactTable() {\n    // DELETED 상태 제거하고 재배치\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[capacity];\n    \n    for (Entry<K, V> entry : oldTable) {\n        if (entry.state == OCCUPIED) {\n            put(entry.key, entry.value);\n        }\n    }\n}\n```\n\n**4. Load Factor 제한**\n\n**문제:** Load Factor가 높으면 성능 급격히 저하\n\n```java\n// Load Factor > 0.7 이면 성능 나쁨\nif (size > capacity * 0.7) {\n    resize();  // 2배로 확장\n}\n```\n\n**해결책: 동적 리사이징**\n```java\nvoid resize() {\n    int newCapacity = nextPrime(capacity * 2);\n    Entry<K, V>[] oldTable = table;\n    table = new Entry[newCapacity];\n    \n    for (Entry<K, V> entry : oldTable) {\n        if (entry != null && entry.state == OCCUPIED) {\n            put(entry.key, entry.value);  // 재해싱\n        }\n    }\n}\n```\n\n---\n\n## 최적화된 구현 예시\n\n```java\nclass DoubleHashMap<K, V> {\n    private static final double MAX_LOAD_FACTOR = 0.7;\n    private int capacity;  // 항상 소수\n    private Entry<K, V>[] table;\n    \n    private int h1(K key) {\n        return Math.abs(key.hashCode()) % capacity;\n    }\n    \n    private int h2(K key) {\n        int h = Math.abs(key.hashCode()) % (capacity - 1);\n        return h == 0 ? 1 : h;  // 0 방지\n    }\n    \n    public void put(K key, V value) {\n        if (size > capacity * MAX_LOAD_FACTOR) {\n            resize();\n        }\n        \n        int hashCode = key.hashCode();  // 한 번만 계산\n        int h1 = Math.abs(hashCode) % capacity;\n        int h2 = 1 + Math.abs(hashCode) % (capacity - 1);\n        \n        for (int i = 0; i < capacity; i++) {\n            int index = (h1 + i * h2) % capacity;\n            \n            if (table[index] == null || table[index].state != OCCUPIED) {\n                table[index] = new Entry<>(key, value, OCCUPIED);\n                size++;\n                return;\n            }\n        }\n    }\n}\n```\n\n---\n\n## 결론\n\n**Double Hashing 사용 시기:**\n- Open Addressing 필요 (메모리 제약)\n- 높은 성능 필요 (캐시 효율)\n- 삭제 연산 적음\n\n**대안:**\n- 삭제가 많으면: **Chaining**\n- 구현 간단함 우선: **Linear Probing**\n- 최고 성능: **Cuckoo Hashing**",
      "type": "essay",
      "tags": ["Double Hashing", "해시", "충돌 해결", "성능 최적화"]
    },
    {
      "question": "Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?",
      "answer": "## Load Factor (적재율)\n\n**정의:**\n```\nLoad Factor (α) = 저장된 원소 개수 / 테이블 크기\n                = n / m\n```\n\n**의미:**\n- 해시 테이블이 얼마나 차 있는지를 나타내는 지표\n- 충돌 확률과 직접적으로 연관\n\n---\n\n## Load Factor와 성능\n\n**Chaining 방식:**\n```\nα = 0.5  → 평균 체인 길이: 0.5\nα = 1.0  → 평균 체인 길이: 1.0\nα = 2.0  → 평균 체인 길이: 2.0\n\n검색 시간: O(1 + α)\n```\n\n**Open Addressing 방식:**\n```\nα = 0.5  → 평균 조사 횟수: ~1.5\nα = 0.7  → 평균 조사 횟수: ~2.5\nα = 0.9  → 평균 조사 횟수: ~5.5\nα = 0.99 → 평균 조사 횟수: ~50\n\n// α가 1에 가까워질수록 급격히 느려짐\n```\n\n---\n\n## Java HashMap\n\n**기본 Load Factor: 0.75**\n\n```java\npublic class HashMap<K,V> {\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    static final int DEFAULT_INITIAL_CAPACITY = 16;\n    \n    // threshold = capacity * loadFactor\n    int threshold;\n    \n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        this.threshold = (int)(16 * 0.75);  // 12\n    }\n}\n```\n\n**리사이징 정책:**\n```java\npublic V put(K key, V value) {\n    // ...\n    if (++size > threshold) {\n        resize();  // 2배로 확장\n    }\n    return null;\n}\n\nfinal Node<K,V>[] resize() {\n    int oldCap = table.length;\n    int newCap = oldCap << 1;  // 2배\n    threshold = (int)(newCap * loadFactor);\n    \n    // 모든 원소 재해싱\n    Node<K,V>[] newTab = new Node[newCap];\n    // ... rehashing logic\n    return newTab;\n}\n```\n\n**왜 0.75?**\n- 0.75는 시간-공간 트레이드오프의 최적값\n- 너무 낮으면: 메모리 낭비\n- 너무 높으면: 충돌 증가, 성능 저하\n\n**사용자 정의 Load Factor:**\n```java\n// 메모리 중요 시\nMap<K,V> map = new HashMap<>(16, 0.9f);\n\n// 성능 중요 시\nMap<K,V> map = new HashMap<>(16, 0.5f);\n```\n\n---\n\n## Python dict\n\n**Load Factor: 2/3 (약 0.67)**\n\n```python\n# CPython 내부 구현\n#define USABLE_FRACTION(n) (((n) << 1) / 3)\n\n# 66.7% 차면 리사이징\nif (mp->ma_used > mp->ma_mask * 2/3):\n    dictresize(mp)\n```\n\n**리사이징 정책:**\n```python\n# 크기에 따라 증가 배수 다름\nif size < 50000:\n    new_size = size * 4  # 4배\nelse:\n    new_size = size * 2  # 2배\n```\n\n**특징:**\n- Java보다 낮은 Load Factor (더 공격적)\n- 메모리보다 속도 우선\n- 삽입 순서 유지를 위한 추가 구조\n\n---\n\n## JavaScript (V8 Engine)\n\n**Object:**\n```javascript\n// Hidden Class 최적화\n// Load Factor 정책은 엔진마다 다름\n// V8: 대략 0.75 사용\n```\n\n**Map:**\n```javascript\nconst map = new Map();\n\n// OrderedHashTable 사용\n// Load Factor: 약 1.0\n// 100% 차면 리사이징\n```\n\n---\n\n## C++ std::unordered_map\n\n**기본 Load Factor: 1.0**\n\n```cpp\nstd::unordered_map<int, string> map;\n\nstd::cout << map.max_load_factor();  // 1.0\nstd::cout << map.load_factor();      // 현재 적재율\n\n// 현재 상태\nstd::cout << map.size();             // 원소 개수\nstd::cout << map.bucket_count();     // 버킷 개수\n```\n\n**사용자 정의:**\n```cpp\nmap.max_load_factor(0.75);  // Java처럼 설정\n\n// 수동 리사이징\nmap.reserve(1000);  // 최소 1000개 수용 가능하도록\nmap.rehash(100);    // 버킷 개수를 100개로\n```\n\n**리사이징 정책:**\n```cpp\n// GCC libstdc++ 구현\nif (size() > bucket_count() * max_load_factor()) {\n    rehash(bucket_count() * 2);  // 2배\n}\n```\n\n---\n\n## 언어별 비교\n\n| 언어 | Load Factor | 리사이징 배수 | 비고 |\n|------|-------------|---------------|------|\n| Java | 0.75 | 2배 | 균형잡힌 설정 |\n| Python | 0.67 | 4배 (작을 때), 2배 (클 때) | 속도 우선 |\n| C++ | 1.0 | 2배 | 메모리 효율 |\n| JavaScript | ~0.75 ~ 1.0 | 엔진마다 다름 | 구현체 의존 |\n\n---\n\n## 최적 Load Factor 선택\n\n**Chaining 방식:**\n```java\n// 일반적으로 0.75 ~ 1.0\n// α = 1.0이어도 성능 괜찮음\nLoadFactor = 0.75;  // 추천\n```\n\n**Open Addressing 방식:**\n```java\n// 반드시 < 1.0\n// 0.5 ~ 0.7 추천\nLoadFactor = 0.6;  // 안정적\n```\n\n**성능 테스트 예시:**\n```java\n// 100만 개 삽입 테스트\nLoadFactor 0.5: 150ms, 메모리 20MB\nLoadFactor 0.75: 180ms, 메모리 15MB  // 균형\nLoadFactor 0.9: 250ms, 메모리 12MB\nLoadFactor 1.0: 400ms, 메모리 10MB\n```",
      "type": "essay",
      "tags": ["Load Factor", "해시", "성능", "메모리"]
    },
    {
      "question": "다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.",
      "answer": "## 해시 테이블의 멀티스레드 문제\n\n**Race Condition 발생 시나리오:**\n\n```java\n// Thread 1: put(\"A\", 1)\n// Thread 2: put(\"B\", 2)\n// 동시에 같은 버킷 수정 → 데이터 손실\n\n// Thread 1: resize() 진행 중\n// Thread 2: get(\"key\") 호출\n// → 일관성 없는 데이터 읽기\n```\n\n---\n\n## 해결 방법\n\n### 1. 전체 테이블 락 (Coarse-grained Locking)\n\n```java\nclass SynchronizedHashMap<K, V> {\n    private Map<K, V> map = new HashMap<>();\n    \n    public synchronized void put(K key, V value) {\n        map.put(key, value);\n    }\n    \n    public synchronized V get(K key) {\n        return map.get(key);\n    }\n}\n```\n\n**장점:** 구현 간단  \n**단점:** 모든 스레드가 순차 실행 → 병렬성 0\n\n---\n\n### 2. 버킷별 락 (Fine-grained Locking)\n\n```java\nclass BucketLockedHashMap<K, V> {\n    private static final int BUCKET_COUNT = 16;\n    private List<Entry<K, V>>[] buckets = new List[BUCKET_COUNT];\n    private ReentrantLock[] locks = new ReentrantLock[BUCKET_COUNT];\n    \n    public BucketLockedHashMap() {\n        for (int i = 0; i < BUCKET_COUNT; i++) {\n            buckets[i] = new ArrayList<>();\n            locks[i] = new ReentrantLock();\n        }\n    }\n    \n    public void put(K key, V value) {\n        int bucket = hash(key) % BUCKET_COUNT;\n        locks[bucket].lock();\n        try {\n            // 버킷 내 검색 및 삽입\n            for (Entry<K, V> entry : buckets[bucket]) {\n                if (entry.key.equals(key)) {\n                    entry.value = value;\n                    return;\n                }\n            }\n            buckets[bucket].add(new Entry<>(key, value));\n        } finally {\n            locks[bucket].unlock();\n        }\n    }\n}\n```\n\n**장점:** 다른 버킷 동시 접근 가능  \n**단점:** 리사이징 시 모든 락 필요\n\n---\n\n### 3. Lock-Free (CAS 기반)\n\n**Compare-And-Swap 활용:**\n\n```java\nclass LockFreeHashMap<K, V> {\n    private AtomicReferenceArray<Node<K, V>> table;\n    \n    static class Node<K, V> {\n        final K key;\n        volatile V value;\n        volatile Node<K, V> next;\n    }\n    \n    public void put(K key, V value) {\n        int index = hash(key);\n        \n        while (true) {\n            Node<K, V> head = table.get(index);\n            \n            // 기존 키 찾기\n            Node<K, V> node = head;\n            while (node != null) {\n                if (node.key.equals(key)) {\n                    node.value = value;  // volatile write\n                    return;\n                }\n                node = node.next;\n            }\n            \n            // 새 노드 추가 (CAS)\n            Node<K, V> newNode = new Node<>(key, value);\n            newNode.next = head;\n            \n            if (table.compareAndSet(index, head, newNode)) {\n                return;  // 성공\n            }\n            // 실패 시 재시도\n        }\n    }\n}\n```\n\n**장점:** 락 오버헤드 없음  \n**단점:** ABA 문제, 복잡한 구현\n\n---\n\n### 4. Striped Locking (세그먼트 락)\n\n**Java ConcurrentHashMap 방식:**\n\n```java\nclass StripedHashMap<K, V> {\n    private static final int STRIPE_COUNT = 32;\n    \n    private Segment<K, V>[] segments = new Segment[STRIPE_COUNT];\n    \n    static class Segment<K, V> {\n        private ReentrantLock lock = new ReentrantLock();\n        private Map<K, V> map = new HashMap<>();\n        \n        public void put(K key, V value) {\n            lock.lock();\n            try {\n                map.put(key, value);\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public void put(K key, V value) {\n        int segment = hash(key) % STRIPE_COUNT;\n        segments[segment].put(key, value);\n    }\n}\n```\n\n**장점:** 병렬성 증가 (최대 32개 스레드 동시 실행)  \n**단점:** 세그먼트 수만큼만 병렬 가능\n\n---\n\n### 5. 최적 설계: Lock-Free + Optimistic Read\n\n**Java 8+ ConcurrentHashMap 방식:**\n\n```java\nclass OptimizedConcurrentHashMap<K, V> {\n    private volatile Node<K, V>[] table;\n    \n    static class Node<K, V> {\n        final int hash;\n        final K key;\n        volatile V value;\n        volatile Node<K, V> next;\n    }\n    \n    // CAS를 이용한 버킷 헤드 업데이트\n    private static final VarHandle TABLE;\n    \n    public V get(K key) {\n        Node<K, V>[] tab = table;\n        Node<K, V> node = tabAt(tab, hash(key));\n        \n        // Lock-Free Read\n        while (node != null) {\n            if (node.key.equals(key)) {\n                return node.value;\n            }\n            node = node.next;\n        }\n        return null;\n    }\n    \n    public void put(K key, V value) {\n        int hash = hash(key);\n        Node<K, V>[] tab = table;\n        \n        for (;;) {\n            Node<K, V> f = tabAt(tab, hash);\n            \n            if (f == null) {\n                // 빈 버킷: CAS로 추가\n                if (casTabAt(tab, hash, null, new Node<>(key, value))) {\n                    break;\n                }\n            } else {\n                // 버킷에 노드 있음: synchronized로 보호\n                synchronized (f) {\n                    // Double-check\n                    if (tabAt(tab, hash) == f) {\n                        // 체이닝 로직\n                        Node<K, V> node = f;\n                        while (true) {\n                            if (node.key.equals(key)) {\n                                node.value = value;\n                                break;\n                            }\n                            if (node.next == null) {\n                                node.next = new Node<>(key, value);\n                                break;\n                            }\n                            node = node.next;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n```\n\n**핵심 아이디어:**\n1. **읽기**: 완전 Lock-Free (volatile read)\n2. **쓰기 (빈 버킷)**: CAS로 Lock-Free\n3. **쓰기 (충돌)**: 버킷 헤드만 synchronized\n\n**장점:**\n- 읽기 성능 극대화\n- 쓰기도 대부분 Lock-Free\n- 충돌 시에만 최소한의 락\n\n---\n\n## 리사이징 처리\n\n**점진적 리사이징 (Incremental Resize):**\n\n```java\n// 한 번에 모든 버킷 이동 X\n// 각 연산마다 일부 버킷만 이동\npublic V get(K key) {\n    // 리사이징 중이면 1~2개 버킷 이동 도움\n    helpTransfer();\n    \n    // 실제 get 로직\n    return getValue(key);\n}\n```\n\n---\n\n## 성능 비교\n\n**16 스레드, 100만 연산 기준:**\n\n| 방식 | 처리량 (ops/sec) | 특징 |\n|------|------------------|------|\n| Synchronized | 100K | 순차 실행 |\n| Bucket Lock (16) | 800K | 버킷 수만큼 병렬 |\n| Striped (32) | 1.5M | 세그먼트 수만큼 병렬 |\n| ConcurrentHashMap | 3.5M | Lock-Free Read |\n\n---\n\n## 실전 사용\n\n**Java:**\n```java\nConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();\nmap.put(key, value);  // Thread-Safe\n```\n\n**Python:**\n```python\nimport threading\n\nclass ThreadSafeDict:\n    def __init__(self):\n        self.dict = {}\n        self.lock = threading.RLock()\n    \n    def put(self, key, value):\n        with self.lock:\n            self.dict[key] = value\n```\n\n**C++:**\n```cpp\n#include <shared_mutex>\n\ntemplate<typename K, typename V>\nclass ConcurrentMap {\n    std::unordered_map<K, V> map;\n    mutable std::shared_mutex mutex;\n    \npublic:\n    V get(K key) {\n        std::shared_lock lock(mutex);  // 읽기 락\n        return map[key];\n    }\n    \n    void put(K key, V value) {\n        std::unique_lock lock(mutex);  // 쓰기 락\n        map[key] = value;\n    }\n};\n```",
      "type": "essay",
      "tags": ["멀티스레드", "Thread Safe", "해시", "동시성", "ConcurrentHashMap"]
    },
    {
      "question": "트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.",
      "answer": "## 트리 (Tree)\n\n**정의:**  \n계층적 구조를 가진 비선형 자료구조. 하나의 루트 노드에서 시작하여 부모-자식 관계로 연결됩니다.\n\n**기본 용어:**\n```\n         1         ← Root (루트)\n       /   \\\n      2     3       ← Internal Node (내부 노드)\n     / \\     \\\n    4   5     6     ← Leaf (리프)\n\n- 노드 (Node): 트리의 각 원소\n- 간선 (Edge): 노드 간의 연결\n- 루트 (Root): 최상위 노드\n- 리프 (Leaf): 자식이 없는 노드\n- 높이 (Height): 루트부터 가장 깊은 리프까지의 거리\n- 깊이 (Depth): 루트부터 특정 노드까지의 거리\n- 서브트리 (Subtree): 특정 노드를 루트로 하는 트리\n```\n\n**트리의 성질:**\n- N개의 노드 → N-1개의 간선\n- 사이클이 없음 (Acyclic)\n- 임의의 두 노드 사이에 경로는 유일\n\n---\n\n## 이진트리 (Binary Tree)\n\n**정의:**  \n각 노드가 **최대 2개의 자식**만 가지는 트리\n\n**기본 구조:**\n\n```java\nclass TreeNode {\n    int value;\n    TreeNode left;   // 왼쪽 자식\n    TreeNode right;  // 오른쪽 자식\n    \n    TreeNode(int value) {\n        this.value = value;\n    }\n}\n```\n\n**이진트리 종류:**\n\n**1. Full Binary Tree (정 이진트리)**\n```\n       1\n     /   \\\n    2     3\n   / \\   / \\\n  4   5 6   7\n\n// 모든 노드가 0개 또는 2개의 자식\n```\n\n**2. Complete Binary Tree (완전 이진트리)**\n```\n       1\n     /   \\\n    2     3\n   / \\   /\n  4   5 6\n\n// 마지막 레벨 제외, 모든 레벨이 꽉 참\n// 마지막 레벨은 왼쪽부터 채워짐\n```\n\n**3. Perfect Binary Tree (포화 이진트리)**\n```\n       1\n     /   \\\n    2     3\n   / \\   / \\\n  4   5 6   7\n\n// 모든 리프가 같은 레벨\n// 높이 h → 노드 개수: 2^(h+1) - 1\n```\n\n**4. Skewed Binary Tree (편향 이진트리)**\n```\n    1\n     \\\n      2\n       \\\n        3\n         \\\n          4\n\n// 한쪽으로만 치우침\n// 최악의 경우 (연결 리스트와 동일)\n```\n\n**이진트리 순회:**\n\n```java\n// 전위 순회 (Pre-order): Root → Left → Right\nvoid preorder(TreeNode node) {\n    if (node == null) return;\n    System.out.print(node.value + \" \");\n    preorder(node.left);\n    preorder(node.right);\n}\n\n// 중위 순회 (In-order): Left → Root → Right\nvoid inorder(TreeNode node) {\n    if (node == null) return;\n    inorder(node.left);\n    System.out.print(node.value + \" \");\n    inorder(node.right);\n}\n\n// 후위 순회 (Post-order): Left → Right → Root\nvoid postorder(TreeNode node) {\n    if (node == null) return;\n    postorder(node.left);\n    postorder(node.right);\n    System.out.print(node.value + \" \");\n}\n```\n\n**예시:**\n```\n     4\n   /   \\\n  2     6\n / \\   / \\\n1   3 5   7\n\nPreorder:  4 2 1 3 6 5 7\nInorder:   1 2 3 4 5 6 7  ← 정렬된 순서!\nPostorder: 1 3 2 5 7 6 4\n```\n\n---\n\n## 이진탐색트리 (Binary Search Tree, BST)\n\n**정의:**  \n모든 노드가 다음 조건을 만족하는 이진트리:\n1. **왼쪽 서브트리**의 모든 값 < **현재 노드 값**\n2. **오른쪽 서브트리**의 모든 값 > **현재 노드 값**\n3. 왼쪽과 오른쪽 서브트리도 각각 BST\n\n**예시:**\n```\n       8\n     /   \\\n    3     10\n   / \\      \\\n  1   6      14\n     / \\    /\n    4   7  13\n\nBST 조건 체크:\n- 8의 왼쪽: 3, 1, 6, 4, 7 (모두 < 8) ✓\n- 8의 오른쪽: 10, 14, 13 (모두 > 8) ✓\n```\n\n**BST 연산:**\n\n**1. 검색 (Search): O(h)**\n```java\nTreeNode search(TreeNode node, int target) {\n    if (node == null || node.value == target) {\n        return node;\n    }\n    \n    if (target < node.value) {\n        return search(node.left, target);\n    } else {\n        return search(node.right, target);\n    }\n}\n```\n\n**2. 삽입 (Insert): O(h)**\n```java\nTreeNode insert(TreeNode node, int value) {\n    if (node == null) {\n        return new TreeNode(value);\n    }\n    \n    if (value < node.value) {\n        node.left = insert(node.left, value);\n    } else if (value > node.value) {\n        node.right = insert(node.right, value);\n    }\n    \n    return node;\n}\n```\n\n**3. 삭제 (Delete): O(h)**\n```java\nTreeNode delete(TreeNode node, int value) {\n    if (node == null) return null;\n    \n    if (value < node.value) {\n        node.left = delete(node.left, value);\n    } else if (value > node.value) {\n        node.right = delete(node.right, value);\n    } else {\n        // Case 1: 리프 노드\n        if (node.left == null && node.right == null) {\n            return null;\n        }\n        // Case 2: 자식 1개\n        if (node.left == null) return node.right;\n        if (node.right == null) return node.left;\n        \n        // Case 3: 자식 2개\n        // → 오른쪽 서브트리의 최솟값으로 대체\n        TreeNode min = findMin(node.right);\n        node.value = min.value;\n        node.right = delete(node.right, min.value);\n    }\n    \n    return node;\n}\n```\n\n**시간복잡도:**\n- 평균: O(log n)\n- 최악: O(n) (편향 트리)\n\n**비교:**\n\n| 연산 | 배열 (정렬) | 연결 리스트 | BST (평균) | BST (최악) |\n|------|-------------|-------------|------------|------------|\n| 검색 | O(log n) | O(n) | O(log n) | O(n) |\n| 삽입 | O(n) | O(1) | O(log n) | O(n) |\n| 삭제 | O(n) | O(n) | O(log n) | O(n) |\n\n**장점:**\n- 정렬된 데이터 유지\n- 빠른 검색, 삽입, 삭제 (평균)\n\n**단점:**\n- 편향 시 성능 저하 → BBST로 해결 (AVL, Red-Black Tree)",
      "type": "essay",
      "tags": ["트리", "이진트리", "이진탐색트리", "BST"]
    },
    {
      "question": "이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?",
      "answer": "## 중위 탐색 (In-order Traversal)\n\n**정의:**  \n**Left → Root → Right** 순서로 트리를 순회\n\n```java\nvoid inorder(TreeNode node) {\n    if (node == null) return;\n    inorder(node.left);           // 왼쪽 서브트리\n    System.out.print(node.value + \" \");  // 현재 노드\n    inorder(node.right);          // 오른쪽 서브트리\n}\n```\n\n---\n\n## BST에서 중위 탐색의 의미\n\n**핵심: 중위 탐색 결과 = 오름차순 정렬**\n\n**예시:**\n```\n       8\n     /   \\\n    3     10\n   / \\      \\\n  1   6      14\n     / \\    /\n    4   7  13\n\n중위 탐색 결과: 1 3 4 6 7 8 10 13 14\n→ 오름차순으로 정렬됨!\n```\n\n**증명:**\n\nBST의 성질:\n- 왼쪽 서브트리의 모든 값 < 현재 노드\n- 오른쪽 서브트리의 모든 값 > 현재 노드\n\n중위 탐색 순서:\n1. 왼쪽 서브트리 방문 (현재 노드보다 작은 값들)\n2. 현재 노드 방문\n3. 오른쪽 서브트리 방문 (현재 노드보다 큰 값들)\n\n→ **작은 값 → 중간 값 → 큰 값** 순서로 방문\n\n---\n\n## 실전 활용\n\n**1. BST 검증**\n\n```java\n// BST가 올바른지 확인\nboolean isBST(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    inorder(root, result);\n    \n    // 오름차순인지 확인\n    for (int i = 1; i < result.size(); i++) {\n        if (result.get(i) <= result.get(i - 1)) {\n            return false;  // BST 아님\n        }\n    }\n    return true;\n}\n\nvoid inorder(TreeNode node, List<Integer> result) {\n    if (node == null) return;\n    inorder(node.left, result);\n    result.add(node.value);\n    inorder(node.right, result);\n}\n```\n\n**2. K번째 작은 원소 찾기**\n\n```java\n// BST에서 K번째 작은 원소 찾기\nclass Solution {\n    private int count = 0;\n    private int result = -1;\n    \n    int kthSmallest(TreeNode root, int k) {\n        inorder(root, k);\n        return result;\n    }\n    \n    void inorder(TreeNode node, int k) {\n        if (node == null) return;\n        \n        inorder(node.left, k);\n        \n        count++;\n        if (count == k) {\n            result = node.value;  // K번째 원소\n            return;\n        }\n        \n        inorder(node.right, k);\n    }\n}\n```\n\n**예시:**\n```\n     5\n   /   \\\n  3     7\n / \\   / \\\n2   4 6   8\n\n중위 탐색: 2 3 4 5 6 7 8\n\nkthSmallest(root, 1) → 2\nkthSmallest(root, 3) → 4\nkthSmallest(root, 5) → 6\n```\n\n**3. 범위 내 원소 찾기**\n\n```java\n// [low, high] 범위 내 모든 원소 찾기\nList<Integer> rangeBST(TreeNode root, int low, int high) {\n    List<Integer> result = new ArrayList<>();\n    inorderRange(root, low, high, result);\n    return result;\n}\n\nvoid inorderRange(TreeNode node, int low, int high, List<Integer> result) {\n    if (node == null) return;\n    \n    // 왼쪽 서브트리 탐색 (node.value > low인 경우만)\n    if (node.value > low) {\n        inorderRange(node.left, low, high, result);\n    }\n    \n    // 현재 노드가 범위 내라면 추가\n    if (node.value >= low && node.value <= high) {\n        result.add(node.value);\n    }\n    \n    // 오른쪽 서브트리 탐색 (node.value < high인 경우만)\n    if (node.value < high) {\n        inorderRange(node.right, low, high, result);\n    }\n}\n```\n\n**4. BST를 정렬된 배열로 변환**\n\n```java\nint[] BSTtoArray(TreeNode root) {\n    List<Integer> list = new ArrayList<>();\n    inorder(root, list);\n    \n    // List → Array\n    return list.stream().mapToInt(i -> i).toArray();\n}\n```\n\n**5. 정렬된 배열 → BST 변환**\n\n```java\n// 정렬된 배열을 균형 BST로 변환\nTreeNode sortedArrayToBST(int[] nums) {\n    return build(nums, 0, nums.length - 1);\n}\n\nTreeNode build(int[] nums, int left, int right) {\n    if (left > right) return null;\n    \n    int mid = left + (right - left) / 2;\n    TreeNode node = new TreeNode(nums[mid]);\n    \n    node.left = build(nums, left, mid - 1);\n    node.right = build(nums, mid + 1, right);\n    \n    return node;\n}\n```\n\n**예시:**\n```\n배열: [1, 2, 3, 4, 5, 6, 7]\n\n생성된 균형 BST:\n       4\n     /   \\\n    2     6\n   / \\   / \\\n  1   3 5   7\n\n중위 탐색: 1 2 3 4 5 6 7 (원래 배열과 동일)\n```\n\n---\n\n## 다른 순회와 비교\n\n```\n       8\n     /   \\\n    3     10\n   / \\      \\\n  1   6      14\n\n중위 (In-order):   1 3 6 8 10 14  ← 정렬됨!\n전위 (Pre-order):  8 3 1 6 10 14  ← 트리 복원 가능\n후위 (Post-order): 1 6 3 14 10 8  ← 삭제 순서\n```\n\n**용도:**\n- **중위**: 정렬된 순서 출력\n- **전위**: 트리 직렬화/복사\n- **후위**: 트리 삭제/평가\n\n---\n\n## 시간/공간 복잡도\n\n**시간복잡도:** O(n)  \n- 모든 노드를 한 번씩 방문\n\n**공간복잡도:** O(h)  \n- 재귀 스택 깊이 = 트리 높이\n- 균형 트리: O(log n)\n- 편향 트리: O(n)\n\n**반복문 구현 (스택 사용):**\n\n```java\nvoid inorderIterative(TreeNode root) {\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode current = root;\n    \n    while (current != null || !stack.isEmpty()) {\n        // 왼쪽 끝까지 이동\n        while (current != null) {\n            stack.push(current);\n            current = current.left;\n        }\n        \n        // 현재 노드 처리\n        current = stack.pop();\n        System.out.print(current.value + \" \");\n        \n        // 오른쪽으로 이동\n        current = current.right;\n    }\n}\n```",
      "type": "essay",
      "tags": ["이진탐색트리", "중위 탐색", "In-order", "순회"]
    },
    {
      "question": "이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.",
      "answer": "## 이진탐색트리 (BST) 주요 연산\n\n### 1. 검색 (Search)\n\n**시간복잡도:**\n- **평균**: O(log n)\n- **최악**: O(n)\n- **최선**: O(1)\n\n**구현:**\n```java\nTreeNode search(TreeNode node, int target) {\n    if (node == null || node.value == target) {\n        return node;  // 최선: O(1)\n    }\n    \n    if (target < node.value) {\n        return search(node.left, target);  // 왼쪽으로\n    } else {\n        return search(node.right, target); // 오른쪽으로\n    }\n}\n```\n\n**왜 O(log n)?**\n\n```\n균형 BST (높이 h = log n):\n           8\n         /   \\\n        4     12\n       / \\   / \\\n      2   6 10  14\n\n검색: 14 찾기\n1. 8과 비교 → 오른쪽\n2. 12와 비교 → 오른쪽\n3. 14 찾음!\n\n최대 비교 횟수 = 트리 높이 = log₂(n)\n```\n\n**왜 최악이 O(n)?**\n\n```\n편향 BST (높이 h = n):\n    1\n     \\\n      2\n       \\\n        3\n         \\\n          4\n\n검색: 4 찾기\n1 → 2 → 3 → 4 (연결 리스트와 동일)\n\n최대 비교 횟수 = n\n```\n\n---\n\n### 2. 삽입 (Insert)\n\n**시간복잡도:**\n- **평균**: O(log n)\n- **최악**: O(n)\n\n**구현:**\n```java\nTreeNode insert(TreeNode node, int value) {\n    // 1. 빈 위치 찾기: O(h)\n    if (node == null) {\n        return new TreeNode(value);  // 2. 삽입: O(1)\n    }\n    \n    if (value < node.value) {\n        node.left = insert(node.left, value);\n    } else if (value > node.value) {\n        node.right = insert(node.right, value);\n    }\n    \n    return node;\n}\n```\n\n**왜 O(log n)?**\n\n```\n삽입 과정 = 검색 + 노드 생성\n\n1. 삽입 위치 찾기: O(h) = O(log n)\n2. 노드 생성: O(1)\n\n전체: O(log n) + O(1) = O(log n)\n```\n\n---\n\n### 3. 삭제 (Delete)\n\n**시간복잡도:**\n- **평균**: O(log n)\n- **최악**: O(n)\n\n**구현:**\n```java\nTreeNode delete(TreeNode node, int value) {\n    if (node == null) return null;\n    \n    // 1. 삭제할 노드 찾기: O(h)\n    if (value < node.value) {\n        node.left = delete(node.left, value);\n    } else if (value > node.value) {\n        node.right = delete(node.right, value);\n    } else {\n        // 2. 삭제 처리: O(1) or O(h)\n        \n        // Case 1: 리프 노드 - O(1)\n        if (node.left == null && node.right == null) {\n            return null;\n        }\n        \n        // Case 2: 자식 1개 - O(1)\n        if (node.left == null) return node.right;\n        if (node.right == null) return node.left;\n        \n        // Case 3: 자식 2개 - O(h)\n        // 오른쪽 서브트리의 최솟값 찾기\n        TreeNode min = findMin(node.right);  // O(h)\n        node.value = min.value;\n        node.right = delete(node.right, min.value);\n    }\n    \n    return node;\n}\n\n// 최솟값 찾기: O(h)\nTreeNode findMin(TreeNode node) {\n    while (node.left != null) {\n        node = node.left;\n    }\n    return node;\n}\n```\n\n**왜 O(log n)?**\n\n```\n삭제 과정:\n1. 노드 찾기: O(h)\n2. Case 3의 경우:\n   - 후계자 찾기: O(h)\n   - 후계자 삭제: O(h)\n\n전체: O(h) + O(h) = O(h) = O(log n)\n```\n\n---\n\n### 4. 최솟값/최댓값 찾기\n\n**시간복잡도:**\n- **평균**: O(log n)\n- **최악**: O(n)\n\n**구현:**\n```java\n// 최솟값: 왼쪽 끝\nint findMin(TreeNode node) {\n    while (node.left != null) {\n        node = node.left;\n    }\n    return node.value;\n}\n\n// 최댓값: 오른쪽 끝\nint findMax(TreeNode node) {\n    while (node.right != null) {\n        node = node.right;\n    }\n    return node.value;\n}\n```\n\n**왜 O(log n)?**\n\n```\n균형 BST:\n       8\n     /   \\\n    4     12\n   /\n  2\n /\n1    ← 최솟값 (높이만큼 탐색)\n\n탐색 횟수 = 트리 높이 = log n\n```\n\n---\n\n### 5. 중위 순회 (Inorder Traversal)\n\n**시간복잡도:** O(n)  \n**공간복잡도:** O(h) (재귀 스택)\n\n**구현:**\n```java\nvoid inorder(TreeNode node) {\n    if (node == null) return;\n    inorder(node.left);   // n/2 노드\n    visit(node);          // O(1)\n    inorder(node.right);  // n/2 노드\n}\n```\n\n**왜 O(n)?**\n\n```\n모든 노드를 정확히 한 번씩 방문\n\nT(n) = T(n/2) + T(n/2) + O(1)\n     = 2 * T(n/2) + O(1)\n     = O(n)  // Master Theorem\n```\n\n---\n\n## 시간복잡도 비교표\n\n| 연산 | 평균 (균형) | 최악 (편향) | 최선 |\n|------|-------------|-------------|------|\n| 검색 | O(log n) | O(n) | O(1) |\n| 삽입 | O(log n) | O(n) | O(log n) |\n| 삭제 | O(log n) | O(n) | O(log n) |\n| 최솟값/최댓값 | O(log n) | O(n) | O(1) |\n| 순회 | O(n) | O(n) | O(n) |\n\n---\n\n## 높이와 시간복잡도 관계\n\n**핵심: 모든 연산의 시간복잡도 = O(h)**\n\n**균형 트리 (h = log n):**\n```\n완전 이진트리:\n       1\n     /   \\\n    2     3\n   / \\   / \\\n  4   5 6   7\n / \\\n8   9\n\nn = 9\nh = log₂(9) ≈ 3.17 → 높이 = 3\n\n연산 시간 = O(3) = O(log 9)\n```\n\n**편향 트리 (h = n):**\n```\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n\nn = 4\nh = 4\n\n연산 시간 = O(4) = O(n)\n```\n\n---\n\n## 공간복잡도\n\n**저장 공간:** O(n)\n- n개 노드 저장\n\n**재귀 호출 스택:** O(h)\n- 검색, 삽입, 삭제 모두 재귀 깊이 = 트리 높이\n- 균형 트리: O(log n)\n- 편향 트리: O(n)\n\n**반복문 구현 시:** O(1)\n```java\n// 반복문으로 검색 - 스택 불필요\nTreeNode searchIterative(TreeNode node, int target) {\n    while (node != null && node.value != target) {\n        if (target < node.value) {\n            node = node.left;\n        } else {\n            node = node.right;\n        }\n    }\n    return node;\n}\n```\n\n---\n\n## 다른 자료구조와 비교\n\n| 자료구조 | 검색 | 삽입 | 삭제 | 공간 |\n|----------|------|------|------|------|\n| 배열 (정렬) | O(log n) | O(n) | O(n) | O(n) |\n| 연결 리스트 | O(n) | O(1)* | O(n) | O(n) |\n| BST (평균) | O(log n) | O(log n) | O(log n) | O(n) |\n| BST (최악) | O(n) | O(n) | O(n) | O(n) |\n| AVL/Red-Black | O(log n) | O(log n) | O(log n) | O(n) |\n| 해시 테이블 | O(1) | O(1) | O(1) | O(n) |\n\n*연결 리스트 삽입은 위치를 알고 있을 때 O(1)\n\n---\n\n## 성능 개선: BBST (Balanced Binary Search Tree)\n\n**문제:** 편향 시 O(n)\n\n**해결:** 자동으로 균형 유지\n\n```\nAVL Tree, Red-Black Tree:\n- 삽입/삭제 시 자동 회전\n- 모든 연산 보장: O(log n)\n\n예: Java TreeMap, C++ std::map\n```",
      "type": "essay",
      "tags": ["이진탐색트리", "시간복잡도", "성능 분석", "BST"]
    },
    {
      "question": "이진탐색트리의 한계점에 대해 설명해주세요.",
      "answer": "## 이진탐색트리 (BST)의 한계점\n\n### 1. 편향 (Skew) 문제\n\n**최대 한계점: 정렬된 데이터 삽입 시 연결 리스트로 퇴화**\n\n```java\n// 1, 2, 3, 4, 5를 순서대로 삽입\nBST tree = new BST();\ntree.insert(1);\ntree.insert(2);\ntree.insert(3);\ntree.insert(4);\ntree.insert(5);\n\n// 결과: 오른쪽 편향 트리\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n\n높이: 5 (n)\n검색 시간: O(n) ← BST의 장점 상실!\n```\n\n**비교:**\n```\n균형 BST (높이 log n):\n       3\n     /   \\\n    2     5\n   /     /\n  1     4\n\n검색 시간: O(log 5) ≈ O(2.3)\n\nVS\n\n편향 BST (높이 n):\n1 → 2 → 3 → 4 → 5\n\n검색 시간: O(5)\n```\n\n**언제 발생?**\n- 정렬된 데이터 삽입\n- 역순 정렬된 데이터 삽입\n- 특정 패턴의 데이터\n\n---\n\n### 2. 삽입 순서 의존성\n\n**같은 데이터, 다른 트리 구조:**\n\n```java\n// Case 1: [3, 1, 5, 2, 4]\n       3\n     /   \\\n    1     5\n     \\   /\n      2 4\n높이: 2\n\n// Case 2: [1, 2, 3, 4, 5]\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n높이: 5\n\n// 동일한 데이터, 다른 성능!\n```\n\n**문제:**\n- 삽입 순서에 따라 성능이 크게 달라짐\n- 예측 불가능한 성능\n\n---\n\n### 3. 균형 유지 불가\n\n**일반 BST는 자동 균형 유지 X:**\n\n```java\n// 삽입: [50, 25, 75, 10, 30, 60, 80]\n        50\n      /    \\\n    25      75\n   /  \\    /  \\\n  10  30  60  80\n\n// 60 삭제 후:\n        50\n      /    \\\n    25      75\n   /  \\      \\\n  10  30     80\n\n// 여전히 균형이지만, 보장은 안 됨\n\n// 10, 30 삭제 후:\n        50\n      /    \\\n    25      75\n             \\\n             80\n\n// 오른쪽으로 편향 시작\n```\n\n---\n\n### 4. 메모리 오버헤드\n\n**각 노드마다 2개의 포인터 필요:**\n\n```java\nclass TreeNode {\n    int value;         // 4 bytes (int)\n    TreeNode left;     // 8 bytes (포인터)\n    TreeNode right;    // 8 bytes (포인터)\n    // 총: 20 bytes\n}\n\n// 배열: int[n]\nint[] array = new int[100];\n// 총: 4 * 100 = 400 bytes\n\n// BST: TreeNode[n]\nBST tree = new BST();\nfor (int i = 0; i < 100; i++) tree.insert(i);\n// 총: 20 * 100 = 2000 bytes (5배!)\n```\n\n---\n\n### 5. 캐시 비효율\n\n**메모리 비연속성:**\n\n```\n배열: 연속된 메모리\n[1][2][3][4][5] ← 캐시 친화적\n\nBST: 흩어진 메모리\n  [3] → 메모리 주소 0x1000\n  / \\\n [1] [5] → 주소 0x2000, 0x3000\n    \\  /\n    [2][4] → 주소 0x4000, 0x5000\n\n// 캐시 미스 빈번 → 성능 저하\n```\n\n**벤치마크 예시:**\n```java\n// 100만 개 검색\n배열 (이진 탐색): 50ms\nBST (균형):      120ms ← 캐시 미스로 느림\n```\n\n---\n\n### 6. 중복 값 처리 모호\n\n**일반 BST는 중복 허용 안 함:**\n\n```java\ntree.insert(5);\ntree.insert(3);\ntree.insert(5);  // 어떻게 처리?\n\n// 옵션 1: 무시\n// 옵션 2: 카운트 증가\n// 옵션 3: 리스트로 저장\n// → 표준 없음, 구현마다 다름\n```\n\n---\n\n### 7. 범위 쿼리 비효율\n\n**모든 원소 순회 필요할 수 있음:**\n\n```java\n// [10, 15] 범위 원소 찾기\n           20\n         /    \\\n       10      30\n      /  \\    /  \\\n     5   15  25  35\n\n// 최악: O(n) - 모든 노드 확인\n// 배열 (정렬): O(log n) - Binary Search로 시작점 찾기\n```\n\n---\n\n### 8. 동시성 제어 어려움\n\n**멀티스레드 환경:**\n\n```java\n// Thread 1: insert(10)\n// Thread 2: delete(10)\n// → Race Condition\n\n// 전체 트리 락 필요\nsynchronized void insert(int value) {\n    // ...\n}\n// → 병렬성 0\n```\n\n---\n\n## 한계점 요약표\n\n| 한계점 | 문제 | 영향 | 해결책 |\n|--------|------|------|--------|\n| 편향 | 정렬 데이터 삽입 시 O(n) | 성능 저하 | AVL, Red-Black Tree |\n| 순서 의존 | 삽입 순서로 구조 결정 | 예측 불가 성능 | BBST |\n| 균형 미보장 | 자동 균형 X | 편향 위험 | BBST |\n| 메모리 | 포인터 오버헤드 | 메모리 5배 | B-Tree |\n| 캐시 | 비연속 메모리 | 캐시 미스 | B-Tree |\n| 중복 | 표준 없음 | 구현 혼란 | Multiset |\n| 범위 쿼리 | O(n) | 비효율 | Segment Tree |\n| 동시성 | 전체 락 필요 | 병렬성 0 | Lock-Free BST |\n\n---\n\n## 해결책: Balanced BST (BBST)\n\n**1. AVL Tree**\n```\n자동 균형 유지 (높이 차이 ≤ 1)\n모든 연산 보장: O(log n)\n```\n\n**2. Red-Black Tree**\n```\nJava TreeMap, C++ std::map\n느슨한 균형 (AVL보다 빠른 삽입/삭제)\n모든 연산 보장: O(log n)\n```\n\n**3. B-Tree**\n```\n데이터베이스, 파일 시스템\n디스크 I/O 최적화\n캐시 효율 높음\n```\n\n**4. Splay Tree**\n```\n최근 접근 노드를 루트로\n캐시 효과\nAmortized O(log n)\n```\n\n---\n\n## 실전 사용\n\n**일반 BST 사용하지 말 것:**\n```java\n// ❌ 나쁜 예\nBST tree = new BST();\ntree.insert(1);\ntree.insert(2);\ntree.insert(3);  // 편향 위험\n\n// ✅ 좋은 예\nTreeSet<Integer> set = new TreeSet<>();  // Red-Black Tree\nset.add(1);\nset.add(2);\nset.add(3);  // 자동 균형\n```\n\n**언어별 BBST:**\n- **Java**: `TreeMap`, `TreeSet` (Red-Black)\n- **C++**: `std::map`, `std::set` (Red-Black)\n- **Python**: `sortedcontainers` 라이브러리\n- **JavaScript**: 직접 구현 필요 (라이브러리 사용)\n\n---\n\n## 결론\n\n일반 BST는 **교육용**으로는 좋지만, **실전에서는 BBST 사용 필수**입니다.\n\n**이유:**\n- 편향 위험\n- 성능 예측 불가\n- 현대 언어의 표준 라이브러리가 모두 BBST 제공",
      "type": "essay",
      "tags": ["이진탐색트리", "한계점", "편향", "성능"]
    },
    {
      "question": "이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?",
      "answer": "## 이진탐색트리 삽입 (Insert)\n\n### 삽입 알고리즘\n\n```java\nTreeNode insert(TreeNode node, int value) {\n    // 1. 빈 위치 도달 → 새 노드 생성\n    if (node == null) {\n        return new TreeNode(value);\n    }\n    \n    // 2. 값 비교하여 방향 결정\n    if (value < node.value) {\n        node.left = insert(node.left, value);  // 왼쪽\n    } else if (value > node.value) {\n        node.right = insert(node.right, value); // 오른쪽\n    }\n    // value == node.value → 중복, 무시\n    \n    return node;\n}\n```\n\n**삽입 과정 예시:**\n```\n초기 트리:      삽입 value = 7\n       8\n     /   \\\n    3     10\n   / \\\n  1   6\n\nStep 1: 8과 비교 → 7 < 8 → 왼쪽\nStep 2: 3과 비교 → 7 > 3 → 오른쪽\nStep 3: 6과 비교 → 7 > 6 → 오른쪽\nStep 4: null 도달 → 삽입\n\n결과:\n       8\n     /   \\\n    3     10\n   / \\\n  1   6\n       \\\n        7\n```\n\n**시간복잡도:**\n- 평균: O(log n)\n- 최악: O(n) (편향 트리)\n\n---\n\n## 이진탐색트리 삭제 (Delete)\n\n### 삭제 3가지 경우\n\n**Case 1: 리프 노드 (자식 없음)**\n```java\nif (node.left == null && node.right == null) {\n    return null;  // 그냥 제거\n}\n```\n\n**예시:**\n```\n삭제 전:        삭제: 1\n       8\n     /   \\\n    3     10\n   / \\\n  1   6    →     8\n               /   \\\n              3     10\n               \\\n                6\n```\n\n**Case 2: 자식 1개**\n```java\nif (node.left == null) return node.right;\nif (node.right == null) return node.left;\n```\n\n**예시:**\n```\n삭제 전:        삭제: 10\n       8\n     /   \\\n    3     10\n   / \\      \\\n  1   6      14    →     8\n                       /   \\\n                      3     14\n                     / \\\n                    1   6\n```\n\n**Case 3: 자식 2개**\n```java\n// 오른쪽 서브트리의 최솟값(후계자)으로 대체\nTreeNode min = findMin(node.right);\nnode.value = min.value;\nnode.right = delete(node.right, min.value);\n\n// 또는 왼쪽 서브트리의 최댓값으로 대체\n// TreeNode max = findMax(node.left);\n// node.value = max.value;\n// node.left = delete(node.left, max.value);\n```\n\n**예시:**\n```\n삭제 전:              삭제: 8\n       8\n     /   \\\n    3     10\n   / \\      \\\n  1   6      14\n            /\n           13\n\nStep 1: 오른쪽 서브트리 최솟값 찾기 → 10\nStep 2: 8을 10으로 교체\nStep 3: 원래 10 노드 삭제\n\n결과:\n       10\n     /    \\\n    3      14\n   / \\    /\n  1   6  13\n```\n\n**전체 구현:**\n```java\nTreeNode delete(TreeNode node, int value) {\n    if (node == null) return null;\n    \n    // 삭제할 노드 찾기\n    if (value < node.value) {\n        node.left = delete(node.left, value);\n    } else if (value > node.value) {\n        node.right = delete(node.right, value);\n    } else {\n        // 삭제할 노드 발견\n        \n        // Case 1: 리프 노드\n        if (node.left == null && node.right == null) {\n            return null;\n        }\n        \n        // Case 2: 자식 1개\n        if (node.left == null) return node.right;\n        if (node.right == null) return node.left;\n        \n        // Case 3: 자식 2개\n        TreeNode successor = findMin(node.right);\n        node.value = successor.value;\n        node.right = delete(node.right, successor.value);\n    }\n    \n    return node;\n}\n\nTreeNode findMin(TreeNode node) {\n    while (node.left != null) {\n        node = node.left;\n    }\n    return node;\n}\n```\n\n---\n\n## 편향 (Skew) 발생 조건\n\n### 1. 오름차순 삽입 → 오른쪽 편향\n\n```java\nfor (int i = 1; i <= 5; i++) {\n    tree.insert(i);\n}\n\n결과:\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n\n높이: n\n검색: O(n)\n```\n\n**이유:**\n```\ninsert(1): 1\n\ninsert(2): 2 > 1 → 오른쪽\n1\n \\\n  2\n\ninsert(3): 3 > 1 → 오른쪽, 3 > 2 → 오른쪽\n1\n \\\n  2\n   \\\n    3\n\n// 계속 오른쪽으로만 확장\n```\n\n---\n\n### 2. 내림차순 삽입 → 왼쪽 편향\n\n```java\nfor (int i = 5; i >= 1; i--) {\n    tree.insert(i);\n}\n\n결과:\n        5\n       /\n      4\n     /\n    3\n   /\n  2\n /\n1\n\n높이: n\n```\n\n---\n\n### 3. 특정 패턴\n\n**교대로 증가하는 패턴:**\n```java\ntree.insert(1);\ntree.insert(3);\ntree.insert(2);\ntree.insert(5);\ntree.insert(4);\n\n결과:\n  1\n   \\\n    3\n   / \\\n  2   5\n     /\n    4\n\n// 오른쪽으로 편향 경향\n```\n\n**중간값 없이 삽입:**\n```java\ntree.insert(10);\ntree.insert(5);\ntree.insert(15);\ntree.insert(3);\ntree.insert(7);\ntree.insert(1);  // 왼쪽만 계속 추가\n\n결과:\n      10\n     /  \\\n    5    15\n   / \\\n  3   7\n /\n1\n\n// 왼쪽 서브트리 편향\n```\n\n---\n\n## 편향 방지 삽입 순서\n\n### 최적: 중간값부터 삽입\n\n```java\n// 배열 [1, 2, 3, 4, 5, 6, 7]\n// 중간부터 삽입\ntree.insert(4);  // 중간값\ntree.insert(2);  // 왼쪽 중간\ntree.insert(6);  // 오른쪽 중간\ntree.insert(1);\ntree.insert(3);\ntree.insert(5);\ntree.insert(7);\n\n결과 (균형):\n       4\n     /   \\\n    2     6\n   / \\   / \\\n  1   3 5   7\n\n높이: log n\n```\n\n**구현:**\n```java\nvoid insertBalanced(int[] arr, int left, int right) {\n    if (left > right) return;\n    \n    int mid = left + (right - left) / 2;\n    tree.insert(arr[mid]);\n    \n    insertBalanced(arr, left, mid - 1);\n    insertBalanced(arr, mid + 1, right);\n}\n\nint[] arr = {1, 2, 3, 4, 5, 6, 7};\ninsertBalanced(arr, 0, arr.length - 1);\n```\n\n---\n\n## 편향 발생 비교\n\n| 삽입 순서 | 결과 트리 높이 | 검색 시간 |\n|-----------|----------------|----------|\n| [1,2,3,4,5] | 5 (n) | O(n) |\n| [5,4,3,2,1] | 5 (n) | O(n) |\n| [3,1,5,2,4] | 2 (log n) | O(log n) |\n| [3,2,4,1,5] | 2 (log n) | O(log n) |\n| [4,2,6,1,3,5,7] | 2 (log n) | O(log n) |\n\n---\n\n## 실전 예제\n\n**편향 발생:**\n```java\n// ❌ 나쁜 예: 타임스탬프 삽입\nfor (Event event : events) {\n    tree.insert(event.timestamp);  // 계속 증가\n}\n// → 오른쪽 편향\n\n// ❌ 나쁜 예: 정렬된 배열 삽입\nint[] sorted = {1, 2, 3, 4, 5};\nfor (int x : sorted) {\n    tree.insert(x);\n}\n// → 오른쪽 편향\n```\n\n**편향 방지:**\n```java\n// ✅ 좋은 예: 랜덤 셔플\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\nCollections.shuffle(list);\nfor (int x : list) {\n    tree.insert(x);\n}\n// → 균형 가능성 높음\n\n// ✅ 더 좋은 예: BBST 사용\nTreeSet<Integer> set = new TreeSet<>();\nfor (int i = 1; i <= 5; i++) {\n    set.add(i);  // 자동 균형\n}\n```\n\n---\n\n## 결론\n\n**편향 발생 원인:**\n1. 정렬된 데이터 (오름/내림차순)\n2. 단조 증가/감소 패턴\n3. 중간값 없이 한쪽만 추가\n\n**해결책:**\n1. 중간값부터 삽입\n2. 랜덤 셔플\n3. **BBST 사용 (AVL, Red-Black Tree)** ← 권장",
      "type": "essay",
      "tags": ["이진탐색트리", "삽입", "삭제", "편향"]
    },
    {
      "question": "이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.",
      "answer": "## 삼진탐색트리 가능성 검토\n\n**결론: 가능하지만, 일반적으로 사용하지 않음**\n\n---\n\n## 삼진탐색트리 (Ternary Search Tree)\n\n### 정의 가능한 두 가지 방식\n\n**방식 1: 값 범위로 분할 (가능)**\n\n```java\nclass TernaryNode {\n    int value1, value2;  // 두 개의 값 저장\n    TernaryNode left;    // < value1\n    TernaryNode middle;  // value1 < x < value2\n    TernaryNode right;   // > value2\n}\n```\n\n**예시:**\n```\n노드: [10, 20]\n      /    |    \\\n  (<10) (10-20) (>20)\n\n     [10, 20]\n    /    |    \\\n  [5]  [15]  [25, 30]\n  / \\   / \\   / |  \\\n```\n\n**검색 구현:**\n```java\nboolean search(TernaryNode node, int target) {\n    if (node == null) return false;\n    \n    if (target == node.value1 || target == node.value2) {\n        return true;\n    }\n    \n    if (target < node.value1) {\n        return search(node.left, target);\n    } else if (target > node.value2) {\n        return search(node.right, target);\n    } else {\n        return search(node.middle, target);  // value1 < target < value2\n    }\n}\n```\n\n---\n\n**방식 2: 문자열용 TST (Ternary Search Tree)**\n\n```java\nclass TSTNode {\n    char c;              // 현재 문자\n    TSTNode left;        // c보다 작은 문자\n    TSTNode middle;      // c와 같은 문자, 다음 문자로\n    TSTNode right;       // c보다 큰 문자\n    boolean isEndOfWord;\n}\n```\n\n**예시: \"cat\", \"cats\", \"dog\" 저장**\n```\n       c\n      /|\\\n     a m d\n      |   |\n      t   o\n      |   |\n      $ s g\n          |\n          $\n\n$ = 단어 끝\n```\n\n**문자열 검색:**\n```java\nboolean search(TSTNode node, String word, int index) {\n    if (node == null) return false;\n    \n    char c = word.charAt(index);\n    \n    if (c < node.c) {\n        return search(node.left, word, index);\n    } else if (c > node.c) {\n        return search(node.right, word, index);\n    } else {\n        // c == node.c\n        if (index == word.length() - 1) {\n            return node.isEndOfWord;  // 단어 끝\n        }\n        return search(node.middle, word, index + 1);  // 다음 문자\n    }\n}\n```\n\n---\n\n## 왜 일반적으로 사용하지 않는가?\n\n### 1. 복잡도 증가\n\n**이진탐색트리:**\n```java\nif (target < node.value) {\n    // 왼쪽\n} else {\n    // 오른쪽\n}\n// 1번 비교\n```\n\n**삼진탐색트리:**\n```java\nif (target < node.value1) {\n    // 왼쪽\n} else if (target > node.value2) {\n    // 오른쪽\n} else if (target == node.value1 || target == node.value2) {\n    // 찾음\n} else {\n    // 중간\n}\n// 3~4번 비교\n```\n\n---\n\n### 2. 삽입 복잡성\n\n**이진탐색트리 삽입:**\n```java\nTreeNode insert(TreeNode node, int value) {\n    if (node == null) return new TreeNode(value);\n    \n    if (value < node.value) {\n        node.left = insert(node.left, value);\n    } else {\n        node.right = insert(node.right, value);\n    }\n    return node;\n}\n```\n\n**삼진탐색트리 삽입:**\n```java\nTernaryNode insert(TernaryNode node, int value) {\n    if (node == null) {\n        return new TernaryNode(value);  // 초기값 하나만\n    }\n    \n    // Case 1: 노드에 값 1개만 있음\n    if (node.value2 == null) {\n        if (value == node.value1) return node;\n        \n        // 두 값을 정렬하여 저장\n        if (value < node.value1) {\n            node.value2 = node.value1;\n            node.value1 = value;\n        } else {\n            node.value2 = value;\n        }\n        return node;\n    }\n    \n    // Case 2: 노드가 꽉 참 (2개 값)\n    if (value < node.value1) {\n        node.left = insert(node.left, value);\n    } else if (value > node.value2) {\n        node.right = insert(node.right, value);\n    } else if (value != node.value1 && value != node.value2) {\n        node.middle = insert(node.middle, value);\n    }\n    \n    return node;\n}\n// → 케이스 분기가 많고 복잡\n```\n\n---\n\n### 3. 삭제의 복잡성\n\n**자식이 3개 → 후계자 선택 복잡:**\n\n```java\n// 삭제할 노드의 자식이 3개\n      [10, 20]\n      /   |   \\\n    Left Mid Right\n\n// 어느 서브트리에서 후계자를 가져올까?\n// 1. left의 최댓값?\n// 2. middle의 최솟값? 최댓값?\n// 3. right의 최솟값?\n// → 선택지 많음, 균형 유지 어려움\n```\n\n---\n\n### 4. 시간복잡도 개선 미미\n\n**이진탐색트리:**\n```\n높이: log₂(n)\n검색: log₂(n)번 비교\n```\n\n**삼진탐색트리:**\n```\n높이: log₃(n)\n검색: log₃(n)번 노드 방문, 각 노드마다 3번 비교\n\n실제: log₃(n) * 3 ≈ log₂(n) * 1.9\n// 별로 빠르지 않음\n```\n\n**비교:**\n```\nn = 1,000,000\n\n이진:\nlog₂(1,000,000) ≈ 20 비교\n\n삼진:\nlog₃(1,000,000) ≈ 13 노드, 각 노드마다 3번\n= 13 * 3 = 39 비교\n\n// 오히려 느림!\n```\n\n---\n\n### 5. 메모리 오버헤드\n\n**노드당 포인터 수:**\n\n```java\n// 이진 노드\nclass BinaryNode {\n    int value;      // 4 bytes\n    Node left;      // 8 bytes\n    Node right;     // 8 bytes\n    // 총: 20 bytes\n}\n\n// 삼진 노드\nclass TernaryNode {\n    int value1;     // 4 bytes\n    int value2;     // 4 bytes\n    Node left;      // 8 bytes\n    Node middle;    // 8 bytes\n    Node right;     // 8 bytes\n    // 총: 32 bytes (60% 증가)\n}\n```\n\n---\n\n## 삼진탐색트리가 유용한 경우\n\n### 문자열 저장 (TST)\n\n**장점:**\n- Trie보다 메모리 효율적\n- Hash Table보다 정렬 가능\n- 부분 문자열 검색 가능\n\n**사용 사례:**\n- 자동완성\n- 사전 구현\n- DNA 서열 분석\n\n**예시:**\n```java\n// Trie vs TST 메모리 비교\n// 단어: \"cat\", \"car\", \"card\"\n\nTrie:\n       c\n       |\n       a\n      / \\\n     t   r\n         |\n         d\n// 노드당 26개 포인터 배열 (알파벳)\n// 메모리: 노드당 ~200 bytes\n\nTST:\n     c\n     |\n     a\n     |\n     t\n    / \\\n   $   r\n       |\n       $\n      / \\\n     d   (other)\n// 노드당 3개 포인터\n// 메모리: 노드당 ~32 bytes\n```\n\n---\n\n## B-Tree (실전에서 사용되는 다진 트리)\n\n**실무에서는 B-Tree 사용:**\n\n```java\n// B-Tree 노드 (3차 B-Tree)\nclass BTreeNode {\n    int[] keys = new int[2];      // 최대 2개 키\n    BTreeNode[] children = new BTreeNode[3];  // 최대 3개 자식\n    int numKeys;  // 현재 키 개수\n}\n\n// 특징:\n// 1. 모든 리프가 같은 레벨\n// 2. 디스크 I/O 최적화\n// 3. 데이터베이스 인덱스에 사용\n```\n\n**왜 B-Tree는 성공했는가?**\n1. **균형 보장**: 모든 리프가 같은 깊이\n2. **디스크 최적화**: 한 번에 여러 키 읽기\n3. **검증된 알고리즘**: 삽입/삭제 잘 정의됨\n\n---\n\n## 결론\n\n**삼진탐색트리 (범용):**\n- ✅ 정의 가능\n- ❌ 실용성 낮음 (복잡도 증가, 성능 개선 미미)\n- ❌ 균형 유지 어려움\n\n**삼진탐색트리 (문자열 TST):**\n- ✅ 문자열 저장에 유용\n- ✅ Trie보다 메모리 효율적\n- ✅ 자동완성, 사전 구현\n\n**실무 추천:**\n- 범용: **이진탐색트리** (AVL, Red-Black)\n- 디스크: **B-Tree**\n- 문자열: **TST** 또는 Trie\n\n**N-진 트리 일반론:**\n```\nN이 클수록:\n- 높이 감소: log_N(n)\n- 노드당 비교 증가: N-1번\n- 구현 복잡도 증가\n- 균형 유지 어려움\n\n→ 이진(N=2)이 구현과 성능의 최적 균형\n```",
      "type": "essay",
      "tags": ["삼진탐색트리", "이진탐색트리", "TST", "트리"]
    },
    {
      "question": "힙에 대해 설명해 주세요.",
      "answer": "## 힙 (Heap)\n\n**정의:**  \n**완전 이진트리** 형태의 자료구조로, 부모-자식 간에 특정 순서 관계를 만족합니다.\n\n---\n\n## 힙의 종류\n\n### 1. 최대 힙 (Max Heap)\n\n**조건:** 부모 노드 ≥ 자식 노드\n\n```\n        100\n       /   \\\n     80     90\n    / \\    / \\\n   50  60 70  40\n  / \\\n 30  20\n\n// 루트: 최댓값 (100)\n// 모든 부모 ≥ 자식\n```\n\n### 2. 최소 힙 (Min Heap)\n\n**조건:** 부모 노드 ≤ 자식 노드\n\n```\n         10\n       /   \\\n     20     30\n    / \\    / \\\n   40  50 60  70\n  / \\\n 80  90\n\n// 루트: 최솟값 (10)\n// 모든 부모 ≤ 자식\n```\n\n---\n\n## 힙의 핵심 특징\n\n### 1. 완전 이진트리 (Complete Binary Tree)\n\n```\n✅ 완전 이진트리 (힙 가능):\n       1\n     /   \\\n    2     3\n   / \\   /\n  4   5 6\n\n// 마지막 레벨 제외 모두 채워짐\n// 마지막 레벨은 왼쪽부터\n\n❌ 불완전 이진트리 (힙 불가능):\n       1\n     /   \\\n    2     3\n     \\     \\\n      4     5\n\n// 왼쪽부터 채워지지 않음\n```\n\n### 2. 부분 순서 (Partial Order)\n\n**BST vs Heap:**\n\n```\nBST (전체 순서):\n       5\n     /   \\\n    3     7\n   / \\   / \\\n  2   4 6   8\n\n// 중위 순회: 2 3 4 5 6 7 8 (완전 정렬)\n// 왼쪽 < 현재 < 오른쪽\n\nMax Heap (부분 순서):\n       8\n     /   \\\n    7     6\n   / \\   / \\\n  5   4 3   2\n\n// 부모 > 자식만 보장\n// 형제 간 순서 없음 (7 vs 6 순서 무관)\n```\n\n---\n\n## 힙의 주요 연산\n\n### 1. 삽입 (Insert) - O(log n)\n\n```java\nvoid insert(int value) {\n    // 1. 맨 끝에 추가\n    heap.add(value);\n    \n    // 2. Heapify Up (상향 조정)\n    int i = heap.size() - 1;\n    while (i > 0) {\n        int parent = (i - 1) / 2;\n        \n        if (heap.get(i) <= heap.get(parent)) {\n            break;  // 힙 조건 만족\n        }\n        \n        // 부모와 교환\n        swap(i, parent);\n        i = parent;\n    }\n}\n```\n\n**예시: 최대 힙에 95 삽입**\n```\n초기:        삽입 95:       Heapify Up:\n   100          100            100\n   / \\          / \\            / \\\n  80  90       80  90         95  90\n / \\          / \\  /        / \\  /\n50  60       50  60 95     50  60 80\n\n// 95가 부모 80보다 크므로 교환\n```\n\n---\n\n### 2. 삭제 (Extract Max/Min) - O(log n)\n\n```java\nint extractMax() {\n    if (heap.isEmpty()) throw new Exception();\n    \n    // 1. 루트 저장 (반환값)\n    int max = heap.get(0);\n    \n    // 2. 마지막 원소를 루트로\n    int last = heap.remove(heap.size() - 1);\n    if (heap.isEmpty()) return max;\n    \n    heap.set(0, last);\n    \n    // 3. Heapify Down (하향 조정)\n    int i = 0;\n    while (true) {\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        int largest = i;\n        \n        if (left < heap.size() && heap.get(left) > heap.get(largest)) {\n            largest = left;\n        }\n        if (right < heap.size() && heap.get(right) > heap.get(largest)) {\n            largest = right;\n        }\n        \n        if (largest == i) break;  // 힙 조건 만족\n        \n        swap(i, largest);\n        i = largest;\n    }\n    \n    return max;\n}\n```\n\n**예시: 최댓값 삭제**\n```\n초기:           마지막→루트:    Heapify Down:\n    100             60             90\n   /   \\           / \\            / \\\n  80    90        80  90         80  70\n / \\   / \\       / \\  / \\       / \\  /\n50  60 70 40    50  X 70 40    50  60 40\n\n// 60 < 90이므로 교환\n// 60 < 70이므로 교환\n```\n\n---\n\n### 3. Peek (최댓값/최솟값 조회) - O(1)\n\n```java\nint peek() {\n    return heap.get(0);  // 루트\n}\n```\n\n---\n\n## 힙의 시간복잡도\n\n| 연산 | 시간복잡도 | 이유 |\n|------|-----------|------|\n| Insert | O(log n) | Heapify Up (트리 높이) |\n| Extract Max/Min | O(log n) | Heapify Down (트리 높이) |\n| Peek | O(1) | 루트 접근 |\n| Build Heap | O(n) | Bottom-up 구성 |\n| Search | O(n) | 순서 없음, 전체 탐색 |\n\n---\n\n## 힙 vs BST\n\n| 특성 | Heap | BST |\n|------|------|-----|\n| 구조 | 완전 이진트리 | 이진트리 |\n| 순서 | 부분 순서 (부모-자식만) | 전체 순서 (왼쪽 < 현재 < 오른쪽) |\n| 최댓값 찾기 | O(1) | O(log n) ~ O(n) |\n| 검색 | O(n) | O(log n) ~ O(n) |\n| 삽입 | O(log n) | O(log n) ~ O(n) |\n| 삭제 | O(log n) | O(log n) ~ O(n) |\n| 배열 구현 | 쉬움 | 어려움 |\n| 사용 사례 | 우선순위 큐, 힙 정렬 | 정렬된 데이터, 검색 |\n\n---\n\n## 힙의 활용\n\n### 1. 우선순위 큐 (Priority Queue)\n\n```java\nPriorityQueue<Integer> pq = new PriorityQueue<>();  // Min Heap\npq.add(5);\npq.add(3);\npq.add(7);\npq.poll();  // 3 (최솟값)\n\n// Max Heap\nPriorityQueue<Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());\n```\n\n### 2. 힙 정렬 (Heap Sort)\n\n```java\nvoid heapSort(int[] arr) {\n    // 1. Build Heap: O(n)\n    buildMaxHeap(arr);\n    \n    // 2. Extract Max 반복: O(n log n)\n    for (int i = arr.length - 1; i > 0; i--) {\n        swap(arr, 0, i);  // 최댓값을 뒤로\n        heapify(arr, 0, i);  // 남은 부분 Heapify\n    }\n}\n\n// 시간: O(n log n)\n// 공간: O(1) (in-place)\n```\n\n### 3. K번째 최댓값/최솟값\n\n```java\n// K번째 최솟값\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\nfor (int num : nums) {\n    maxHeap.add(num);\n    if (maxHeap.size() > k) {\n        maxHeap.poll();  // 큰 값 제거\n    }\n}\nreturn maxHeap.peek();  // K번째 최솟값\n```\n\n### 4. 중앙값 찾기\n\n```java\n// 두 개의 힙 사용\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());  // 작은 쪽 절반\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();  // 큰 쪽 절반\n\n// 중앙값 = maxHeap의 루트 (또는 두 루트의 평균)\n```\n\n---\n\n## Java 구현\n\n```java\nimport java.util.PriorityQueue;\n\n// Min Heap (기본)\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n// Max Heap\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(\n    (a, b) -> b - a\n);\n\n// 사용자 정의 비교\nPriorityQueue<Task> pq = new PriorityQueue<>(\n    (a, b) -> a.priority - b.priority\n);\n```\n\n---\n\n## 결론\n\n**힙의 장점:**\n- 최댓값/최솟값 빠른 접근 (O(1))\n- 삽입/삭제 효율적 (O(log n))\n- 배열로 구현 가능 (메모리 효율)\n\n**힙의 단점:**\n- 검색 느림 (O(n))\n- 정렬되지 않음 (부분 순서만)\n\n**사용 시기:**\n- 우선순위 큐 필요 시\n- 최댓값/최솟값 반복 조회\n- 정렬 (힙 정렬)",
      "type": "essay",
      "tags": ["힙", "Heap", "우선순위 큐", "자료구조"]
    },
    {
      "question": "힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?",
      "answer": "## 힙의 배열 구현\n\n**핵심: 완전 이진트리는 배열로 표현 가능**\n\n---\n\n## 인덱스 매핑 규칙\n\n**부모-자식 관계:**\n\n```\n노드 인덱스: i (0-based)\n\n왼쪽 자식: 2*i + 1\n오른쪽 자식: 2*i + 2\n부모: (i - 1) / 2\n```\n\n**예시 (최대 힙):**\n\n```\n트리 형태:          배열 인덱스:\n      100 (0)           0\n     /   \\            /   \\\n   80(1)  90(2)      1     2\n  / \\    / \\        / \\   / \\\n50  60  70 40      3   4 5   6\n(3)(4) (5)(6)\n\n배열:\nindex: 0   1   2   3   4   5   6\nvalue: [100, 80, 90, 50, 60, 70, 40]\n\n관계:\n- 100의 왼쪽 자식: 2*0+1 = 1 → 80\n- 100의 오른쪽 자식: 2*0+2 = 2 → 90\n- 80의 부모: (1-1)/2 = 0 → 100\n- 50의 부모: (3-1)/2 = 1 → 80\n```\n\n---\n\n## Java 구현\n\n### 최대 힙 (Max Heap)\n\n```java\nclass MaxHeap {\n    private List<Integer> heap = new ArrayList<>();\n    \n    // 부모 인덱스\n    private int parent(int i) {\n        return (i - 1) / 2;\n    }\n    \n    // 왼쪽 자식 인덱스\n    private int left(int i) {\n        return 2 * i + 1;\n    }\n    \n    // 오른쪽 자식 인덱스\n    private int right(int i) {\n        return 2 * i + 2;\n    }\n    \n    // 교환\n    private void swap(int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n    \n    // 삽입: O(log n)\n    public void insert(int value) {\n        heap.add(value);  // 맨 끝에 추가\n        heapifyUp(heap.size() - 1);\n    }\n    \n    // 상향 조정\n    private void heapifyUp(int i) {\n        while (i > 0 && heap.get(i) > heap.get(parent(i))) {\n            swap(i, parent(i));\n            i = parent(i);\n        }\n    }\n    \n    // 최댓값 추출: O(log n)\n    public int extractMax() {\n        if (heap.isEmpty()) {\n            throw new NoSuchElementException(\"Heap is empty\");\n        }\n        \n        int max = heap.get(0);  // 루트\n        int last = heap.remove(heap.size() - 1);  // 마지막 원소\n        \n        if (!heap.isEmpty()) {\n            heap.set(0, last);  // 마지막 원소를 루트로\n            heapifyDown(0);\n        }\n        \n        return max;\n    }\n    \n    // 하향 조정\n    private void heapifyDown(int i) {\n        int maxIndex = i;\n        int l = left(i);\n        int r = right(i);\n        \n        // 왼쪽 자식과 비교\n        if (l < heap.size() && heap.get(l) > heap.get(maxIndex)) {\n            maxIndex = l;\n        }\n        \n        // 오른쪽 자식과 비교\n        if (r < heap.size() && heap.get(r) > heap.get(maxIndex)) {\n            maxIndex = r;\n        }\n        \n        // 교환 필요 시\n        if (i != maxIndex) {\n            swap(i, maxIndex);\n            heapifyDown(maxIndex);  // 재귀\n        }\n    }\n    \n    // 최댓값 조회: O(1)\n    public int peek() {\n        if (heap.isEmpty()) {\n            throw new NoSuchElementException(\"Heap is empty\");\n        }\n        return heap.get(0);\n    }\n    \n    // 크기\n    public int size() {\n        return heap.size();\n    }\n}\n```\n\n---\n\n## 동작 예시\n\n### 삽입 과정 (95 삽입)\n\n```\n초기 배열: [100, 80, 90, 50, 60, 70, 40]\n\n트리:\n      100\n     /   \\\n   80     90\n  / \\    / \\\n 50  60 70  40\n\nStep 1: 맨 끝에 추가\n배열: [100, 80, 90, 50, 60, 70, 40, 95]\nindex: 7\n\n      100\n     /   \\\n   80     90\n  / \\    / \\\n 50  60 70  40\n/\n95\n\nStep 2: Heapify Up\n95 > 80 (parent(7) = 3) → 교환\n배열: [100, 95, 90, 50, 60, 70, 40, 80]\nindex: 1\n\n      100\n     /   \\\n   95     90\n  / \\    / \\\n 50  60 70  40\n          \\\n          80\n\nStep 3: 계속 Heapify Up\n95 < 100 → 종료\n\n최종 배열: [100, 95, 90, 50, 60, 70, 40, 80]\n```\n\n---\n\n### 삭제 과정 (최댓값 추출)\n\n```\n초기 배열: [100, 80, 90, 50, 60, 70, 40]\n\nStep 1: 루트 저장 (100)\nStep 2: 마지막 원소(40)를 루트로\n배열: [40, 80, 90, 50, 60, 70]\n\n      40\n     /  \\\n   80    90\n  / \\   /\n 50  60 70\n\nStep 3: Heapify Down\n40 < 90 (right child) → 교환\n배열: [90, 80, 40, 50, 60, 70]\n\n      90\n     /  \\\n   80    40\n  / \\   /\n 50  60 70\n\nStep 4: 계속 Heapify Down\n40 < 70 (right child) → 교환\n배열: [90, 80, 70, 50, 60, 40]\n\n      90\n     /  \\\n   80    70\n  / \\   /\n 50  60 40\n\n종료 (40이 리프)\n반환값: 100\n```\n\n---\n\n## 1-based 인덱스 (대안)\n\n**일부 구현은 1-based 사용 (수식 간결):**\n\n```java\n노드 인덱스: i (1-based, index 0 사용 안 함)\n\n왼쪽 자식: 2*i\n오른쪽 자식: 2*i + 1\n부모: i / 2\n\n배열:\nindex: 0   1   2   3   4   5   6   7\nvalue: [X, 100, 80, 90, 50, 60, 70, 40]\n              ↑ 루트\n\n// 수식이 더 간단\n```\n\n---\n\n## Build Heap: O(n)\n\n**배열을 힙으로 변환:**\n\n```java\nvoid buildHeap(int[] arr) {\n    heap = new ArrayList<>();\n    for (int val : arr) {\n        heap.add(val);\n    }\n    \n    // 마지막 부모부터 Heapify Down\n    for (int i = heap.size() / 2 - 1; i >= 0; i--) {\n        heapifyDown(i);\n    }\n}\n```\n\n**예시:**\n```\n초기 배열: [10, 20, 15, 30, 40]\n\n트리:\n      10\n     /  \\\n   20    15\n  / \\\n 30  40\n\n마지막 부모: i = (5/2 - 1) = 1\n\nStep 1: heapifyDown(1) → 20과 40 교환\n      10\n     /  \\\n   40    15\n  / \\\n 30  20\n\nStep 2: heapifyDown(0) → 10과 40 교환\n      40\n     /  \\\n   10    15\n  / \\\n 30  20\n\nStep 3: heapifyDown(0) 계속 → 10과 30 교환\n      40\n     /  \\\n   30    15\n  / \\\n 10  20\n\n최종 배열: [40, 30, 15, 10, 20]\n```\n\n**시간복잡도:** O(n)\n- 각 레벨의 노드 수와 Heapify 비용이 역비례\n- 리프(n/2개): O(0)\n- 레벨 h-1(n/4개): O(1)\n- 레벨 h-2(n/8개): O(2)\n- ...\n- 루트(1개): O(log n)\n\n---\n\n## 배열 vs 포인터 구현\n\n| 특성 | 배열 | 포인터 |\n|------|------|--------|\n| 구현 복잡도 | 간단 | 복잡 |\n| 메모리 | O(n) | O(n) + 포인터 오버헤드 |\n| 캐시 효율 | 높음 (연속 메모리) | 낮음 (흩어진 메모리) |\n| 인덱스 계산 | 산술 연산 | 포인터 따라가기 |\n| 리사이징 | 필요 시 O(n) | 불필요 |\n| 사용 | 일반적 | 거의 없음 |\n\n**결론: 힙은 거의 항상 배열로 구현**\n\n---\n\n## JavaScript 예시\n\n```javascript\nclass MaxHeap {\n    constructor() {\n        this.heap = [];\n    }\n    \n    parent(i) { return Math.floor((i - 1) / 2); }\n    left(i) { return 2 * i + 1; }\n    right(i) { return 2 * i + 2; }\n    \n    insert(val) {\n        this.heap.push(val);\n        this.heapifyUp(this.heap.length - 1);\n    }\n    \n    heapifyUp(i) {\n        while (i > 0 && this.heap[i] > this.heap[this.parent(i)]) {\n            [this.heap[i], this.heap[this.parent(i)]] = \n            [this.heap[this.parent(i)], this.heap[i]];\n            i = this.parent(i);\n        }\n    }\n    \n    extractMax() {\n        if (this.heap.length === 0) return null;\n        \n        const max = this.heap[0];\n        const last = this.heap.pop();\n        \n        if (this.heap.length > 0) {\n            this.heap[0] = last;\n            this.heapifyDown(0);\n        }\n        \n        return max;\n    }\n    \n    heapifyDown(i) {\n        let maxIdx = i;\n        const l = this.left(i);\n        const r = this.right(i);\n        \n        if (l < this.heap.length && this.heap[l] > this.heap[maxIdx]) {\n            maxIdx = l;\n        }\n        if (r < this.heap.length && this.heap[r] > this.heap[maxIdx]) {\n            maxIdx = r;\n        }\n        \n        if (i !== maxIdx) {\n            [this.heap[i], this.heap[maxIdx]] = \n            [this.heap[maxIdx], this.heap[i]];\n            this.heapifyDown(maxIdx);\n        }\n    }\n}\n```",
      "type": "essay",
      "tags": ["힙", "배열", "구현", "인덱싱"]
    },
    {
      "question": "힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.",
      "answer": "## 힙의 삽입과 삭제\n\n### 삽입 (Insert) - O(log n)\n\n**알고리즘:**\n1. 새 값을 맨 끝(완전 이진트리 유지)에 추가\n2. Heapify Up (부모와 비교하며 올라감)\n\n```java\nvoid insert(int value) {\n    // 1. 맨 끝에 추가\n    heap.add(value);\n    \n    // 2. Heapify Up\n    int i = heap.size() - 1;\n    while (i > 0) {\n        int parent = (i - 1) / 2;\n        \n        if (heap.get(i) <= heap.get(parent)) {\n            break;  // 힙 조건 만족\n        }\n        \n        swap(i, parent);\n        i = parent;\n    }\n}\n```\n\n**예시: 최대 힙에 95 삽입**\n```\nStep 1: 맨 끝에 추가\n      100              [100, 80, 90, 50, 60, 70, 40, 95]\n     /   \\                                           ↑\n   80     90                                      여기 추가\n  / \\    / \\\n 50  60 70  40\n/\n95\n\nStep 2: 95 > 50 (부모) → 교환\n      100\n     /   \\\n   80     90\n  / \\    / \\\n 95  60 70  40\n/\n50\n\nStep 3: 95 > 80 (부모) → 교환\n      100\n     /   \\\n   95     90\n  / \\    / \\\n 80  60 70  40\n/\n50\n\nStep 4: 95 < 100 (부모) → 종료\n최종: [100, 95, 90, 80, 60, 70, 40, 50]\n```\n\n**핵심: 항상 맨 끝에 추가 → 완전 이진트리 유지**\n\n---\n\n### 삭제 (Extract Max) - O(log n)\n\n**알고리즘:**\n1. 루트(최댓값/최솟값) 제거\n2. 마지막 원소를 루트로 이동\n3. Heapify Down (자식과 비교하며 내려감)\n\n```java\nint extractMax() {\n    int max = heap.get(0);  // 루트 저장\n    \n    // 마지막 원소를 루트로\n    int last = heap.remove(heap.size() - 1);\n    if (heap.isEmpty()) return max;\n    \n    heap.set(0, last);\n    \n    // Heapify Down\n    int i = 0;\n    while (true) {\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        int largest = i;\n        \n        if (left < heap.size() && heap.get(left) > heap.get(largest)) {\n            largest = left;\n        }\n        if (right < heap.size() && heap.get(right) > heap.get(largest)) {\n            largest = right;\n        }\n        \n        if (largest == i) break;\n        \n        swap(i, largest);\n        i = largest;\n    }\n    \n    return max;\n}\n```\n\n**예시: 최댓값 삭제**\n```\nStep 1: 루트(100) 제거, 마지막(40)을 루트로\n      40               [40, 80, 90, 50, 60, 70]\n     /  \\\n   80    90\n  / \\   /\n 50  60 70\n\nStep 2: 40 < 90 (오른쪽 자식, 최대) → 교환\n      90\n     /  \\\n   80    40\n  / \\   /\n 50  60 70\n\nStep 3: 40 < 70 (오른쪽 자식) → 교환\n      90\n     /  \\\n   80    70\n  / \\   /\n 50  60 40\n\nStep 4: 40이 리프 → 종료\n최종: [90, 80, 70, 50, 60, 40]\n반환: 100\n```\n\n**핵심: 마지막 원소를 사용 → 완전 이진트리 유지**\n\n---\n\n## 왜 힙은 편향이 발생하지 않는가?\n\n### 1. 완전 이진트리 강제\n\n**힙:**\n```java\n// 항상 맨 끝에 추가\ninsert(1);\ninsert(2);\ninsert(3);\ninsert(4);\ninsert(5);\n\n결과 (최대 힙):\n       5\n     /   \\\n    4     3\n   / \\\n  1   2\n\n// 완전 이진트리 형태 유지\n// 높이: log₂(5) = 2.32 → 3\n```\n\n**BST (비교):**\n```java\n// 삽입 위치가 값에 따라 결정\ninsert(1);\ninsert(2);\ninsert(3);\ninsert(4);\ninsert(5);\n\n결과:\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n\n// 편향 발생!\n// 높이: 5\n```\n\n**차이점:**\n- **힙**: 삽입 위치가 값과 무관 (항상 맨 끝)\n- **BST**: 삽입 위치가 값에 따라 결정\n\n---\n\n### 2. 삽입 순서와 무관\n\n**힙은 어떤 순서로 삽입해도 완전 이진트리:**\n\n```\n오름차순 삽입 [1,2,3,4,5]:\n       5\n     /   \\\n    4     3\n   / \\\n  1   2\n높이: 3\n\n내림차순 삽입 [5,4,3,2,1]:\n       5\n     /   \\\n    4     3\n   / \\\n  2   1\n높이: 3\n\n랜덤 삽입 [3,1,4,5,2]:\n       5\n     /   \\\n    3     4\n   / \\\n  1   2\n높이: 3\n\n// 모두 높이 ≈ log n!\n// 트리 모양만 다를 뿐, 높이는 동일\n```\n\n**BST (비교):**\n```\n오름차순: 높이 5 (편향)\n내림차순: 높이 5 (편향)\n랜덤: 높이 2~5 (운에 따라)\n```\n\n---\n\n### 3. 레벨별 채우기 방식\n\n**힙의 삽입 규칙:**\n```\n삽입 순서: A, B, C, D, E, F, G\n\nStep 1: A 삽입\n   A\n\nStep 2: B 삽입 (왼쪽부터)\n   A\n  /\n B\n\nStep 3: C 삽입 (왼쪽 끝)\n   A\n  / \\\n B   C\n\nStep 4: D 삽입 (다음 레벨, 왼쪽부터)\n   A\n  / \\\n B   C\n/\nD\n\nStep 5-7: E, F, G 삽입\n      A\n    /   \\\n   B     C\n  / \\   / \\\n D   E F   G\n\n// 레벨 0: 1개 (2^0)\n// 레벨 1: 2개 (2^1)\n// 레벨 2: 4개 (2^2)\n// → 완전 이진트리\n```\n\n**높이 보장:**\n```\nn개 노드 → 높이 = ⌊log₂(n)⌋\n\nn = 7 → h = 2\nn = 15 → h = 3\nn = 100 → h = 6\n\n// 항상 최소 높이 유지\n```\n\n---\n\n### 4. 삭제도 균형 유지\n\n**힙:**\n```java\n// 항상 마지막 원소 사용\nextractMax();  // 마지막 → 루트\n\n삭제 전: [100, 80, 90, 50, 60, 70, 40]\n         100\n        /   \\\n      80     90\n     / \\    / \\\n    50 60  70 40\n\n삭제 후: [90, 80, 70, 50, 60, 40]\n         90\n        /  \\\n      80    70\n     / \\   /\n    50 60 40\n\n// 여전히 완전 이진트리\n// 높이: log(6) ≈ 2\n```\n\n**BST (비교):**\n```\n삭제 전:    삭제(100):\n   100         80\n  /   \\       /  \\\n 80    90    50   90\n/  \\          \\     \\\n50  60         60   110\n    \\\n     110\n\n// 삭제 후 균형 보장 없음\n// 편향 가능\n```\n\n---\n\n## 힙 vs BST 비교표\n\n| 특성 | Heap | BST |\n|------|------|-----|\n| 삽입 위치 | 항상 맨 끝 | 값에 따라 결정 |\n| 트리 형태 | 완전 이진트리 강제 | 형태 보장 없음 |\n| 높이 | 항상 log n | 최악 n (편향 시) |\n| 정렬 의존성 | 없음 | 있음 (정렬 시 편향) |\n| 균형 유지 | 자동 | 없음 (BBST 필요) |\n| 삽입 순서 영향 | 없음 | 큼 |\n\n---\n\n## 배열 인덱스로 보는 균형\n\n**힙 (배열 구현):**\n```java\n삽입 순서: 1, 2, 3, 4, 5\n\n배열: [5, 4, 3, 2, 1]\nindex: 0  1  2  3  4\n\n트리:\n       5 (0)\n      / \\\n    4(1) 3(2)\n   / \\\n  2(3) 1(4)\n\n// 인덱스 0~4 순서대로 채워짐\n// 빈 공간 없음 → 완전 이진트리\n```\n\n**BST (배열 구현 어려움):**\n```\n삽입 순서: 1, 2, 3, 4, 5\n\n배열: [1, _, 2, _, _, _, 3, ..., 5]\n       ↑    ↑          ↑        ↑\n      root  ?         ?       편향\n\n// 빈 공간 많음\n// 배열 크기 = 2^h (낭비)\n```\n\n---\n\n## 결론\n\n**힙이 편향되지 않는 이유:**\n\n1. **완전 이진트리 강제**\n   - 맨 끝에만 삽입\n   - 레벨별로 왼쪽부터 채움\n\n2. **삽입 순서 무관**\n   - 정렬 여부와 관계없이 균형\n   - 값이 아닌 위치 기반\n\n3. **높이 보장**\n   - 항상 O(log n)\n   - 최소 높이 유지\n\n4. **자동 균형**\n   - Heapify만으로 균형\n   - 회전 불필요\n\n**BST의 편향 이유:**\n\n1. **값 기반 삽입**\n   - 정렬된 데이터 → 편향\n\n2. **형태 보장 없음**\n   - 균형 트리 아님\n\n3. **BBST 필요**\n   - AVL, Red-Black Tree로 해결\n\n**사용 시기:**\n- **힙**: 최댓값/최솟값 반복 조회, 우선순위 큐\n- **BST**: 정렬된 데이터, 범위 쿼리, 검색",
      "type": "essay",
      "tags": ["힙", "삽입", "삭제", "편향", "완전 이진트리"]
    },
    {
      "question": "힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?",
      "answer": "## 힙 정렬 (Heap Sort)\n\n### 시간복잡도\n\n**전체: O(n log n)**\n\n**단계별 분석:**\n\n1. **Build Heap: O(n)**\n2. **Extract Max 반복 (n번): O(n log n)**\n\n---\n\n## 힙 정렬 구현\n\n```java\nvoid heapSort(int[] arr) {\n    int n = arr.length;\n    \n    // 1. Build Max Heap: O(n)\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    \n    // 2. Extract Max 반복: O(n log n)\n    for (int i = n - 1; i > 0; i--) {\n        // 루트(최댓값)와 마지막 원소 교환\n        swap(arr, 0, i);\n        \n        // 남은 부분에 대해 Heapify\n        heapify(arr, i, 0);  // O(log n)\n    }\n}\n\nvoid heapify(int[] arr, int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n    \n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n    \n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, n, largest);  // 재귀\n    }\n}\n\nvoid swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n```\n\n---\n\n## 동작 과정 예시\n\n```\n초기 배열: [4, 10, 3, 5, 1]\n\nStep 1: Build Max Heap\n초기:   4\n       / \\\n     10   3\n     / \\\n    5   1\n\nHeapify(1): 10 > 5, 10 > 1 → 변화 없음\nHeapify(0): 4 < 10 → 교환\n\n결과:  10\n       / \\\n      5   3\n     / \\\n    4   1\n\n배열: [10, 5, 3, 4, 1]\n\n---\n\nStep 2: Extract Max 반복\n\ni=4: [10, 5, 3, 4, 1]\n     루트(10)와 마지막(1) 교환\n     [1, 5, 3, 4 | 10]\n     Heapify(0): [5, 4, 3, 1 | 10]\n\ni=3: [5, 4, 3, 1 | 10]\n     루트(5)와 마지막(1) 교환\n     [1, 4, 3 | 5, 10]\n     Heapify(0): [4, 1, 3 | 5, 10]\n\ni=2: [4, 1, 3 | 5, 10]\n     루트(4)와 마지막(3) 교환\n     [3, 1 | 4, 5, 10]\n     Heapify(0): [3, 1 | 4, 5, 10]\n\ni=1: [3, 1 | 4, 5, 10]\n     루트(3)와 마지막(1) 교환\n     [1 | 3, 4, 5, 10]\n\n최종 정렬: [1, 3, 4, 5, 10]\n```\n\n---\n\n## 시간복잡도 증명\n\n### Build Heap: O(n)\n\n**각 레벨의 비용:**\n\n```\n높이 h = log n\n\n레벨 h (리프):      n/2 노드, 이동 0번\n레벨 h-1:          n/4 노드, 이동 1번\n레벨 h-2:          n/8 노드, 이동 2번\n...\n레벨 0 (루트):      1 노드,   이동 h번\n\n총 비용:\nT = n/2 * 0 + n/4 * 1 + n/8 * 2 + ... + 1 * log n\n  = n * (1/4 + 2/8 + 3/16 + ...)\n  = n * Σ(i/2^(i+1))  (i=0 to ∞)\n  = n * 1/2  // 수렴\n  = O(n)\n```\n\n### Extract Max: O(n log n)\n\n```\nn번 반복 * Heapify O(log n)\n= O(n log n)\n```\n\n**전체:**\n```\nBuild Heap + Extract Max\n= O(n) + O(n log n)\n= O(n log n)\n```\n\n---\n\n## Stable한가? → 아니오! (Unstable)\n\n**Stable Sort:**\n- 같은 값의 상대적 순서가 유지됨\n\n**힙 정렬은 Unstable:**\n\n**예시:**\n```\n초기 배열: [3a, 3b, 2, 1]\n// a, b는 같은 값의 순서 구분\n\nBuild Heap (Max Heap):\n      3a\n     /  \\\n   3b    2\n   /\n  1\n\n배열: [3a, 3b, 2, 1]\n\nExtract Max:\n1) [3a, 3b, 2, 1] → 3a와 1 교환\n   [1, 3b, 2 | 3a]\n   Heapify: [3b, 1, 2 | 3a]\n\n2) [3b, 1, 2 | 3a] → 3b와 2 교환\n   [2, 1 | 3b, 3a]  ← 3b가 3a보다 앞!\n   Heapify: [2, 1 | 3b, 3a]\n\n3) [2, 1 | 3b, 3a] → 2와 1 교환\n   [1 | 2, 3b, 3a]\n\n최종: [1, 2, 3b, 3a]\n//        ↑   ↑\n//     순서 바뀜! (원래 3a가 먼저)\n```\n\n**왜 Unstable?**\n\n1. **Heap 구성 시 교환**: 같은 값도 위치 바뀜\n2. **Extract 시 교환**: 루트와 마지막 원소 교환\n\n---\n\n## 힙 정렬 vs 다른 정렬\n\n### 시간복잡도 비교\n\n| 정렬 | 최선 | 평균 | 최악 | 공간 | Stable |\n|------|------|------|------|------|--------|\n| 힙 정렬 | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ |\n| 병합 정렬 | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ |\n| 퀵 정렬 | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ |\n| 삽입 정렬 | O(n) | O(n²) | O(n²) | O(1) | ✅ |\n\n---\n\n### 장단점\n\n**장점:**\n1. **보장된 O(n log n)**: 최악도 O(n log n)\n2. **In-place**: 추가 메모리 O(1)\n3. **간단한 구현**: 힙 연산만 이해하면 됨\n\n**단점:**\n1. **Unstable**: 같은 값의 순서 바뀜\n2. **캐시 비효율**: 비연속 접근\n3. **실전 느림**: 평균적으로 퀵 정렬보다 느림\n\n---\n\n## 성능 비교 (실제 벤치마크)\n\n```\n100만 개 정렬:\n\n퀵 정렬:    50ms   (빠름, 캐시 효율적)\n병합 정렬:  80ms   (안정적, O(n) 메모리)\n힙 정렬:    120ms  (느림, 캐시 미스)\n```\n\n**왜 힙 정렬이 느릴까?**\n\n```\nHeapify 과정에서 비연속 접근:\n\n배열: [10, 5, 3, 4, 1]\nindex:  0  1  2  3  4\n\nHeapify(0):\n- 인덱스 0 접근\n- 인덱스 1 접근 (2*0+1)\n- 인덱스 2 접근 (2*0+2)\n- 인덱스 4 접근 (재귀)\n\n// 띄엄띄엄 접근 → 캐시 미스\n```\n\n---\n\n## 사용 사례\n\n**힙 정렬 사용:**\n- 메모리 제한 심함 (O(1) 필요)\n- 최악 성능 보장 필요\n- Stable 필요 없음\n\n**다른 정렬 사용:**\n- **퀵 정렬**: 일반적 경우 (가장 빠름)\n- **병합 정렬**: Stable 필요 시\n- **삽입 정렬**: 거의 정렬된 데이터\n\n---\n\n## Java 예시\n\n```java\nimport java.util.Arrays;\n\npublic class HeapSortExample {\n    public static void main(String[] args) {\n        int[] arr = {12, 11, 13, 5, 6, 7};\n        \n        System.out.println(\"Original: \" + Arrays.toString(arr));\n        heapSort(arr);\n        System.out.println(\"Sorted: \" + Arrays.toString(arr));\n    }\n    \n    static void heapSort(int[] arr) {\n        int n = arr.length;\n        \n        // Build heap\n        for (int i = n / 2 - 1; i >= 0; i--)\n            heapify(arr, n, i);\n        \n        // Extract elements\n        for (int i = n - 1; i > 0; i--) {\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n            \n            heapify(arr, i, 0);\n        }\n    }\n    \n    static void heapify(int[] arr, int n, int i) {\n        int largest = i;\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        \n        if (l < n && arr[l] > arr[largest])\n            largest = l;\n        \n        if (r < n && arr[r] > arr[largest])\n            largest = r;\n        \n        if (largest != i) {\n            int swap = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = swap;\n            \n            heapify(arr, n, largest);\n        }\n    }\n}\n```\n\n---\n\n## 결론\n\n**시간복잡도:**\n- **모든 경우: O(n log n)** (최선, 평균, 최악)\n\n**Stable:**\n- **아니오 (Unstable)**\n- 같은 값의 순서 보장 안 됨\n\n**사용:**\n- 메모리 제한 + 최악 성능 보장 필요 시\n- 실전에서는 퀵 정렬/병합 정렬 선호",
      "type": "essay",
      "tags": ["힙 정렬", "Heap Sort", "시간복잡도", "Stable"]
    }
  ]
}
