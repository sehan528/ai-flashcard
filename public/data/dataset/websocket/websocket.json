{
  "name": "WebSocket",
  "description": "WebSocket 핵심 개념 및 실무 질문",
  "cards": [
    {
      "question": "WebSocket의 기본 개념과 HTTP와의 차이점은 무엇인가요?",
      "answer": "**WebSocket**은 클라이언트와 서버 간 **양방향 실시간 통신**을 위한 프로토콜입니다.\n\n**HTTP와의 주요 차이점:**\n\n1. **연결 방식**\n   - HTTP: 요청-응답 기반, 단방향 통신\n   - WebSocket: 지속적인 연결, 양방향 통신\n\n2. **오버헤드**\n   - HTTP: 매 요청마다 헤더 전송 (수백 바이트)\n   - WebSocket: 최초 핸드셰이크 후 최소한의 프레임 헤더(2-14바이트)\n\n3. **실시간성**\n   - HTTP: 폴링 필요, 지연 발생\n   - WebSocket: 서버에서 즉시 푸시 가능\n\n4. **프로토콜**\n   - HTTP: http:// 또는 https://\n   - WebSocket: ws:// 또는 wss://\n\n5. **연결 유지**\n   - HTTP: Stateless, 연결이 계속 끊김\n   - WebSocket: Stateful, 연결 유지\n\n**사용 사례:** 채팅, 실시간 알림, 게임, 주식 시세, 협업 도구 등",
      "type": "essay",
      "tags": ["WebSocket", "HTTP", "실시간통신", "양방향통신"],
      "id": "1763358000000-ws001",
      "createdAt": "2025-11-17T12:30:00.000000",
      "studyCount": 0
    },
    {
      "question": "WebSocket 연결의 Handshake 과정은 어떻게 진행되나요?",
      "answer": "WebSocket은 **HTTP 기반 핸드셰이크**로 연결을 시작합니다.\n\n**1. 클라이언트 → 서버 (Upgrade 요청)**\n```http\nGET /chat HTTP/1.1\nHost: example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\n```\n\n**2. 서버 → 클라이언트 (Upgrade 응답)**\n```http\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n```\n\n**핵심 동작:**\n- `Sec-WebSocket-Key`: 클라이언트가 생성한 랜덤 값 (Base64)\n- `Sec-WebSocket-Accept`: 서버가 Key + 매직 스트링(258EAFA5-E914-47DA-95CA-C5AB0DC85B11)을 SHA-1 해싱하여 생성\n- 101 상태 코드로 프로토콜 전환 확인\n\n**핸드셰이크 성공 후:**\n- HTTP 연결이 WebSocket 연결로 업그레이드\n- 이후 데이터 프레임으로 통신",
      "type": "essay",
      "tags": ["WebSocket", "Handshake", "프로토콜", "HTTP Upgrade"],
      "id": "1763358000000-ws002",
      "createdAt": "2025-11-17T12:30:00.000001",
      "studyCount": 0
    },
    {
      "question": "WebSocket의 메시지 프레이밍(message framing) 메커니즘에 대해 설명해주세요.",
      "answer": "WebSocket은 **데이터 프레임** 단위로 메시지를 전송합니다.\n\n**프레임 구조 (RFC 6455):**\n```\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-------+-+-------------+-------------------------------+\n|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n|N|V|V|V|       |S|             |   (if payload len==126/127)   |\n| |1|2|3|       |K|             |                               |\n+-+-+-+-+-------+-+-------------+-------------------------------+\n```\n\n**주요 필드:**\n\n1. **FIN (1bit)**: 최종 프레임 여부 (1=마지막, 0=분할된 메시지의 일부)\n\n2. **Opcode (4bits)**\n   - 0x1: 텍스트 프레임 (UTF-8)\n   - 0x2: 바이너리 프레임\n   - 0x8: 연결 종료\n   - 0x9: Ping\n   - 0xA: Pong\n\n3. **MASK (1bit)**: 클라이언트→서버는 항상 1 (마스킹 필수)\n\n4. **Payload Length (7bits, 7+16bits, 7+64bits)**\n   - 0-125: 실제 길이\n   - 126: 다음 2바이트가 길이\n   - 127: 다음 8바이트가 길이\n\n5. **Masking-key (32bits)**: MASK=1일 때 존재\n\n**메시지 분할:**\n큰 메시지는 여러 프레임으로 분할 가능 (FIN=0으로 연속 전송, 마지막만 FIN=1)",
      "type": "essay",
      "tags": ["WebSocket", "프레이밍", "프로토콜", "데이터 전송"],
      "id": "1763358000000-ws003",
      "createdAt": "2025-11-17T12:30:00.000002",
      "studyCount": 0
    },
    {
      "question": "Long Polling과 WebSocket의 차이점은 무엇인가요?",
      "answer": "둘 다 실시간 데이터 전송을 위한 기술이지만, 동작 방식과 효율성에서 큰 차이가 있습니다.\n\n**Long Polling:**\n1. 클라이언트가 HTTP 요청 전송\n2. 서버가 새 데이터가 있을 때까지 응답 보류\n3. 데이터 발생 시 응답 반환\n4. 클라이언트가 즉시 새 요청 전송 (반복)\n\n**WebSocket:**\n1. 최초 핸드셰이크로 연결 수립\n2. 연결 유지하며 양방향 통신\n3. 서버/클라이언트 모두 언제든지 메시지 전송 가능\n\n**비교:**\n\n| 항목 | Long Polling | WebSocket |\n|------|--------------|------------|\n| **오버헤드** | 매우 높음 (매번 HTTP 헤더) | 낮음 (프레임 헤더만) |\n| **지연시간** | 높음 (재연결 필요) | 매우 낮음 |\n| **서버 부하** | 높음 (다수 연결 유지) | 상대적으로 낮음 |\n| **양방향성** | 제한적 (요청 있어야 응답) | 완전한 양방향 |\n| **브라우저 지원** | 모든 브라우저 | 최신 브라우저 (IE10+) |\n| **프록시 호환** | 좋음 | 프록시 설정 필요할 수 있음 |\n\n**사용 권장:**\n- Long Polling: 레거시 브라우저 지원, 간헐적 업데이트\n- WebSocket: 고빈도 실시간 통신, 낮은 지연 요구사항",
      "type": "essay",
      "tags": ["WebSocket", "Long Polling", "실시간통신", "성능비교"],
      "id": "1763358000000-ws004",
      "createdAt": "2025-11-17T12:30:00.000003",
      "studyCount": 0
    },
    {
      "question": "WebSocket 통신에서 보안을 강화하기 위한 주요 고려 사항은 무엇인가요?",
      "answer": "WebSocket은 실시간 양방향 통신이기 때문에 보안에 특별한 주의가 필요합니다.\n\n**1. WSS (WebSocket Secure) 사용**\n- TLS/SSL 암호화된 ws 프로토콜 (wss://)\n- 중간자 공격(MITM) 방지\n- 데이터 암호화 및 무결성 보장\n\n**2. Origin 검증**\n```javascript\n// 서버에서 Origin 헤더 검증\nconst allowedOrigins = ['https://example.com'];\nif (!allowedOrigins.includes(request.headers.origin)) {\n  connection.reject();\n}\n```\n\n**3. 인증 및 인가**\n- 핸드셰이크 시 토큰 검증 (JWT, 세션 등)\n- 쿠키 기반 인증 사용 시 HttpOnly, Secure 플래그 설정\n- 연결 후에도 메시지별 권한 검증\n\n**4. 입력 검증 및 새니타이제이션**\n- 클라이언트로부터 받은 모든 데이터 검증\n- XSS 공격 방지를 위한 이스케이프 처리\n- JSON 파싱 에러 핸들링\n\n**5. Rate Limiting**\n- 메시지 전송 빈도 제한\n- DoS/DDoS 공격 방지\n- 클라이언트별 연결 수 제한\n\n**6. CSRF 토큰**\n- 핸드셰이크 요청에 CSRF 토큰 포함\n- 비인가 연결 시도 차단\n\n**7. 연결 수명 관리**\n- 타임아웃 설정\n- 비활성 연결 자동 종료\n- 재연결 시 재인증 요구",
      "type": "essay",
      "tags": ["WebSocket", "보안", "WSS", "인증", "CSRF"],
      "id": "1763358000000-ws005",
      "createdAt": "2025-11-17T12:30:00.000004",
      "studyCount": 0
    },
    {
      "question": "WebSocket 연결이 끊어졌을 때 재연결(reconnect) 로직은 어떻게 구현하나요?",
      "answer": "안정적인 WebSocket 애플리케이션을 위해서는 **지수 백오프(Exponential Backoff)**를 활용한 재연결 전략이 필요합니다.\n\n**기본 재연결 로직:**\n```javascript\nclass WebSocketClient {\n  constructor(url) {\n    this.url = url;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 10;\n    this.reconnectDelay = 1000; // 초기 1초\n    this.maxReconnectDelay = 30000; // 최대 30초\n    this.connect();\n  }\n\n  connect() {\n    this.ws = new WebSocket(this.url);\n    \n    this.ws.onopen = () => {\n      console.log('Connected');\n      this.reconnectAttempts = 0; // 재연결 카운터 초기화\n      this.reconnectDelay = 1000; // 지연 시간 리셋\n    };\n    \n    this.ws.onclose = (event) => {\n      if (event.code === 1000) { // 정상 종료\n        console.log('Connection closed normally');\n        return;\n      }\n      this.handleReconnect();\n    };\n    \n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n  \n  handleReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnect attempts reached');\n      return;\n    }\n    \n    this.reconnectAttempts++;\n    \n    // 지수 백오프: 1초 → 2초 → 4초 → 8초 → ...\n    const delay = Math.min(\n      this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),\n      this.maxReconnectDelay\n    );\n    \n    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);\n    \n    setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n  \n  send(data) {\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(data);\n    } else {\n      console.warn('WebSocket is not connected');\n    }\n  }\n}\n```\n\n**고급 전략:**\n\n1. **Heartbeat/Ping-Pong**\n   - 주기적으로 ping 전송하여 연결 상태 확인\n   - 응답 없으면 재연결 시도\n\n2. **메시지 큐잉**\n   - 재연결 중 전송할 메시지를 큐에 저장\n   - 연결 후 큐의 메시지 재전송\n\n3. **연결 상태 관리**\n   - CONNECTING, OPEN, CLOSING, CLOSED 상태 추적\n   - UI에 연결 상태 표시\n\n4. **네트워크 상태 감지**\n   - `navigator.onLine` 이벤트 활용\n   - 네트워크 복구 시 즉시 재연결",
      "type": "essay",
      "tags": ["WebSocket", "재연결", "지수백오프", "안정성"],
      "id": "1763358000000-ws006",
      "createdAt": "2025-11-17T12:30:00.000005",
      "studyCount": 0
    },
    {
      "question": "WebSocket 프로토콜에서 사용되는 상태 코드와 그 의미에 대해 설명해주세요.",
      "answer": "WebSocket은 연결 종료 시 **상태 코드(Close Code)**를 사용하여 종료 이유를 전달합니다.\n\n**표준 상태 코드 (RFC 6455):**\n\n**1xxx: 프로토콜 정의 코드**\n- **1000** (Normal Closure): 정상 종료, 목적 달성\n- **1001** (Going Away): 서버 다운 또는 브라우저 페이지 이탈\n- **1002** (Protocol Error): 프로토콜 오류\n- **1003** (Unsupported Data): 지원하지 않는 데이터 타입 수신\n- **1006** (Abnormal Closure): 비정상 종료 (코드 없이 연결 끊김)\n- **1007** (Invalid frame payload data): 데이터 형식 불일치 (예: UTF-8 오류)\n- **1008** (Policy Violation): 정책 위반\n- **1009** (Message Too Big): 메시지 크기 초과\n- **1010** (Mandatory Extension): 필수 확장 누락\n- **1011** (Internal Server Error): 서버 내부 오류\n- **1012** (Service Restart): 서버 재시작\n- **1013** (Try Again Later): 일시적 서버 과부하\n- **1014** (Bad Gateway): 게이트웨이 오류\n- **1015** (TLS Handshake): TLS 핸드셰이크 실패\n\n**3xxx-4xxx: 애플리케이션 정의 코드**\n- **3000-3999**: 라이브러리/프레임워크 예약\n- **4000-4999**: 애플리케이션 커스텀 코드\n\n**사용 예시:**\n```javascript\n// 클라이언트\nws.close(1000, 'Work complete');\nws.close(4001, 'Authentication timeout');\n\n// 서버\nws.on('close', (code, reason) => {\n  console.log(`Closed: ${code} - ${reason}`);\n  \n  if (code === 1006) {\n    // 비정상 종료 - 재연결 시도\n  } else if (code === 1000) {\n    // 정상 종료 - 재연결 불필요\n  }\n});\n```\n\n**실무 팁:**\n- 1000-1015는 프로토콜 표준, 커스텀 코드는 4000+ 사용\n- 상태 코드로 재연결 여부 판단\n- 로깅 및 모니터링에 활용",
      "type": "essay",
      "tags": ["WebSocket", "상태코드", "Close Code", "프로토콜"],
      "id": "1763358000000-ws007",
      "createdAt": "2025-11-17T12:30:00.000006",
      "studyCount": 0
    },
    {
      "question": "Ping/Pong 메커니즘이 WebSocket 연결 유지에 어떻게 활용되는지 설명해주세요.",
      "answer": "Ping/Pong은 WebSocket의 **연결 유지(Keep-Alive)** 및 **연결 상태 확인**을 위한 메커니즘입니다.\n\n**동작 원리:**\n\n1. **Ping 프레임 (Opcode 0x9)**\n   - 한쪽에서 연결 확인을 위해 전송\n   - Payload 데이터 포함 가능 (최대 125바이트)\n\n2. **Pong 프레임 (Opcode 0xA)**\n   - Ping을 받은 쪽에서 가능한 빨리 응답\n   - Ping의 Payload를 그대로 복사하여 전송\n\n**주요 용도:**\n\n**1. 연결 상태 확인 (Heartbeat)**\n```javascript\n// 서버 측 (Node.js ws 라이브러리)\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws) => {\n  let isAlive = true;\n  \n  ws.on('pong', () => {\n    isAlive = true; // Pong 받으면 살아있음\n  });\n  \n  // 30초마다 Ping 전송\n  const interval = setInterval(() => {\n    if (!isAlive) {\n      // Pong 응답 없으면 연결 종료\n      ws.terminate();\n      return;\n    }\n    \n    isAlive = false;\n    ws.ping(); // Ping 전송\n  }, 30000);\n  \n  ws.on('close', () => {\n    clearInterval(interval);\n  });\n});\n```\n\n**2. 프록시/방화벽 타임아웃 방지**\n- 많은 프록시가 비활성 연결을 60초 후 종료\n- 주기적인 Ping으로 연결 유지\n\n**3. 네트워크 장애 감지**\n```javascript\n// 클라이언트 측\nlet pingTimeout;\n\nws.on('ping', () => {\n  clearTimeout(pingTimeout);\n  \n  // 60초 이내 Ping 없으면 연결 끊김으로 간주\n  pingTimeout = setTimeout(() => {\n    ws.close(1006, 'Ping timeout');\n  }, 60000);\n});\n```\n\n**실무 권장사항:**\n\n- **서버에서 Ping 전송 권장** (클라이언트는 자동 Pong 응답)\n- **간격: 30-60초** (프록시 타임아웃보다 짧게)\n- **무응답 허용: 1-2회** (네트워크 지연 고려)\n- **타임아웃 시 연결 종료 후 재연결**\n\n**브라우저 제약:**\n- 브라우저 WebSocket API는 자동으로 Pong 응답\n- JavaScript에서 직접 Ping/Pong 제어 불가\n- 서버에서 Ping 보내면 브라우저가 자동 Pong 응답",
      "type": "essay",
      "tags": ["WebSocket", "Ping", "Pong", "Heartbeat", "Keep-Alive"],
      "id": "1763358000000-ws008",
      "createdAt": "2025-11-17T12:30:00.000007",
      "studyCount": 0
    },
    {
      "question": "WebSocket 확장(extensions) 기능은 무엇이며, 어떤 용도로 사용되나요?",
      "answer": "WebSocket Extensions는 **프로토콜의 기본 기능을 확장**하여 추가 기능을 제공하는 메커니즘입니다.\n\n**핸드셰이크에서의 협상:**\n```http\n// 클라이언트 요청\nGET /chat HTTP/1.1\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\n\n// 서버 응답\nHTTP/1.1 101 Switching Protocols\nSec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=15\n```\n\n**주요 확장 기능:**\n\n**1. permessage-deflate (RFC 7692)**\n- **용도**: 메시지 압축 (DEFLATE 알고리즘)\n- **효과**: 대역폭 절감 (텍스트 70-90% 압축 가능)\n- **설정 파라미터**:\n  - `server_max_window_bits`: 서버 압축 윈도우 크기 (8-15)\n  - `client_max_window_bits`: 클라이언트 압축 윈도우 크기\n  - `server_no_context_takeover`: 메시지마다 새 압축 컨텍스트\n  - `client_no_context_takeover`: 클라이언트 컨텍스트 재사용 안함\n\n```javascript\n// Node.js 서버 예시\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({\n  port: 8080,\n  perMessageDeflate: {\n    zlibDeflateOptions: {\n      chunkSize: 1024,\n      memLevel: 7,\n      level: 3 // 압축 레벨 (0-9)\n    },\n    zlibInflateOptions: {\n      chunkSize: 10 * 1024\n    },\n    threshold: 1024 // 1KB 이상만 압축\n  }\n});\n```\n\n**2. 기타 확장 (비표준/제안)**\n- **multiplexing**: 하나의 연결로 여러 논리적 채널\n- **fragmentation**: 프레임 분할 최적화\n\n**장점:**\n- **대역폭 절감**: 특히 JSON/텍스트 데이터에 효과적\n- **비용 절감**: 클라우드 환경의 네트워크 비용 감소\n\n**단점/주의사항:**\n- **CPU 오버헤드**: 압축/해제에 CPU 사용\n- **레이턴시 증가**: 실시간성이 중요하면 압축 비활성화 고려\n- **작은 메시지**: 오히려 오버헤드 증가 가능 (threshold 설정)\n\n**실무 권장:**\n```javascript\n// 메시지 크기에 따른 압축 전략\nperMessageDeflate: {\n  threshold: 1024, // 1KB 이상만 압축\n  level: 3 // 낮은 압축률로 CPU 절약 (1-9, 기본 6)\n}\n```\n\n**브라우저 지원:**\n- 대부분의 최신 브라우저가 permessage-deflate 지원\n- 서버가 지원하면 자동으로 활성화",
      "type": "essay",
      "tags": ["WebSocket", "Extensions", "압축", "permessage-deflate"],
      "id": "1763358000000-ws009",
      "createdAt": "2025-11-17T12:30:00.000008",
      "studyCount": 0
    },
    {
      "question": "WebSocket 구현 시 발생할 수 있는 Cross-Origin 문제와 그 해결 방법은 무엇인가요?",
      "answer": "WebSocket은 **기본적으로 CORS(Cross-Origin Resource Sharing) 정책을 따르지 않지만**, Origin 기반 보안 검증이 필요합니다.\n\n**WebSocket과 CORS의 차이:**\n\n1. **HTTP CORS**: 브라우저가 자동으로 preflight 요청 보내고 검증\n2. **WebSocket**: 브라우저가 Origin 헤더만 전송, **서버가 직접 검증해야 함**\n\n**문제 상황:**\n```javascript\n// https://example.com에서 실행되는 코드\nconst ws = new WebSocket('wss://api.other-domain.com/socket');\n// Origin 헤더: https://example.com\n```\n\n**서버측 검증이 없으면:**\n- 모든 Origin에서 연결 가능\n- CSRF 공격에 취약\n- 인증 쿠키가 자동으로 전송되어 보안 위험\n\n**해결 방법:**\n\n**1. Origin 헤더 검증 (필수)**\n```javascript\n// Node.js (ws 라이브러리)\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ \n  noServer: true \n});\n\nconst allowedOrigins = [\n  'https://example.com',\n  'https://www.example.com'\n];\n\nserver.on('upgrade', (request, socket, head) => {\n  const origin = request.headers.origin;\n  \n  // Origin 검증\n  if (!allowedOrigins.includes(origin)) {\n    socket.write('HTTP/1.1 403 Forbidden\\r\\n\\r\\n');\n    socket.destroy();\n    return;\n  }\n  \n  wss.handleUpgrade(request, socket, head, (ws) => {\n    wss.emit('connection', ws, request);\n  });\n});\n```\n\n**2. 토큰 기반 인증**\n```javascript\n// 쿠키 대신 토큰 사용\nconst ws = new WebSocket('wss://api.example.com/socket?token=JWT_TOKEN');\n\n// 또는 Sec-WebSocket-Protocol 활용\nconst ws = new WebSocket('wss://api.example.com/socket', [\n  'access_token',\n  yourToken\n]);\n```\n\n**3. 서버 측 토큰 검증**\n```javascript\nwss.on('connection', (ws, request) => {\n  // URL 파라미터에서 토큰 추출\n  const url = new URL(request.url, 'ws://base');\n  const token = url.searchParams.get('token');\n  \n  // 토큰 검증\n  if (!verifyToken(token)) {\n    ws.close(1008, 'Invalid token');\n    return;\n  }\n  \n  // 연결 승인\n});\n```\n\n**4. 개발 환경 프록시 설정**\n```javascript\n// Vite 설정 예시\nexport default {\n  server: {\n    proxy: {\n      '/socket': {\n        target: 'ws://localhost:8080',\n        ws: true\n      }\n    }\n  }\n};\n```\n\n**보안 체크리스트:**\n- ✅ Origin 헤더 검증 (화이트리스트)\n- ✅ 토큰 기반 인증 (쿠키 의존 최소화)\n- ✅ WSS(TLS) 사용\n- ✅ Rate limiting\n- ✅ 연결 후에도 메시지별 권한 검증",
      "type": "essay",
      "tags": ["WebSocket", "CORS", "보안", "Origin", "인증"],
      "id": "1763358000000-ws010",
      "createdAt": "2025-11-17T12:30:00.000009",
      "studyCount": 0
    },
    {
      "question": "단일 서버와 클러스터 환경에서의 WebSocket 구현 차이점은 무엇인가요?",
      "answer": "클러스터 환경에서는 **연결 상태 공유**와 **메시지 브로드캐스팅**이 핵심 과제입니다.\n\n**단일 서버:**\n```javascript\n// 간단한 브로드캐스트\nconst clients = new Set();\n\nwss.on('connection', (ws) => {\n  clients.add(ws);\n  \n  ws.on('message', (data) => {\n    // 모든 클라이언트에게 전송\n    clients.forEach(client => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(data);\n      }\n    });\n  });\n  \n  ws.on('close', () => {\n    clients.delete(ws);\n  });\n});\n```\n\n**클러스터 환경의 문제:**\n\n1. **연결 분산**: 사용자 A와 B가 서로 다른 서버에 연결\n2. **상태 공유 불가**: 서버 1의 메시지를 서버 2의 클라이언트가 받을 수 없음\n3. **세션 지속성**: Sticky Session 필요할 수 있음\n\n**해결 방법:**\n\n**1. Redis Pub/Sub 사용**\n```javascript\nconst Redis = require('ioredis');\nconst publisher = new Redis();\nconst subscriber = new Redis();\n\n// 각 서버 인스턴스\nconst clients = new Set();\n\nwss.on('connection', (ws) => {\n  clients.add(ws);\n  \n  ws.on('message', (data) => {\n    // Redis로 발행\n    publisher.publish('chat-channel', data);\n  });\n});\n\n// Redis 구독\nsubscriber.subscribe('chat-channel');\nsubscriber.on('message', (channel, data) => {\n  // 현재 서버의 모든 클라이언트에게 전송\n  clients.forEach(client => {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(data);\n    }\n  });\n});\n```\n\n**2. Socket.IO 어댑터 사용**\n```javascript\nconst io = require('socket.io')(server);\nconst { createAdapter } = require('@socket.io/redis-adapter');\nconst { createClient } = require('redis');\n\nconst pubClient = createClient({ host: 'localhost', port: 6379 });\nconst subClient = pubClient.duplicate();\n\nio.adapter(createAdapter(pubClient, subClient));\n\n// 이제 자동으로 모든 서버 인스턴스 간 동기화\nio.emit('message', 'Hello to all servers');\n```\n\n**3. 공유 데이터 저장소**\n```javascript\n// 사용자 연결 정보 저장\nconst userConnections = new Map(); // 로컬\n\n// Redis에도 저장\naws.on('connection', (ws, request) => {\n  const userId = getUserIdFromToken(request);\n  \n  // 로컬 저장\n  userConnections.set(userId, ws);\n  \n  // Redis에 현재 서버 정보 저장\n  redis.hset('user:connections', userId, SERVER_ID);\n  \n  ws.on('close', () => {\n    userConnections.delete(userId);\n    redis.hdel('user:connections', userId);\n  });\n});\n```\n\n**4. 로드 밸런서 설정**\n```nginx\n# Nginx - Sticky Session 설정\nupstream websocket_backend {\n  ip_hash; # 같은 IP는 같은 서버로\n  server backend1:8080;\n  server backend2:8080;\n  server backend3:8080;\n}\n\nserver {\n  location /socket {\n    proxy_pass http://websocket_backend;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_read_timeout 86400; # 24시간\n  }\n}\n```\n\n**아키텍처 비교:**\n\n| 방식 | 장점 | 단점 |\n|------|------|------|\n| **Sticky Session** | 구현 간단 | 서버 장애 시 연결 끊김, 부하 불균형 |\n| **Redis Pub/Sub** | 실시간 동기화, 확장성 | Redis 의존성, 약간의 오버헤드 |\n| **Message Queue** | 안정적, 메시지 보장 | 복잡도 증가, 레이턴시 |\n| **Service Mesh** | 자동 관리, 모니터링 | 인프라 복잡도 |\n\n**권장 아키텍처:**\n- **소규모**: Sticky Session\n- **중규모**: Redis Pub/Sub + Sticky Session\n- **대규모**: Redis Cluster + Message Queue + 전용 WS 서버",
      "type": "essay",
      "tags": ["WebSocket", "클러스터", "Redis", "Pub/Sub", "확장성"],
      "id": "1763358000000-ws011",
      "createdAt": "2025-11-17T12:30:00.000010",
      "studyCount": 0
    },
    {
      "question": "WebSocket에서 텍스트와 이진 데이터 전송 방식의 장단점은 무엇인가요?",
      "answer": "WebSocket은 **텍스트(Text)** 와 **이진(Binary)** 두 가지 데이터 타입을 지원하며, 각각 다른 용도에 최적화되어 있습니다.\n\n**텍스트 프레임 (Opcode 0x1):**\n\n**특징:**\n- UTF-8 인코딩 필수\n- 사람이 읽을 수 있는 형식\n- JSON, XML, 일반 텍스트 전송\n\n**장점:**\n- 디버깅 용이 (브라우저 개발자 도구에서 확인 가능)\n- 플랫폼 독립적\n- JSON과 잘 맞음\n\n**단점:**\n- UTF-8 검증 오버헤드\n- Base64 인코딩 필요 시 크기 33% 증가\n- 이진 데이터에 비효율적\n\n```javascript\n// 텍스트 전송\nconst data = { type: 'message', content: 'Hello' };\nws.send(JSON.stringify(data)); // 문자열\n```\n\n**이진 프레임 (Opcode 0x2):**\n\n**특징:**\n- 원시 바이트 데이터\n- UTF-8 검증 없음\n- ArrayBuffer, Blob, TypedArray 전송\n\n**장점:**\n- 효율적인 크기 (인코딩 오버헤드 없음)\n- 빠른 처리 (검증 최소화)\n- 미디어, 파일, 프로토콜 버퍼에 적합\n\n**단점:**\n- 디버깅 어려움\n- 직렬화/역직렬화 수동 처리\n- 브라우저 도구에서 확인 불편\n\n```javascript\n// 이진 전송\nconst buffer = new ArrayBuffer(8);\nconst view = new DataView(buffer);\nview.setInt32(0, 42);\nws.send(buffer); // ArrayBuffer\n\n// Blob\nconst blob = new Blob(['binary data'], { type: 'application/octet-stream' });\nws.send(blob);\n```\n\n**성능 비교:**\n\n**JSON (텍스트) vs Protocol Buffers (이진)**\n```javascript\n// JSON: 57 bytes\n{\"userId\":123,\"message\":\"Hello\",\"timestamp\":1699999999}\n\n// Protocol Buffers: ~20 bytes (64% 절감)\n[압축된 이진 데이터]\n```\n\n**수신 처리:**\n```javascript\nws.binaryType = 'arraybuffer'; // 또는 'blob' (기본값)\n\nws.onmessage = (event) => {\n  if (typeof event.data === 'string') {\n    // 텍스트 메시지\n    const data = JSON.parse(event.data);\n    console.log('Text:', data);\n  } else {\n    // 이진 메시지 (ArrayBuffer 또는 Blob)\n    if (event.data instanceof ArrayBuffer) {\n      const view = new DataView(event.data);\n      console.log('Binary:', view.getInt32(0));\n    }\n  }\n};\n```\n\n**선택 기준:**\n\n| 사용 사례 | 권장 타입 | 이유 |\n|-----------|-----------|------|\n| 채팅 메시지 | 텍스트 | 디버깅, JSON 호환 |\n| 실시간 게임 | 이진 | 낮은 지연, 작은 크기 |\n| 센서 데이터 | 이진 | 효율성, 높은 빈도 |\n| API 응답 | 텍스트 | 호환성, 명확성 |\n| 파일 전송 | 이진 | 원본 유지 |\n| 영상/오디오 | 이진 | 스트리밍 효율 |\n| 알림 | 텍스트 | 간단함 |\n\n**최적화 팁:**\n\n1. **하이브리드 접근**\n```javascript\n// 메타데이터는 JSON, 실제 데이터는 이진\nconst metadata = JSON.stringify({ type: 'image', size: 1024 });\nconst imageData = new ArrayBuffer(1024);\n\n// 구분자로 결합하거나 별도 메시지로 전송\nws.send(metadata);\nws.send(imageData);\n```\n\n2. **MessagePack 사용**\n```javascript\nconst msgpack = require('msgpack-lite');\n\n// JSON보다 작고 빠름\nconst encoded = msgpack.encode({ userId: 123, message: 'Hello' });\nws.send(encoded); // 이진\n```\n\n3. **압축 활용**\n- 텍스트: permessage-deflate 확장\n- 이진: 이미 압축된 경우 압축 비활성화",
      "type": "essay",
      "tags": ["WebSocket", "텍스트", "이진데이터", "성능", "Protocol Buffers"],
      "id": "1763358000000-ws012",
      "createdAt": "2025-11-17T12:30:00.000011",
      "studyCount": 0
    },
    {
      "question": "실시간 채팅이나 게임 애플리케이션에서 WebSocket이 선호되는 이유는 무엇인가요?",
      "answer": "WebSocket은 **낮은 지연시간**, **양방향 통신**, **효율성** 덕분에 실시간 애플리케이션에 최적화되어 있습니다.\n\n**1. 낮은 지연시간 (Low Latency)**\n\n**HTTP 폴링:**\n```\n클라이언트 → 서버: 새 메시지 있나요? (요청)\n서버 → 클라이언트: 없음 (응답)\n[1초 대기]\n클라이언트 → 서버: 새 메시지 있나요?\n서버 → 클라이언트: 없음\n...\n평균 지연: 500ms + 네트워크 왕복 시간\n```\n\n**WebSocket:**\n```\n서버 → 클라이언트: 새 메시지! (즉시 푸시)\n지연: 네트워크 왕복 시간만 (~10-50ms)\n```\n\n**2. 오버헤드 절감**\n\n**HTTP 요청:**\n```http\nGET /messages HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0...\nCookie: session=abc123...\nAccept: application/json\n...\n총 ~500-1000 bytes 헤더\n```\n\n**WebSocket 프레임:**\n```\n[2-14 bytes 헤더] + 실제 데이터\n오버헤드 99% 감소\n```\n\n**대역폭 비교 (1000명 사용자, 1초당 1개 메시지):**\n- HTTP 폴링: ~500KB/s × 1000 = 500MB/s\n- WebSocket: ~0.1KB/s × 1000 = 100KB/s\n**절감: 99.8%**\n\n**3. 실시간 채팅 예시**\n\n```javascript\n// 채팅 메시지 즉시 전달\nws.on('message', (data) => {\n  const message = JSON.parse(data);\n  \n  // 같은 방의 모든 사용자에게 즉시 브로드캐스트\n  chatRooms.get(message.roomId).forEach(client => {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(JSON.stringify({\n        user: message.user,\n        text: message.text,\n        timestamp: Date.now()\n      }));\n    }\n  });\n});\n\n// 타이핑 표시도 실시간\nws.on('typing', (data) => {\n  broadcastToRoom(data.roomId, {\n    type: 'typing',\n    user: data.user\n  });\n});\n```\n\n**4. 게임 애플리케이션 예시**\n\n```javascript\n// 플레이어 위치 업데이트 (60fps)\nsetInterval(() => {\n  const state = {\n    players: getPlayerPositions(),\n    timestamp: Date.now()\n  };\n  \n  // 이진 데이터로 효율적 전송\n  const buffer = encodeGameState(state); // Protocol Buffers\n  \n  players.forEach(player => {\n    player.ws.send(buffer);\n  });\n}, 16); // ~60fps\n```\n\n**WebSocket의 장점 요약:**\n\n| 요구사항 | WebSocket | HTTP 폴링 |\n|----------|-----------|------------|\n| **지연시간** | 10-50ms | 500-1000ms |\n| **서버 부하** | 낮음 | 매우 높음 |\n| **대역폭** | 최소 | 많음 |\n| **배터리 소모** | 적음 | 많음 (모바일) |\n| **동시 연결** | 10k+ | ~1k |\n| **실시간성** | 완벽 | 제한적 |\n\n**실제 사용 사례:**\n\n**채팅:**\n- Slack, Discord, WhatsApp Web\n- 메시지 즉시 전달\n- 읽음 표시, 타이핑 표시\n- 파일 업로드 진행 상황\n\n**게임:**\n- 멀티플레이어 게임 (Agar.io, Slither.io)\n- 플레이어 위치/상태 동기화\n- 낮은 지연으로 부드러운 경험\n\n**협업 도구:**\n- Google Docs, Figma\n- 실시간 공동 편집\n- 커서 위치 공유\n\n**라이브 피드:**\n- 주식 시세\n- 스포츠 경기 점수\n- SNS 피드 업데이트\n\n**IoT/모니터링:**\n- 센서 데이터 실시간 수집\n- 대시보드 업데이트\n- 알림 즉시 전달",
      "type": "essay",
      "tags": ["WebSocket", "실시간", "채팅", "게임", "성능"],
      "id": "1763358000000-ws013",
      "createdAt": "2025-11-17T12:30:00.000012",
      "studyCount": 0
    },
    {
      "question": "WebSocket 서버의 부하 분산(load balancing) 전략에는 어떤 것들이 있나요?",
      "answer": "WebSocket은 **장시간 연결 유지**와 **상태 유지** 특성 때문에 일반 HTTP보다 부하 분산이 복잡합니다.\n\n**부하 분산 전략:**\n\n**1. IP Hash (Sticky Session)**\n\n```nginx\nupstream websocket_backend {\n  ip_hash;\n  server backend1:8080;\n  server backend2:8080;\n  server backend3:8080;\n}\n```\n\n**장점:**\n- 구현 간단\n- 같은 클라이언트는 항상 같은 서버 연결\n\n**단점:**\n- NAT 환경에서 불균형 발생 가능\n- 서버 장애 시 해당 연결 모두 끊김\n- 동적 스케일링 어려움\n\n**2. 쿠키/토큰 기반 라우팅**\n\n```nginx\n# Nginx Plus\nupstream websocket_backend {\n  hash $cookie_server_id consistent;\n  server backend1:8080;\n  server backend2:8080;\n}\n\nmap $cookie_server_id $backend_server {\n  \"server1\" backend1:8080;\n  \"server2\" backend2:8080;\n  default   backend1:8080;\n}\n```\n\n**3. Least Connections**\n\n```nginx\nupstream websocket_backend {\n  least_conn; # 연결 수가 가장 적은 서버로\n  server backend1:8080;\n  server backend2:8080;\n  server backend3:8080;\n}\n```\n\n**장점:**\n- 동적 부하 분산\n- 서버 간 균형 유지\n\n**단점:**\n- Sticky Session 없으면 클러스터 환경 복잡도 증가\n\n**4. 지리적 라우팅**\n\n```nginx\n# AWS ALB / CloudFront\ngeo $nearest_region {\n  default        us-east;\n  1.2.0.0/16     asia;\n  10.0.0.0/8     europe;\n}\n\nupstream websocket_backend {\n  server backend-us.example.com;\n  server backend-asia.example.com;\n  server backend-eu.example.com;\n}\n```\n\n**5. 애플리케이션 레벨 라우팅**\n\n```javascript\n// 연결 시 서버 선택\nconst selectServer = (userId) => {\n  const serverIndex = userId % NUM_SERVERS;\n  return SERVERS[serverIndex];\n};\n\n// 클라이언트\nconst serverId = await fetch('/api/get-ws-server').then(r => r.json());\nconst ws = new WebSocket(`wss://${serverId}/socket`);\n```\n\n**클러스터 환경 아키텍처:**\n\n**방법 1: Redis Pub/Sub**\n```\n클라이언트 A → 서버 1 ──┐\n클라이언트 B → 서버 2 ──┼→ Redis Pub/Sub\n클라이언트 C → 서버 3 ──┘\n\n서버 간 메시지 동기화\n```\n\n**방법 2: 전용 Message Broker**\n```\n           ┌→ WebSocket Server 1 (연결 관리 전용)\n           ├→ WebSocket Server 2\nKafka/RabbitMQ ├→ WebSocket Server 3\n           └→ WebSocket Server N\n           ↑\n      Application Servers (비즈니스 로직)\n```\n\n**고급 전략:**\n\n**1. Connection Draining**\n```javascript\n// 서버 종료 전 연결 점진적 이동\nprocess.on('SIGTERM', () => {\n  console.log('Draining connections...');\n  \n  // 새 연결 거부\n  server.close();\n  \n  // 기존 연결에 재연결 요청\n  clients.forEach(ws => {\n    ws.send(JSON.stringify({\n      type: 'reconnect',\n      reason: 'server_maintenance'\n    }));\n  });\n  \n  // 30초 후 강제 종료\n  setTimeout(() => {\n    process.exit(0);\n  }, 30000);\n});\n```\n\n**2. Health Check**\n```nginx\nupstream websocket_backend {\n  server backend1:8080 max_fails=3 fail_timeout=30s;\n  server backend2:8080 max_fails=3 fail_timeout=30s;\n  \n  # Health check endpoint\n  check interval=3000 rise=2 fall=3 timeout=1000;\n}\n```\n\n**3. 동적 스케일링**\n```javascript\n// AWS Auto Scaling + ALB Target Group\n// 연결 수 기반 스케일링\nif (activeConnections > 8000) {\n  scaleUp();\n} else if (activeConnections < 2000) {\n  scaleDown();\n}\n```\n\n**모니터링 지표:**\n\n```javascript\n// 각 서버에서 수집\nconst metrics = {\n  activeConnections: clients.size,\n  messagesPerSecond: messageCount / interval,\n  cpuUsage: process.cpuUsage(),\n  memoryUsage: process.memoryUsage().heapUsed,\n  errorRate: errors / totalMessages\n};\n\n// 중앙 모니터링 시스템으로 전송\nsendToPrometheus(metrics);\n```\n\n**권장 아키텍처:**\n\n**소규모 (<10k 연결):**\n- Nginx IP Hash\n- 2-3개 서버\n- 간단한 health check\n\n**중규모 (<100k 연결):**\n- Nginx Least Connections + Redis Pub/Sub\n- Auto Scaling\n- Connection Draining\n\n**대규모 (100k+ 연결):**\n- 지리적 분산 (Multi-region)\n- 전용 WS 서버 클러스터\n- Kafka/RabbitMQ 메시지 브로커\n- 고급 모니터링 및 알림",
      "type": "essay",
      "tags": ["WebSocket", "로드밸런싱", "부하분산", "클러스터", "스케일링"],
      "id": "1763358000000-ws014",
      "createdAt": "2025-11-17T12:30:00.000013",
      "studyCount": 0
    },
    {
      "question": "WebSocket 연결 유지 시 메모리 및 리소스 관리 방법은 무엇인가요?",
      "answer": "WebSocket은 **장시간 연결 유지**로 인해 메모리 누수와 리소스 고갈에 취약합니다. 체계적인 관리가 필수입니다.\n\n**1. 연결 수 제한**\n\n```javascript\nconst MAX_CONNECTIONS = 10000;\nlet currentConnections = 0;\n\nwss.on('connection', (ws, req) => {\n  if (currentConnections >= MAX_CONNECTIONS) {\n    ws.close(1008, 'Server at capacity');\n    return;\n  }\n  \n  currentConnections++;\n  \n  ws.on('close', () => {\n    currentConnections--;\n  });\n});\n```\n\n**2. 사용자당 연결 제한**\n\n```javascript\nconst userConnections = new Map(); // userId -> Set<WebSocket>\nconst MAX_CONNECTIONS_PER_USER = 5;\n\nwss.on('connection', (ws, req) => {\n  const userId = getUserId(req);\n  \n  if (!userConnections.has(userId)) {\n    userConnections.set(userId, new Set());\n  }\n  \n  const connections = userConnections.get(userId);\n  \n  if (connections.size >= MAX_CONNECTIONS_PER_USER) {\n    // 가장 오래된 연결 종료\n    const oldest = connections.values().next().value;\n    oldest.close(1008, 'Connection limit exceeded');\n  }\n  \n  connections.add(ws);\n  \n  ws.on('close', () => {\n    connections.delete(ws);\n    if (connections.size === 0) {\n      userConnections.delete(userId);\n    }\n  });\n});\n```\n\n**3. 유휴 연결 타임아웃**\n\n```javascript\nconst IDLE_TIMEOUT = 5 * 60 * 1000; // 5분\n\nwss.on('connection', (ws) => {\n  let idleTimer;\n  \n  const resetIdleTimer = () => {\n    clearTimeout(idleTimer);\n    idleTimer = setTimeout(() => {\n      ws.close(1000, 'Idle timeout');\n    }, IDLE_TIMEOUT);\n  };\n  \n  resetIdleTimer();\n  \n  ws.on('message', () => {\n    resetIdleTimer(); // 메시지 받으면 타이머 리셋\n  });\n  \n  ws.on('pong', () => {\n    resetIdleTimer(); // Pong 받아도 리셋\n  });\n  \n  ws.on('close', () => {\n    clearTimeout(idleTimer);\n  });\n});\n```\n\n**4. 메모리 누수 방지**\n\n```javascript\n// 잘못된 예: 메모리 누수 발생\nconst clients = [];\nwss.on('connection', (ws) => {\n  clients.push(ws);\n  // close 이벤트에서 제거 안 함 → 메모리 누수!\n});\n\n// 올바른 예: WeakSet/WeakMap 또는 명시적 제거\nconst clients = new Set();\n\nwss.on('connection', (ws) => {\n  clients.add(ws);\n  \n  ws.on('close', () => {\n    clients.delete(ws); // 반드시 제거!\n  });\n});\n```\n\n**5. 메시지 크기 제한**\n\n```javascript\nconst MAX_MESSAGE_SIZE = 1024 * 1024; // 1MB\n\nconst wss = new WebSocket.Server({\n  maxPayload: MAX_MESSAGE_SIZE\n});\n\nws.on('message', (data) => {\n  if (data.length > MAX_MESSAGE_SIZE) {\n    ws.close(1009, 'Message too large');\n    return;\n  }\n});\n```\n\n**6. Rate Limiting**\n\n```javascript\nconst RATE_LIMIT = 100; // 메시지/분\nconst RATE_WINDOW = 60 * 1000; // 1분\n\nconst messageCounts = new Map(); // ws -> { count, resetTime }\n\nws.on('message', (data) => {\n  const now = Date.now();\n  let rateData = messageCounts.get(ws);\n  \n  if (!rateData || now > rateData.resetTime) {\n    rateData = { count: 0, resetTime: now + RATE_WINDOW };\n    messageCounts.set(ws, rateData);\n  }\n  \n  rateData.count++;\n  \n  if (rateData.count > RATE_LIMIT) {\n    ws.close(1008, 'Rate limit exceeded');\n    return;\n  }\n  \n  // 정상 처리\n});\n```\n\n**7. 버퍼 관리**\n\n```javascript\nws.on('message', (data) => {\n  // 버퍼링된 데이터 확인\n  if (ws.bufferedAmount > 1024 * 1024) { // 1MB\n    console.warn('Send buffer is full, slowing down');\n    // 전송 속도 조절 또는 연결 종료\n    return;\n  }\n  \n  ws.send(data);\n});\n```\n\n**8. 리소스 정리**\n\n```javascript\nwss.on('connection', (ws) => {\n  const timers = [];\n  const intervals = [];\n  \n  // 타이머 추적\n  const addTimer = (timer) => timers.push(timer);\n  const addInterval = (interval) => intervals.push(interval);\n  \n  addTimer(setTimeout(() => {\n    ws.send('periodic update');\n  }, 1000));\n  \n  ws.on('close', () => {\n    // 모든 타이머/인터벌 정리\n    timers.forEach(clearTimeout);\n    intervals.forEach(clearInterval);\n    \n    // 다른 리소스도 정리\n    // - DB 연결, 파일 핸들, 이벤트 리스너 등\n  });\n});\n```\n\n**9. 메모리 모니터링**\n\n```javascript\nconst monitoring = setInterval(() => {\n  const usage = process.memoryUsage();\n  \n  console.log({\n    rss: `${Math.round(usage.rss / 1024 / 1024)}MB`,\n    heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,\n    connections: clients.size\n  });\n  \n  // 메모리 임계치 초과 시 경고\n  if (usage.heapUsed > 500 * 1024 * 1024) { // 500MB\n    console.error('High memory usage!');\n    // 알림 발송, 새 연결 거부 등\n  }\n}, 10000); // 10초마다\n```\n\n**10. Graceful Shutdown**\n\n```javascript\nprocess.on('SIGTERM', async () => {\n  console.log('Shutting down gracefully...');\n  \n  // 새 연결 거부\n  server.close();\n  \n  // 모든 클라이언트에게 알림\n  clients.forEach(ws => {\n    ws.send(JSON.stringify({ type: 'server_shutdown' }));\n    ws.close(1001, 'Server restarting');\n  });\n  \n  // 리소스 정리\n  clearInterval(monitoring);\n  \n  // 완료 대기\n  await waitForConnectionsToClose();\n  \n  process.exit(0);\n});\n```\n\n**모범 사례 체크리스트:**\n\n- ✅ 전역 연결 수 제한\n- ✅ 사용자당 연결 수 제한\n- ✅ 유휴 타임아웃 설정\n- ✅ 메시지 크기 제한\n- ✅ Rate limiting\n- ✅ close 이벤트에서 리소스 정리\n- ✅ 메모리 모니터링\n- ✅ Graceful shutdown\n- ✅ 주기적인 메모리 프로파일링",
      "type": "essay",
      "tags": ["WebSocket", "메모리관리", "리소스관리", "성능최적화"],
      "id": "1763358000000-ws015",
      "createdAt": "2025-11-17T12:30:00.000014",
      "studyCount": 0
    },
    {
      "question": "WebSocket과 HTTP/2의 주요 차이점은 무엇인가요?",
      "answer": "HTTP/2와 WebSocket은 모두 성능 개선을 목표로 하지만, **설계 목적과 동작 방식**이 다릅니다.\n\n**HTTP/2 특징:**\n\n1. **멀티플렉싱**: 단일 TCP 연결로 여러 요청/응답 동시 처리\n2. **서버 푸시**: 서버가 클라이언트 요청 전에 리소스 전송 가능\n3. **헤더 압축**: HPACK 압축으로 헤더 크기 감소\n4. **여전히 요청-응답 모델**: 클라이언트가 먼저 요청해야 함\n\n**WebSocket 특징:**\n\n1. **완전한 양방향**: 어느 쪽이든 먼저 메시지 전송 가능\n2. **단일 연결**: 핸드셰이크 후 지속적 연결\n3. **최소 프레임 헤더**: 2-14바이트\n4. **실시간 통신 최적화**: 낮은 지연시간\n\n**비교 표:**\n\n| 특성 | HTTP/2 | WebSocket |\n|------|--------|------------|\n| **프로토콜** | HTTP 확장 | 독립 프로토콜 |\n| **통신 방식** | 요청-응답 | 양방향 스트리밍 |\n| **서버 푸시** | 제한적 (요청 기반) | 완전 자유 |\n| **헤더 크기** | HPACK 압축 (~수십 바이트) | 2-14 바이트 |\n| **오버헤드** | 중간 | 최소 |\n| **연결 수** | 도메인당 1개 | 필요만큼 |\n| **사용 사례** | 웹 페이지 로딩 | 실시간 애플리케이션 |\n\n**HTTP/2 Server Push vs WebSocket:**\n\n```\nHTTP/2 Server Push:\n클라이언트: GET /index.html\n서버: index.html 전송\n서버: (예측) style.css, script.js도 함께 푸시\n→ 여전히 요청 기반, 서버가 예측해서 전송\n\nWebSocket:\n서버: 언제든지 메시지 전송 가능\n클라이언트: 언제든지 메시지 전송 가능\n→ 완전한 양방향, 이벤트 기반\n```\n\n**언제 무엇을 사용할까?**\n\n**HTTP/2 권장:**\n- 일반 웹 페이지/API\n- RESTful 서비스\n- 파일 다운로드\n- 대부분의 웹 애플리케이션\n\n**WebSocket 권장:**\n- 실시간 채팅\n- 라이브 피드/알림\n- 멀티플레이어 게임\n- 협업 도구\n- IoT 센서 데이터\n\n**결론:** HTTP/2는 기존 HTTP의 개선이고, WebSocket은 실시간 양방향 통신을 위한 별도 프로토콜입니다.",
      "type": "essay",
      "tags": ["WebSocket", "HTTP/2", "프로토콜", "비교"],
      "id": "1763358000000-ws016",
      "createdAt": "2025-11-17T12:30:00.000015",
      "studyCount": 0
    },
    {
      "question": "WebSocket 연결의 성능 최적화를 위한 고려사항은 무엇인가요?",
      "answer": "WebSocket 성능 최적화는 **네트워크**, **서버**, **클라이언트** 모든 레이어에서 고려해야 합니다.\n\n**1. 프로토콜 레벨 최적화**\n\n**압축 활성화:**\n```javascript\nconst wss = new WebSocket.Server({\n  perMessageDeflate: {\n    threshold: 1024, // 1KB 이상만 압축\n    level: 3 // 압축 레벨 (1-9, 낮을수록 빠름)\n  }\n});\n```\n\n**이진 데이터 사용:**\n```javascript\n// JSON (텍스트): 57 bytes\nws.send(JSON.stringify({type: 'move', x: 100, y: 200}));\n\n// Protocol Buffers (이진): ~12 bytes\nconst buffer = encodeMove({type: 1, x: 100, y: 200});\nws.send(buffer);\n```\n\n**2. 메시지 배칭 (Batching)**\n\n```javascript\n// 비효율적: 개별 전송\nfor (let i = 0; i < 100; i++) {\n  ws.send(JSON.stringify({type: 'update', data: items[i]}));\n}\n\n// 효율적: 배치 전송\nconst batch = items.slice(0, 100);\nws.send(JSON.stringify({type: 'batch_update', items: batch}));\n```\n\n**3. 메시지 큐잉과 쓰로틀링**\n\n```javascript\nclass ThrottledWebSocket {\n  constructor(ws, messagesPerSecond = 60) {\n    this.ws = ws;\n    this.queue = [];\n    this.interval = 1000 / messagesPerSecond;\n    this.startQueue();\n  }\n  \n  send(data) {\n    this.queue.push(data);\n  }\n  \n  startQueue() {\n    setInterval(() => {\n      if (this.queue.length > 0) {\n        const message = this.queue.shift();\n        if (this.ws.readyState === WebSocket.OPEN) {\n          this.ws.send(message);\n        }\n      }\n    }, this.interval);\n  }\n}\n```\n\n**4. 백프레셔 처리 (Backpressure)**\n\n```javascript\nws.on('message', (data) => {\n  // 전송 버퍼 확인\n  if (ws.bufferedAmount > 1024 * 1024) { // 1MB\n    console.warn('Send buffer full, pausing');\n    return; // 또는 큐에 저장\n  }\n  \n  ws.send(processData(data));\n});\n```\n\n**5. 연결 풀링 (Connection Pooling)**\n\n```javascript\n// 클라이언트: 연결 재사용\nclass WebSocketPool {\n  constructor(url, poolSize = 3) {\n    this.connections = [];\n    this.currentIndex = 0;\n    \n    for (let i = 0; i < poolSize; i++) {\n      this.connections.push(new WebSocket(url));\n    }\n  }\n  \n  send(data) {\n    const ws = this.connections[this.currentIndex];\n    this.currentIndex = (this.currentIndex + 1) % this.connections.length;\n    ws.send(data);\n  }\n}\n```\n\n**6. TCP 튜닝**\n\n```javascript\n// Node.js 서버\nconst server = require('net').createServer();\n\nserver.on('connection', (socket) => {\n  socket.setNoDelay(true); // Nagle 알고리즘 비활성화 (저지연)\n  socket.setKeepAlive(true, 30000); // 30초 keep-alive\n});\n```\n\n**7. 서버 성능 튜닝**\n\n```javascript\n// Worker threads 활용 (CPU 집약적 작업)\nconst { Worker } = require('worker_threads');\n\nws.on('message', (data) => {\n  if (isCpuIntensive(data)) {\n    // 워커에서 처리\n    const worker = new Worker('./process-message.js', {\n      workerData: data\n    });\n    \n    worker.on('message', (result) => {\n      ws.send(result);\n    });\n  } else {\n    // 메인 스레드에서 처리\n    ws.send(processMessage(data));\n  }\n});\n```\n\n**8. 메모리 최적화**\n\n```javascript\n// 버퍼 재사용\nconst bufferPool = {\n  pool: [],\n  acquire() {\n    return this.pool.pop() || Buffer.allocUnsafe(1024);\n  },\n  release(buffer) {\n    buffer.fill(0);\n    this.pool.push(buffer);\n  }\n};\n```\n\n**9. CDN과 엣지 네트워크**\n\n```\n사용자 (서울) → CDN 엣지 (서울) ← 10ms → WebSocket 서버\n vs\n사용자 (서울) ← 200ms → WebSocket 서버 (미국)\n\n지연시간 95% 감소\n```\n\n**10. 모니터링 및 프로파일링**\n\n```javascript\nconst metrics = {\n  messagesSent: 0,\n  messagesReceived: 0,\n  avgLatency: 0,\n  \n  track(ws) {\n    const start = Date.now();\n    \n    ws.on('message', () => {\n      this.messagesReceived++;\n      const latency = Date.now() - start;\n      this.avgLatency = (this.avgLatency + latency) / 2;\n    });\n  }\n};\n```\n\n**체크리스트:**\n\n- ✅ 압축 활성화 (1KB+ 메시지)\n- ✅ 이진 데이터 사용 (고빈도 전송)\n- ✅ 메시지 배칭\n- ✅ 쓰로틀링/디바운싱\n- ✅ TCP_NODELAY 설정\n- ✅ 백프레셔 처리\n- ✅ 연결 풀링 (클라이언트)\n- ✅ Worker threads (CPU 작업)\n- ✅ CDN/엣지 활용\n- ✅ 메트릭 수집 및 분석\n\n**성능 벤치마크 예시:**\n\n| 최적화 | 메시지/초 | 지연시간 | CPU 사용률 |\n|--------|-----------|----------|------------|\n| 기본 | 10,000 | 50ms | 80% |\n| + 압축 | 15,000 | 45ms | 85% |\n| + 이진 | 25,000 | 30ms | 70% |\n| + 배칭 | 50,000 | 25ms | 60% |\n| + 모든 최적화 | 100,000+ | 10ms | 50% |",
      "type": "essay",
      "tags": ["WebSocket", "성능최적화", "압축", "배칭", "튜닝"],
      "id": "1763358000000-ws017",
      "createdAt": "2025-11-17T12:30:00.000016",
      "studyCount": 0
    },
    {
      "question": "WebSocket 서버 구축 시 장애 조치(failover) 방안을 어떻게 마련할 수 있나요?",
      "answer": "WebSocket은 상태 유지(stateful) 연결이므로 **장애 조치**가 일반 HTTP보다 복잡합니다.\n\n**1. Health Check와 자동 재시작**\n\n```javascript\n// PM2 설정 (ecosystem.config.js)\nmodule.exports = {\n  apps: [{\n    name: 'websocket-server',\n    script: './server.js',\n    instances: 4,\n    exec_mode: 'cluster',\n    watch: false,\n    max_memory_restart: '1G',\n    env: {\n      NODE_ENV: 'production'\n    }\n  }]\n};\n\n// Health check 엔드포인트\napp.get('/health', (req, res) => {\n  const health = {\n    uptime: process.uptime(),\n    connections: wss.clients.size,\n    memory: process.memoryUsage(),\n    status: 'ok'\n  };\n  \n  res.json(health);\n});\n```\n\n**2. 로드 밸런서 레벨 Failover**\n\n```nginx\n# Nginx with health checks\nupstream websocket_backend {\n  least_conn;\n  \n  server backend1:8080 max_fails=3 fail_timeout=30s;\n  server backend2:8080 max_fails=3 fail_timeout=30s backup;\n  server backend3:8080 max_fails=3 fail_timeout=30s backup;\n}\n\nserver {\n  location /socket {\n    proxy_pass http://websocket_backend;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    \n    # Health check\n    proxy_next_upstream error timeout invalid_header http_502 http_503;\n    proxy_connect_timeout 5s;\n  }\n}\n```\n\n**3. 클라이언트 자동 재연결**\n\n```javascript\nclass ResilientWebSocket {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = options.maxAttempts || 10;\n    this.reconnectDelay = options.initialDelay || 1000;\n    this.maxReconnectDelay = options.maxDelay || 30000;\n    this.connect();\n  }\n  \n  connect() {\n    this.ws = new WebSocket(this.url);\n    \n    this.ws.onopen = () => {\n      console.log('Connected');\n      this.reconnectAttempts = 0;\n      this.reconnectDelay = 1000;\n      \n      // 세션 복구\n      this.restoreSession();\n    };\n    \n    this.ws.onclose = (event) => {\n      if (event.code !== 1000 && event.code !== 1001) {\n        // 비정상 종료 - 재연결\n        this.handleReconnect();\n      }\n    };\n    \n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n  \n  handleReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnect attempts reached');\n      this.onFailover?.(); // 백업 서버로 전환\n      return;\n    }\n    \n    this.reconnectAttempts++;\n    const delay = Math.min(\n      this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),\n      this.maxReconnectDelay\n    );\n    \n    console.log(`Reconnecting in ${delay}ms`);\n    setTimeout(() => this.connect(), delay);\n  }\n  \n  restoreSession() {\n    // 세션 토큰으로 상태 복구\n    const sessionToken = localStorage.getItem('ws_session');\n    if (sessionToken) {\n      this.ws.send(JSON.stringify({\n        type: 'restore_session',\n        token: sessionToken\n      }));\n    }\n  }\n}\n```\n\n**4. 세션 상태 저장 (Redis)**\n\n```javascript\nconst Redis = require('ioredis');\nconst redis = new Redis();\n\nwss.on('connection', async (ws, req) => {\n  const sessionId = generateSessionId();\n  ws.sessionId = sessionId;\n  \n  // 세션 정보 저장\n  await redis.hset(`session:${sessionId}`, {\n    userId: getUserId(req),\n    connectedAt: Date.now(),\n    serverId: SERVER_ID\n  });\n  \n  ws.on('message', async (data) => {\n    // 중요한 상태 Redis에 저장\n    await redis.hset(`session:${sessionId}`, 'lastMessage', data);\n  });\n  \n  ws.on('close', async () => {\n    // 세션 유지 (1시간)\n    await redis.expire(`session:${sessionId}`, 3600);\n  });\n});\n\n// 세션 복구\nws.on('restore_session', async (token) => {\n  const session = await redis.hgetall(`session:${token}`);\n  if (session) {\n    // 상태 복원\n    ws.userId = session.userId;\n    ws.send(JSON.stringify({\n      type: 'session_restored',\n      lastMessage: session.lastMessage\n    }));\n  }\n});\n```\n\n**5. Multi-Region Failover**\n\n```javascript\n// 클라이언트: 리전별 우선순위\nconst regions = [\n  'wss://ws-us-east.example.com',\n  'wss://ws-us-west.example.com',\n  'wss://ws-eu.example.com'\n];\n\nlet currentRegion = 0;\n\nfunction connectToNextRegion() {\n  if (currentRegion >= regions.length) {\n    console.error('All regions failed');\n    return;\n  }\n  \n  const ws = new WebSocket(regions[currentRegion]);\n  \n  ws.onerror = () => {\n    console.log(`Region ${currentRegion} failed, trying next`);\n    currentRegion++;\n    connectToNextRegion();\n  };\n}\n```\n\n**6. Database Replication**\n\n```\nMaster DB (Write) ─┬─→ Replica 1 (Read)\n                   ├─→ Replica 2 (Read)\n                   └─→ Replica 3 (Read)\n\nWebSocket 서버는 Replica에서 읽기\nMaster 장애 시 자동 Failover\n```\n\n**7. Message Queue 기반 아키텍처**\n\n```javascript\n// 메시지를 큐에 저장하여 서버 장애 대비\nconst { Kafka } = require('kafkajs');\n\nconst kafka = new Kafka({\n  clientId: 'ws-server',\n  brokers: ['kafka1:9092', 'kafka2:9092']\n});\n\nconst producer = kafka.producer();\n\nws.on('message', async (data) => {\n  // 메시지를 Kafka에 저장\n  await producer.send({\n    topic: 'websocket-messages',\n    messages: [{ value: data }]\n  });\n  \n  // 처리\n  processMessage(data);\n});\n```\n\n**8. Graceful Shutdown**\n\n```javascript\nprocess.on('SIGTERM', async () => {\n  console.log('Graceful shutdown initiated');\n  \n  // 1. 새 연결 거부\n  server.close();\n  \n  // 2. 모든 클라이언트에게 재연결 요청\n  wss.clients.forEach(ws => {\n    ws.send(JSON.stringify({\n      type: 'server_shutdown',\n      reconnectTo: 'wss://backup.example.com'\n    }));\n  });\n  \n  // 3. 5초 대기\n  await new Promise(resolve => setTimeout(resolve, 5000));\n  \n  // 4. 남은 연결 강제 종료\n  wss.clients.forEach(ws => ws.close(1001));\n  \n  // 5. 리소스 정리\n  await redis.quit();\n  await db.close();\n  \n  process.exit(0);\n});\n```\n\n**9. 모니터링 및 알림**\n\n```javascript\n// Prometheus 메트릭\nconst prometheus = require('prom-client');\n\nconst connectionGauge = new prometheus.Gauge({\n  name: 'websocket_connections',\n  help: 'Number of active WebSocket connections'\n});\n\nconst errorCounter = new prometheus.Counter({\n  name: 'websocket_errors_total',\n  help: 'Total number of WebSocket errors'\n});\n\nsetInterval(() => {\n  connectionGauge.set(wss.clients.size);\n}, 5000);\n```\n\n**Failover 체크리스트:**\n\n- ✅ Health check 엔드포인트\n- ✅ 로드 밸런서 자동 failover\n- ✅ 클라이언트 자동 재연결\n- ✅ 세션 상태 영구 저장 (Redis)\n- ✅ Multi-region 배포\n- ✅ Database replication\n- ✅ Message queue 통합\n- ✅ Graceful shutdown\n- ✅ 실시간 모니터링\n- ✅ 자동 알림 시스템",
      "type": "essay",
      "tags": ["WebSocket", "Failover", "장애조치", "고가용성", "재연결"],
      "id": "1763358000000-ws018",
      "createdAt": "2025-11-17T12:30:00.000017",
      "studyCount": 0
    },
    {
      "question": "클라이언트에서 WebSocket 연결 오류를 디버깅하는 방법에는 어떤 것들이 있나요?",
      "answer": "WebSocket 디버깅은 **브라우저 도구**, **로깅**, **네트워크 분석**을 조합하여 수행합니다.\n\n**1. 브라우저 개발자 도구**\n\n**Chrome DevTools - Network 탭:**\n```\n1. F12 → Network 탭\n2. WS 필터 선택\n3. WebSocket 연결 클릭\n\n확인 가능한 정보:\n- Handshake 요청/응답 헤더\n- 전송/수신 메시지 (Frames 탭)\n- 연결 시간, 종료 코드\n- 오류 메시지\n```\n\n**2. 상세 로깅 구현**\n\n```javascript\nclass DebugWebSocket {\n  constructor(url) {\n    this.url = url;\n    this.messageLog = [];\n    this.connect();\n  }\n  \n  connect() {\n    console.log(`[WS] Connecting to ${this.url}`);\n    this.ws = new WebSocket(this.url);\n    \n    this.ws.onopen = (event) => {\n      console.log('[WS] Connected', {\n        url: this.url,\n        protocol: this.ws.protocol,\n        extensions: this.ws.extensions,\n        readyState: this.ws.readyState,\n        timestamp: new Date().toISOString()\n      });\n    };\n    \n    this.ws.onmessage = (event) => {\n      const log = {\n        type: 'received',\n        data: event.data,\n        size: event.data.length,\n        timestamp: new Date().toISOString()\n      };\n      \n      this.messageLog.push(log);\n      console.log('[WS] ← Received', log);\n    };\n    \n    this.ws.onerror = (error) => {\n      console.error('[WS] Error', {\n        error,\n        readyState: this.ws.readyState,\n        url: this.url,\n        timestamp: new Date().toISOString()\n      });\n    };\n    \n    this.ws.onclose = (event) => {\n      console.log('[WS] Closed', {\n        code: event.code,\n        reason: event.reason,\n        wasClean: event.wasClean,\n        timestamp: new Date().toISOString()\n      });\n      \n      // 종료 코드 분석\n      this.analyzeCloseCode(event.code);\n    };\n  }\n  \n  send(data) {\n    const log = {\n      type: 'sent',\n      data,\n      size: data.length,\n      timestamp: new Date().toISOString()\n    };\n    \n    this.messageLog.push(log);\n    console.log('[WS] → Sent', log);\n    \n    try {\n      this.ws.send(data);\n    } catch (error) {\n      console.error('[WS] Send failed', error);\n    }\n  }\n  \n  analyzeCloseCode(code) {\n    const codes = {\n      1000: 'Normal closure',\n      1001: 'Going away',\n      1002: 'Protocol error',\n      1003: 'Unsupported data',\n      1006: 'Abnormal closure (no status code)',\n      1007: 'Invalid frame payload data',\n      1008: 'Policy violation',\n      1009: 'Message too big',\n      1010: 'Mandatory extension missing',\n      1011: 'Internal server error',\n      1015: 'TLS handshake failure'\n    };\n    \n    console.log(`Close code ${code}: ${codes[code] || 'Unknown'}`);\n  }\n  \n  getMessageHistory() {\n    return this.messageLog;\n  }\n  \n  exportLogs() {\n    const blob = new Blob([JSON.stringify(this.messageLog, null, 2)], {\n      type: 'application/json'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `websocket-log-${Date.now()}.json`;\n    a.click();\n  }\n}\n```\n\n**3. 네트워크 상태 확인**\n\n```javascript\n// 네트워크 연결 감지\nwindow.addEventListener('online', () => {\n  console.log('[Network] Connection restored');\n  ws.connect(); // 재연결\n});\n\nwindow.addEventListener('offline', () => {\n  console.log('[Network] Connection lost');\n});\n\n// 주기적 연결 테스트\nsetInterval(() => {\n  if (navigator.onLine) {\n    console.log('[Network] Online');\n  } else {\n    console.log('[Network] Offline');\n  }\n}, 5000);\n```\n\n**4. Ping/Pong 모니터링**\n\n```javascript\nclass HeartbeatWebSocket {\n  constructor(url) {\n    this.ws = new WebSocket(url);\n    this.lastPong = Date.now();\n    this.pingInterval = null;\n    \n    this.ws.onopen = () => {\n      this.startHeartbeat();\n    };\n    \n    // 서버가 Ping 보내면 브라우저가 자동 Pong 응답\n    // Pong 수신 시각 추적 (실제로는 서버에서 추적)\n  }\n  \n  startHeartbeat() {\n    this.pingInterval = setInterval(() => {\n      const timeSinceLastPong = Date.now() - this.lastPong;\n      \n      console.log('[Heartbeat] Last pong:', timeSinceLastPong + 'ms ago');\n      \n      if (timeSinceLastPong > 60000) { // 60초\n        console.error('[Heartbeat] Connection appears dead');\n        this.ws.close();\n      }\n    }, 30000);\n  }\n}\n```\n\n**5. 오류 패턴 분석**\n\n```javascript\nconst errorTracker = {\n  errors: [],\n  \n  track(error) {\n    this.errors.push({\n      ...error,\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    });\n    \n    // 패턴 분석\n    this.analyze();\n  },\n  \n  analyze() {\n    const recentErrors = this.errors.slice(-10);\n    \n    // 연속 실패 감지\n    const consecutiveFails = recentErrors.filter(e => \n      e.code === 1006\n    ).length;\n    \n    if (consecutiveFails > 5) {\n      console.error('[Analysis] Multiple connection failures detected');\n      console.error('[Analysis] Possible causes:');\n      console.error('- Server is down');\n      console.error('- Network firewall blocking WebSocket');\n      console.error('- Proxy not supporting WebSocket');\n    }\n  }\n};\n```\n\n**6. Wireshark로 패킷 분석**\n\n```\n1. Wireshark 실행\n2. 필터: websocket\n3. Handshake 확인:\n   - HTTP Upgrade 요청\n   - 101 Switching Protocols 응답\n4. 프레임 분석:\n   - Opcode\n   - Payload length\n   - Masking key\n```\n\n**7. curl로 Handshake 테스트**\n\n```bash\n# WebSocket Handshake 수동 테스트\ncurl -i -N -H \"Connection: Upgrade\" \\\n     -H \"Upgrade: websocket\" \\\n     -H \"Sec-WebSocket-Version: 13\" \\\n     -H \"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\" \\\n     http://localhost:8080/socket\n\n# 응답 확인:\n# HTTP/1.1 101 Switching Protocols\n# Upgrade: websocket\n# Connection: Upgrade\n# Sec-WebSocket-Accept: ...\n```\n\n**8. 일반적인 오류 해결**\n\n**오류 1: 연결 거부 (Connection refused)**\n```javascript\n// 원인: 서버가 실행 중이 아님, 잘못된 포트\n// 해결:\n1. 서버 상태 확인: netstat -an | grep 8080\n2. 방화벽 확인\n3. URL 확인 (ws:// vs wss://)\n```\n\n**오류 2: 1006 Abnormal Closure**\n```javascript\n// 원인: 네트워크 단절, 서버 크래시, 방화벽\n// 해결:\n1. 네트워크 연결 확인\n2. 서버 로그 확인\n3. Ping/Pong heartbeat 구현\n4. 재연결 로직 추가\n```\n\n**오류 3: 1008 Policy Violation**\n```javascript\n// 원인: Origin 검증 실패, 인증 실패\n// 해결:\n1. Origin 헤더 확인\n2. 토큰/인증 정보 확인\n3. 서버 CORS 설정 확인\n```\n\n**9. 디버깅 도구 추천**\n\n- **Postman**: WebSocket 요청 테스트\n- **wscat**: CLI WebSocket 클라이언트\n  ```bash\n  npm install -g wscat\n  wscat -c ws://localhost:8080\n  ```\n- **WebSocket King**: 브라우저 확장 프로그램\n- **Socket.IO Debugger**: Socket.IO 전용 디버거\n\n**10. 프로덕션 모니터링**\n\n```javascript\n// Sentry 통합\nimport * as Sentry from '@sentry/browser';\n\nws.onerror = (error) => {\n  Sentry.captureException(error, {\n    tags: {\n      component: 'websocket',\n      url: ws.url\n    },\n    extra: {\n      readyState: ws.readyState,\n      timestamp: Date.now()\n    }\n  });\n};\n```",
      "type": "essay",
      "tags": ["WebSocket", "디버깅", "오류처리", "DevTools", "로깅"],
      "id": "1763358000000-ws019",
      "createdAt": "2025-11-17T12:30:00.000018",
      "studyCount": 0
    },
    {
      "question": "WebSocket과 서버 푸시(Server-Sent Events)의 차이점은 무엇인가요?",
      "answer": "**WebSocket**과 **SSE(Server-Sent Events)**는 서버 푸시를 지원하지만, **통신 방향**과 **용도**가 다릅니다.\n\n**Server-Sent Events (SSE):**\n\n**특징:**\n- HTTP 기반, 단방향 (서버 → 클라이언트만)\n- 텍스트 전용 (UTF-8)\n- 자동 재연결 지원\n- EventSource API 사용\n\n**기본 사용:**\n```javascript\n// 클라이언트\nconst eventSource = new EventSource('/events');\n\neventSource.onmessage = (event) => {\n  console.log('Message:', event.data);\n};\n\neventSource.addEventListener('custom-event', (event) => {\n  console.log('Custom:', JSON.parse(event.data));\n});\n\neventSource.onerror = (error) => {\n  console.error('Error:', error);\n  // 자동으로 재연결 시도\n};\n\n// 서버 (Node.js/Express)\napp.get('/events', (req, res) => {\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n  \n  // 이벤트 전송\n  const sendEvent = (data) => {\n    res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n  };\n  \n  // 커스텀 이벤트\n  const sendCustomEvent = (eventName, data) => {\n    res.write(`event: ${eventName}\\n`);\n    res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n  };\n  \n  // 주기적 전송\n  const interval = setInterval(() => {\n    sendEvent({ time: new Date().toISOString() });\n  }, 1000);\n  \n  req.on('close', () => {\n    clearInterval(interval);\n  });\n});\n```\n\n**비교 표:**\n\n| 특성 | WebSocket | SSE |\n|------|-----------|-----|\n| **통신 방향** | 양방향 (Full-Duplex) | 단방향 (서버→클라이언트) |\n| **프로토콜** | WS/WSS (독립) | HTTP/HTTPS |\n| **데이터 타입** | 텍스트, 이진 | 텍스트만 (UTF-8) |\n| **재연결** | 수동 구현 필요 | 자동 재연결 (내장) |\n| **브라우저 지원** | 거의 모든 최신 브라우저 | IE/Edge(구버전) 미지원 |\n| **방화벽/프록시** | 차단될 수 있음 | HTTP이므로 대부분 통과 |\n| **연결 수 제한** | 브라우저별 상이 | HTTP/1.1: 도메인당 6개 |\n| **오버헤드** | 낮음 (2-14bytes) | 중간 (HTTP 헤더) |\n| **구현 복잡도** | 중간 | 간단 |\n\n**WebSocket 예제:**\n```javascript\nconst ws = new WebSocket('ws://localhost:8080');\n\n// 양방향 통신\nws.onopen = () => {\n  ws.send('Hello Server'); // 클라이언트 → 서버\n};\n\nws.onmessage = (event) => {\n  console.log('From server:', event.data); // 서버 → 클라이언트\n};\n```\n\n**SSE 예제:**\n```javascript\nconst es = new EventSource('/events');\n\n// 단방향: 수신만 가능\nes.onmessage = (event) => {\n  console.log('From server:', event.data);\n};\n\n// 클라이언트 → 서버 전송은 별도 HTTP 요청 필요\nfetch('/api/send-message', {\n  method: 'POST',\n  body: JSON.stringify({ message: 'Hello' })\n});\n```\n\n**SSE의 장점:**\n\n1. **자동 재연결**\n```javascript\n// 연결 끊기면 자동으로 재연결 시도 (기본 3초 후)\neventSource.onerror = () => {\n  console.log('Reconnecting...');\n  // EventSource가 자동 처리\n};\n\n// 서버에서 재연결 시간 지정 가능\nres.write('retry: 5000\\n'); // 5초\n```\n\n2. **이벤트 ID 및 재개**\n```javascript\n// 서버: 이벤트 ID 전송\nres.write('id: 123\\n');\nres.write('data: message\\n\\n');\n\n// 클라이언트: Last-Event-ID 헤더로 자동 전송\n// 서버는 이 ID 이후 이벤트만 재전송 가능\n```\n\n3. **HTTP 호환성**\n- 일반 웹 서버로 쉽게 구현\n- 프록시/방화벽 통과 용이\n- HTTPS 인증서 재사용\n\n**WebSocket의 장점:**\n\n1. **양방향 통신**\n```javascript\n// 실시간 채팅\nws.send(JSON.stringify({ message: 'Hello' }));\nws.onmessage = (e) => console.log(e.data);\n```\n\n2. **이진 데이터**\n```javascript\n// 파일, 이미지, 스트리밍\nconst buffer = new ArrayBuffer(1024);\nws.send(buffer);\n```\n\n3. **낮은 오버헤드**\n- 프레임 헤더만 2-14바이트\n- 고빈도 메시지에 유리\n\n**사용 사례:**\n\n**SSE 권장:**\n- 📰 **뉴스 피드** (읽기 전용)\n- 📈 **주식 시세** (서버 → 클라이언트)\n- 🔔 **알림 시스템** (푸시 알림)\n- 📊 **실시간 대시보드** (모니터링)\n- 🎥 **라이브 스코어** (스포츠 경기)\n\n**WebSocket 권장:**\n- 💬 **채팅** (양방향)\n- 🎮 **멀티플레이어 게임** (저지연)\n- 🖊️ **협업 편집** (실시간 동기화)\n- 📹 **화상 통화 시그널링** (양방향)\n- 🤖 **IoT 제어** (명령 + 상태)\n\n**하이브리드 접근:**\n\n```javascript\n// SSE로 서버 푸시 받기\nconst es = new EventSource('/notifications');\nes.onmessage = (event) => {\n  showNotification(event.data);\n};\n\n// 클라이언트 → 서버는 fetch로\nfetch('/api/mark-as-read', {\n  method: 'POST',\n  body: JSON.stringify({ notificationId: 123 })\n});\n```\n\n**결론:**\n- **SSE**: 단방향 실시간 피드, 간단한 구현, HTTP 호환성 중요\n- **WebSocket**: 양방향 실시간 통신, 저지연, 고빈도 메시지",
      "type": "essay",
      "tags": ["WebSocket", "SSE", "Server-Sent Events", "실시간통신", "비교"],
      "id": "1763358000000-ws020",
      "createdAt": "2025-11-17T12:30:00.000019",
      "studyCount": 0
    },
    {
      "question": "TLS/SSL을 활용하여 WebSocket 연결을 보호하는 방법에 대해 설명해주세요.",
      "answer": "**WSS (WebSocket Secure)**는 TLS/SSL로 암호화된 WebSocket 연결로, HTTPS와 동일한 보안을 제공합니다.\n\n**1. WSS 기본 사용**\n\n**클라이언트:**\n```javascript\n// wss:// 프로토콜 사용\nconst ws = new WebSocket('wss://example.com/socket');\n\n// 브라우저가 자동으로 TLS 핸드셰이크 처리\nws.onopen = () => {\n  console.log('Secure connection established');\n};\n```\n\n**서버 (Node.js):**\n```javascript\nconst https = require('https');\nconst WebSocket = require('ws');\nconst fs = require('fs');\n\n// HTTPS 서버 생성\nconst server = https.createServer({\n  cert: fs.readFileSync('/path/to/cert.pem'),\n  key: fs.readFileSync('/path/to/key.pem'),\n  \n  // 선택적: 클라이언트 인증서 요구\n  requestCert: false,\n  rejectUnauthorized: false\n});\n\n// WebSocket 서버를 HTTPS 서버에 연결\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', (ws, req) => {\n  console.log('Secure WebSocket connection established');\n  \n  // TLS 정보 확인\n  const socket = req.socket;\n  console.log('Cipher:', socket.getCipher());\n  console.log('Protocol:', socket.getProtocol());\n});\n\nserver.listen(443);\n```\n\n**2. Let's Encrypt 인증서 사용**\n\n```bash\n# Certbot으로 무료 인증서 발급\nsudo certbot certonly --standalone -d example.com\n\n# 인증서 위치:\n# /etc/letsencrypt/live/example.com/fullchain.pem\n# /etc/letsencrypt/live/example.com/privkey.pem\n```\n\n```javascript\nconst server = https.createServer({\n  cert: fs.readFileSync('/etc/letsencrypt/live/example.com/fullchain.pem'),\n  key: fs.readFileSync('/etc/letsencrypt/live/example.com/privkey.pem')\n});\n```\n\n**3. Nginx Reverse Proxy (권장)**\n\n```nginx\n# Nginx가 TLS 종료(Termination) 처리\nserver {\n  listen 443 ssl http2;\n  server_name example.com;\n  \n  # TLS 인증서\n  ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n  ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n  \n  # TLS 설정 (Mozilla Modern Configuration)\n  ssl_protocols TLSv1.2 TLSv1.3;\n  ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';\n  ssl_prefer_server_ciphers off;\n  \n  # HSTS (Strict Transport Security)\n  add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\" always;\n  \n  # WebSocket 프록시\n  location /socket {\n    proxy_pass http://localhost:8080;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    \n    # 타임아웃\n    proxy_read_timeout 86400;\n    proxy_send_timeout 86400;\n  }\n}\n\n# HTTP를 HTTPS로 리다이렉트\nserver {\n  listen 80;\n  server_name example.com;\n  return 301 https://$server_name$request_uri;\n}\n```\n\n**백엔드 서버 (TLS 없이):**\n```javascript\n// Nginx가 TLS 처리하므로 일반 HTTP\nconst http = require('http');\nconst server = http.createServer();\nconst wss = new WebSocket.Server({ server });\n\nserver.listen(8080); // 내부 포트\n```\n\n**4. 클라이언트 인증서 (mTLS)**\n\n```javascript\n// 서버: 클라이언트 인증서 요구\nconst server = https.createServer({\n  cert: fs.readFileSync('server-cert.pem'),\n  key: fs.readFileSync('server-key.pem'),\n  ca: fs.readFileSync('client-ca.pem'), // 클라이언트 CA\n  requestCert: true, // 클라이언트 인증서 요구\n  rejectUnauthorized: true // 유효하지 않은 인증서 거부\n});\n\nwss.on('connection', (ws, req) => {\n  const cert = req.socket.getPeerCertificate();\n  \n  if (cert && cert.subject) {\n    console.log('Client CN:', cert.subject.CN);\n    console.log('Valid from:', cert.valid_from);\n    console.log('Valid to:', cert.valid_to);\n  } else {\n    ws.close(1008, 'Client certificate required');\n  }\n});\n```\n\n**5. 보안 설정 체크리스트**\n\n```javascript\n// Node.js 보안 강화\nconst server = https.createServer({\n  cert: cert,\n  key: key,\n  \n  // TLS 버전 제한\n  minVersion: 'TLSv1.2',\n  maxVersion: 'TLSv1.3',\n  \n  // 약한 암호화 제거\n  ciphers: [\n    'ECDHE-ECDSA-AES128-GCM-SHA256',\n    'ECDHE-RSA-AES128-GCM-SHA256',\n    'ECDHE-ECDSA-AES256-GCM-SHA384',\n    'ECDHE-RSA-AES256-GCM-SHA384'\n  ].join(':'),\n  \n  // 서버 우선 암호화 선택\n  honorCipherOrder: true,\n  \n  // Perfect Forward Secrecy\n  dhparam: fs.readFileSync('dhparam.pem')\n});\n```\n\n**6. 혼합 콘텐츠 방지**\n\n```javascript\n// HTTPS 페이지에서는 반드시 WSS 사용\nconst protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\nconst ws = new WebSocket(`${protocol}//${window.location.host}/socket`);\n\n// 또는\nconst ws = new WebSocket(\n  (window.location.protocol === 'https:' ? 'wss://' : 'ws://') +\n  window.location.host +\n  '/socket'\n);\n```\n\n**7. Content Security Policy (CSP)**\n\n```html\n<!-- HTML 헤더 -->\n<meta http-equiv=\"Content-Security-Policy\" \n      content=\"connect-src 'self' wss://example.com\">\n```\n\n```javascript\n// Express 미들웨어\napp.use((req, res, next) => {\n  res.setHeader(\n    'Content-Security-Policy',\n    \"connect-src 'self' wss://example.com\"\n  );\n  next();\n});\n```\n\n**8. 인증서 갱신 자동화**\n\n```bash\n# Certbot 자동 갱신 (cron)\n0 0 * * * certbot renew --quiet --post-hook \"systemctl reload nginx\"\n```\n\n**9. 인증서 검증**\n\n```bash\n# OpenSSL로 연결 테스트\nopenssl s_client -connect example.com:443 -servername example.com\n\n# WebSocket 핸드셰이크 테스트\nwscat -c wss://example.com/socket\n```\n\n**10. 보안 모니터링**\n\n```javascript\n// 인증서 만료 알림\nconst tls = require('tls');\n\nconst checkCertExpiry = () => {\n  const socket = tls.connect(443, 'example.com', () => {\n    const cert = socket.getPeerCertificate();\n    const expiryDate = new Date(cert.valid_to);\n    const daysLeft = (expiryDate - Date.now()) / (1000 * 60 * 60 * 24);\n    \n    if (daysLeft < 30) {\n      console.warn(`Certificate expires in ${daysLeft} days!`);\n      // 알림 전송\n    }\n    \n    socket.end();\n  });\n};\n\nsetInterval(checkCertExpiry, 24 * 60 * 60 * 1000); // 매일 체크\n```\n\n**보안 체크리스트:**\n\n- ✅ WSS (wss://) 사용\n- ✅ TLS 1.2 이상\n- ✅ 강력한 암호화 스위트\n- ✅ 유효한 인증서 (Let's Encrypt 등)\n- ✅ HSTS 헤더\n- ✅ 인증서 자동 갱신\n- ✅ Perfect Forward Secrecy\n- ✅ CSP 설정\n- ✅ Nginx/Apache로 TLS 종료\n- ✅ 정기적인 보안 감사",
      "type": "essay",
      "tags": ["WebSocket", "WSS", "TLS", "SSL", "보안", "암호화"],
      "id": "1763358000000-ws021",
      "createdAt": "2025-11-17T12:30:00.000020",
      "studyCount": 0
    },
    {
      "question": "WebSocket 통신에서 프록시 서버 사용 시 발생할 수 있는 문제는 무엇인가요?",
      "answer": "프록시 서버는 WebSocket 연결에 여러 가지 문제를 일으킬 수 있습니다.\n\n**1. HTTP Upgrade 지원 부족**\n\n**문제:**\n```\n클라이언트 → 프록시 → 서버\n\nUpgrade: websocket 헤더를 프록시가 이해하지 못함\n→ 101 Switching Protocols 응답 차단\n→ WebSocket 연결 실패\n```\n\n**해결:**\n```nginx\n# Nginx 프록시 설정\nlocation /socket {\n  proxy_pass http://backend:8080;\n  proxy_http_version 1.1;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection \"upgrade\";\n}\n```\n\n**2. 연결 타임아웃**\n\n**문제:**\n- 프록시가 유휴 연결을 30-60초 후 자동 종료\n- WebSocket은 장시간 연결 유지 필요\n\n**해결:**\n```nginx\n# Nginx: 타임아웃 연장\nproxy_read_timeout 86400s; # 24시간\nproxy_send_timeout 86400s;\nproxy_connect_timeout 60s;\n```\n\n```javascript\n// Ping/Pong으로 연결 유지\nconst keepAliveInterval = setInterval(() => {\n  if (ws.readyState === WebSocket.OPEN) {\n    ws.ping(); // 서버 측\n  }\n}, 30000); // 30초마다\n```\n\n**3. 버퍼링 문제**\n\n**문제:**\n- 프록시가 메시지를 버퍼링하여 지연 발생\n- 실시간성 저하\n\n**해결:**\n```nginx\n# 버퍼링 비활성화\nproxy_buffering off;\nproxy_request_buffering off;\n```\n\n**4. 프록시 인증**\n\n**문제:**\n```\n기업 네트워크의 인증 프록시:\nHTTP CONNECT 메서드 필요\n→ WebSocket은 직접 프록시 인증 지원 안 함\n```\n\n**해결:**\n```javascript\n// 프록시 인증이 필요한 경우\n// 브라우저는 자동 처리하지만, Node.js는 수동 설정 필요\n\nconst HttpsProxyAgent = require('https-proxy-agent');\n\nconst proxyUrl = 'http://username:password@proxy.example.com:8080';\nconst agent = new HttpsProxyAgent(proxyUrl);\n\nconst ws = new WebSocket('wss://example.com/socket', {\n  agent: agent\n});\n```\n\n**5. SSL/TLS 종료**\n\n**문제:**\n```\n클라이언트 (wss://) → 프록시 (TLS 종료) → 서버 (ws://)\n\n프록시에서 TLS 종료 시:\n- 백엔드 서버는 암호화되지 않은 연결\n- X-Forwarded-Proto 헤더로 원본 프로토콜 확인 필요\n```\n\n**해결:**\n```nginx\n# Nginx: 프로토콜 전달\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n```\n\n```javascript\n// 서버: 프로토콜 확인\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['x-forwarded-proto'] || 'ws';\n  console.log('Original protocol:', protocol);\n  \n  if (protocol === 'wss') {\n    // 원래 HTTPS 연결이었음\n  }\n});\n```\n\n**6. 방화벽 차단**\n\n**문제:**\n- 기업 방화벽이 WebSocket 포트 차단\n- Upgrade 헤더를 위험으로 간주\n\n**해결:**\n```javascript\n// Fallback 전략: WebSocket → Long Polling\nlet transport = 'websocket';\n\ntry {\n  const ws = new WebSocket('wss://example.com/socket');\n  \n  ws.onerror = () => {\n    console.log('WebSocket blocked, falling back to polling');\n    transport = 'polling';\n    useLongPolling();\n  };\n} catch (error) {\n  transport = 'polling';\n  useLongPolling();\n}\n```\n\n```javascript\n// Socket.IO는 자동 fallback 지원\nconst socket = io('https://example.com', {\n  transports: ['websocket', 'polling'] // WebSocket 우선, 실패 시 polling\n});\n```\n\n**7. 로드 밸런서 Sticky Session**\n\n**문제:**\n```\n요청 1 → 로드밸런서 → 서버 A (WebSocket 연결)\n요청 2 → 로드밸런서 → 서버 B (다른 서버로 라우팅)\n→ 연결 끊김\n```\n\n**해결:**\n```nginx\n# Nginx: IP Hash\nupstream websocket_backend {\n  ip_hash; # 같은 IP는 같은 서버로\n  server backend1:8080;\n  server backend2:8080;\n}\n```\n\n**8. WebSocket 지원 확인**\n\n```javascript\n// 프록시 환경에서 WebSocket 지원 테스트\nfunction testWebSocketSupport() {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket('wss://example.com/socket');\n    \n    const timeout = setTimeout(() => {\n      ws.close();\n      reject(new Error('WebSocket connection timeout'));\n    }, 5000);\n    \n    ws.onopen = () => {\n      clearTimeout(timeout);\n      ws.close();\n      resolve(true);\n    };\n    \n    ws.onerror = () => {\n      clearTimeout(timeout);\n      reject(new Error('WebSocket not supported by proxy'));\n    };\n  });\n}\n\n// 사용\ntestWebSocketSupport()\n  .then(() => console.log('WebSocket supported'))\n  .catch(() => console.log('Use fallback transport'));\n```\n\n**9. 일반적인 프록시 설정**\n\n**HAProxy:**\n```haproxy\nfrontend http-in\n  bind *:80\n  bind *:443 ssl crt /etc/ssl/certs/cert.pem\n  \n  # WebSocket 감지\n  acl is_websocket hdr(Upgrade) -i websocket\n  \n  use_backend websocket if is_websocket\n  default_backend web\n\nbackend websocket\n  balance leastconn\n  option http-server-close\n  option forwardfor\n  \n  # Sticky session\n  stick-table type ip size 1m expire 30m\n  stick on src\n  \n  server ws1 10.0.0.1:8080 check\n  server ws2 10.0.0.2:8080 check\n```\n\n**체크리스트:**\n\n- ✅ 프록시가 HTTP Upgrade 지원하는지 확인\n- ✅ 타임아웃 설정 충분히 길게 (24시간+)\n- ✅ Ping/Pong 구현 (30-60초)\n- ✅ 버퍼링 비활성화\n- ✅ Sticky Session 설정\n- ✅ X-Forwarded-* 헤더 전달\n- ✅ Fallback 전략 (Long Polling)\n- ✅ 연결 테스트 구현",
      "type": "essay",
      "tags": ["WebSocket", "프록시", "Nginx", "방화벽", "네트워크"],
      "id": "1763358000000-ws022",
      "createdAt": "2025-11-17T12:30:00.000021",
      "studyCount": 0
    },
    {
      "question": "WebSocket 라이브러리(예: Socket.IO, ws 등)의 차이점과 선택 기준에 대해 설명해주세요.",
      "answer": "WebSocket 라이브러리는 **기능**, **추상화 수준**, **사용 사례**에 따라 선택해야 합니다.\n\n**주요 라이브러리 비교:**\n\n**1. 네이티브 WebSocket API**\n\n```javascript\nconst ws = new WebSocket('ws://localhost:8080');\n\nws.onopen = () => console.log('Connected');\nws.onmessage = (event) => console.log(event.data);\nws.onerror = (error) => console.error(error);\nws.onclose = () => console.log('Disconnected');\n\nws.send('Hello');\n```\n\n**장점:**\n- 브라우저 내장, 별도 설치 불필요\n- 가벼움 (추가 번들 없음)\n- 간단한 API\n\n**단점:**\n- 재연결 로직 직접 구현 필요\n- Room/Channel 개념 없음\n- Fallback 없음\n- 서버 구현 별도 필요\n\n**2. ws (Node.js 라이브러리)**\n\n```javascript\n// 서버\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws) => {\n  ws.on('message', (data) => {\n    console.log('received:', data);\n    ws.send('response');\n  });\n  \n  ws.on('close', () => {\n    console.log('disconnected');\n  });\n});\n\n// 클라이언트 (브라우저는 네이티브 API)\nconst WebSocket = require('ws');\nconst ws = new WebSocket('ws://localhost:8080');\n```\n\n**장점:**\n- 빠르고 가벼움\n- 낮은 오버헤드\n- 표준 WebSocket 프로토콜\n- 프로덕션 검증됨\n\n**단점:**\n- 기본 기능만 제공\n- Room/Namespace 없음\n- Fallback 없음\n- 재연결 직접 구현\n\n**3. Socket.IO**\n\n```javascript\n// 서버\nconst io = require('socket.io')(server);\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  \n  // 이벤트 기반\n  socket.on('chat message', (msg) => {\n    io.emit('chat message', msg); // 모두에게 브로드캐스트\n  });\n  \n  // Room 지원\n  socket.join('room1');\n  io.to('room1').emit('message', 'Hello room');\n  \n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\n// 클라이언트\nconst socket = io('http://localhost:3000');\n\nsocket.on('connect', () => {\n  console.log('Connected');\n  socket.emit('chat message', 'Hello');\n});\n\nsocket.on('chat message', (msg) => {\n  console.log('Message:', msg);\n});\n```\n\n**장점:**\n- **자동 재연결**\n- **Fallback** (WebSocket → Polling)\n- **Room/Namespace** 지원\n- **이벤트 기반 API**\n- **바이너리 데이터** 지원\n- **Acknowledgment** (수신 확인)\n- 양쪽(클라이언트/서버) 라이브러리\n\n**단점:**\n- 큰 번들 크기 (~40KB gzipped)\n- 표준 WebSocket 프로토콜 아님 (호환성 이슈)\n- 오버헤드 높음\n- 다른 WebSocket 클라이언트와 호환 불가\n\n**4. SockJS**\n\n```javascript\n// 서버 (Node.js)\nconst sockjs = require('sockjs');\nconst http = require('http');\n\nconst echo = sockjs.createServer();\necho.on('connection', (conn) => {\n  conn.on('data', (message) => {\n    conn.write(message);\n  });\n});\n\nconst server = http.createServer();\necho.attach(server);\nserver.listen(8080);\n\n// 클라이언트\nconst sock = new SockJS('http://localhost:8080/echo');\n\nsock.onopen = () => {\n  sock.send('Hello');\n};\n\nsock.onmessage = (e) => {\n  console.log('message', e.data);\n};\n```\n\n**장점:**\n- 강력한 Fallback (다양한 전송 방식)\n- 크로스 브라우저 호환성 우수\n- 간단한 API\n\n**단점:**\n- Socket.IO보다 기능 적음\n- 유지보수 덜 활발\n\n**5. µWebSockets.js**\n\n```javascript\nconst uWS = require('uWebSockets.js');\n\nuWS.App()\n  .ws('/*', {\n    message: (ws, message, isBinary) => {\n      ws.send(message, isBinary);\n    },\n    open: (ws) => {\n      console.log('Client connected');\n    },\n    close: (ws, code, message) => {\n      console.log('Client disconnected');\n    }\n  })\n  .listen(8080, (token) => {\n    console.log('Listening on port 8080');\n  });\n```\n\n**장점:**\n- **매우 빠름** (C++ 기반)\n- 낮은 메모리 사용\n- 고성능 필요 시 최적\n\n**단점:**\n- API가 다름\n- 커뮤니티 작음\n- 디버깅 어려움\n\n**선택 기준 표:**\n\n| 요구사항 | 추천 라이브러리 | 이유 |\n|----------|-----------------|------|\n| **간단한 실시간 통신** | 네이티브 WebSocket | 가볍고 충분함 |\n| **서버만 필요** | ws | 빠르고 안정적 |\n| **풍부한 기능** | Socket.IO | Room, 재연결, Fallback |\n| **레거시 브라우저** | Socket.IO / SockJS | 자동 Fallback |\n| **최고 성능** | µWebSockets.js | C++ 성능 |\n| **표준 준수** | ws | 표준 WebSocket |\n| **채팅 앱** | Socket.IO | Room/이벤트 |\n| **게임** | ws + 커스텀 | 낮은 지연 |\n| **IoT** | MQTT over WS | 경량, 신뢰성 |\n\n**실제 사용 예시:**\n\n**간단한 알림:**\n```javascript\n// 네이티브 WebSocket으로 충분\nconst ws = new WebSocket('ws://api.example.com/notifications');\nws.onmessage = (event) => {\n  showNotification(JSON.parse(event.data));\n};\n```\n\n**채팅 애플리케이션:**\n```javascript\n// Socket.IO 권장 (Room 기능)\nconst socket = io();\n\nsocket.emit('join-room', 'room123');\nsocket.on('new-message', (message) => {\n  displayMessage(message);\n});\n```\n\n**고성능 게임:**\n```javascript\n// ws + Protocol Buffers\nconst ws = new WebSocket('ws://game.example.com');\nws.binaryType = 'arraybuffer';\n\nws.onmessage = (event) => {\n  const state = decodeGameState(event.data); // Protobuf\n  updateGame(state);\n};\n```\n\n**번들 크기 비교:**\n\n- 네이티브 WebSocket: 0 KB\n- ws (서버만): ~5 KB\n- Socket.IO: ~40 KB (gzipped)\n- SockJS: ~15 KB (gzipped)\n\n**결론:**\n\n- **프로토타입/간단한 앱**: 네이티브 WebSocket\n- **프로덕션 서버**: ws\n- **복잡한 실시간 앱**: Socket.IO\n- **최고 성능 필요**: µWebSockets.js\n- **레거시 지원**: Socket.IO 또는 SockJS",
      "type": "essay",
      "tags": ["WebSocket", "Socket.IO", "ws", "라이브러리", "비교"],
      "id": "1763358000000-ws023",
      "createdAt": "2025-11-17T12:30:00.000022",
      "studyCount": 0
    },
    {
      "question": "WebSocket을 활용한 Pub/Sub 시스템 구현 방법에 대해 설명해주세요.",
      "answer": "Pub/Sub(발행-구독) 패턴을 WebSocket으로 구현하면 **확장 가능한 실시간 메시징 시스템**을 만들 수 있습니다.\n\n**1. 기본 Pub/Sub 구조**\n\n```javascript\n// 간단한 Pub/Sub 구현\nclass PubSub {\n  constructor() {\n    this.channels = new Map(); // channel -> Set<WebSocket>\n  }\n  \n  subscribe(ws, channel) {\n    if (!this.channels.has(channel)) {\n      this.channels.set(channel, new Set());\n    }\n    this.channels.get(channel).add(ws);\n    console.log(`Subscribed to ${channel}`);\n  }\n  \n  unsubscribe(ws, channel) {\n    if (this.channels.has(channel)) {\n      this.channels.get(channel).delete(ws);\n      \n      // 채널에 구독자 없으면 삭제\n      if (this.channels.get(channel).size === 0) {\n        this.channels.delete(channel);\n      }\n    }\n  }\n  \n  publish(channel, message) {\n    if (this.channels.has(channel)) {\n      const subscribers = this.channels.get(channel);\n      \n      subscribers.forEach(ws => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({\n            channel,\n            message,\n            timestamp: Date.now()\n          }));\n        }\n      });\n      \n      console.log(`Published to ${channel}: ${subscribers.size} subscribers`);\n    }\n  }\n  \n  unsubscribeAll(ws) {\n    // 연결 종료 시 모든 채널에서 구독 해제\n    this.channels.forEach((subscribers, channel) => {\n      subscribers.delete(ws);\n      if (subscribers.size === 0) {\n        this.channels.delete(channel);\n      }\n    });\n  }\n}\n\n// 서버\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\nconst pubsub = new PubSub();\n\nwss.on('connection', (ws) => {\n  ws.on('message', (data) => {\n    const msg = JSON.parse(data);\n    \n    switch (msg.type) {\n      case 'subscribe':\n        pubsub.subscribe(ws, msg.channel);\n        break;\n        \n      case 'unsubscribe':\n        pubsub.unsubscribe(ws, msg.channel);\n        break;\n        \n      case 'publish':\n        pubsub.publish(msg.channel, msg.message);\n        break;\n    }\n  });\n  \n  ws.on('close', () => {\n    pubsub.unsubscribeAll(ws);\n  });\n});\n```\n\n**클라이언트 사용:**\n```javascript\nconst ws = new WebSocket('ws://localhost:8080');\n\nws.onopen = () => {\n  // 채널 구독\n  ws.send(JSON.stringify({\n    type: 'subscribe',\n    channel: 'news'\n  }));\n  \n  // 메시지 발행\n  ws.send(JSON.stringify({\n    type: 'publish',\n    channel: 'news',\n    message: { title: 'Breaking News!', content: '...' }\n  }));\n};\n\nws.onmessage = (event) => {\n  const data = JSON.parse(event.data);\n  console.log(`[${data.channel}]`, data.message);\n};\n```\n\n**2. Redis Pub/Sub 통합 (클러스터 환경)**\n\n```javascript\nconst Redis = require('ioredis');\nconst WebSocket = require('ws');\n\nclass DistributedPubSub {\n  constructor(wss) {\n    this.wss = wss;\n    this.publisher = new Redis();\n    this.subscriber = new Redis();\n    this.localSubscriptions = new Map(); // ws -> Set<channel>\n    \n    this.setupRedisSubscriber();\n  }\n  \n  setupRedisSubscriber() {\n    this.subscriber.on('message', (channel, message) => {\n      // Redis로부터 메시지 받으면 로컬 구독자에게 전달\n      this.wss.clients.forEach(ws => {\n        if (this.isSubscribed(ws, channel)) {\n          ws.send(JSON.stringify({\n            channel,\n            message: JSON.parse(message)\n          }));\n        }\n      });\n    });\n  }\n  \n  subscribe(ws, channel) {\n    // 로컬 구독 추적\n    if (!this.localSubscriptions.has(ws)) {\n      this.localSubscriptions.set(ws, new Set());\n    }\n    \n    const channels = this.localSubscriptions.get(ws);\n    const isFirstSubscriber = channels.size === 0;\n    \n    channels.add(channel);\n    \n    // 이 채널의 첫 구독자면 Redis 구독\n    if (isFirstSubscriber || !this.isChannelSubscribed(channel)) {\n      this.subscriber.subscribe(channel);\n    }\n  }\n  \n  publish(channel, message) {\n    // Redis에 발행 (모든 서버 인스턴스가 받음)\n    this.publisher.publish(channel, JSON.stringify(message));\n  }\n  \n  unsubscribe(ws, channel) {\n    if (this.localSubscriptions.has(ws)) {\n      this.localSubscriptions.get(ws).delete(channel);\n      \n      // 이 채널의 구독자가 없으면 Redis 구독 해제\n      if (!this.hasLocalSubscribers(channel)) {\n        this.subscriber.unsubscribe(channel);\n      }\n    }\n  }\n  \n  unsubscribeAll(ws) {\n    if (this.localSubscriptions.has(ws)) {\n      const channels = this.localSubscriptions.get(ws);\n      channels.forEach(channel => {\n        this.unsubscribe(ws, channel);\n      });\n      this.localSubscriptions.delete(ws);\n    }\n  }\n  \n  isSubscribed(ws, channel) {\n    return this.localSubscriptions.has(ws) &&\n           this.localSubscriptions.get(ws).has(channel);\n  }\n  \n  hasLocalSubscribers(channel) {\n    for (const [ws, channels] of this.localSubscriptions) {\n      if (channels.has(channel)) return true;\n    }\n    return false;\n  }\n  \n  isChannelSubscribed(channel) {\n    // Redis 구독 중인 채널 확인 로직\n    return this.hasLocalSubscribers(channel);\n  }\n}\n\n// 사용\nconst wss = new WebSocket.Server({ port: 8080 });\nconst pubsub = new DistributedPubSub(wss);\n\nwss.on('connection', (ws) => {\n  ws.on('message', (data) => {\n    const msg = JSON.parse(data);\n    \n    switch (msg.type) {\n      case 'subscribe':\n        pubsub.subscribe(ws, msg.channel);\n        break;\n      case 'publish':\n        pubsub.publish(msg.channel, msg.message);\n        break;\n      case 'unsubscribe':\n        pubsub.unsubscribe(ws, msg.channel);\n        break;\n    }\n  });\n  \n  ws.on('close', () => {\n    pubsub.unsubscribeAll(ws);\n  });\n});\n```\n\n**3. Socket.IO로 Pub/Sub**\n\n```javascript\n// 서버\nconst io = require('socket.io')(server);\n\nio.on('connection', (socket) => {\n  // Room이 곧 Channel\n  socket.on('subscribe', (channel) => {\n    socket.join(channel);\n    console.log(`Joined ${channel}`);\n  });\n  \n  socket.on('publish', ({ channel, message }) => {\n    io.to(channel).emit('message', {\n      channel,\n      message,\n      timestamp: Date.now()\n    });\n  });\n  \n  socket.on('unsubscribe', (channel) => {\n    socket.leave(channel);\n  });\n});\n\n// 클라이언트\nconst socket = io('http://localhost:3000');\n\nsocket.emit('subscribe', 'news');\n\nsocket.on('message', (data) => {\n  console.log(`[${data.channel}]`, data.message);\n});\n\nsocket.emit('publish', {\n  channel: 'news',\n  message: { title: 'Breaking News' }\n});\n```\n\n**4. 와일드카드 구독**\n\n```javascript\n// 패턴 매칭 구독\nclass WildcardPubSub {\n  subscribe(ws, pattern) {\n    // user.* → user.123, user.456 등 매칭\n    // user.**.message → user.123.message, user.456.private.message 등\n  }\n  \n  matchesPattern(channel, pattern) {\n    const regex = new RegExp(\n      '^' + pattern\n        .replace(/\\./g, '\\\\.')\n        .replace(/\\*/g, '[^.]*')\n        .replace(/\\*\\*/g, '.*') + '$'\n    );\n    return regex.test(channel);\n  }\n}\n\n// 사용\npubsub.subscribe(ws, 'user.*'); // user.123, user.456\npubsub.subscribe(ws, 'chat.**.message'); // chat.room1.message, chat.room1.private.message\n```\n\n**5. 메시지 필터링**\n\n```javascript\n// 조건부 구독\npubsub.subscribe(ws, 'news', {\n  filter: (message) => message.category === 'tech'\n});\n\npubsub.publish('news', {\n  category: 'tech',\n  title: 'New Framework Released'\n}); // ws에 전달됨\n\npubsub.publish('news', {\n  category: 'sports',\n  title: 'Game Results'\n}); // ws에 전달 안 됨\n```\n\n**실제 사용 사례:**\n\n**실시간 알림:**\n```javascript\n// 사용자별 채널\npubsub.subscribe(ws, `user:${userId}:notifications`);\n\n// 알림 발행\npubsub.publish(`user:${userId}:notifications`, {\n  type: 'new_message',\n  from: 'Alice',\n  message: 'Hello!'\n});\n```\n\n**주식 시세:**\n```javascript\n// 특정 종목 구독\npubsub.subscribe(ws, 'stock:AAPL');\npubsub.subscribe(ws, 'stock:GOOGL');\n\n// 시세 업데이트 발행\nsetInterval(() => {\n  pubsub.publish('stock:AAPL', { price: 150.25, change: +1.5 });\n}, 1000);\n```\n\n**채팅 Room:**\n```javascript\n// 채팅방 참여\npubsub.subscribe(ws, `chat:room:${roomId}`);\n\n// 메시지 전송\npubsub.publish(`chat:room:${roomId}`, {\n  user: 'Alice',\n  message: 'Hello everyone!'\n});\n```",
      "type": "essay",
      "tags": ["WebSocket", "Pub/Sub", "발행구독", "Redis", "메시징"],
      "id": "1763358000000-ws024",
      "createdAt": "2025-11-17T12:30:00.000023",
      "studyCount": 0
    },
    {
      "question": "WebSocket 연결 종료 시 graceful shutdown을 구현하는 방법은 무엇인가요?",
      "answer": "**Graceful Shutdown**은 연결된 클라이언트에게 영향을 최소화하면서 서버를 안전하게 종료하는 것입니다.\n\n**서버 측 Graceful Shutdown:**\n\n```javascript\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nconst clients = new Set();\n\nwss.on('connection', (ws) => {\n  clients.add(ws);\n  \n  ws.on('close', () => {\n    clients.delete(ws);\n  });\n});\n\n// Graceful shutdown 함수\nfunction gracefulShutdown(signal) {\n  console.log(`${signal} received, starting graceful shutdown...`);\n  \n  // 1단계: 새 연결 거부\n  wss.close((err) => {\n    if (err) {\n      console.error('Error closing WebSocket server:', err);\n    } else {\n      console.log('No longer accepting new connections');\n    }\n  });\n  \n  // 2단계: 기존 클라이언트에게 종료 알림\n  const shutdownMessage = JSON.stringify({\n    type: 'server_shutdown',\n    message: 'Server is restarting, please reconnect',\n    reconnectAfter: 5000 // 5초 후 재연결\n  });\n  \n  clients.forEach(ws => {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(shutdownMessage);\n    }\n  });\n  \n  console.log(`Notified ${clients.size} clients`);\n  \n  // 3단계: 클라이언트가 정상 종료할 시간 대기\n  setTimeout(() => {\n    console.log('Closing remaining connections...');\n    \n    // 4단계: 남은 연결 강제 종료\n    clients.forEach(ws => {\n      ws.close(1001, 'Server restarting');\n    });\n    \n    // 5단계: 리소스 정리\n    console.log('Cleanup complete');\n    process.exit(0);\n  }, 5000); // 5초 대기\n}\n\n// 시그널 핸들러 등록\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n```\n\n**완전한 예시 (Redis, DB 포함):**\n\n```javascript\nconst http = require('http');\nconst WebSocket = require('ws');\nconst Redis = require('ioredis');\nconst { Pool } = require('pg');\n\n// 리소스 초기화\nconst server = http.createServer();\nconst wss = new WebSocket.Server({ server });\nconst redis = new Redis();\nconst db = new Pool();\n\nconst clients = new Set();\nlet isShuttingDown = false;\n\nwss.on('connection', (ws) => {\n  // 셧다운 중이면 새 연결 거부\n  if (isShuttingDown) {\n    ws.close(1001, 'Server shutting down');\n    return;\n  }\n  \n  clients.add(ws);\n  \n  ws.on('close', () => {\n    clients.delete(ws);\n  });\n});\n\nserver.listen(8080);\n\n// Graceful shutdown\nasync function gracefulShutdown(signal) {\n  console.log(`\\n${signal} received`);\n  \n  if (isShuttingDown) {\n    console.log('Already shutting down...');\n    return;\n  }\n  \n  isShuttingDown = true;\n  \n  console.log('1. Stopping health checks...');\n  // 로드 밸런서에게 unhealthy 신호\n  \n  console.log('2. Closing server (no new connections)...');\n  server.close(() => {\n    console.log('Server closed');\n  });\n  \n  console.log('3. Notifying WebSocket clients...');\n  const notification = JSON.stringify({\n    type: 'server_shutdown',\n    reconnectAfter: 5000\n  });\n  \n  clients.forEach(ws => {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(notification);\n    }\n  });\n  \n  console.log(`Notified ${clients.size} clients`);\n  \n  // 클라이언트가 graceful하게 종료할 시간\n  await new Promise(resolve => setTimeout(resolve, 5000));\n  \n  console.log('4. Closing remaining WebSocket connections...');\n  clients.forEach(ws => {\n    ws.close(1001, 'Server shutting down');\n  });\n  \n  // 모든 연결이 종료될 때까지 대기\n  await waitForConnectionsToClose();\n  \n  console.log('5. Closing Redis connection...');\n  await redis.quit();\n  \n  console.log('6. Closing database pool...');\n  await db.end();\n  \n  console.log('7. Shutdown complete');\n  process.exit(0);\n}\n\nfunction waitForConnectionsToClose() {\n  return new Promise((resolve) => {\n    const checkInterval = setInterval(() => {\n      if (clients.size === 0) {\n        clearInterval(checkInterval);\n        resolve();\n      }\n    }, 100);\n    \n    // 최대 10초 대기\n    setTimeout(() => {\n      clearInterval(checkInterval);\n      console.log(`Timeout: ${clients.size} connections still open`);\n      resolve();\n    }, 10000);\n  });\n}\n\nprocess.on('SIGTERM', gracefulShutdown);\nprocess.on('SIGINT', gracefulShutdown);\n\n// 처리되지 않은 에러 캐치\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  gracefulShutdown('unhandledRejection');\n});\n```\n\n**클라이언트 측 Graceful Shutdown 처리:**\n\n```javascript\nclass ResilientWebSocket {\n  constructor(url) {\n    this.url = url;\n    this.reconnectDelay = 1000;\n    this.connect();\n  }\n  \n  connect() {\n    this.ws = new WebSocket(this.url);\n    \n    this.ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      \n      // 서버 종료 알림 처리\n      if (data.type === 'server_shutdown') {\n        console.log('Server shutting down, will reconnect...');\n        \n        // 메시지 큐에 저장 (재연결 후 재전송)\n        this.saveUnsendMessages();\n        \n        // 지정된 시간 후 재연결\n        setTimeout(() => {\n          this.connect();\n        }, data.reconnectAfter || 5000);\n      }\n    };\n    \n    this.ws.onclose = (event) => {\n      if (event.code === 1001) {\n        // Server restart - 재연결 시도\n        console.log('Server restarting, reconnecting...');\n        setTimeout(() => this.connect(), this.reconnectDelay);\n      } else if (event.code === 1000) {\n        // Normal closure - 재연결 안 함\n        console.log('Connection closed normally');\n      }\n    };\n  }\n  \n  saveUnsendMessages() {\n    // 전송 실패한 메시지를 localStorage에 저장\n    // 재연결 후 재전송\n  }\n}\n```\n\n**PM2와 통합:**\n\n```javascript\n// PM2는 SIGINT를 보내므로 핸들러 준비 필수\nprocess.on('SIGINT', async () => {\n  await gracefulShutdown('SIGINT');\n  process.exit(0);\n});\n\n// ecosystem.config.js\nmodule.exports = {\n  apps: [{\n    name: 'websocket-server',\n    script: './server.js',\n    kill_timeout: 15000, // 15초 대기 후 SIGKILL\n    listen_timeout: 3000,\n    shutdown_with_message: true\n  }]\n};\n```\n\n**Kubernetes와 통합:**\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: websocket-server\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: websocket\n        image: websocket-server:latest\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"/bin/sh\", \"-c\", \"sleep 15\"]\n        terminationGracePeriodSeconds: 30\n```\n\n**Health Check 엔드포인트:**\n\n```javascript\nlet healthy = true;\n\n// Health check\napp.get('/health', (req, res) => {\n  if (healthy && !isShuttingDown) {\n    res.status(200).json({ status: 'ok' });\n  } else {\n    res.status(503).json({ status: 'shutting down' });\n  }\n});\n\n// Readiness check (로드 밸런서용)\napp.get('/ready', (req, res) => {\n  if (!isShuttingDown) {\n    res.status(200).json({ ready: true });\n  } else {\n    res.status(503).json({ ready: false });\n  }\n});\n```\n\n**체크리스트:**\n\n- ✅ 새 연결 거부\n- ✅ 기존 클라이언트에게 알림\n- ✅ 연결 종료 대기 시간 (5-10초)\n- ✅ 강제 종료 전 정리\n- ✅ Redis/DB 연결 종료\n- ✅ 타이머/인터벌 정리\n- ✅ Health check 업데이트\n- ✅ 로그 기록\n- ✅ 클라이언트 재연결 로직\n- ✅ PM2/K8s 설정",
      "type": "essay",
      "tags": ["WebSocket", "Graceful Shutdown", "종료처리", "서버관리"],
      "id": "1763358000000-ws025",
      "createdAt": "2025-11-17T12:30:00.000024",
      "studyCount": 0
    },
    {
      "question": "WebSocket의 버전 관리 및 프로토콜 업데이트가 필요한 이유는 무엇인가요?",
      "answer": "WebSocket 애플리케이션은 시간이 지남에 따라 **메시지 형식**, **기능**, **API**가 변경되므로 버전 관리가 필수입니다.\n\n**버전 관리가 필요한 이유:**\n\n1. **하위 호환성 유지**: 구버전 클라이언트도 작동\n2. **점진적 배포**: 서버/클라이언트를 단계적으로 업데이트\n3. **API 변경 추적**: 메시지 형식 변경 관리\n4. **롤백 가능**: 문제 발생 시 이전 버전으로 복귀\n\n**1. Sec-WebSocket-Protocol을 활용한 버전 관리**\n\n```javascript\n// 클라이언트: 지원하는 프로토콜 버전 명시\nconst ws = new WebSocket('ws://example.com/socket', [\n  'v2', // 우선순위 1\n  'v1'  // 우선순위 2 (Fallback)\n]);\n\nws.onopen = () => {\n  console.log('Protocol:', ws.protocol); // 서버가 선택한 버전\n  \n  if (ws.protocol === 'v2') {\n    // v2 메시지 형식 사용\n    ws.send(JSON.stringify({\n      version: 2,\n      type: 'message',\n      data: { text: 'Hello' }\n    }));\n  } else {\n    // v1 메시지 형식 사용\n    ws.send(JSON.stringify({\n      type: 'message',\n      text: 'Hello'\n    }));\n  }\n};\n```\n\n```javascript\n// 서버: 프로토콜 버전 협상\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({\n  handleProtocols: (protocols, request) => {\n    // 클라이언트가 제안한 프로토콜 중 선택\n    if (protocols.has('v2')) {\n      return 'v2'; // 최신 버전 선택\n    } else if (protocols.has('v1')) {\n      return 'v1'; // 구버전 지원\n    }\n    return false; // 지원하지 않는 버전\n  }\n});\n\nwss.on('connection', (ws, req) => {\n  const version = ws.protocol || 'v1';\n  console.log(`Client connected with protocol: ${version}`);\n  \n  ws.on('message', (data) => {\n    if (version === 'v2') {\n      handleV2Message(data);\n    } else {\n      handleV1Message(data);\n    }\n  });\n});\n```\n\n**2. 메시지 기반 버전 관리**\n\n```javascript\n// 모든 메시지에 버전 포함\nconst MESSAGE_V1 = {\n  type: 'chat',\n  message: 'Hello'\n};\n\nconst MESSAGE_V2 = {\n  version: 2,\n  type: 'chat',\n  payload: {\n    message: 'Hello',\n    timestamp: Date.now(),\n    userId: '123'\n  }\n};\n\n// 서버: 버전별 처리\nws.on('message', (data) => {\n  const msg = JSON.parse(data);\n  const version = msg.version || 1; // 기본값 v1\n  \n  switch (version) {\n    case 1:\n      handleV1(msg);\n      break;\n    case 2:\n      handleV2(msg);\n      break;\n    default:\n      ws.send(JSON.stringify({\n        error: 'Unsupported version',\n        supportedVersions: [1, 2]\n      }));\n  }\n});\n```\n\n**3. API 버전 엔드포인트**\n\n```javascript\n// URL 기반 버전 관리\nconst wsV1 = new WebSocket('ws://example.com/v1/socket');\nconst wsV2 = new WebSocket('ws://example.com/v2/socket');\n\n// 서버\nconst http = require('http');\nconst url = require('url');\nconst WebSocket = require('ws');\n\nconst server = http.createServer();\nconst wssV1 = new WebSocket.Server({ noServer: true });\nconst wssV2 = new WebSocket.Server({ noServer: true });\n\nserver.on('upgrade', (request, socket, head) => {\n  const pathname = url.parse(request.url).pathname;\n  \n  if (pathname === '/v1/socket') {\n    wssV1.handleUpgrade(request, socket, head, (ws) => {\n      wssV1.emit('connection', ws, request);\n    });\n  } else if (pathname === '/v2/socket') {\n    wssV2.handleUpgrade(request, socket, head, (ws) => {\n      wssV2.emit('connection', ws, request);\n    });\n  } else {\n    socket.destroy();\n  }\n});\n\nwssV1.on('connection', (ws) => {\n  console.log('V1 client connected');\n  // V1 로직\n});\n\nwssV2.on('connection', (ws) => {\n  console.log('V2 client connected');\n  // V2 로직\n});\n\nserver.listen(8080);\n```\n\n**4. 버전 협상 및 자동 업그레이드**\n\n```javascript\n// 클라이언트: 버전 협상\nclass VersionedWebSocket {\n  constructor(url) {\n    this.url = url;\n    this.connect();\n  }\n  \n  async connect() {\n    // 최신 버전으로 연결 시도\n    try {\n      this.ws = new WebSocket(this.url, ['v2']);\n      this.version = 'v2';\n    } catch (error) {\n      console.log('V2 not supported, falling back to V1');\n      this.ws = new WebSocket(this.url, ['v1']);\n      this.version = 'v1';\n    }\n    \n    this.ws.onopen = () => {\n      // 버전 정보 요청\n      this.send({ type: 'version_info' });\n    };\n    \n    this.ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      \n      if (data.type === 'version_info') {\n        console.log('Server version:', data.version);\n        console.log('Client version:', this.version);\n        \n        // 서버가 더 높은 버전을 지원하면 업그레이드 제안\n        if (data.version > this.version) {\n          console.log('New version available, please update');\n          this.showUpdateNotification();\n        }\n      }\n    };\n  }\n  \n  send(message) {\n    if (this.version === 'v2') {\n      this.ws.send(JSON.stringify({\n        version: 2,\n        ...message\n      }));\n    } else {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n}\n```\n\n**5. 버전별 기능 플래그**\n\n```javascript\nconst FEATURES = {\n  v1: ['chat', 'typing'],\n  v2: ['chat', 'typing', 'reactions', 'threads']\n};\n\n// 서버: 기능 지원 여부 확인\nfunction handleMessage(ws, msg) {\n  const version = ws.protocol || 'v1';\n  const supportedFeatures = FEATURES[version];\n  \n  if (!supportedFeatures.includes(msg.type)) {\n    ws.send(JSON.stringify({\n      error: 'Feature not supported',\n      feature: msg.type,\n      version: version,\n      upgrade: 'Please upgrade to v2 for this feature'\n    }));\n    return;\n  }\n  \n  // 기능 처리\n  handleFeature(msg.type, msg.data);\n}\n```\n\n**6. 마이그레이션 전략**\n\n```javascript\n// 점진적 마이그레이션\nclass MigrationHandler {\n  constructor() {\n    this.v1Clients = new Set();\n    this.v2Clients = new Set();\n  }\n  \n  broadcast(message) {\n    // V1 클라이언트에게는 변환된 메시지 전송\n    const v1Message = this.convertToV1(message);\n    this.v1Clients.forEach(ws => {\n      ws.send(JSON.stringify(v1Message));\n    });\n    \n    // V2 클라이언트에게는 원본 메시지 전송\n    this.v2Clients.forEach(ws => {\n      ws.send(JSON.stringify(message));\n    });\n  }\n  \n  convertToV1(v2Message) {\n    // V2 → V1 변환\n    return {\n      type: v2Message.type,\n      message: v2Message.payload.message\n      // V2의 추가 필드는 제거\n    };\n  }\n}\n```\n\n**7. 버전 모니터링**\n\n```javascript\n// 버전별 사용 통계\nconst versionStats = {\n  v1: 0,\n  v2: 0\n};\n\nwss.on('connection', (ws, req) => {\n  const version = ws.protocol || 'v1';\n  versionStats[version]++;\n  \n  console.log('Version stats:', versionStats);\n  \n  ws.on('close', () => {\n    versionStats[version]--;\n  });\n});\n\n// 정기적으로 메트릭 전송\nsetInterval(() => {\n  sendMetrics({\n    v1_clients: versionStats.v1,\n    v2_clients: versionStats.v2,\n    v1_percentage: (versionStats.v1 / (versionStats.v1 + versionStats.v2)) * 100\n  });\n}, 60000);\n```\n\n**베스트 프랙티스:**\n\n- ✅ Semantic Versioning 사용 (v1.0.0, v2.0.0)\n- ✅ 최소 2개 버전 동시 지원\n- ✅ 버전 deprecation 공지 (3-6개월 전)\n- ✅ 버전별 사용 통계 수집\n- ✅ 자동 마이그레이션 도구 제공\n- ✅ 버전별 문서 유지\n- ✅ 테스트에 모든 버전 포함",
      "type": "essay",
      "tags": ["WebSocket", "버전관리", "프로토콜", "API", "마이그레이션"],
      "id": "1763358000000-ws026",
      "createdAt": "2025-11-17T12:30:00.000025",
      "studyCount": 0
    },
    {
      "question": "WebSocket 통신에서 데이터 압축 기능을 사용할 때 고려해야 할 점은 무엇인가요?",
      "answer": "WebSocket의 **permessage-deflate** 확장은 대역폭을 절감하지만 **트레이드오프**가 있습니다.\n\n**1. 압축 활성화**\n\n```javascript\n// 서버 (Node.js ws)\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({\n  port: 8080,\n  perMessageDeflate: {\n    // 압축 옵션\n    zlibDeflateOptions: {\n      chunkSize: 1024,\n      memLevel: 7,  // 메모리 사용량 (1-9)\n      level: 6      // 압축 레벨 (0-9, 기본 6)\n    },\n    zlibInflateOptions: {\n      chunkSize: 10 * 1024\n    },\n    \n    // 서버 설정\n    serverNoContextTakeover: true,  // 메시지마다 새 압축 컨텍스트\n    clientNoContextTakeover: true,  // 클라이언트도 컨텍스트 재사용 안 함\n    serverMaxWindowBits: 15,         // 압축 윈도우 크기 (8-15)\n    clientMaxWindowBits: 15,\n    \n    // 임계값: 이 크기 이상만 압축\n    threshold: 1024 // 1KB\n  }\n});\n```\n\n**2. 압축 레벨별 트레이드오프**\n\n```javascript\n// 압축 레벨 비교\nconst compressionLevels = {\n  0: { compression: '0%',   cpu: '최소', latency: '~1ms' },\n  1: { compression: '40%',  cpu: '낮음', latency: '~5ms' },\n  3: { compression: '60%',  cpu: '중간', latency: '~10ms' },\n  6: { compression: '70%',  cpu: '높음', latency: '~20ms' },\n  9: { compression: '73%',  cpu: '최대', latency: '~40ms' }\n};\n\n// 권장 설정\nconst settings = {\n  // 실시간 게임: 압축 비활성화 또는 낮은 레벨\n  realtime: { level: 0, threshold: Infinity },\n  \n  // 일반 채팅: 중간 레벨\n  chat: { level: 3, threshold: 1024 },\n  \n  // 대용량 데이터: 높은 레벨\n  data: { level: 6, threshold: 512 }\n};\n```\n\n**3. 메시지 크기별 압축 효과**\n\n```javascript\n// 메시지 크기에 따른 압축 효과\nfunction shouldCompress(data) {\n  const size = Buffer.byteLength(data);\n  \n  // 1KB 미만: 압축 오버헤드가 이득보다 큼\n  if (size < 1024) {\n    return false;\n  }\n  \n  // 1KB - 10KB: 압축 권장\n  if (size < 10240) {\n    return true;\n  }\n  \n  // 10KB 이상: 반드시 압축\n  return true;\n}\n\n// 동적 threshold 설정\nconst dynamicThreshold = {\n  perMessageDeflate: {\n    threshold: 1024,\n    level: (size) => {\n      if (size < 10240) return 3;  // 10KB 미만: 빠른 압축\n      if (size < 102400) return 6; // 100KB 미만: 중간 압축\n      return 9;                     // 100KB 이상: 최대 압축\n    }\n  }\n};\n```\n\n**4. CPU 사용률 모니터링**\n\n```javascript\n// 압축으로 인한 CPU 사용률 추적\nconst { performance } = require('perf_hooks');\n\nfunction measureCompressionOverhead(data) {\n  const start = performance.now();\n  \n  // 압축\n  const compressed = compress(data);\n  \n  const compressionTime = performance.now() - start;\n  const compressionRatio = compressed.length / data.length;\n  \n  console.log({\n    originalSize: data.length,\n    compressedSize: compressed.length,\n    ratio: compressionRatio,\n    time: compressionTime + 'ms',\n    cpuCost: compressionTime > 10 ? 'HIGH' : 'OK'\n  });\n  \n  return compressed;\n}\n```\n\n**5. 메모리 사용량**\n\n```javascript\n// 압축 메모리 설정\nconst wss = new WebSocket.Server({\n  perMessageDeflate: {\n    // memLevel: 메모리 사용량 vs 압축률\n    // 1 = 최소 메모리 (256KB), 낮은 압축률\n    // 9 = 최대 메모리 (512KB), 높은 압축률\n    zlibDeflateOptions: {\n      memLevel: 7 // 균형잡힌 설정\n    },\n    \n    // windowBits: 슬라이딩 윈도우 크기 (메모리)\n    // 8 = 256 bytes 윈도우\n    // 15 = 32KB 윈도우 (기본값)\n    serverMaxWindowBits: 12 // 4KB 윈도우 (메모리 절약)\n  }\n});\n\n// 연결당 메모리 계산\nconst memoryPerConnection = {\n  windowBits15: '64KB',  // 압축(32KB) + 해제(32KB)\n  windowBits12: '8KB',   // 압축(4KB) + 해제(4KB)\n  windowBits8:  '512B'   // 압축(256B) + 해제(256B)\n};\n\n// 1000개 연결 시:\n// windowBits15: 64MB\n// windowBits12: 8MB\n```\n\n**6. Context Takeover 설정**\n\n```javascript\n// Context Takeover: 이전 메시지 압축 컨텍스트 재사용\n\n// 옵션 1: Context Takeover 활성화 (기본값)\nconst withContext = {\n  perMessageDeflate: {\n    serverNoContextTakeover: false, // 컨텍스트 재사용\n    clientNoContextTakeover: false\n  }\n};\n// 장점: 더 높은 압축률 (연속 메시지에서 패턴 인식)\n// 단점: 메모리 사용량 증가, 메시지 순서 의존성\n\n// 옵션 2: Context Takeover 비활성화\nconst noContext = {\n  perMessageDeflate: {\n    serverNoContextTakeover: true, // 매번 새 컨텍스트\n    clientNoContextTakeover: true\n  }\n};\n// 장점: 메모리 효율적, 메시지 독립적\n// 단점: 약간 낮은 압축률\n\n// 권장: 대부분의 경우 noContext (메모리 안정성)\n```\n\n**7. 압축 비활성화가 나은 경우**\n\n```javascript\n// 이미 압축된 데이터는 재압축 불필요\nconst skipCompression = [\n  'image/jpeg',\n  'image/png',\n  'video/mp4',\n  'application/zip',\n  'application/gzip'\n];\n\nfunction shouldCompressData(data, type) {\n  // 이미 압축된 형식\n  if (skipCompression.includes(type)) {\n    return false;\n  }\n  \n  // 매우 작은 데이터 (오버헤드 > 이득)\n  if (data.length < 100) {\n    return false;\n  }\n  \n  // 랜덤 데이터 (압축 불가능)\n  if (isRandom(data)) {\n    return false;\n  }\n  \n  return true;\n}\n```\n\n**8. 실시간성 vs 대역폭 트레이드오프**\n\n```javascript\n// 게임: 실시간성 우선\nconst gameSettings = {\n  perMessageDeflate: false // 압축 비활성화\n};\n\n// 파일 전송: 대역폭 우선\nconst fileTransferSettings = {\n  perMessageDeflate: {\n    level: 9,      // 최대 압축\n    threshold: 0   // 모든 메시지 압축\n  }\n};\n\n// 채팅: 균형\nconst chatSettings = {\n  perMessageDeflate: {\n    level: 3,        // 빠른 압축\n    threshold: 1024  // 1KB 이상만\n  }\n};\n```\n\n**9. 압축 효과 측정**\n\n```javascript\nclass CompressionMetrics {\n  constructor() {\n    this.stats = {\n      totalOriginal: 0,\n      totalCompressed: 0,\n      messageCount: 0,\n      compressionTime: 0\n    };\n  }\n  \n  track(originalSize, compressedSize, time) {\n    this.stats.totalOriginal += originalSize;\n    this.stats.totalCompressed += compressedSize;\n    this.stats.messageCount++;\n    this.stats.compressionTime += time;\n  }\n  \n  getReport() {\n    const ratio = this.stats.totalCompressed / this.stats.totalOriginal;\n    const saved = this.stats.totalOriginal - this.stats.totalCompressed;\n    const avgTime = this.stats.compressionTime / this.stats.messageCount;\n    \n    return {\n      ratio: (ratio * 100).toFixed(2) + '%',\n      saved: (saved / 1024 / 1024).toFixed(2) + 'MB',\n      avgCompressionTime: avgTime.toFixed(2) + 'ms'\n    };\n  }\n}\n```\n\n**10. 브라우저 지원**\n\n```javascript\n// 브라우저 압축 지원 확인\nconst ws = new WebSocket('ws://example.com');\n\nws.onopen = () => {\n  // extensions에 'permessage-deflate' 포함 여부 확인\n  console.log('Extensions:', ws.extensions);\n  \n  if (ws.extensions.includes('permessage-deflate')) {\n    console.log('Compression enabled');\n  } else {\n    console.log('Compression not supported');\n  }\n};\n```\n\n**권장 설정 요약:**\n\n| 사용 사례 | Level | Threshold | Context | 이유 |\n|----------|-------|-----------|---------|------|\n| **실시간 게임** | 0 | ∞ | N/A | 지연 최소화 |\n| **채팅** | 3 | 1KB | false | 균형 |\n| **파일 전송** | 9 | 0 | true | 대역폭 최대 절약 |\n| **IoT 센서** | 1 | 100B | false | 저전력 |\n| **스트리밍** | 0 | ∞ | N/A | 지연 최소화 |\n\n**체크리스트:**\n\n- ✅ 메시지 크기별 threshold 설정\n- ✅ CPU/메모리 사용률 모니터링\n- ✅ 압축률과 지연시간 측정\n- ✅ 이미 압축된 데이터 제외\n- ✅ Context takeover 신중히 선택\n- ✅ 브라우저 지원 확인\n- ✅ A/B 테스트로 최적값 찾기",
      "type": "essay",
      "tags": ["WebSocket", "압축", "permessage-deflate", "성능", "최적화"],
      "id": "1763358000000-ws027",
      "createdAt": "2025-11-17T12:30:00.000026",
      "studyCount": 0
    },
    {
      "question": "WebSocket 연결 시 세션 관리를 구현하는 방법에는 어떤 것들이 있나요?",
      "answer": "WebSocket은 **Stateful** 연결이므로 세션 관리가 중요합니다.\n\n**1. 쿠키 기반 세션**\n\n```javascript\n// 클라이언트: 쿠키 자동 전송\nconst ws = new WebSocket('ws://example.com/socket');\n// 브라우저가 자동으로 쿠키 포함\n\n// 서버: 쿠키에서 세션 ID 추출\nconst cookie = require('cookie');\n\nwss.on('connection', (ws, req) => {\n  const cookies = cookie.parse(req.headers.cookie || '');\n  const sessionId = cookies['session_id'];\n  \n  if (!sessionId) {\n    ws.close(1008, 'No session cookie');\n    return;\n  }\n  \n  // 세션 검증\n  const session = await getSession(sessionId);\n  \n  if (!session || !session.valid) {\n    ws.close(1008, 'Invalid session');\n    return;\n  }\n  \n  // WebSocket에 세션 정보 연결\n  ws.userId = session.userId;\n  ws.sessionId = sessionId;\n  \n  console.log(`User ${ws.userId} connected`);\n});\n```\n\n**2. 토큰 기반 인증**\n\n```javascript\n// 클라이언트: Query string으로 토큰 전송\nconst token = localStorage.getItem('auth_token');\nconst ws = new WebSocket(`ws://example.com/socket?token=${token}`);\n\n// 또는 첫 메시지로 토큰 전송\nconst ws = new WebSocket('ws://example.com/socket');\n\nws.onopen = () => {\n  ws.send(JSON.stringify({\n    type: 'auth',\n    token: token\n  }));\n};\n\n// 서버: 토큰 검증\nconst jwt = require('jsonwebtoken');\nconst url = require('url');\n\nwss.on('connection', (ws, req) => {\n  // URL에서 토큰 추출\n  const params = new url.URL(req.url, 'ws://base').searchParams;\n  const token = params.get('token');\n  \n  if (!token) {\n    ws.close(1008, 'No token provided');\n    return;\n  }\n  \n  // JWT 검증\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    ws.userId = decoded.userId;\n    ws.sessionId = decoded.sessionId;\n    \n    console.log(`Authenticated: ${ws.userId}`);\n  } catch (error) {\n    ws.close(1008, 'Invalid token');\n    return;\n  }\n});\n\n// 첫 메시지 인증 방식\nws.on('message', (data) => {\n  if (!ws.authenticated) {\n    const msg = JSON.parse(data);\n    \n    if (msg.type === 'auth') {\n      try {\n        const decoded = jwt.verify(msg.token, process.env.JWT_SECRET);\n        ws.authenticated = true;\n        ws.userId = decoded.userId;\n        \n        ws.send(JSON.stringify({\n          type: 'auth_success'\n        }));\n      } catch (error) {\n        ws.close(1008, 'Authentication failed');\n      }\n    } else {\n      ws.close(1008, 'Not authenticated');\n    }\n    return;\n  }\n  \n  // 인증된 후 메시지 처리\n  handleMessage(ws, data);\n});\n```\n\n**3. Redis 기반 세션 저장**\n\n```javascript\nconst Redis = require('ioredis');\nconst redis = new Redis();\n\n// 세션 생성\nasync function createSession(userId) {\n  const sessionId = generateSessionId();\n  \n  await redis.setex(\n    `session:${sessionId}`,\n    3600, // 1시간 TTL\n    JSON.stringify({\n      userId,\n      createdAt: Date.now(),\n      lastActivity: Date.now()\n    })\n  );\n  \n  return sessionId;\n}\n\n// 세션 검증 및 갱신\nasync function validateSession(sessionId) {\n  const data = await redis.get(`session:${sessionId}`);\n  \n  if (!data) {\n    return null;\n  }\n  \n  const session = JSON.parse(data);\n  \n  // 세션 갱신\n  session.lastActivity = Date.now();\n  await redis.setex(\n    `session:${sessionId}`,\n    3600,\n    JSON.stringify(session)\n  );\n  \n  return session;\n}\n\n// WebSocket 연결 시 세션 확인\nwss.on('connection', async (ws, req) => {\n  const sessionId = extractSessionId(req);\n  const session = await validateSession(sessionId);\n  \n  if (!session) {\n    ws.close(1008, 'Invalid session');\n    return;\n  }\n  \n  ws.userId = session.userId;\n  ws.sessionId = sessionId;\n  \n  // 사용자 → WebSocket 매핑 저장\n  await redis.hset(`user:${ws.userId}:connections`, ws.sessionId, 'active');\n  \n  ws.on('close', async () => {\n    await redis.hdel(`user:${ws.userId}:connections`, ws.sessionId);\n  });\n});\n```\n\n**4. 사용자별 다중 연결 관리**\n\n```javascript\nclass SessionManager {\n  constructor() {\n    // userId -> Set<WebSocket>\n    this.userConnections = new Map();\n  }\n  \n  addConnection(userId, ws) {\n    if (!this.userConnections.has(userId)) {\n      this.userConnections.set(userId, new Set());\n    }\n    \n    this.userConnections.get(userId).add(ws);\n    console.log(`User ${userId} now has ${this.userConnections.get(userId).size} connections`);\n  }\n  \n  removeConnection(userId, ws) {\n    if (this.userConnections.has(userId)) {\n      this.userConnections.get(userId).delete(ws);\n      \n      if (this.userConnections.get(userId).size === 0) {\n        this.userConnections.delete(userId);\n        console.log(`User ${userId} fully disconnected`);\n      }\n    }\n  }\n  \n  sendToUser(userId, message) {\n    if (this.userConnections.has(userId)) {\n      this.userConnections.get(userId).forEach(ws => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(message);\n        }\n      });\n    }\n  }\n  \n  getUserConnections(userId) {\n    return this.userConnections.get(userId) || new Set();\n  }\n}\n\nconst sessionManager = new SessionManager();\n\nwss.on('connection', (ws, req) => {\n  const userId = authenticateConnection(req);\n  \n  if (!userId) {\n    ws.close(1008, 'Authentication failed');\n    return;\n  }\n  \n  sessionManager.addConnection(userId, ws);\n  \n  ws.on('close', () => {\n    sessionManager.removeConnection(userId, ws);\n  });\n});\n```\n\n**5. 세션 만료 및 갱신**\n\n```javascript\n// 자동 세션 만료\nconst SESSION_TIMEOUT = 30 * 60 * 1000; // 30분\n\nwss.on('connection', (ws, req) => {\n  ws.lastActivity = Date.now();\n  \n  // 활동 시간 업데이트\n  ws.on('message', () => {\n    ws.lastActivity = Date.now();\n  });\n  \n  ws.on('pong', () => {\n    ws.lastActivity = Date.now();\n  });\n});\n\n// 주기적으로 비활성 세션 종료\nsetInterval(() => {\n  const now = Date.now();\n  \n  wss.clients.forEach(ws => {\n    if (now - ws.lastActivity > SESSION_TIMEOUT) {\n      console.log(`Session timeout for user ${ws.userId}`);\n      ws.close(1000, 'Session expired');\n    }\n  });\n}, 60000); // 1분마다 체크\n```\n\n**6. 세션 복구 (재연결 지원)**\n\n```javascript\n// 서버: 세션 복구 토큰 발급\nconst reconnectTokens = new Map();\n\nws.on('close', () => {\n  // 비정상 종료 시 복구 토큰 생성\n  if (ws.userId) {\n    const reconnectToken = generateToken();\n    \n    reconnectTokens.set(reconnectToken, {\n      userId: ws.userId,\n      sessionData: ws.sessionData,\n      expiresAt: Date.now() + 60000 // 1분 유효\n    });\n    \n    // 클라이언트에게 복구 토큰 전송 (종료 전)\n    ws.send(JSON.stringify({\n      type: 'reconnect_token',\n      token: reconnectToken\n    }));\n  }\n});\n\n// 클라이언트: 재연결 시 토큰 사용\nlet reconnectToken = null;\n\nws.onmessage = (event) => {\n  const data = JSON.parse(event.data);\n  \n  if (data.type === 'reconnect_token') {\n    reconnectToken = data.token;\n    localStorage.setItem('reconnect_token', data.token);\n  }\n};\n\nws.onclose = () => {\n  // 재연결\n  const token = reconnectToken || localStorage.getItem('reconnect_token');\n  \n  if (token) {\n    const newWs = new WebSocket(`ws://example.com/socket?reconnect=${token}`);\n  }\n};\n\n// 서버: 세션 복구\nwss.on('connection', (ws, req) => {\n  const params = new url.URL(req.url, 'ws://base').searchParams;\n  const reconnectToken = params.get('reconnect');\n  \n  if (reconnectToken) {\n    const session = reconnectTokens.get(reconnectToken);\n    \n    if (session && session.expiresAt > Date.now()) {\n      // 세션 복구\n      ws.userId = session.userId;\n      ws.sessionData = session.sessionData;\n      \n      reconnectTokens.delete(reconnectToken);\n      \n      ws.send(JSON.stringify({\n        type: 'session_restored',\n        message: 'Your session has been recovered'\n      }));\n      \n      return;\n    }\n  }\n  \n  // 새 세션\n  authenticateNewSession(ws, req);\n});\n```\n\n**7. 세션 보안**\n\n```javascript\n// 세션 하이재킹 방지\nwss.on('connection', (ws, req) => {\n  // IP 주소 확인\n  const clientIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress;\n  \n  if (ws.sessionIp && ws.sessionIp !== clientIp) {\n    console.warn(`IP mismatch for session ${ws.sessionId}`);\n    ws.close(1008, 'Session hijacking detected');\n    return;\n  }\n  \n  ws.sessionIp = clientIp;\n});\n\n// Rate limiting (사용자별)\nconst rateLimits = new Map();\n\nws.on('message', () => {\n  const userId = ws.userId;\n  const now = Date.now();\n  \n  if (!rateLimits.has(userId)) {\n    rateLimits.set(userId, { count: 0, resetAt: now + 60000 });\n  }\n  \n  const limit = rateLimits.get(userId);\n  \n  if (now > limit.resetAt) {\n    limit.count = 0;\n    limit.resetAt = now + 60000;\n  }\n  \n  limit.count++;\n  \n  if (limit.count > 100) { // 분당 100개 제한\n    ws.close(1008, 'Rate limit exceeded');\n    return;\n  }\n});\n```\n\n**체크리스트:**\n\n- ✅ 토큰/쿠키 기반 인증\n- ✅ 세션 만료 및 갱신\n- ✅ Redis 등 외부 저장소 활용\n- ✅ 다중 연결 관리\n- ✅ 세션 복구 메커니즘\n- ✅ IP 검증\n- ✅ Rate limiting\n- ✅ 주기적 세션 검증\n- ✅ Graceful session cleanup",
      "type": "essay",
      "tags": ["WebSocket", "세션관리", "인증", "Redis", "보안"],
      "id": "1763358000000-ws028",
      "createdAt": "2025-11-17T12:30:00.000027",
      "studyCount": 0
    },
    {
      "question": "WebSocket 서버와 클라이언트 간의 인증 및 인가 방식은 어떻게 구현하나요?",
      "answer": "WebSocket은 HTTP와 달리 매 요청마다 인증 헤더를 보낼 수 없으므로 **연결 수립 시 인증**이 중요합니다.\n\n**1. JWT 토큰 인증 (권장)**\n\n```javascript\n// 클라이언트: JWT를 query parameter로 전달\nconst token = localStorage.getItem('jwt_token');\nconst ws = new WebSocket(`wss://api.example.com/socket?token=${token}`);\n\n// 서버: JWT 검증\nconst jwt = require('jsonwebtoken');\nconst url = require('url');\n\nwss.on('connection', (ws, req) => {\n  const params = new url.URL(req.url, 'wss://base').searchParams;\n  const token = params.get('token');\n  \n  if (!token) {\n    return ws.close(4001, JSON.stringify({\n      error: 'No authentication token'\n    }));\n  }\n  \n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    \n    // 사용자 정보 저장\n    ws.user = {\n      id: decoded.userId,\n      email: decoded.email,\n      roles: decoded.roles || []\n    };\n    \n    ws.authenticated = true;\n    \n    ws.send(JSON.stringify({\n      type: 'authenticated',\n      user: ws.user\n    }));\n    \n  } catch (error) {\n    ws.close(4002, JSON.stringify({\n      error: 'Invalid or expired token'\n    }));\n  }\n});\n```\n\n**2. 2단계 인증 (연결 후 인증)**\n\n```javascript\n// 클라이언트\nconst ws = new WebSocket('wss://api.example.com/socket');\n\nws.onopen = () => {\n  // 연결 후 인증 메시지 전송\n  ws.send(JSON.stringify({\n    type: 'auth',\n    token: localStorage.getItem('jwt_token')\n  }));\n};\n\nws.onmessage = (event) => {\n  const data = JSON.parse(event.data);\n  \n  if (data.type === 'auth_success') {\n    console.log('Authenticated!');\n    // 이제 일반 메시지 전송 가능\n  } else if (data.type === 'auth_failed') {\n    console.error('Authentication failed:', data.error);\n    ws.close();\n  }\n};\n\n// 서버\nconst UNAUTHENTICATED_TIMEOUT = 5000; // 5초\n\nwss.on('connection', (ws, req) => {\n  ws.authenticated = false;\n  \n  // 5초 내에 인증하지 않으면 연결 종료\n  const authTimeout = setTimeout(() => {\n    if (!ws.authenticated) {\n      ws.close(4003, 'Authentication timeout');\n    }\n  }, UNAUTHENTICATED_TIMEOUT);\n  \n  ws.on('message', (data) => {\n    const msg = JSON.parse(data);\n    \n    // 인증되지 않은 상태에서는 auth 메시지만 허용\n    if (!ws.authenticated) {\n      if (msg.type === 'auth') {\n        try {\n          const decoded = jwt.verify(msg.token, process.env.JWT_SECRET);\n          \n          clearTimeout(authTimeout);\n          ws.authenticated = true;\n          ws.user = decoded;\n          \n          ws.send(JSON.stringify({\n            type: 'auth_success',\n            user: {\n              id: decoded.userId,\n              email: decoded.email\n            }\n          }));\n          \n        } catch (error) {\n          ws.send(JSON.stringify({\n            type: 'auth_failed',\n            error: 'Invalid token'\n          }));\n          ws.close(4002, 'Authentication failed');\n        }\n      } else {\n        ws.close(4003, 'Must authenticate first');\n      }\n      return;\n    }\n    \n    // 인증된 후 메시지 처리\n    handleAuthenticatedMessage(ws, msg);\n  });\n});\n```\n\n**3. 역할 기반 접근 제어 (RBAC)**\n\n```javascript\n// 권한 미들웨어\nfunction requireRole(roles) {\n  return function(ws, msg, next) {\n    if (!ws.user) {\n      return ws.send(JSON.stringify({\n        error: 'Not authenticated'\n      }));\n    }\n    \n    const hasRole = roles.some(role => ws.user.roles.includes(role));\n    \n    if (!hasRole) {\n      return ws.send(JSON.stringify({\n        error: 'Insufficient permissions',\n        required: roles,\n        current: ws.user.roles\n      }));\n    }\n    \n    next();\n  };\n}\n\n// 사용\nws.on('message', (data) => {\n  const msg = JSON.parse(data);\n  \n  switch (msg.type) {\n    case 'admin_action':\n      requireRole(['admin'])(ws, msg, () => {\n        handleAdminAction(ws, msg);\n      });\n      break;\n      \n    case 'moderator_action':\n      requireRole(['admin', 'moderator'])(ws, msg, () => {\n        handleModeratorAction(ws, msg);\n      });\n      break;\n      \n    default:\n      handleMessage(ws, msg);\n  }\n});\n```\n\n**4. OAuth 2.0 통합**\n\n```javascript\n// 1. HTTP로 OAuth 토큰 받기\napp.get('/auth/google/callback', async (req, res) => {\n  const { code } = req.query;\n  \n  // OAuth 토큰 교환\n  const tokens = await exchangeCodeForTokens(code);\n  const userInfo = await getUserInfo(tokens.access_token);\n  \n  // JWT 생성\n  const jwt_token = jwt.sign(\n    {\n      userId: userInfo.id,\n      email: userInfo.email,\n      provider: 'google'\n    },\n    process.env.JWT_SECRET,\n    { expiresIn: '1h' }\n  );\n  \n  res.send(`\n    <script>\n      localStorage.setItem('jwt_token', '${jwt_token}');\n      window.location.href = '/';\n    </script>\n  `);\n});\n\n// 2. WebSocket 연결 시 JWT 사용\nconst token = localStorage.getItem('jwt_token');\nconst ws = new WebSocket(`wss://api.example.com/socket?token=${token}`);\n```\n\n**5. API Key 인증**\n\n```javascript\n// 클라이언트\nconst ws = new WebSocket('wss://api.example.com/socket', {\n  headers: {\n    'X-API-Key': 'your-api-key'\n  }\n});\n\n// 서버\nwss.on('connection', (ws, req) => {\n  const apiKey = req.headers['x-api-key'];\n  \n  if (!apiKey) {\n    return ws.close(4001, 'API key required');\n  }\n  \n  // API 키 검증\n  const isValid = await validateApiKey(apiKey);\n  \n  if (!isValid) {\n    return ws.close(4002, 'Invalid API key');\n  }\n  \n  ws.apiKey = apiKey;\n  ws.authenticated = true;\n});\n```\n\n**6. 세션 쿠키 인증**\n\n```javascript\n// 서버 (Express Session)\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\n\napp.use(session({\n  secret: 'secret',\n  resave: false,\n  saveUninitialized: false,\n  cookie: { secure: true, httpOnly: true }\n}));\n\n// WebSocket 업그레이드 시 세션 확인\nserver.on('upgrade', (req, socket, head) => {\n  sessionMiddleware(req, {}, () => {\n    if (!req.session || !req.session.userId) {\n      socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n      socket.destroy();\n      return;\n    }\n    \n    wss.handleUpgrade(req, socket, head, (ws) => {\n      ws.userId = req.session.userId;\n      wss.emit('connection', ws, req);\n    });\n  });\n});\n```\n\n**7. 메시지별 권한 검증**\n\n```javascript\n// 리소스별 권한 체크\nconst permissions = {\n  'message:read': ['user', 'moderator', 'admin'],\n  'message:write': ['user', 'moderator', 'admin'],\n  'message:delete': ['moderator', 'admin'],\n  'user:ban': ['admin']\n};\n\nfunction checkPermission(ws, action) {\n  const requiredRoles = permissions[action];\n  \n  if (!requiredRoles) {\n    return false;\n  }\n  \n  return ws.user.roles.some(role => requiredRoles.includes(role));\n}\n\nws.on('message', (data) => {\n  const msg = JSON.parse(data);\n  \n  if (msg.type === 'delete_message') {\n    if (!checkPermission(ws, 'message:delete')) {\n      return ws.send(JSON.stringify({\n        error: 'Permission denied',\n        action: 'message:delete'\n      }));\n    }\n    \n    deleteMessage(msg.messageId);\n  }\n});\n```\n\n**8. 토큰 갱신**\n\n```javascript\n// 액세스 토큰 + 리프레시 토큰\nws.on('message', async (data) => {\n  const msg = JSON.parse(data);\n  \n  if (msg.type === 'refresh_token') {\n    try {\n      const decoded = jwt.verify(msg.refreshToken, process.env.REFRESH_SECRET);\n      \n      // 새 액세스 토큰 발급\n      const newAccessToken = jwt.sign(\n        { userId: decoded.userId },\n        process.env.JWT_SECRET,\n        { expiresIn: '15m' }\n      );\n      \n      ws.send(JSON.stringify({\n        type: 'token_refreshed',\n        accessToken: newAccessToken\n      }));\n      \n    } catch (error) {\n      ws.close(4002, 'Invalid refresh token');\n    }\n  }\n});\n\n// 클라이언트: 자동 갱신\nsetInterval(() => {\n  ws.send(JSON.stringify({\n    type: 'refresh_token',\n    refreshToken: localStorage.getItem('refresh_token')\n  }));\n}, 10 * 60 * 1000); // 10분마다\n```\n\n**9. IP 화이트리스트**\n\n```javascript\nconst allowedIPs = ['192.168.1.100', '10.0.0.50'];\n\nwss.on('connection', (ws, req) => {\n  const clientIP = req.headers['x-forwarded-for'] || req.socket.remoteAddress;\n  \n  if (!allowedIPs.includes(clientIP)) {\n    ws.close(4003, 'IP not whitelisted');\n    return;\n  }\n});\n```\n\n**10. Rate Limiting**\n\n```javascript\nconst rateLimiter = new Map();\n\nws.on('message', () => {\n  const userId = ws.user.id;\n  const now = Date.now();\n  \n  if (!rateLimiter.has(userId)) {\n    rateLimiter.set(userId, { count: 0, resetAt: now + 60000 });\n  }\n  \n  const limit = rateLimiter.get(userId);\n  \n  if (now > limit.resetAt) {\n    limit.count = 0;\n    limit.resetAt = now + 60000;\n  }\n  \n  limit.count++;\n  \n  if (limit.count > 100) {\n    ws.close(4029, 'Too many requests');\n    return;\n  }\n});\n```\n\n**보안 체크리스트:**\n\n- ✅ HTTPS/WSS 사용\n- ✅ JWT 검증 (서명, 만료)\n- ✅ 연결 시 인증 필수\n- ✅ 역할 기반 권한 관리\n- ✅ Rate limiting\n- ✅ IP 검증\n- ✅ 토큰 갱신 메커니즘\n- ✅ 인증 타임아웃\n- ✅ 로깅 및 감사\n- ✅ CORS 설정",
      "type": "essay",
      "tags": ["WebSocket", "인증", "인가", "JWT", "보안", "RBAC"],
      "id": "1763358000000-ws029",
      "createdAt": "2025-11-17T12:30:00.000028",
      "studyCount": 0
    },
    {
      "question": "WebSocket 기반 애플리케이션에서 발생할 수 있는 일반적인 문제와 해결 방안은 무엇인가요?",
      "answer": "WebSocket 애플리케이션 개발 시 자주 발생하는 문제들과 해결책을 정리했습니다.\n\n**1. 연결 끊김 (Connection Drops)**\n\n**문제:** 네트워크 불안정, 프록시 타임아웃, 모바일 네트워크 전환\n\n**해결:**\n```javascript\n// Heartbeat (Ping/Pong)\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_TIMEOUT = 5000;\n\nconst heartbeat = setInterval(() => {\n  if (ws.readyState === WebSocket.OPEN) {\n    ws.ping();\n  }\n}, HEARTBEAT_INTERVAL);\n\nws.on('pong', () => {\n  // 연결 살아있음\n});\n\n// 자동 재연결\nfunction connect() {\n  const ws = new WebSocket('wss://example.com');\n  \n  ws.onclose = () => {\n    setTimeout(() => connect(), 1000); // 1초 후 재연결\n  };\n}\n```\n\n**2. 메모리 누수**\n\n**문제:** 이벤트 리스너, 타이머, 연결 객체가 정리되지 않음\n\n**해결:**\n```javascript\n// 올바른 정리\nconst timers = [];\nconst listeners = [];\n\nwss.on('connection', (ws) => {\n  // 타이머 추적\n  const timer = setInterval(() => {\n    ws.send('ping');\n  }, 30000);\n  timers.push(timer);\n  \n  // 이벤트 리스너 추적\n  const messageHandler = (data) => { /* ... */ };\n  ws.on('message', messageHandler);\n  listeners.push({ ws, event: 'message', handler: messageHandler });\n  \n  // 연결 종료 시 정리\n  ws.on('close', () => {\n    // 타이머 정리\n    timers.forEach(clearInterval);\n    timers.length = 0;\n    \n    // 리스너 제거\n    listeners.forEach(({ ws, event, handler }) => {\n      ws.removeListener(event, handler);\n    });\n    listeners.length = 0;\n    \n    // 참조 제거\n    ws = null;\n  });\n});\n```\n\n**3. 메시지 순서 보장 문제**\n\n**문제:** 비동기 처리로 메시지 순서가 뒤바뀜\n\n**해결:**\n```javascript\n// 시퀀스 번호 추가\nlet sequenceNumber = 0;\n\nfunction sendMessage(data) {\n  ws.send(JSON.stringify({\n    seq: sequenceNumber++,\n    data: data\n  }));\n}\n\n// 수신 측: 순서 보장\nlet expectedSeq = 0;\nconst messageQueue = [];\n\nws.onmessage = (event) => {\n  const msg = JSON.parse(event.data);\n  \n  if (msg.seq === expectedSeq) {\n    processMessage(msg.data);\n    expectedSeq++;\n    \n    // 큐에서 다음 메시지 처리\n    while (messageQueue.length > 0) {\n      const next = messageQueue.find(m => m.seq === expectedSeq);\n      if (next) {\n        processMessage(next.data);\n        expectedSeq++;\n        messageQueue.splice(messageQueue.indexOf(next), 1);\n      } else {\n        break;\n      }\n    }\n  } else {\n    // 순서 벗어난 메시지는 큐에 저장\n    messageQueue.push(msg);\n  }\n};\n```\n\n**4. 대용량 메시지 처리**\n\n**문제:** 큰 파일/데이터 전송 시 메모리 부족, 연결 끊김\n\n**해결:**\n```javascript\n// 청크로 분할 전송\nfunction sendLargeData(data, chunkSize = 64 * 1024) {\n  const messageId = generateId();\n  const chunks = [];\n  \n  for (let i = 0; i < data.length; i += chunkSize) {\n    chunks.push(data.slice(i, i + chunkSize));\n  }\n  \n  // 메타데이터 전송\n  ws.send(JSON.stringify({\n    type: 'large_message_start',\n    messageId: messageId,\n    totalChunks: chunks.length\n  }));\n  \n  // 청크 전송\n  chunks.forEach((chunk, index) => {\n    ws.send(JSON.stringify({\n      type: 'chunk',\n      messageId: messageId,\n      index: index,\n      data: chunk\n    }));\n  });\n  \n  // 완료 메시지\n  ws.send(JSON.stringify({\n    type: 'large_message_end',\n    messageId: messageId\n  }));\n}\n\n// 수신 측: 청크 재조립\nconst incomingMessages = new Map();\n\nws.onmessage = (event) => {\n  const msg = JSON.parse(event.data);\n  \n  if (msg.type === 'large_message_start') {\n    incomingMessages.set(msg.messageId, {\n      chunks: new Array(msg.totalChunks),\n      received: 0\n    });\n  } else if (msg.type === 'chunk') {\n    const message = incomingMessages.get(msg.messageId);\n    message.chunks[msg.index] = msg.data;\n    message.received++;\n  } else if (msg.type === 'large_message_end') {\n    const message = incomingMessages.get(msg.messageId);\n    const fullData = message.chunks.join('');\n    processData(fullData);\n    incomingMessages.delete(msg.messageId);\n  }\n};\n```\n\n**5. 동시 연결 수 제한**\n\n**문제:** 서버가 너무 많은 연결을 처리하여 다운\n\n**해결:**\n```javascript\nconst MAX_CONNECTIONS = 10000;\nlet currentConnections = 0;\n\nwss.on('connection', (ws) => {\n  if (currentConnections >= MAX_CONNECTIONS) {\n    ws.close(1008, 'Server at capacity');\n    return;\n  }\n  \n  currentConnections++;\n  \n  ws.on('close', () => {\n    currentConnections--;\n  });\n});\n```\n\n**6. 브라우저 연결 수 제한**\n\n**문제:** 브라우저가 도메인당 WebSocket 연결 수 제한\n\n**해결:**\n```javascript\n// 연결 풀링\nclass WebSocketPool {\n  constructor(url, poolSize = 6) {\n    this.connections = [];\n    for (let i = 0; i < poolSize; i++) {\n      this.connections.push(new WebSocket(url));\n    }\n    this.currentIndex = 0;\n  }\n  \n  send(data) {\n    const ws = this.connections[this.currentIndex];\n    this.currentIndex = (this.currentIndex + 1) % this.connections.length;\n    ws.send(data);\n  }\n}\n```\n\n**7. CORS 및 Origin 검증**\n\n**문제:** Cross-origin 요청 차단\n\n**해결:**\n```javascript\nconst ALLOWED_ORIGINS = ['https://example.com'];\n\nwss.on('connection', (ws, req) => {\n  const origin = req.headers.origin;\n  \n  if (!ALLOWED_ORIGINS.includes(origin)) {\n    ws.close(1008, 'Origin not allowed');\n    return;\n  }\n});\n```\n\n**8. 상태 동기화 문제**\n\n**문제:** 클러스터 환경에서 서버 간 상태 불일치\n\n**해결:**\n```javascript\n// Redis Pub/Sub로 상태 동기화\nconst redis = new Redis();\n\n// 상태 변경 시 발행\nfunction updateState(userId, state) {\n  redis.publish('state_update', JSON.stringify({\n    userId,\n    state\n  }));\n}\n\n// 구독하여 동기화\nredis.subscribe('state_update');\nredis.on('message', (channel, message) => {\n  const { userId, state } = JSON.parse(message);\n  broadcastToUser(userId, state);\n});\n```\n\n**9. 디버깅 어려움**\n\n**문제:** 실시간 통신 디버깅이 복잡함\n\n**해결:**\n```javascript\n// 상세 로깅\nclass DebugWebSocket {\n  constructor(url) {\n    this.ws = new WebSocket(url);\n    this.log = [];\n    \n    this.ws.onopen = (e) => {\n      this.logEvent('open', e);\n    };\n    \n    this.ws.onmessage = (e) => {\n      this.logEvent('message', { data: e.data });\n    };\n    \n    this.ws.onerror = (e) => {\n      this.logEvent('error', e);\n    };\n    \n    this.ws.onclose = (e) => {\n      this.logEvent('close', { code: e.code, reason: e.reason });\n    };\n  }\n  \n  logEvent(type, data) {\n    const entry = {\n      timestamp: new Date().toISOString(),\n      type,\n      data\n    };\n    this.log.push(entry);\n    console.log(`[WS ${type}]`, entry);\n  }\n  \n  exportLog() {\n    return JSON.stringify(this.log, null, 2);\n  }\n}\n```\n\n**10. 성능 저하**\n\n**문제:** 많은 메시지로 인한 성능 저하\n\n**해결:**\n```javascript\n// 메시지 배칭\nclass BatchedWebSocket {\n  constructor(ws, interval = 16) {\n    this.ws = ws;\n    this.queue = [];\n    \n    setInterval(() => {\n      if (this.queue.length > 0) {\n        this.ws.send(JSON.stringify(this.queue));\n        this.queue = [];\n      }\n    }, interval);\n  }\n  \n  send(data) {\n    this.queue.push(data);\n  }\n}\n```\n\n**문제 해결 체크리스트:**\n\n- ✅ Heartbeat 구현\n- ✅ 자동 재연결\n- ✅ 메모리 누수 방지\n- ✅ 메시지 순서 보장\n- ✅ 대용량 데이터 청킹\n- ✅ 연결 수 제한\n- ✅ Origin 검증\n- ✅ 상태 동기화 (클러스터)\n- ✅ 상세 로깅\n- ✅ 성능 최적화 (배칭)",
      "type": "essay",
      "tags": ["WebSocket", "문제해결", "디버깅", "최적화", "베스트프랙티스"],
      "id": "1763358000000-ws030",
      "createdAt": "2025-11-17T12:30:00.000029",
      "studyCount": 0
    }
  ]
}
