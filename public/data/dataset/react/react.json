{
  "name": "리액트",
  "description": "React 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "React는 무엇이고 왜 사용하나요?",
      "answer": "**정의:**\nReact는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다. Facebook에서 개발했으며 컴포넌트 기반의 선언적 프로그래밍 방식으로 효율적이고 유지보수하기 쉬운 UI를 만들 수 있게 해줍니다.\n\n**React의 핵심 개념:**\n- 컴포넌트 기반: UI를 재사용 가능한 독립적인 조각으로 나눕니다. 각 컴포넌트는 자체 로직과 표현을 가집니다.\n- 선언적: 원하는 UI 상태를 선언하면 React가 알아서 DOM을 업데이트합니다. 명령형보다 직관적입니다.\n- 단방향 데이터 흐름: 데이터가 부모에서 자식으로만 흐릅니다. 예측 가능하고 디버깅이 쉽습니다.\n- Virtual DOM: 실제 DOM 조작을 최소화하여 성능을 최적화합니다.\n\n**React를 사용하는 이유:**\n- 재사용성이 높습니다. 컴포넌트를 여러 곳에서 재사용할 수 있습니다.\n- 개발 생산성이 향상됩니다. 선언적 코드로 빠르게 개발할 수 있습니다.\n- 큰 커뮤니티와 생태계를 가집니다. 수많은 라이브러리와 도구가 있습니다.\n- 성능이 우수합니다. Virtual DOM과 최적화 기법으로 빠릅니다.\n- 학습하기 쉽습니다. JavaScript 지식만 있으면 시작할 수 있습니다.\n\n**React의 장점:**\n- 유지보수가 쉽습니다. 컴포넌트 단위로 관리하여 복잡도를 낮춥니다.\n- 테스트가 용이합니다. 순수 함수처럼 동작하는 컴포넌트는 테스트하기 쉽습니다.\n- SEO 최적화가 가능합니다. Next.js 같은 프레임워크로 SSR을 구현할 수 있습니다.\n- 모바일 앱 개발도 가능합니다. React Native로 네이티브 앱을 만듭니다.\n\n**실무 활용:**\n- 싱글 페이지 애플리케이션 개발에 최적입니다. 빠르고 부드러운 사용자 경험을 제공합니다.\n- 대규모 프로젝트에 적합합니다. 컴포넌트 구조로 확장성이 좋습니다.\n- 팀 협업이 원활합니다. 컴포넌트 단위로 작업을 나눌 수 있습니다.\n- 다양한 플랫폼을 지원합니다. 웹, 모바일, 데스크톱 애플리케이션을 만들 수 있습니다.\n- 전 세계적으로 널리 사용됩니다. Facebook, Instagram, Netflix 등이 사용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901802-vdb1ysu1r",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "컴포넌트(Component)란 무엇이고 어떤 종류가 있나요?",
      "answer": "**정의:**\n컴포넌트는 UI의 독립적이고 재사용 가능한 조각입니다. 자체 로직과 렌더링을 담당하며, props를 입력받아 React 엘리먼트를 반환합니다.\n\n**함수형 컴포넌트:**\n- 함수로 정의됩니다. JavaScript 함수 그 자체입니다.\n- props를 매개변수로 받습니다. 구조 분해로 쉽게 사용할 수 있습니다.\n- JSX를 반환합니다. UI를 표현하는 엘리먼트를 돌려줍니다.\n- Hooks를 사용할 수 있습니다. useState, useEffect 등으로 상태와 생명주기를 관리합니다.\n- 간결하고 테스트하기 쉽습니다. 순수 함수에 가깝습니다.\n\n**클래스 컴포넌트:**\n- ES6 클래스로 정의됩니다. React.Component를 상속받습니다.\n- render 메서드를 구현해야 합니다. 이 메서드가 JSX를 반환합니다.\n- this.props로 props에 접근합니다.\n- this.state와 this.setState로 상태를 관리합니다.\n- 생명주기 메서드를 사용합니다. componentDidMount 등입니다.\n- 레거시 코드에서 많이 볼 수 있습니다.\n\n**함수형과 클래스형의 차이:**\n- 함수형이 더 간결합니다. 보일러플레이트가 적습니다.\n- 함수형은 Hooks로 강력해졌습니다. 거의 모든 기능을 구현할 수 있습니다.\n- 클래스형은 this 바인딩이 필요합니다. 복잡하고 혼란스러울 수 있습니다.\n- React 팀은 함수형을 권장합니다. 새 프로젝트는 함수형으로 시작하는 것이 좋습니다.\n\n**컴포넌트의 종류:**\n- Presentational Component: UI 표현만 담당합니다. 로직이 거의 없습니다. props를 받아 렌더링합니다.\n- Container Component: 로직을 담당합니다. 데이터를 가져오고 상태를 관리합니다. Presentational에 props를 전달합니다.\n- 하지만 Hooks 등장 이후 이 구분이 흐려졌습니다. 함수형 컴포넌트가 모든 역할을 할 수 있습니다.\n\n**컴포넌트 구성 원칙:**\n- 단일 책임 원칙을 따릅니다. 하나의 컴포넌트는 하나의 역할만 합니다.\n- 재사용 가능하게 만듭니다. 특정 맥락에 종속되지 않도록 합니다.\n- 작게 유지합니다. 너무 크면 분리를 고려합니다.\n- Props로 커스터마이징합니다. 유연하게 사용할 수 있도록 합니다.\n\n**실무 활용:**\n- UI를 컴포넌트 단위로 설계합니다. 재사용성을 고려합니다.\n- 디자인 시스템을 컴포넌트로 구현합니다. 버튼, 인풋 등 기본 요소를 만듭니다.\n- 페이지를 여러 컴포넌트로 나눕니다. Header, Footer, Sidebar 등입니다.\n- Storybook으로 컴포넌트를 독립적으로 개발하고 문서화합니다.\n- 함수형 컴포넌트와 Hooks를 기본으로 사용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "component"
      ],
      "id": "1763441901802-ey9tadn9u",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "JSX란 무엇이고 왜 사용하나요?",
      "answer": "**정의:**\nJSX는 JavaScript XML의 약자로, JavaScript 안에서 HTML과 유사한 문법으로 UI를 표현할 수 있게 해주는 문법 확장입니다. React 엘리먼트를 생성하는 간편한 방법입니다.\n\n**JSX의 특징:**\n- HTML처럼 보이지만 JavaScript입니다. 표현식을 중괄호로 삽입할 수 있습니다.\n- Babel이 일반 JavaScript로 변환합니다. React.createElement 호출로 컴파일됩니다.\n- XML 규칙을 따릅니다. 모든 태그는 닫혀야 합니다.\n- camelCase 속성명을 사용합니다. className, onClick 등입니다.\n\n**JSX를 사용하는 이유:**\n- 가독성이 높습니다. UI 구조가 한눈에 들어옵니다.\n- 직관적입니다. HTML을 아는 사람이라면 쉽게 이해할 수 있습니다.\n- 컴파일 타임 에러를 잡을 수 있습니다. 문법 오류를 미리 발견합니다.\n- JavaScript의 모든 기능을 사용할 수 있습니다. 조건부 렌더링, 반복 등이 쉽습니다.\n\n**JSX 문법 규칙:**\n- 하나의 루트 요소만 반환해야 합니다. Fragment로 감싸거나 배열을 사용합니다.\n- JavaScript 표현식은 중괄호 안에 씁니다. 변수, 함수 호출, 연산 등이 가능합니다.\n- 주석은 중괄호와 다중 라인 주석을 사용합니다.\n- 스타일은 객체로 전달합니다. 카멜케이스 속성명을 사용합니다.\n- className으로 CSS 클래스를 지정합니다. class는 예약어입니다.\n\n**JSX vs createElement:**\n- JSX는 간결하고 읽기 쉽습니다.\n- createElement는 장황하지만 JSX 없이도 React를 사용할 수 있습니다.\n- 내부적으로는 동일합니다. JSX가 createElement로 변환됩니다.\n- JSX를 사용하는 것이 압도적으로 일반적입니다.\n\n**조건부 렌더링:**\n- 삼항 연산자를 많이 사용합니다. 간결한 조건부 표현입니다.\n- 논리 AND 연산자로 조건부 렌더링을 합니다.\n- if 문은 JSX 밖에서 사용합니다.\n- 즉시 실행 함수로 복잡한 로직을 처리할 수 있습니다.\n\n**리스트 렌더링:**\n- map 메서드로 배열을 JSX로 변환합니다.\n- key prop이 필요합니다. 각 항목을 고유하게 식별합니다.\n- key는 안정적이고 예측 가능해야 합니다. 인덱스 사용은 피합니다.\n\n**실무 활용:**\n- 컴포넌트의 UI를 JSX로 표현합니다. 선언적이고 명확합니다.\n- 조건부와 반복 렌더링을 JavaScript 문법으로 처리합니다.\n- props와 state를 JSX에 삽입합니다. 동적인 UI를 만듭니다.\n- Fragment로 불필요한 DOM 노드를 줄입니다.\n- TypeScript와 함께 사용하면 타입 안전성을 얻습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901802-3s4lnruab",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Virtual DOM의 동작 원리와 장점은 무엇인가요?",
      "answer": "**정의:**\nVirtual DOM은 실제 DOM의 가벼운 복사본으로, 메모리에 존재하는 JavaScript 객체입니다. React는 Virtual DOM을 사용하여 실제 DOM 조작을 최소화하고 성능을 최적화합니다.\n\n**Virtual DOM의 동작 원리:**\n- 상태가 변경되면 새로운 Virtual DOM 트리를 생성합니다. 전체 UI를 다시 렌더링합니다.\n- 이전 Virtual DOM과 새 Virtual DOM을 비교합니다. Diffing 알고리즘을 사용합니다.\n- 변경된 부분만 찾아냅니다. 최소한의 변경사항을 계산합니다.\n- 실제 DOM에 한 번에 적용합니다. Reconciliation 과정을 거칩니다.\n- 배치 업데이트로 효율성을 높입니다.\n\n**Diffing 알고리즘:**\n- 트리를 레벨별로 비교합니다. 같은 레벨의 요소들만 비교합니다.\n- 타입이 다르면 전체를 교체합니다. 세부 비교를 하지 않습니다.\n- 같은 타입이면 속성만 업데이트합니다.\n- key를 사용하여 리스트 항목을 식별합니다. 순서가 바뀌어도 재사용합니다.\n- 휴리스틱 알고리즘으로 효율성과 성능의 균형을 맞춥니다.\n\n**Virtual DOM의 장점:**\n- 성능이 향상됩니다. 실제 DOM 조작을 최소화합니다. DOM 조작은 비용이 큽니다.\n- 배치 업데이트로 리플로우와 리페인트를 줄입니다.\n- 선언적 프로그래밍이 가능합니다. 개발자는 최종 상태만 선언하면 됩니다.\n- 크로스 플랫폼 렌더링이 가능합니다. React Native가 이를 활용합니다.\n\n**실제 DOM과의 차이:**\n- 실제 DOM은 무겁고 느립니다. 브라우저 API와 연결되어 있습니다.\n- Virtual DOM은 가볍고 빠릅니다. 단순한 JavaScript 객체입니다.\n- 실제 DOM 조작은 리플로우를 유발합니다.\n- Virtual DOM은 메모리에서만 동작합니다.\n\n**Reconciliation 과정:**\n- Render Phase: Virtual DOM을 생성하고 비교합니다. 변경사항을 계산합니다.\n- Commit Phase: 실제 DOM에 변경사항을 적용합니다. 한 번에 반영합니다.\n- Fiber 아키텍처로 작업을 분할합니다. 우선순위를 관리하고 중단할 수 있습니다.\n\n**한계와 오해:**\n- 항상 빠른 것은 아닙니다. 간단한 업데이트는 직접 DOM 조작이 더 빠를 수 있습니다.\n- Virtual DOM이 React의 전부는 아닙니다. 컴포넌트 모델이 더 중요합니다.\n- 메모리를 사용합니다. Virtual DOM도 공간을 차지합니다.\n- 하지만 대부분의 경우 장점이 단점을 상회합니다.\n\n**실무 활용:**\n- 복잡한 UI에서 성능 이점이 큽니다. 많은 요소가 자주 변경될 때 유용합니다.\n- key prop을 올바르게 사용하여 최적화합니다.\n- 불필요한 리렌더링을 방지합니다. React.memo, useMemo 등을 활용합니다.\n- 개발자는 Virtual DOM을 직접 다루지 않습니다. React가 내부적으로 처리합니다.\n- 성능 프로파일링으로 병목을 찾고 최적화합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "DOM"
      ],
      "id": "1763441901802-b1vokvz60",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React의 렌더링 과정을 설명해주세요.",
      "answer": "**정의:**\nReact의 렌더링은 컴포넌트의 현재 상태를 기반으로 UI를 생성하고 화면에 표시하는 전체 프로세스입니다. 초기 렌더링과 리렌더링으로 나뉘며, Virtual DOM을 활용한 효율적인 업데이트 메커니즘을 사용합니다.\n\n**렌더링 과정의 단계:**\n- 트리거 단계: 초기 렌더링이나 상태 변경으로 렌더링이 시작됩니다. setState, useState 훅 호출 등이 트리거가 됩니다.\n- 렌더 단계: 컴포넌트 함수를 호출하여 새로운 Virtual DOM 트리를 생성합니다. 순수한 계산 과정이며 부작용이 없어야 합니다.\n- 재조정 단계: 이전 Virtual DOM과 새 Virtual DOM을 비교합니다. Diffing 알고리즘으로 변경사항을 찾습니다.\n- 커밋 단계: 변경된 부분만 실제 DOM에 반영합니다. 한 번에 배치 업데이트로 적용됩니다.\n- 브라우저 렌더링: DOM 변경 후 브라우저가 레이아웃과 페인트를 수행합니다.\n\n**초기 렌더링:**\n- 루트 컴포넌트에서 시작합니다. ReactDOM.render 또는 createRoot를 호출합니다.\n- 전체 컴포넌트 트리를 순회하며 Virtual DOM을 생성합니다.\n- 실제 DOM 노드를 생성하여 화면에 삽입합니다.\n- useEffect 같은 부작용 훅이 실행됩니다.\n\n**리렌더링 조건:**\n- 상태가 변경되면 해당 컴포넌트와 자식들이 리렌더링됩니다.\n- 부모가 리렌더링되면 자식도 기본적으로 리렌더링됩니다.\n- Context 값이 변경되면 구독 중인 컴포넌트들이 리렌더링됩니다.\n- 최적화 기법으로 불필요한 리렌더링을 방지할 수 있습니다.\n\n**렌더와 커밋의 분리:**\n- 렌더 단계는 순수해야 합니다. 같은 입력에 같은 출력을 보장합니다.\n- 커밋 단계에서만 DOM을 조작합니다.\n- React 18의 Concurrent 기능으로 렌더 단계를 중단하고 재개할 수 있습니다.\n- 우선순위가 높은 업데이트를 먼저 처리할 수 있습니다.\n\n**실무 활용:**\n- 렌더링 성능을 모니터링합니다. React DevTools Profiler를 사용합니다.\n- 불필요한 렌더링을 최소화합니다. memo, useMemo, useCallback을 활용합니다.\n- 상태를 적절히 분리하여 리렌더링 범위를 제한합니다.\n- 큰 리스트는 가상화 기법을 사용합니다.\n- 렌더 단계에서 부작용을 일으키지 않도록 주의합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901802-qbbllmh4r",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React의 단방향 데이터 흐름(Unidirectional Data Flow)이란 무엇인가요?",
      "answer": "**정의:**\n단방향 데이터 흐름은 데이터가 부모 컴포넌트에서 자식 컴포넌트로만 흐르는 React의 핵심 원칙입니다. Props를 통해 위에서 아래로만 전달되며, 자식이 직접 부모의 데이터를 수정할 수 없습니다.\n\n**단방향 흐름의 원리:**\n- 부모가 props로 데이터를 전달합니다. 자식은 읽기만 가능합니다.\n- 자식이 데이터를 변경하려면 부모가 제공한 콜백을 호출합니다.\n- 상태는 소유한 컴포넌트에서만 변경됩니다.\n- 데이터의 출처가 명확합니다. 추적이 쉽고 버그를 찾기 용이합니다.\n\n**양방향 바인딩과의 차이:**\n- 양방향 바인딩은 뷰와 모델이 자동 동기화됩니다. Angular 1.x가 대표적입니다.\n- 데이터 흐름이 복잡해지고 예측하기 어렵습니다.\n- 디버깅이 어렵습니다. 어디서 변경이 일어났는지 추적이 힘듭니다.\n- React의 단방향은 명시적이고 예측 가능합니다.\n\n**단방향 흐름의 장점:**\n- 데이터 흐름이 명확합니다. 위에서 아래로만 흐르므로 이해하기 쉽습니다.\n- 디버깅이 용이합니다. 상태 변경 지점을 쉽게 찾을 수 있습니다.\n- 예측 가능성이 높습니다. 입력이 같으면 출력도 같습니다.\n- 유지보수가 쉽습니다. 코드의 동작을 파악하기 쉽습니다.\n- 테스트하기 좋습니다. 순수 함수처럼 동작합니다.\n\n**데이터 전달 패턴:**\n- Props로 하위로 전달: 가장 기본적인 방법입니다.\n- 콜백으로 상위로 알림: 자식이 이벤트를 부모에게 전달합니다.\n- State 끌어올리기: 공통 상태를 부모로 이동합니다.\n- Context로 깊은 전달: 중간 컴포넌트를 거치지 않고 전달합니다.\n\n**상태 관리와의 관계:**\n- 로컬 상태는 해당 컴포넌트에서만 관리합니다.\n- 공유 상태는 공통 조상으로 끌어올립니다.\n- 전역 상태는 Context나 Redux 같은 라이브러리를 사용합니다.\n- 단방향 원칙은 여전히 유지됩니다.\n\n**실무 활용:**\n- 상태를 최상위에 집중하지 말고 필요한 곳에 둡니다.\n- Props drilling이 심하면 Context나 상태 관리 라이브러리를 고려합니다.\n- 콜백 함수로 자식의 이벤트를 부모에게 전달합니다.\n- 데이터 흐름을 명확하게 설계하여 복잡도를 낮춥니다.\n- 컴포넌트 구조를 잘 설계하면 자연스럽게 단방향을 따르게 됩니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901802-7rv7juey3",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React Hooks가 등장한 이유는 무엇인가요?",
      "answer": "**정의:**\nReact Hooks는 함수형 컴포넌트에서 상태와 생명주기 기능을 사용할 수 있게 해주는 함수들입니다. React 16.8에서 도입되어 클래스 컴포넌트의 한계를 극복하고 코드 재사용성을 높였습니다.\n\n**클래스 컴포넌트의 문제점:**\n- this 바인딩이 복잡합니다. 이벤트 핸들러마다 bind를 해야 합니다. 초보자에게 혼란스럽습니다.\n- 생명주기 메서드에 로직이 분산됩니다. 관련 없는 코드가 섞이고 관련된 코드가 나뉩니다.\n- 컴포넌트 재사용이 어렵습니다. HOC나 Render Props는 래퍼 지옥을 만듭니다.\n- 코드 최소화와 최적화가 어렵습니다. 클래스는 압축이 잘 안 됩니다.\n- 코드량이 많습니다. 보일러플레이트가 많습니다.\n\n**Hooks의 등장 배경:**\n- 상태 관련 로직을 재사용하기 어려웠습니다. Custom Hook으로 해결합니다.\n- 복잡한 컴포넌트를 이해하기 어려웠습니다. 로직을 훅으로 분리합니다.\n- 클래스가 사람과 기계 모두에게 어려웠습니다.\n- 함수형 프로그래밍이 트렌드였습니다.\n\n**Hooks가 제공하는 이점:**\n- 함수형 컴포넌트에서 모든 기능을 사용할 수 있습니다.\n- 로직을 Custom Hook으로 분리하여 재사용합니다.\n- 관련된 코드를 한곳에 모을 수 있습니다. useEffect 여러 개를 사용합니다.\n- 컴포넌트 트리가 단순해집니다. HOC 래퍼가 필요 없습니다.\n- 테스트하기 쉽습니다. 순수 함수에 가깝습니다.\n- 번들 크기가 작아집니다. 클래스보다 압축이 잘 됩니다.\n\n**주요 Hooks:**\n- useState: 상태를 관리합니다.\n- useEffect: 부작용을 처리합니다.\n- useContext: Context를 구독합니다.\n- useReducer: 복잡한 상태 로직을 관리합니다.\n- useRef: 변경 가능한 값을 저장하거나 DOM에 접근합니다.\n- useMemo, useCallback: 성능을 최적화합니다.\n\n**Hooks의 철학:**\n- 클래스를 대체하는 것이 목표입니다. 점진적으로 도입할 수 있습니다.\n- 기존 개념을 제거하지 않습니다. 클래스도 여전히 작동합니다.\n- 100% 하위 호환됩니다. 기존 코드를 바꿀 필요가 없습니다.\n- 함수형 프로그래밍을 장려합니다.\n\n**실무 활용:**\n- 새 컴포넌트는 함수형과 Hooks로 작성합니다.\n- Custom Hook으로 로직을 재사용합니다. 여러 컴포넌트에서 공유합니다.\n- 클래스 컴포넌트를 점진적으로 마이그레이션합니다. 급할 필요는 없습니다.\n- Hooks 규칙을 준수합니다. ESLint 플러그인을 사용합니다.\n- React 생태계가 Hooks 중심으로 발전하고 있습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook"
      ],
      "id": "1763441901803-bibq5eshu",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useState의 동작 원리와 사용법은 무엇인가요?",
      "answer": "**정의:**\nuseState는 함수형 컴포넌트에서 상태를 관리할 수 있게 해주는 가장 기본적인 Hook입니다. 현재 상태 값과 이를 업데이트하는 함수를 배열로 반환합니다.\n\n**기본 사용법:**\n- 배열 구조 분해로 상태와 업데이트 함수를 받습니다.\n- 초기값을 인자로 전달합니다. 모든 타입이 가능합니다.\n- 업데이트 함수를 호출하면 컴포넌트가 리렌더링됩니다.\n- 여러 useState를 사용하여 여러 상태를 관리할 수 있습니다.\n\n**동작 원리:**\n- React는 컴포넌트별로 상태 배열을 관리합니다.\n- 호출 순서로 상태를 식별합니다. 조건문 안에서 사용하면 안 되는 이유입니다.\n- 클로저를 활용하여 상태를 보존합니다.\n- 상태 업데이트는 비동기적으로 배치됩니다.\n- 같은 값으로 업데이트하면 리렌더링을 건너뜁니다. Object.is로 비교합니다.\n\n**상태 업데이트 방식:**\n- 직접 값을 전달: 새로운 값을 직접 설정합니다.\n- 함수형 업데이트: 이전 상태를 기반으로 계산합니다. 현재 상태가 필요할 때 사용합니다.\n- 함수형 업데이트는 클로저 문제를 해결합니다.\n- 여러 업데이트가 배치되어 처리됩니다.\n\n**초기값 설정:**\n- 단순한 값을 직접 전달합니다.\n- 계산 비용이 크면 함수를 전달합니다. 지연 초기화입니다.\n- 함수는 초기 렌더링 시에만 실행됩니다.\n- localStorage에서 읽기 같은 작업에 유용합니다.\n\n**주의사항:**\n- 상태는 불변성을 유지해야 합니다. 객체나 배열을 직접 수정하면 안 됩니다.\n- 스프레드 연산자나 map, filter로 새 객체를 만듭니다.\n- 상태 업데이트는 즉시 반영되지 않습니다. 비동기적입니다.\n- 같은 렌더링 안에서 여러 번 호출해도 마지막 렌더링 때의 값을 참조합니다.\n\n**객체와 배열 상태:**\n- 중첩된 객체는 전체를 새로 만들어야 합니다.\n- Immer 같은 라이브러리로 간편하게 업데이트할 수 있습니다.\n- 배열은 push 대신 concat이나 스프레드를 사용합니다.\n- 삭제는 filter를 사용합니다.\n\n**실무 활용:**\n- 폼 입력값을 관리합니다. 각 필드마다 useState를 사용하거나 객체로 묶습니다.\n- 토글 상태를 관리합니다. 모달 열림 닫힘 등입니다.\n- 목록 데이터를 관리합니다. 추가 삭제 수정 기능을 구현합니다.\n- 복잡한 상태는 useReducer를 고려합니다.\n- TypeScript와 함께 사용하면 타입 안전성을 얻습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook",
        "state"
      ],
      "id": "1763441901803-jxmfpqi4c",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useEffect의 동작 원리와 의존성 배열의 역할은 무엇인가요?",
      "answer": "**정의:**\nuseEffect는 함수형 컴포넌트에서 부작용을 처리하는 Hook입니다. 데이터 가져오기, 구독 설정, DOM 수동 조작 등 렌더링 외부의 작업을 수행할 때 사용합니다.\n\n**동작 원리:**\n- 컴포넌트가 렌더링된 후에 실행됩니다. 화면 업데이트를 블로킹하지 않습니다.\n- 브라우저가 페인트를 완료한 후 비동기적으로 실행됩니다.\n- 매 렌더링마다 새로운 effect 함수가 생성됩니다.\n- 이전 effect의 클린업을 실행한 후 새 effect를 실행합니다.\n- 의존성 배열의 값이 변경되었는지 체크합니다.\n\n**의존성 배열의 역할:**\n- 언제 effect를 다시 실행할지 결정합니다.\n- 배열 내 값이 변경되면 effect가 재실행됩니다.\n- 빈 배열이면 마운트 시에만 실행됩니다.\n- 배열을 생략하면 매 렌더링마다 실행됩니다.\n- React는 Object.is로 이전 값과 비교합니다.\n\n**의존성 배열 사용 패턴:**\n- 특정 값 변경 시 실행: 의존성 배열에 해당 값들을 넣습니다.\n- 마운트/언마운트 시에만: 빈 배열을 사용합니다.\n- 매 렌더링마다: 의존성 배열을 생략합니다. 거의 사용하지 않습니다.\n- 모든 의존성을 포함해야 합니다. ESLint 규칙이 도와줍니다.\n\n**effect 실행 타이밍:**\n- 초기 렌더링 후 첫 effect가 실행됩니다.\n- 의존성이 변경된 렌더링 후 effect가 실행됩니다.\n- useLayoutEffect는 페인트 전에 동기적으로 실행됩니다.\n- effect는 렌더링을 블로킹하지 않아 성능이 좋습니다.\n\n**의존성 누락 문제:**\n- effect 내에서 사용하는 모든 값을 의존성에 포함해야 합니다.\n- 누락하면 오래된 값을 참조하는 버그가 발생합니다.\n- ESLint exhaustive-deps 규칙을 사용합니다.\n- 함수는 useCallback으로 메모이제이션합니다.\n- 객체는 useMemo로 메모이제이션합니다.\n\n**무한 루프 방지:**\n- 의존성에 객체나 배열을 직접 넣으면 위험합니다.\n- 매 렌더링마다 새 참조가 생성되어 무한 루프가 됩니다.\n- 원시값만 의존성에 넣거나 메모이제이션을 사용합니다.\n- effect 내에서 상태를 업데이트할 때 주의합니다.\n\n**실무 활용:**\n- API 호출과 데이터 페칭에 사용합니다.\n- 이벤트 리스너를 등록하고 클린업에서 제거합니다.\n- 타이머를 설정하고 클린업에서 정리합니다.\n- 외부 라이브러리를 초기화합니다.\n- 브라우저 API와 상호작용합니다. localStorage, WebSocket 등입니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "array",
        "Hook"
      ],
      "id": "1763441901803-xrx76gboe",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useEffect의 클린업 함수는 언제 사용하나요?",
      "answer": "**정의:**\n클린업 함수는 useEffect에서 반환하는 함수로, effect가 다시 실행되기 전이나 컴포넌트가 언마운트될 때 실행됩니다. 리소스 정리와 메모리 누수 방지에 사용됩니다.\n\n**클린업 함수의 실행 시점:**\n- 컴포넌트가 언마운트될 때 실행됩니다.\n- 다음 effect가 실행되기 전에 이전 effect를 정리합니다.\n- 의존성이 변경되어 effect가 재실행될 때마다 이전 것을 정리합니다.\n- 렌더링마다 새로운 클린업 함수가 생성됩니다.\n\n**클린업이 필요한 경우:**\n- 이벤트 리스너 등록: 메모리 누수를 방지하려면 제거해야 합니다.\n- 타이머 설정: setInterval, setTimeout을 정리해야 합니다.\n- 구독 설정: WebSocket, 외부 스토어 구독을 해제해야 합니다.\n- 네트워크 요청 취소: 컴포넌트가 사라진 후 응답이 와도 안전합니다.\n- 외부 라이브러리 정리: 인스턴스를 파괴하거나 연결을 끊습니다.\n\n**이벤트 리스너 정리:**\n- addEventListener로 등록한 리스너를 removeEventListener로 제거합니다.\n- 같은 함수 참조를 사용해야 제거가 됩니다.\n- 윈도우나 document 이벤트는 반드시 정리해야 합니다.\n- 정리하지 않으면 컴포넌트가 사라져도 리스너는 남아 있습니다.\n\n**타이머 정리:**\n- setInterval은 clearInterval로 정리합니다.\n- setTimeout은 clearTimeout으로 정리합니다.\n- 타이머가 계속 실행되면 메모리 누수와 예상치 못한 동작이 발생합니다.\n- 타이머 ID를 저장했다가 클린업에서 사용합니다.\n\n**구독과 연결 정리:**\n- WebSocket 연결을 닫습니다.\n- 외부 상태 관리 라이브러리의 구독을 해제합니다.\n- 데이터베이스나 실시간 리스너를 정리합니다.\n- RxJS 같은 스트림의 구독을 해제합니다.\n\n**비동기 작업 정리:**\n- fetch 요청을 AbortController로 취소합니다.\n- 컴포넌트가 언마운트된 후 setState를 방지합니다.\n- 플래그 변수로 마운트 상태를 추적할 수 있습니다.\n- 최신 React에서는 자동 배치로 일부 문제가 완화됩니다.\n\n**클린업 함수 작성 패턴:**\n- effect 함수 안에서 클린업 함수를 반환합니다.\n- 설정한 것과 정확히 대응되게 정리합니다.\n- 클린업은 effect의 역순으로 생각하면 됩니다.\n- 멱등성을 보장하여 여러 번 호출되어도 안전하게 합니다.\n\n**실무 활용:**\n- 스크롤 이벤트 리스너를 등록하고 정리합니다.\n- 실시간 채팅 구독을 설정하고 해제합니다.\n- 인터벌 타이머로 주기적 업데이트를 하고 정리합니다.\n- API 호출을 취소하여 메모리 누수를 방지합니다.\n- 외부 차트 라이브러리 인스턴스를 생성하고 파괴합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "function",
        "Hook"
      ],
      "id": "1763441901803-cn3zjeitq",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useRef는 언제 사용하고 useState와 어떻게 다른가요?",
      "answer": "**정의:**\nuseRef는 렌더링과 무관하게 값을 저장하거나 DOM 요소에 접근할 수 있는 Hook입니다. 변경 가능한 객체를 반환하며, 값이 바뀌어도 리렌더링을 유발하지 않습니다.\n\n**useRef의 특징:**\n- 변경해도 리렌더링되지 않습니다. 렌더링 사이에 값을 유지합니다.\n- current 프로퍼티로 값에 접근합니다.\n- 컴포넌트 생애 주기 동안 같은 객체를 유지합니다.\n- 동기적으로 즉시 업데이트됩니다.\n- 모든 렌더링에서 같은 ref 객체를 받습니다.\n\n**useState와의 차이점:**\n- useState는 변경 시 리렌더링을 유발합니다. useRef는 유발하지 않습니다.\n- useState는 비동기 업데이트입니다. useRef는 동기 업데이트입니다.\n- useState는 불변성을 지켜야 합니다. useRef는 직접 변경 가능합니다.\n- useState는 화면에 보이는 데이터용입니다. useRef는 렌더링에 영향 없는 데이터용입니다.\n\n**useRef 사용 경우:**\n- DOM 요소에 접근할 때: focus 설정, 스크롤 제어, 크기 측정 등입니다.\n- 이전 값을 저장할 때: 이전 state나 props를 기억합니다.\n- 타이머 ID 저장: setInterval, setTimeout의 반환값을 보관합니다.\n- 인스턴스 변수 대체: 클래스의 인스턴스 변수처럼 사용합니다.\n- 렌더링과 무관한 값 저장: 변경해도 UI에 영향이 없는 값입니다.\n\n**DOM 접근 패턴:**\n- ref 속성에 ref 객체를 전달합니다.\n- 렌더링 후 ref.current에 DOM 노드가 할당됩니다.\n- useEffect에서 ref.current를 사용합니다.\n- input에 포커스를 주거나 스크롤 위치를 제어합니다.\n- 애니메이션 라이브러리와 통합할 때 유용합니다.\n\n**이전 값 추적:**\n- useEffect와 조합하여 이전 값을 저장합니다.\n- 현재 값과 이전 값을 비교할 수 있습니다.\n- 값의 변화를 감지하는 커스텀 훅을 만들 수 있습니다.\n- 디버깅이나 조건부 로직에 활용합니다.\n\n**주의사항:**\n- 렌더링 중에 ref.current를 읽거나 쓰면 안 됩니다. 순수성을 해칩니다.\n- 이벤트 핸들러나 useEffect에서 사용합니다.\n- ref 변경으로 리렌더링을 유발하고 싶다면 useState를 사용해야 합니다.\n- DOM 조작은 최소화합니다. React의 선언적 방식을 우선합니다.\n\n**실무 활용:**\n- 폼 제출 시 첫 번째 에러 필드로 포커스를 이동합니다.\n- 스크롤 위치를 저장하고 복원합니다.\n- 비디오나 오디오 재생을 제어합니다.\n- 차트 라이브러리의 인스턴스를 저장합니다.\n- 디바운스나 쓰로틀 타이머를 관리합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook",
        "state"
      ],
      "id": "1763441901803-lil8ocfz3",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useMemo와 useCallback의 차이점은 무엇인가요?",
      "answer": "**정의:**\nuseMemo와 useCallback은 성능 최적화를 위한 메모이제이션 Hook입니다. useMemo는 계산된 값을 메모이제이션하고, useCallback은 함수 자체를 메모이제이션합니다.\n\n**useMemo의 특징:**\n- 계산 비용이 큰 연산 결과를 캐싱합니다.\n- 의존성이 변경될 때만 재계산합니다.\n- 첫 번째 인자는 값을 반환하는 함수입니다.\n- 두 번째 인자는 의존성 배열입니다.\n- 렌더링 중에 실행됩니다.\n\n**useCallback의 특징:**\n- 함수 인스턴스를 메모이제이션합니다.\n- 의존성이 변경될 때만 새 함수를 생성합니다.\n- 자식 컴포넌트에 콜백을 전달할 때 유용합니다.\n- 함수 자체를 반환합니다.\n- useCallback은 useMemo의 특수 케이스입니다.\n\n**useMemo 사용 경우:**\n- 복잡한 계산이나 필터링 결과를 캐싱합니다.\n- 큰 배열이나 객체를 변환할 때 사용합니다.\n- 렌더링마다 같은 계산을 반복하는 것을 방지합니다.\n- 참조 동등성이 중요한 객체나 배열을 생성할 때 사용합니다.\n\n**useCallback 사용 경우:**\n- 자식 컴포넌트에 props로 전달하는 함수를 메모이제이션합니다.\n- 자식이 React.memo로 최적화되어 있을 때 효과적입니다.\n- useEffect의 의존성으로 사용되는 함수를 메모이제이션합니다.\n- 이벤트 핸들러를 메모이제이션하여 불필요한 리렌더링을 방지합니다.\n\n**차이점 비교:**\n- useMemo는 값을 반환합니다. useCallback은 함수를 반환합니다.\n- useMemo는 함수를 실행한 결과를 캐싱합니다. useCallback은 함수 자체를 캐싱합니다.\n- useCallback은 함수용 useMemo의 문법적 설탕입니다.\n- 용도가 다르지만 내부 구현은 유사합니다.\n\n**참조 동등성 문제:**\n- 객체와 배열은 렌더링마다 새로 생성되어 참조가 달라집니다.\n- React.memo나 의존성 배열은 참조로 비교합니다.\n- useMemo로 같은 참조를 유지하면 불필요한 연산을 방지합니다.\n- 함수도 매번 새로 생성되므로 useCallback이 필요합니다.\n\n**최적화 시기:**\n- 성능 문제가 실제로 있을 때만 사용합니다.\n- 프로파일링으로 병목을 확인합니다.\n- 모든 곳에 사용하면 오히려 성능이 나빠질 수 있습니다.\n- 메모이제이션 자체도 비용이 듭니다.\n- 단순한 연산은 메모이제이션하지 않는 것이 더 빠릅니다.\n\n**실무 활용:**\n- 큰 테이블 데이터를 필터링하거나 정렬할 때 useMemo를 사용합니다.\n- 복잡한 차트 데이터 변환 결과를 캐싱합니다.\n- 자식 컴포넌트의 불필요한 리렌더링을 useCallback으로 방지합니다.\n- Context value를 useMemo로 메모이제이션하여 성능을 개선합니다.\n- 항상 측정 후 최적화합니다. 추측하지 않습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook"
      ],
      "id": "1763441901803-na4oueafs",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useReducer는 언제 useState 대신 사용하나요?",
      "answer": "**정의:**\nuseReducer는 복잡한 상태 로직을 관리하는 Hook으로, Redux와 유사한 패턴을 사용합니다. reducer 함수와 초기 상태를 받아 현재 상태와 dispatch 함수를 반환합니다.\n\n**useReducer의 구조:**\n- reducer 함수는 현재 상태와 액션을 받아 새 상태를 반환합니다.\n- 초기 상태를 두 번째 인자로 전달합니다.\n- dispatch 함수로 액션을 전달하여 상태를 업데이트합니다.\n- 모든 상태 변경 로직이 reducer에 집중됩니다.\n- 순수 함수여야 합니다.\n\n**useState 대신 useReducer를 사용하는 경우:**\n- 상태 업데이트 로직이 복잡할 때: 여러 하위 값이 연관되어 있습니다.\n- 다음 상태가 이전 상태에 의존할 때: 여러 단계의 계산이 필요합니다.\n- 상태 전환이 많을 때: 여러 가지 액션 타입이 있습니다.\n- 비즈니스 로직을 분리하고 싶을 때: 테스트하기 쉬워집니다.\n- 상태 업데이트를 추적하고 디버깅하기 쉽게 하고 싶을 때입니다.\n\n**useState vs useReducer 비교:**\n- useState는 간단한 상태에 적합합니다. useReducer는 복잡한 상태에 적합합니다.\n- useState는 직접 값을 설정합니다. useReducer는 액션을 디스패치합니다.\n- useState는 보일러플레이트가 적습니다. useReducer는 초기 설정이 더 많습니다.\n- useState는 상태가 독립적일 때 좋습니다. useReducer는 상태가 연관될 때 좋습니다.\n\n**reducer 함수 작성 패턴:**\n- switch 문으로 액션 타입을 분기합니다.\n- 각 케이스에서 새 상태 객체를 반환합니다.\n- 불변성을 유지합니다. 스프레드 연산자를 사용합니다.\n- default 케이스에서 현재 상태를 반환하거나 에러를 던집니다.\n- 순수 함수로 작성합니다. 부작용이 없어야 합니다.\n\n**액션 설계:**\n- type 필드로 액션을 식별합니다.\n- payload 필드로 추가 데이터를 전달합니다.\n- 명확하고 의미 있는 액션명을 사용합니다.\n- 액션 생성자 함수로 일관성을 유지할 수 있습니다.\n- TypeScript로 타입 안전성을 보장합니다.\n\n**초기화 지연:**\n- 세 번째 인자로 초기화 함수를 전달할 수 있습니다.\n- 초기 상태 계산이 비쌀 때 유용합니다.\n- localStorage에서 읽는 등의 작업에 활용합니다.\n- 초기 렌더링 시에만 실행됩니다.\n\n**실무 활용:**\n- 폼 상태 관리: 여러 입력 필드와 검증 로직이 있을 때 사용합니다.\n- 쇼핑 카트: 추가 삭제 수량 변경 등 다양한 액션이 있습니다.\n- 다단계 위저드: 단계별 데이터와 진행 상태를 관리합니다.\n- 게임 상태: 복잡한 규칙과 상태 전환이 있습니다.\n- Redux 대신 로컬 상태 관리에 활용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "array",
        "Hook",
        "state"
      ],
      "id": "1763441901803-8szi156hd",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useContext는 어떻게 사용하나요?",
      "answer": "**정의:**\nuseContext는 Context API를 함수형 컴포넌트에서 사용하기 위한 Hook입니다. Context 객체를 인자로 받아 현재 context 값을 반환하며, Provider로 감싼 가장 가까운 값을 읽습니다.\n\n**Context API 기본 개념:**\n- Context는 전역적으로 데이터를 공유하는 방법입니다.\n- Props drilling 없이 깊은 컴포넌트에 데이터를 전달합니다.\n- React.createContext로 Context 객체를 생성합니다.\n- Provider로 값을 제공하고 Consumer나 useContext로 소비합니다.\n\n**useContext 사용 방법:**\n- createContext로 Context를 생성합니다.\n- Provider로 컴포넌트 트리를 감싸고 value를 전달합니다.\n- 하위 컴포넌트에서 useContext로 값을 읽습니다.\n- Provider 없이 사용하면 기본값이 반환됩니다.\n- 중첩된 Provider는 가장 가까운 것이 우선됩니다.\n\n**Context 생성과 제공:**\n- 별도 파일에서 Context를 생성하고 export 합니다.\n- Provider 컴포넌트를 만들어 로직을 캡슐화합니다.\n- value에 객체를 전달할 때는 메모이제이션을 고려합니다.\n- 여러 Context를 조합하여 사용할 수 있습니다.\n\n**Context 소비 패턴:**\n- useContext Hook으로 간단하게 값을 읽습니다.\n- Context.Consumer보다 간결하고 읽기 쉽습니다.\n- 여러 Context를 사용할 때도 깔끔합니다.\n- 조건부로 Context를 사용할 수 없습니다. Hooks 규칙을 따라야 합니다.\n\n**적절한 사용 사례:**\n- 테마 설정: 다크 모드 라이트 모드 등을 전역적으로 관리합니다.\n- 사용자 인증 정보: 로그인 상태와 유저 데이터를 공유합니다.\n- 언어 설정: 다국어 지원을 위한 로케일 정보입니다.\n- UI 상태: 모달 토스트 같은 전역 UI 상태입니다.\n- 앱 설정: 전역 설정값을 관리합니다.\n\n**Context의 한계:**\n- 모든 상태 관리를 Context로 하면 안 됩니다.\n- 성능 문제가 있을 수 있습니다. 값이 바뀌면 모든 소비자가 리렌더링됩니다.\n- 컴포넌트 재사용성이 떨어질 수 있습니다.\n- 복잡한 상태는 Redux 같은 라이브러리가 더 적합합니다.\n\n**성능 최적화:**\n- Provider value를 메모이제이션합니다. useMemo를 사용합니다.\n- Context를 여러 개로 분리합니다. 자주 변경되는 것과 그렇지 않은 것을 나눕니다.\n- 필요한 컴포넌트만 구독하도록 합니다.\n- React.memo로 불필요한 리렌더링을 방지합니다.\n\n**실무 활용:**\n- 전역 상태를 간단하게 관리합니다. 작은 앱에 적합합니다.\n- Provider 패턴으로 의존성을 주입합니다.\n- 커스텀 Hook과 조합하여 사용합니다.\n- 테스트 시 Context Provider로 모의 데이터를 제공합니다.\n- 라이브러리에서 설정을 전달하는 용도로 많이 사용됩니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-e647dzd6h",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Custom Hook을 만드는 이유와 방법은 무엇인가요?",
      "answer": "**정의:**\nCustom Hook은 상태 관련 로직을 재사용 가능한 함수로 추출한 것입니다. use로 시작하는 이름을 가지며, 내부에서 다른 Hook을 사용할 수 있습니다.\n\n**Custom Hook을 만드는 이유:**\n- 중복된 로직을 제거합니다. 여러 컴포넌트에서 같은 로직을 공유합니다.\n- 컴포넌트를 단순하게 유지합니다. 복잡한 로직을 분리합니다.\n- 테스트하기 쉽습니다. 로직을 독립적으로 테스트할 수 있습니다.\n- 코드 가독성이 향상됩니다. 의도가 명확해집니다.\n- 관심사를 분리합니다. UI와 로직을 나눕니다.\n\n**Custom Hook 작성 규칙:**\n- 이름은 use로 시작해야 합니다. 컨벤션이자 ESLint 규칙입니다.\n- 일반 JavaScript 함수입니다. 특별한 문법이 없습니다.\n- 내부에서 다른 Hook을 호출할 수 있습니다.\n- Hook 규칙을 따라야 합니다. 조건문이나 반복문 안에서 호출하면 안 됩니다.\n- 상태나 함수를 반환합니다. 필요한 값과 핸들러를 돌려줍니다.\n\n**Custom Hook 작성 패턴:**\n- 관련된 상태와 로직을 하나로 묶습니다.\n- 매개변수로 옵션을 받을 수 있습니다.\n- 필요한 값만 반환합니다. 객체나 배열로 묶어서 반환합니다.\n- 명확한 이름을 사용합니다. 무엇을 하는지 알기 쉽게 합니다.\n- 문서화를 잘 합니다. JSDoc 주석을 추가합니다.\n\n**일반적인 Custom Hook 예시:**\n- useLocalStorage: localStorage와 동기화되는 상태입니다.\n- useFetch: API 호출과 로딩 에러 상태를 관리합니다.\n- useDebounce: 입력값을 디바운스합니다.\n- useWindowSize: 윈도우 크기를 추적합니다.\n- useForm: 폼 상태와 검증을 관리합니다.\n\n**Hook 조합:**\n- Custom Hook 안에서 다른 Custom Hook을 사용할 수 있습니다.\n- 작은 Hook들을 조합하여 더 복잡한 Hook을 만듭니다.\n- 관심사별로 분리하여 재사용성을 높입니다.\n- 과도하게 추상화하지 않도록 주의합니다.\n\n**일반 함수와의 차이:**\n- Custom Hook은 Hook을 호출할 수 있습니다. 일반 함수는 불가능합니다.\n- Custom Hook은 컴포넌트처럼 독립적인 상태를 가집니다.\n- 같은 Hook을 여러 곳에서 사용해도 상태는 독립적입니다.\n- Hook 규칙의 제약을 받습니다.\n\n**실무 활용:**\n- API 호출 로직을 Custom Hook으로 추출합니다.\n- 폼 관리 로직을 재사용 가능하게 만듭니다.\n- 애니메이션이나 인터랙션 로직을 분리합니다.\n- 브라우저 API 접근을 추상화합니다.\n- 라이브러리처럼 배포하여 여러 프로젝트에서 사용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook"
      ],
      "id": "1763441901803-wcvqgeqi2",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Hooks 사용 시 지켜야 할 규칙은 무엇인가요?",
      "answer": "**정의:**\nHooks 규칙은 React Hook을 올바르게 사용하기 위한 두 가지 필수 규칙입니다. 이 규칙을 따라야 Hook이 예측 가능하게 동작하고 버그를 방지할 수 있습니다.\n\n**규칙 1: 최상위에서만 Hook을 호출:**\n- 반복문 조건문 중첩 함수 안에서 Hook을 호출하면 안 됩니다.\n- 항상 React 함수의 최상위에서 호출해야 합니다.\n- 컴포넌트가 렌더링될 때마다 같은 순서로 Hook이 호출되어야 합니다.\n- 조건부로 Hook을 사용하고 싶다면 조건문을 Hook 안에 넣습니다.\n\n**규칙 2: React 함수에서만 Hook을 호출:**\n- 일반 JavaScript 함수에서 Hook을 호출하면 안 됩니다.\n- React 함수형 컴포넌트에서 호출합니다.\n- Custom Hook에서 호출합니다.\n- 클래스 컴포넌트에서는 사용할 수 없습니다.\n\n**규칙이 필요한 이유:**\n- React는 Hook 호출 순서로 상태를 관리합니다.\n- 내부적으로 배열로 Hook 상태를 저장합니다.\n- 순서가 바뀌면 상태가 뒤섞입니다.\n- 조건부 Hook은 순서를 불안정하게 만듭니다.\n- 클로저와 순서에 의존하는 구현 방식 때문입니다.\n\n**조건부 실행 처리:**\n- Hook은 항상 호출하되 내부 로직을 조건부로 만듭니다.\n- useEffect의 조건문을 effect 함수 안에 넣습니다.\n- 플래그 변수로 상태를 관리합니다.\n- 조기 리턴은 Hook 호출 후에 사용합니다.\n\n**ESLint 플러그인:**\n- eslint-plugin-react-hooks가 규칙 위반을 감지합니다.\n- exhaustive-deps 규칙은 의존성 배열을 검증합니다.\n- rules-of-hooks 규칙은 Hook 호출 위치를 검증합니다.\n- Create React App에 기본 포함되어 있습니다.\n- 에디터에서 실시간으로 경고를 표시합니다.\n\n**일반적인 실수:**\n- 조건문 안에서 Hook을 호출합니다.\n- 반복문 안에서 Hook을 호출합니다.\n- 이벤트 핸들러에서 직접 Hook을 호출합니다.\n- useEffect 의존성 배열을 잘못 작성합니다.\n- 일반 함수에서 Hook을 사용하려고 합니다.\n\n**의존성 배열 규칙:**\n- effect나 메모이제이션 Hook의 의존성을 모두 포함해야 합니다.\n- 함수나 객체는 메모이제이션하거나 의존성에서 제외합니다.\n- 의도적으로 제외하는 경우 주석으로 설명합니다.\n- ESLint가 누락된 의존성을 알려줍니다.\n\n**실무 활용:**\n- ESLint 플러그인을 반드시 설치합니다.\n- 경고를 무시하지 않습니다. 근본 원인을 해결합니다.\n- 조건부 로직은 Hook 내부로 이동합니다.\n- 팀 전체가 규칙을 이해하고 따릅니다.\n- 코드 리뷰에서 Hook 규칙 위반을 체크합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook"
      ],
      "id": "1763441901803-j8prtxbzv",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Props와 State의 차이점은 무엇인가요?",
      "answer": "**정의:**\nProps와 State는 React 컴포넌트에서 데이터를 다루는 두 가지 방법입니다. Props는 부모로부터 받는 읽기 전용 데이터이고, State는 컴포넌트 내부에서 관리하는 변경 가능한 데이터입니다.\n\n**Props의 특징:**\n- 부모 컴포넌트가 자식에게 전달하는 데이터입니다.\n- 읽기 전용입니다. 자식이 직접 수정할 수 없습니다.\n- 함수 매개변수처럼 전달됩니다.\n- 컴포넌트 외부에서 제어됩니다.\n- 같은 props면 같은 결과를 렌더링합니다.\n\n**State의 특징:**\n- 컴포넌트 내부에서 관리하는 데이터입니다.\n- 변경 가능합니다. setState나 useState로 업데이트합니다.\n- 변경되면 컴포넌트가 리렌더링됩니다.\n- 컴포넌트가 소유하고 제어합니다.\n- 사용자 인터랙션이나 시간에 따라 변합니다.\n\n**주요 차이점:**\n- Props는 불변입니다. State는 가변입니다.\n- Props는 부모가 설정합니다. State는 컴포넌트가 설정합니다.\n- Props는 자식이 받기만 합니다. State는 컴포넌트가 직접 관리합니다.\n- Props 변경은 부모가 합니다. State 변경은 자신이 합니다.\n- Props는 설정값입니다. State는 상태입니다.\n\n**Props 사용 패턴:**\n- 컴포넌트를 커스터마이징합니다. 재사용 가능하게 만듭니다.\n- 데이터를 하위로 전달합니다. 단방향 흐름을 따릅니다.\n- 콜백 함수를 전달합니다. 자식이 부모에게 이벤트를 알립니다.\n- children prop으로 컴포넌트를 조합합니다.\n- 기본값을 설정할 수 있습니다.\n\n**State 사용 패턴:**\n- 사용자 입력을 저장합니다. 폼 데이터 관리에 활용합니다.\n- UI 상태를 관리합니다. 모달 열림 닫힘 등입니다.\n- 서버에서 받은 데이터를 저장합니다.\n- 컴포넌트의 현재 상태를 추적합니다.\n- 타이머나 애니메이션 상태를 관리합니다.\n\n**Props를 State로 초기화:**\n- Props를 State의 초기값으로 사용할 수 있습니다.\n- 이후 State는 독립적으로 관리됩니다.\n- Props가 변경되어도 State는 자동으로 업데이트되지 않습니다.\n- 의도가 명확하지 않으면 혼란을 줄 수 있습니다.\n- useEffect로 Props 변경을 감지하여 State를 업데이트할 수 있습니다.\n\n**언제 무엇을 사용할까:**\n- 부모로부터 받은 데이터는 Props로 사용합니다.\n- 시간에 따라 변하는 데이터는 State로 관리합니다.\n- 렌더링에 영향을 주는 데이터는 State입니다.\n- 단순히 전달만 하는 데이터는 Props입니다.\n- 컴포넌트가 제어해야 하는 데이터는 State입니다.\n\n**실무 활용:**\n- Presentational 컴포넌트는 주로 Props를 사용합니다.\n- Container 컴포넌트는 State를 관리하고 Props로 전달합니다.\n- 최소한의 State를 유지합니다. 계산 가능한 값은 State로 두지 않습니다.\n- Props와 State를 적절히 조합하여 컴포넌트를 설계합니다.\n- TypeScript로 Props와 State의 타입을 명확히 정의합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "props",
        "state"
      ],
      "id": "1763441901803-zobwe3j4y",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "State 끌어올리기(Lifting State Up)란 무엇이고 왜 필요한가요?",
      "answer": "**정의:**\nState 끌어올리기는 여러 컴포넌트가 같은 데이터를 공유해야 할 때, 그 데이터를 공통 조상 컴포넌트로 이동시키는 패턴입니다. 단일 진실 공급원 원칙을 따르는 React의 권장 방법입니다.\n\n**필요한 상황:**\n- 두 개 이상의 컴포넌트가 같은 데이터를 표시해야 할 때입니다.\n- 한 컴포넌트의 변경이 다른 컴포넌트에 영향을 줘야 할 때입니다.\n- 형제 컴포넌트 간 데이터를 공유해야 할 때입니다.\n- 데이터의 동기화가 필요할 때입니다.\n- 단일 진실 공급원을 만들고 싶을 때입니다.\n\n**끌어올리기 과정:**\n- 공유할 State를 찾습니다. 여러 곳에서 사용하는 데이터입니다.\n- 공통 조상 컴포넌트를 찾습니다. 모든 자식을 포함하는 부모입니다.\n- State를 공통 조상으로 이동합니다.\n- Props로 자식들에게 전달합니다.\n- 업데이트 함수도 Props로 전달합니다.\n\n**단일 진실 공급원:**\n- 모든 데이터는 하나의 출처만 가져야 합니다.\n- 같은 데이터를 여러 곳에 중복 저장하면 동기화 문제가 생깁니다.\n- State를 끌어올려서 하나의 곳에서만 관리합니다.\n- Props로 전달하여 읽기만 하게 합니다.\n- 데이터 일관성이 보장됩니다.\n\n**장점:**\n- 데이터가 동기화됩니다. 한 곳에서만 관리하므로 일관성이 유지됩니다.\n- 버그가 줄어듭니다. 진실 공급원이 명확합니다.\n- 디버깅이 쉬워집니다. 데이터 흐름을 추적하기 쉽습니다.\n- 예측 가능성이 높아집니다. 단방향 데이터 흐름을 따릅니다.\n\n**단점과 한계:**\n- Props drilling이 발생할 수 있습니다. 깊이 중첩된 구조에서 문제가 됩니다.\n- 보일러플레이트가 증가합니다. Props 전달 코드가 많아집니다.\n- 성능에 영향을 줄 수 있습니다. 부모 리렌더링 시 모든 자식이 리렌더링됩니다.\n- 너무 높이 끌어올리면 관리가 어려워집니다.\n\n**Props Drilling 해결:**\n- Context API를 사용합니다. 중간 컴포넌트를 거치지 않고 전달합니다.\n- 상태 관리 라이브러리를 사용합니다. Redux, Zustand 등입니다.\n- Composition 패턴을 활용합니다. children props를 사용합니다.\n- 컴포넌트 구조를 재설계합니다.\n\n**적절한 수준 찾기:**\n- 필요한 만큼만 끌어올립니다. 최소 공통 조상으로만 올립니다.\n- 전역 상태로 만들 필요는 없습니다.\n- 로컬에서 해결 가능하면 로컬에 둡니다.\n- 과도한 끌어올리기는 복잡도를 높입니다.\n\n**실무 활용:**\n- 폼에서 여러 입력 필드의 유효성을 검사할 때 사용합니다.\n- 탭 컴포넌트에서 활성 탭 상태를 관리합니다.\n- 필터와 목록 컴포넌트 간 데이터를 공유합니다.\n- 장바구니와 상품 목록을 동기화합니다.\n- 먼저 로컬 State로 시작하고 필요할 때 끌어올립니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "state"
      ],
      "id": "1763441901803-y4tsmsw9y",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "전역 상태 관리는 왜 필요하고 어떤 방법들이 있나요?",
      "answer": "**정의:**\n전역 상태 관리는 애플리케이션 전체에서 공유되는 데이터를 효율적으로 관리하는 방법입니다. 깊은 컴포넌트 트리에서 Props drilling 없이 데이터를 공유할 수 있게 해줍니다.\n\n**전역 상태 관리가 필요한 이유:**\n- Props drilling을 해결합니다. 중간 컴포넌트를 거치지 않아도 됩니다.\n- 여러 곳에서 같은 데이터를 사용합니다. 사용자 정보, 테마 등입니다.\n- 컴포넌트 간 통신이 필요합니다. 형제나 먼 컴포넌트 간에도 가능합니다.\n- 상태 로직을 중앙화합니다. 일관된 방식으로 관리합니다.\n- 디버깅과 테스팅이 쉬워집니다. 상태 변화를 추적할 수 있습니다.\n\n**Context API:**\n- React 내장 기능입니다. 별도 라이브러리가 필요 없습니다.\n- 간단한 전역 상태에 적합합니다.\n- Provider와 Consumer 패턴을 사용합니다.\n- useContext Hook으로 쉽게 접근합니다.\n- 작은 규모 앱이나 테마 언어 설정에 좋습니다.\n\n**Redux:**\n- 가장 널리 사용되는 상태 관리 라이브러리입니다.\n- 단일 스토어에 모든 상태를 저장합니다.\n- Action과 Reducer 패턴을 사용합니다.\n- 미들웨어로 확장 가능합니다. 비동기 처리에 유용합니다.\n- DevTools로 강력한 디버깅을 지원합니다.\n- 보일러플레이트가 많지만 예측 가능합니다.\n\n**Redux Toolkit:**\n- Redux의 공식 권장 방법입니다.\n- 보일러플레이트를 크게 줄입니다.\n- Immer가 내장되어 불변성 관리가 쉽습니다.\n- createSlice로 간편하게 리듀서를 만듭니다.\n- RTK Query로 데이터 페칭도 처리합니다.\n\n**Zustand:**\n- 매우 간단하고 가벼운 라이브러리입니다.\n- Hooks 기반 API를 제공합니다.\n- 보일러플레이트가 거의 없습니다.\n- Provider가 필요 없습니다.\n- 중소 규모 프로젝트에 적합합니다.\n\n**Recoil:**\n- Facebook이 만든 상태 관리 라이브러리입니다.\n- Atom과 Selector 개념을 사용합니다.\n- React처럼 사용할 수 있습니다.\n- 파생 상태를 쉽게 만듭니다.\n- 아직 실험적이지만 강력합니다.\n\n**Jotai:**\n- Recoil과 유사한 원자 기반 접근입니다.\n- 매우 작고 TypeScript 친화적입니다.\n- 간단한 API를 제공합니다.\n- 필요한 만큼만 사용할 수 있습니다.\n\n**선택 기준:**\n- 앱 규모: 작으면 Context나 Zustand, 크면 Redux입니다.\n- 복잡도: 간단하면 Context, 복잡하면 Redux Toolkit입니다.\n- 팀 경험: 팀이 익숙한 도구를 선택합니다.\n- 요구사항: 디버깅이 중요하면 Redux, 간결함이 중요하면 Zustand입니다.\n- 생태계: Redux는 미들웨어와 도구가 풍부합니다.\n\n**실무 활용:**\n- 사용자 인증 상태를 전역으로 관리합니다.\n- 쇼핑몰의 장바구니 데이터를 공유합니다.\n- 알림이나 토스트 메시지를 전역에서 제어합니다.\n- 다크 모드나 언어 설정을 관리합니다.\n- 필요한 곳에만 상태 관리 라이브러리를 도입합니다. 과도한 사용을 피합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "state"
      ],
      "id": "1763441901803-co9nw2f31",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Props Drilling 문제와 해결 방법은 무엇인가요?",
      "answer": "**정의:**\nProps Drilling은 상위 컴포넌트의 데이터를 깊이 중첩된 하위 컴포넌트로 전달하기 위해 중간의 모든 컴포넌트를 거쳐야 하는 문제입니다. 코드가 복잡해지고 유지보수가 어려워집니다.\n\n**Props Drilling의 문제점:**\n- 중간 컴포넌트가 불필요한 Props를 받습니다. 실제로 사용하지 않는 데이터입니다.\n- 코드가 장황해집니다. Props 전달 코드가 많아집니다.\n- 리팩토링이 어렵습니다. 구조를 바꾸면 여러 곳을 수정해야 합니다.\n- 가독성이 떨어집니다. 데이터 흐름을 파악하기 힘듭니다.\n- 실수하기 쉽습니다. Props 이름을 잘못 쓰거나 누락할 수 있습니다.\n\n**해결 방법 1: Context API:**\n- React 내장 기능으로 해결합니다.\n- Provider로 상위에서 값을 제공합니다.\n- useContext로 하위에서 직접 접근합니다.\n- 중간 컴포넌트는 신경 쓰지 않아도 됩니다.\n- 간단한 경우에 가장 적합합니다.\n\n**해결 방법 2: 상태 관리 라이브러리:**\n- Redux, Zustand, Recoil 등을 사용합니다.\n- 전역 스토어에서 직접 데이터를 가져옵니다.\n- Props 전달이 필요 없습니다.\n- 복잡한 상태 로직에 적합합니다.\n- 디버깅 도구가 풍부합니다.\n\n**해결 방법 3: Component Composition:**\n- children props를 활용합니다.\n- 컴포넌트를 조합하는 방식으로 구조를 변경합니다.\n- 데이터가 필요한 컴포넌트를 상위에서 만들어 전달합니다.\n- Props drilling 없이 데이터를 사용할 수 있습니다.\n- 유연하고 재사용 가능한 구조를 만듭니다.\n\n**해결 방법 4: Render Props:**\n- 함수를 Props로 전달합니다.\n- 함수가 컴포넌트를 렌더링합니다.\n- 데이터를 함수 인자로 전달합니다.\n- HOC의 대안으로 사용됩니다.\n- Hooks 등장 이후 덜 사용됩니다.\n\n**해결 방법 5: 컴포넌트 구조 재설계:**\n- 데이터가 필요한 곳 가까이에 State를 둡니다.\n- 불필요하게 끌어올린 State를 다시 내립니다.\n- 컴포넌트 분리를 재고합니다.\n- 로직과 UI를 분리합니다.\n\n**언제 어떤 방법을 사용할까:**\n- 2-3 레벨 정도는 Props로 전달해도 괜찮습니다.\n- 테마나 로케일 같은 전역 설정은 Context를 사용합니다.\n- 복잡한 상태 관리는 Redux 같은 라이브러리를 사용합니다.\n- 레이아웃 컴포넌트는 Composition 패턴을 사용합니다.\n- 상황에 맞는 방법을 선택합니다.\n\n**주의사항:**\n- Context를 과도하게 사용하면 성능 문제가 생깁니다.\n- 모든 것을 전역 상태로 만들 필요는 없습니다.\n- 간단한 Props 전달은 문제가 아닙니다.\n- 도구가 아닌 문제 해결에 집중합니다.\n\n**실무 활용:**\n- 사용자 정보는 Context로 전역 관리합니다.\n- UI 레이아웃은 Composition 패턴을 사용합니다.\n- 비즈니스 로직이 복잡하면 상태 관리 라이브러리를 도입합니다.\n- 먼저 Props로 시작하고 문제가 생기면 리팩토링합니다.\n- 각 방법의 장단점을 이해하고 적절히 선택합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "props"
      ],
      "id": "1763441901803-5xd60p21k",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "불변성(Immutability)을 유지해야 하는 이유는 무엇인가요?",
      "answer": "**정의:**\n불변성은 기존 값을 직접 수정하지 않고 새로운 값을 생성하는 원칙입니다. React에서는 상태 객체를 직접 변경하지 않고 새로운 객체를 만들어 교체하는 방식으로 불변성을 유지합니다.\n\n**불변성이 중요한 이유:**\n- React가 변경을 감지합니다. 참조 비교로 빠르게 확인합니다.\n- 이전 상태와 새 상태를 비교할 때 Object.is로 참조만 비교합니다.\n- 직접 수정하면 참조가 같아서 변경을 감지하지 못합니다.\n- 리렌더링이 일어나지 않거나 예측 불가능하게 동작합니다.\n- Virtual DOM 비교 알고리즘이 효율적으로 작동합니다.\n\n**변경 감지 메커니즘:**\n- React는 얕은 비교를 합니다. 깊은 비교는 비용이 큽니다.\n- 참조가 다르면 변경되었다고 판단합니다.\n- 참조가 같으면 내용이 바뀌어도 모릅니다.\n- 불변성을 지키면 참조만 비교해도 충분합니다.\n- 성능과 정확성을 동시에 얻습니다.\n\n**불변성을 지키는 방법:**\n- 스프레드 연산자로 새 객체를 만듭니다.\n- 배열 메서드는 map filter concat을 사용합니다. push pop splice는 피합니다.\n- Object.assign으로 객체를 복사합니다.\n- 구조 분해 할당을 활용합니다.\n- Immer 같은 라이브러리를 사용합니다.\n\n**객체 업데이트:**\n- 중첩된 객체는 각 레벨을 새로 만들어야 합니다.\n- 스프레드 연산자를 여러 번 사용합니다.\n- 깊은 중첩은 복잡해집니다.\n- Immer를 사용하면 직접 수정하는 것처럼 쓸 수 있습니다.\n- 내부적으로 불변 업데이트를 처리합니다.\n\n**배열 업데이트:**\n- 추가는 concat이나 스프레드를 사용합니다.\n- 삭제는 filter를 사용합니다.\n- 수정은 map을 사용합니다.\n- 정렬은 slice 후 sort 하거나 스프레드 후 sort 합니다.\n- 원본 배열을 건드리지 않습니다.\n\n**성능과 최적화:**\n- 불변성을 지키면 메모이제이션이 효과적입니다.\n- React.memo가 Props 비교를 정확히 할 수 있습니다.\n- useMemo와 useCallback의 의존성 체크가 정확합니다.\n- PureComponent가 제대로 동작합니다.\n- 불필요한 리렌더링을 방지합니다.\n\n**디버깅과 시간 여행:**\n- 이전 상태가 보존됩니다. 상태 히스토리를 추적할 수 있습니다.\n- 디버깅이 쉬워집니다. 어느 시점의 상태든 확인 가능합니다.\n- 실행 취소와 다시 실행을 구현할 수 있습니다.\n- Redux DevTools 같은 도구가 가능해집니다.\n- 시간 여행 디버깅을 지원합니다.\n\n**실무 활용:**\n- 모든 상태 업데이트에서 불변성을 지킵니다.\n- ESLint 규칙으로 직접 수정을 방지합니다.\n- Immer를 사용하여 코드를 간결하게 만듭니다.\n- TypeScript의 readonly 타입을 활용합니다.\n- 팀 전체가 불변성의 중요성을 이해해야 합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-fn8cpc7yc",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "클래스 컴포넌트의 라이프사이클 메서드에 대해 설명해주세요.",
      "answer": "**정의:**\n라이프사이클 메서드는 클래스 컴포넌트에서 컴포넌트의 생성부터 소멸까지 특정 시점에 실행되는 메서드들입니다. 마운트 업데이트 언마운트의 세 단계로 나뉩니다.\n\n**마운트 단계:**\n- constructor: 컴포넌트가 생성될 때 호출됩니다. state 초기화와 메서드 바인딩을 합니다.\n- static getDerivedStateFromProps: Props로부터 State를 동기화합니다. 거의 사용하지 않습니다.\n- render: JSX를 반환합니다. 순수해야 하며 부작용이 없어야 합니다.\n- componentDidMount: 컴포넌트가 DOM에 추가된 직후 호출됩니다. API 호출이나 구독 설정을 합니다.\n\n**업데이트 단계:**\n- static getDerivedStateFromProps: Props 변경 시에도 호출됩니다.\n- shouldComponentUpdate: 리렌더링 여부를 결정합니다. 성능 최적화에 사용합니다.\n- render: 새로운 JSX를 반환합니다.\n- getSnapshotBeforeUpdate: DOM 업데이트 직전 정보를 캡처합니다. 스크롤 위치 등을 저장합니다.\n- componentDidUpdate: 업데이트 후 호출됩니다. 이전 Props나 State와 비교할 수 있습니다.\n\n**언마운트 단계:**\n- componentWillUnmount: 컴포넌트가 제거되기 직전 호출됩니다. 정리 작업을 합니다.\n- 타이머 제거 구독 해제 등을 수행합니다.\n- 메모리 누수를 방지합니다.\n\n**에러 처리:**\n- static getDerivedStateFromError: 에러 발생 시 State를 업데이트합니다.\n- componentDidCatch: 에러 정보를 로깅합니다.\n- Error Boundary를 구현할 때 사용합니다.\n- 자식 컴포넌트의 에러를 잡습니다.\n\n**레거시 메서드:**\n- componentWillMount: 더 이상 사용하지 않습니다. constructor를 사용합니다.\n- componentWillReceiveProps: getDerivedStateFromProps로 대체되었습니다.\n- componentWillUpdate: getSnapshotBeforeUpdate로 대체되었습니다.\n- 비동기 렌더링에서 문제가 있어 deprecated 되었습니다.\n\n**일반적인 사용 패턴:**\n- componentDidMount에서 데이터를 가져옵니다.\n- componentDidUpdate에서 Props 변경에 반응합니다.\n- componentWillUnmount에서 리소스를 정리합니다.\n- shouldComponentUpdate로 성능을 최적화합니다.\n- render는 순수하게 유지합니다.\n\n**함수형 컴포넌트와 비교:**\n- 클래스는 라이프사이클 메서드를 사용합니다.\n- 함수형은 useEffect Hook을 사용합니다.\n- useEffect가 여러 라이프사이클을 대체합니다.\n- 함수형이 더 간결하고 직관적입니다.\n- 새 코드는 함수형을 권장합니다.\n\n**실무 활용:**\n- 레거시 코드를 유지보수할 때 필요합니다.\n- Error Boundary는 아직 클래스로만 구현 가능합니다.\n- 점진적으로 함수형으로 마이그레이션합니다.\n- 라이프사이클을 이해하면 useEffect를 더 잘 사용할 수 있습니다.\n- 각 메서드의 실행 시점과 목적을 명확히 파악합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "component",
        "lifecycle"
      ],
      "id": "1763441901803-hwof7jfyu",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "함수형 컴포넌트에서 라이프사이클을 어떻게 구현하나요?",
      "answer": "**정의:**\n함수형 컴포넌트는 useEffect Hook을 사용하여 클래스 컴포넌트의 라이프사이클 메서드를 대체합니다. 하나의 Hook으로 마운트 업데이트 언마운트를 모두 처리할 수 있습니다.\n\n**useEffect의 역할:**\n- 부작용을 처리하는 Hook입니다.\n- 여러 라이프사이클 메서드를 통합합니다.\n- 의존성 배열로 실행 시점을 제어합니다.\n- 클린업 함수로 정리 작업을 합니다.\n- 여러 개를 사용하여 관심사를 분리할 수 있습니다.\n\n**componentDidMount 구현:**\n- 의존성 배열을 빈 배열로 설정합니다.\n- 컴포넌트가 마운트될 때 한 번만 실행됩니다.\n- API 호출이나 구독 설정에 사용합니다.\n- 초기 데이터 로딩을 수행합니다.\n\n**componentDidUpdate 구현:**\n- 의존성 배열에 감시할 값을 넣습니다.\n- 해당 값이 변경될 때마다 실행됩니다.\n- 여러 의존성을 추가할 수 있습니다.\n- Props나 State 변경에 반응합니다.\n\n**componentWillUnmount 구현:**\n- useEffect에서 클린업 함수를 반환합니다.\n- 컴포넌트가 언마운트될 때 실행됩니다.\n- 타이머 제거 구독 해제 등을 합니다.\n- 메모리 누수를 방지합니다.\n\n**라이프사이클 조합:**\n- 빈 배열 의존성은 마운트와 언마운트만 처리합니다.\n- 특정 값 의존성은 업데이트도 처리합니다.\n- 여러 useEffect로 로직을 분리합니다.\n- 관련된 코드를 한곳에 모을 수 있습니다.\n- 클래스보다 유연하고 강력합니다.\n\n**여러 useEffect 사용:**\n- 관심사별로 effect를 분리합니다.\n- 데이터 페칭 이벤트 구독 타이머를 각각 다른 effect로 만듭니다.\n- 클래스에서는 한 메서드에 여러 로직이 섞였습니다.\n- 함수형에서는 깔끔하게 분리됩니다.\n- 코드 가독성과 유지보수성이 향상됩니다.\n\n**useLayoutEffect:**\n- useEffect와 비슷하지만 동기적으로 실행됩니다.\n- DOM 변경 직후 브라우저 페인트 전에 실행됩니다.\n- componentDidMount와 componentDidUpdate처럼 동작합니다.\n- DOM 측정이나 동기 레이아웃 업데이트에 사용합니다.\n- 대부분의 경우 useEffect로 충분합니다.\n\n**실무 활용:**\n- API 호출은 빈 배열 의존성으로 마운트 시에만 합니다.\n- 검색어 변경에 따른 필터링은 해당 값을 의존성에 넣습니다.\n- WebSocket 연결은 마운트 시 생성하고 언마운트 시 정리합니다.\n- 여러 독립적인 부작용은 각각 별도 useEffect로 만듭니다.\n- 의존성 배열을 정확히 작성하여 버그를 방지합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "function",
        "component",
        "lifecycle"
      ],
      "id": "1763441901803-84b3eb2rf",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useEffect의 의존성 배열을 빈 배열로 설정하면 어떻게 되나요?",
      "answer": "**정의:**\nuseEffect의 의존성 배열을 빈 배열로 설정하면 effect가 컴포넌트 마운트 시에만 실행되고, 클린업 함수는 언마운트 시에만 실행됩니다. 클래스 컴포넌트의 componentDidMount와 componentWillUnmount와 유사합니다.\n\n**실행 타이밍:**\n- 컴포넌트가 처음 렌더링된 직후 한 번 실행됩니다.\n- 이후 리렌더링되어도 다시 실행되지 않습니다.\n- Props나 State가 변경되어도 무시합니다.\n- 클린업 함수는 컴포넌트가 DOM에서 제거될 때만 실행됩니다.\n\n**일반적인 사용 사례:**\n- 초기 데이터 로딩: API를 호출하여 초기 데이터를 가져옵니다.\n- 이벤트 리스너 등록: window나 document 이벤트를 설정합니다.\n- 타이머 설정: setInterval로 주기적 작업을 시작합니다.\n- 외부 라이브러리 초기화: 차트나 맵 라이브러리를 초기화합니다.\n- 구독 설정: WebSocket이나 실시간 데이터를 구독합니다.\n\n**클린업 함수 역할:**\n- 컴포넌트 언마운트 시 정리 작업을 수행합니다.\n- 이벤트 리스너를 제거합니다.\n- 타이머를 정리합니다.\n- 구독을 해제합니다.\n- 메모리 누수를 방지합니다.\n\n**주의사항:**\n- effect 내부에서 사용하는 값이 변경되어도 effect는 재실행되지 않습니다.\n- 오래된 클로저 값을 참조할 수 있습니다.\n- 의도적으로 한 번만 실행하려는 경우에만 사용합니다.\n- ESLint exhaustive-deps 규칙이 경고를 표시합니다.\n- 정말 한 번만 실행해야 하는지 확인합니다.\n\n**클로저 문제:**\n- effect가 생성된 시점의 값을 캡처합니다.\n- 이후 Props나 State가 바뀌어도 effect는 초기 값을 참조합니다.\n- 최신 값이 필요하면 의존성 배열에 추가해야 합니다.\n- useRef로 최신 값을 참조할 수도 있습니다.\n\n**대안과 해결책:**\n- 최신 값이 필요하면 의존성에 포함합니다.\n- 함수는 useCallback으로 메모이제이션합니다.\n- 정말 한 번만 실행이 필요한지 재고합니다.\n- 데이터 페칭은 React Query 같은 라이브러리를 고려합니다.\n\n**빈 배열 vs 배열 생략:**\n- 빈 배열은 마운트 시에만 실행됩니다.\n- 배열을 생략하면 매 렌더링마다 실행됩니다.\n- 배열 생략은 거의 사용하지 않습니다.\n- 명시적으로 빈 배열을 사용하는 것이 좋습니다.\n\n**실무 활용:**\n- 페이지 로드 시 사용자 데이터를 한 번만 가져옵니다.\n- 전역 이벤트 리스너를 설정하고 정리합니다.\n- 애널리틱스 페이지 뷰를 한 번만 기록합니다.\n- 외부 스크립트를 로드합니다.\n- 의도를 명확히 하기 위해 주석을 추가합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "array",
        "Hook"
      ],
      "id": "1763441901803-1no3dmm7e",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "componentDidMount, componentDidUpdate, componentWillUnmount을 useEffect로 어떻게 대체하나요?",
      "answer": "**정의:**\nuseEffect는 클래스 컴포넌트의 세 가지 주요 라이프사이클 메서드를 하나로 통합한 Hook입니다. 의존성 배열과 클린업 함수를 활용하여 동일한 기능을 구현할 수 있습니다.\n\n**componentDidMount 대체:**\n- 의존성 배열을 빈 배열로 설정합니다.\n- effect가 마운트 시에만 한 번 실행됩니다.\n- 초기 데이터 로딩이나 설정을 수행합니다.\n- 이후 리렌더링되어도 다시 실행되지 않습니다.\n\n**componentDidUpdate 대체:**\n- 의존성 배열에 감시할 값들을 넣습니다.\n- 해당 값이 변경될 때마다 effect가 실행됩니다.\n- 여러 의존성을 추가할 수 있습니다.\n- 초기 마운트 시에도 실행됩니다. 이것이 componentDidUpdate와의 차이점입니다.\n- useRef로 초기 실행을 건너뛸 수 있습니다.\n\n**componentWillUnmount 대체:**\n- useEffect에서 클린업 함수를 반환합니다.\n- 컴포넌트가 언마운트될 때 클린업이 실행됩니다.\n- 타이머 제거 구독 해제 등을 수행합니다.\n- 의존성이 있으면 재실행 전에도 클린업이 호출됩니다.\n\n**초기 마운트 제외하기:**\n- useRef로 마운트 여부를 추적합니다.\n- 첫 렌더링인지 확인하고 건너뜁니다.\n- componentDidUpdate와 정확히 같은 동작을 구현합니다.\n- 대부분의 경우 이렇게까지 할 필요는 없습니다.\n\n**세 가지 메서드를 모두 사용하는 패턴:**\n- 하나의 useEffect로 통합할 수 있습니다.\n- 의존성 배열로 업데이트 시점을 제어합니다.\n- 클린업 함수로 정리를 수행합니다.\n- 관련된 로직이 한곳에 모입니다.\n- 클래스보다 가독성이 좋습니다.\n\n**여러 useEffect로 분리:**\n- 클래스에서는 한 메서드에 여러 로직이 섞입니다.\n- useEffect는 관심사별로 분리할 수 있습니다.\n- 데이터 페칭 이벤트 구독 타이머를 각각 다른 effect로 만듭니다.\n- 코드가 더 명확하고 유지보수하기 쉽습니다.\n\n**이전 Props나 State 비교:**\n- useRef로 이전 값을 저장합니다.\n- effect에서 현재 값과 비교합니다.\n- componentDidUpdate의 prevProps prevState와 동일한 효과입니다.\n- Custom Hook으로 만들어 재사용할 수 있습니다.\n\n**실무 활용:**\n- API 호출은 빈 배열로 마운트 시에만 합니다.\n- 필터 변경 시 데이터를 다시 가져오려면 해당 필터를 의존성에 넣습니다.\n- 타이머나 구독은 클린업 함수로 정리합니다.\n- 여러 독립적인 부작용은 각각의 useEffect로 분리합니다.\n- useEffect가 더 직관적이고 강력합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook",
        "component"
      ],
      "id": "1763441901803-yomw3ff80",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React에서 리렌더링이 발생하는 경우는 언제인가요?",
      "answer": "**정의:**\n리렌더링은 컴포넌트가 다시 렌더 함수를 실행하여 새로운 Virtual DOM을 생성하는 과정입니다. 상태 변경이나 부모의 리렌더링 등 여러 조건에서 발생합니다.\n\n**리렌더링 발생 조건:**\n- State가 변경될 때: setState나 useState Hook으로 상태를 업데이트하면 리렌더링됩니다.\n- Props가 변경될 때: 부모로부터 받은 props가 바뀌면 리렌더링됩니다.\n- 부모가 리렌더링될 때: 기본적으로 부모가 리렌더링되면 모든 자식도 리렌더링됩니다.\n- Context 값이 변경될 때: useContext로 구독 중인 값이 바뀌면 리렌더링됩니다.\n- forceUpdate 호출 시: 강제로 리렌더링을 유발합니다. 거의 사용하지 않습니다.\n\n**State 변경에 의한 리렌더링:**\n- setState 호출 즉시가 아닌 배치 후에 발생합니다.\n- 여러 setState를 묶어서 한 번에 처리합니다.\n- 같은 값으로 업데이트하면 리렌더링을 건너뜁니다.\n- Object.is로 비교하여 참조가 같으면 무시합니다.\n\n**Props 변경에 의한 리렌더링:**\n- 부모가 새로운 props를 전달하면 자식이 리렌더링됩니다.\n- 객체나 배열은 참조로 비교합니다.\n- 내용이 같아도 새 객체면 다르다고 판단합니다.\n- 메모이제이션으로 같은 참조를 유지할 수 있습니다.\n\n**부모 리렌더링 전파:**\n- 부모가 리렌더링되면 기본적으로 모든 자식도 리렌더링됩니다.\n- 자식의 props가 바뀌지 않아도 리렌더링됩니다.\n- React.memo로 props가 같으면 리렌더링을 건너뛸 수 있습니다.\n- 최적화 기법으로 불필요한 리렌더링을 방지합니다.\n\n**Context에 의한 리렌더링:**\n- Provider의 value가 변경되면 구독 중인 모든 컴포넌트가 리렌더링됩니다.\n- 중간 컴포넌트는 건너뛰고 직접 영향을 받습니다.\n- Context를 분리하여 불필요한 리렌더링을 줄일 수 있습니다.\n- value를 메모이제이션하여 참조를 유지합니다.\n\n**리렌더링이 일어나지 않는 경우:**\n- 같은 값으로 State를 업데이트할 때입니다.\n- React.memo로 감싸고 props가 같을 때입니다.\n- shouldComponentUpdate가 false를 반환할 때입니다.\n- PureComponent에서 얕은 비교 결과 같을 때입니다.\n\n**배치 업데이트:**\n- React 18부터 모든 업데이트가 자동으로 배치됩니다.\n- 여러 setState를 호출해도 한 번만 리렌더링됩니다.\n- 이벤트 핸들러뿐 아니라 비동기 코드에서도 배치됩니다.\n- 성능이 크게 향상됩니다.\n\n**실무 활용:**\n- 리렌더링 원인을 파악하여 최적화합니다.\n- React DevTools Profiler로 리렌더링을 분석합니다.\n- 불필요한 리렌더링은 memo나 useMemo로 방지합니다.\n- State를 적절히 분리하여 영향 범위를 줄입니다.\n- 과도한 최적화는 피합니다. 측정 후 최적화합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-z7gd6y6xo",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React.memo는 무엇이고 언제 사용하나요?",
      "answer": "**정의:**\nReact.memo는 고차 컴포넌트로, 컴포넌트를 메모이제이션하여 props가 변경되지 않으면 리렌더링을 건너뛰게 합니다. 함수형 컴포넌트의 성능 최적화 도구입니다.\n\n**동작 원리:**\n- 컴포넌트를 React.memo로 감쌉니다.\n- 이전 props와 새 props를 얕은 비교합니다.\n- 모든 props가 같으면 이전 렌더링 결과를 재사용합니다.\n- 하나라도 다르면 리렌더링합니다.\n- PureComponent와 유사하지만 함수형 컴포넌트용입니다.\n\n**기본 사용법:**\n- 컴포넌트를 React.memo로 감싸면 됩니다.\n- 별도 설정 없이 자동으로 props를 비교합니다.\n- 얕은 비교를 수행합니다.\n- export 시에 감싸거나 변수에 할당합니다.\n\n**커스텀 비교 함수:**\n- 두 번째 인자로 비교 함수를 전달할 수 있습니다.\n- prevProps와 nextProps를 받아 같으면 true를 반환합니다.\n- shouldComponentUpdate와 반대로 동작합니다.\n- 복잡한 비교 로직이 필요할 때 사용합니다.\n- 대부분의 경우 기본 비교로 충분합니다.\n\n**React.memo를 사용해야 하는 경우:**\n- 같은 props로 자주 렌더링되는 컴포넌트입니다.\n- 렌더링이 비용이 큰 컴포넌트입니다.\n- 부모가 자주 리렌더링되지만 자식은 props가 안 바뀝니다.\n- 목록의 아이템 컴포넌트입니다.\n- props가 원시값이거나 메모이제이션된 객체입니다.\n\n**React.memo를 사용하지 말아야 하는 경우:**\n- 항상 다른 props를 받는 컴포넌트입니다.\n- 렌더링 비용이 작은 단순한 컴포넌트입니다.\n- props에 항상 새로운 객체나 함수가 전달됩니다.\n- 측정 없이 추측으로 최적화하는 경우입니다.\n\n**props 메모이제이션 필요성:**\n- 객체나 배열 props는 useMemo로 메모이제이션해야 합니다.\n- 함수 props는 useCallback으로 메모이제이션해야 합니다.\n- 메모이제이션하지 않으면 매번 새 참조가 전달되어 효과가 없습니다.\n- 부모에서 메모이제이션을 제대로 해야 자식의 memo가 의미 있습니다.\n\n**성능 고려사항:**\n- memo 자체도 비교 비용이 듭니다.\n- 항상 빠른 것은 아닙니다.\n- 프로파일링으로 효과를 확인합니다.\n- 병목이 확인된 곳에만 적용합니다.\n- 과도한 사용은 오히려 성능을 해칩니다.\n\n**실무 활용:**\n- 큰 목록의 아이템 컴포넌트를 memo로 감쌉니다.\n- 부모가 자주 업데이트되는 자식 컴포넌트에 적용합니다.\n- 복잡한 차트나 테이블 컴포넌트를 최적화합니다.\n- 항상 props 메모이제이션과 함께 사용합니다.\n- React DevTools로 효과를 검증합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-79boiqiyh",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useMemo는 언제 사용해야 하나요?",
      "answer": "**정의:**\nuseMemo는 계산 비용이 큰 값을 메모이제이션하는 Hook입니다. 의존성이 변경될 때만 재계산하고, 그렇지 않으면 캐시된 값을 반환하여 성능을 최적화합니다.\n\n**동작 원리:**\n- 첫 번째 인자는 값을 계산하는 함수입니다.\n- 두 번째 인자는 의존성 배열입니다.\n- 의존성이 변경되면 함수를 다시 실행합니다.\n- 변경되지 않으면 이전 결과를 재사용합니다.\n- 렌더링 중에 동기적으로 실행됩니다.\n\n**사용해야 하는 경우:**\n- 계산 비용이 큰 연산 결과를 캐싱할 때입니다. 복잡한 데이터 변환이나 필터링입니다.\n- 참조 동등성이 중요한 객체나 배열을 생성할 때입니다.\n- 자식 컴포넌트에 props로 전달하는 객체를 메모이제이션할 때입니다.\n- React.memo와 함께 사용하여 불필요한 리렌더링을 방지할 때입니다.\n- useEffect의 의존성으로 사용되는 값을 메모이제이션할 때입니다.\n\n**사용하지 말아야 하는 경우:**\n- 단순한 계산은 메모이제이션 비용이 더 클 수 있습니다.\n- 항상 의존성이 바뀌는 경우 효과가 없습니다.\n- 측정 없이 추측으로 최적화하는 경우입니다.\n- 모든 값을 메모이제이션하면 오히려 느려집니다.\n\n**계산 비용이 큰 연산:**\n- 큰 배열의 정렬이나 필터링입니다.\n- 복잡한 수학 계산입니다.\n- 재귀적인 데이터 구조 변환입니다.\n- 수천 개 항목의 데이터 처리입니다.\n- 프로파일링으로 병목을 확인합니다.\n\n**참조 동등성 유지:**\n- 객체나 배열은 매 렌더링마다 새로 생성됩니다.\n- 참조가 바뀌면 의존하는 컴포넌트나 effect가 재실행됩니다.\n- useMemo로 같은 참조를 유지합니다.\n- React.memo나 useEffect와 함께 사용할 때 중요합니다.\n\n**의존성 관리:**\n- 계산에 사용되는 모든 값을 의존성에 포함합니다.\n- ESLint exhaustive-deps 규칙을 따릅니다.\n- 의존성이 너무 많으면 설계를 재고합니다.\n- 원시값만 의존성으로 사용하는 것이 안전합니다.\n\n**성능 측정:**\n- React DevTools Profiler로 렌더링 시간을 측정합니다.\n- console.time으로 계산 시간을 측정합니다.\n- 실제로 개선되는지 확인합니다.\n- 추측하지 말고 측정합니다.\n\n**실무 활용:**\n- 복잡한 데이터 필터링이나 정렬 결과를 캐싱합니다.\n- Context Provider의 value를 메모이제이션합니다.\n- 큰 테이블의 계산된 열 값을 캐싱합니다.\n- 자식에게 전달하는 설정 객체를 메모이제이션합니다.\n- 항상 측정 후 최적화하고 과도한 사용을 피합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook"
      ],
      "id": "1763441901803-5lhbq4ezg",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useCallback은 언제 사용해야 하나요?",
      "answer": "**정의:**\nuseCallback은 함수를 메모이제이션하는 Hook입니다. 의존성이 변경될 때만 새 함수를 생성하고, 그렇지 않으면 이전 함수 인스턴스를 재사용하여 불필요한 리렌더링을 방지합니다.\n\n**동작 원리:**\n- 첫 번째 인자는 메모이제이션할 함수입니다.\n- 두 번째 인자는 의존성 배열입니다.\n- 의존성이 변경되면 새 함수를 생성합니다.\n- 변경되지 않으면 이전 함수를 반환합니다.\n- useMemo의 함수 전용 버전입니다.\n\n**사용해야 하는 경우:**\n- 자식 컴포넌트에 콜백을 props로 전달할 때입니다. 자식이 React.memo로 최적화되어 있어야 효과적입니다.\n- useEffect의 의존성 배열에 함수를 넣을 때입니다.\n- 커스텀 Hook에서 함수를 반환할 때입니다.\n- 이벤트 핸들러를 다른 Hook의 의존성으로 사용할 때입니다.\n\n**사용하지 말아야 하는 경우:**\n- 함수를 props로 전달하지 않는 경우입니다.\n- 자식이 최적화되어 있지 않은 경우입니다.\n- 모든 함수를 useCallback으로 감싸는 것은 과도합니다.\n- 측정 없이 추측으로 최적화하는 경우입니다.\n\n**React.memo와 조합:**\n- 자식을 React.memo로 감쌉니다.\n- 부모의 콜백을 useCallback으로 메모이제이션합니다.\n- 자식의 props가 같으면 리렌더링을 건너뜁니다.\n- 메모이제이션하지 않으면 매번 새 함수가 전달되어 효과가 없습니다.\n\n**의존성 관리:**\n- 함수 내부에서 사용하는 모든 값을 의존성에 포함합니다.\n- Props, State, Context 값 등이 포함됩니다.\n- ESLint exhaustive-deps 규칙을 따릅니다.\n- 의존성이 자주 바뀌면 효과가 줄어듭니다.\n\n**클로저와 최신 값:**\n- 의존성에 포함하지 않으면 오래된 값을 참조합니다.\n- 클로저가 생성 시점의 값을 캡처하기 때문입니다.\n- 함수형 업데이트로 최신 state에 접근할 수 있습니다.\n- useRef로 최신 값을 참조할 수도 있습니다.\n\n**useCallback vs useMemo:**\n- useCallback은 함수 자체를 반환합니다.\n- useMemo는 함수 실행 결과를 반환합니다.\n- useCallback은 useMemo의 편의 문법입니다.\n- 함수 메모이제이션에는 useCallback이 더 명확합니다.\n\n**실무 활용:**\n- 목록의 각 아이템에 전달하는 핸들러를 메모이제이션합니다.\n- 디바운스나 쓰로틀 함수를 메모이제이션합니다.\n- useEffect 내부에서 사용할 함수를 메모이제이션합니다.\n- 커스텀 Hook에서 반환하는 함수를 메모이제이션합니다.\n- 항상 실제 성능 문제가 있을 때만 사용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "Hook"
      ],
      "id": "1763441901803-ncb79hk3f",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "key prop의 역할과 중요성은 무엇인가요?",
      "answer": "**정의:**\nkey는 React가 리스트의 각 항목을 고유하게 식별하는 데 사용하는 특별한 prop입니다. Virtual DOM 비교 시 어떤 항목이 변경 추가 삭제되었는지 효율적으로 판단하게 해줍니다.\n\n**key의 역할:**\n- 리스트 항목을 고유하게 식별합니다.\n- Reconciliation 알고리즘이 효율적으로 동작하게 합니다.\n- 변경된 항목만 업데이트하고 나머지는 재사용합니다.\n- 컴포넌트 인스턴스와 DOM 노드를 유지하거나 재생성하는 기준입니다.\n- 성능과 정확성에 모두 영향을 줍니다.\n\n**key가 없을 때의 문제:**\n- React는 순서대로만 비교합니다.\n- 항목이 추가 삭제되면 잘못된 요소가 업데이트됩니다.\n- 모든 항목을 재생성할 수 있습니다.\n- 컴포넌트 state가 잘못된 위치에 유지됩니다.\n- 성능이 크게 저하됩니다.\n\n**좋은 key 선택:**\n- 데이터의 고유 ID를 사용합니다. 데이터베이스 ID가 이상적입니다.\n- 안정적이고 예측 가능해야 합니다. 렌더링마다 바뀌면 안 됩니다.\n- 형제 간에만 고유하면 됩니다. 전역적으로 고유할 필요는 없습니다.\n- 문자열이나 숫자를 사용합니다.\n\n**나쁜 key 선택:**\n- 배열 인덱스를 key로 사용하면 안 됩니다. 순서가 바뀌거나 항목이 추가 삭제될 때 문제가 생깁니다.\n- Math.random이나 Date.now는 절대 사용하면 안 됩니다. 매번 새 key가 생성되어 모든 항목이 재생성됩니다.\n- 불안정한 값은 버그를 유발합니다.\n\n**인덱스를 key로 사용할 수 있는 경우:**\n- 리스트가 정적이고 재정렬되지 않을 때입니다.\n- 항목이 추가 삭제되지 않을 때입니다.\n- 항목에 고유 ID가 없고 순서가 중요할 때입니다.\n- 매우 제한적인 경우에만 허용됩니다.\n\n**key 변경의 효과:**\n- key가 바뀌면 컴포넌트가 언마운트되고 새로 마운트됩니다.\n- state가 초기화됩니다.\n- DOM 노드가 새로 생성됩니다.\n- 의도적으로 state를 리셋하는 데 활용할 수 있습니다.\n\n**Fragment와 key:**\n- Fragment에도 key를 추가할 수 있습니다.\n- 짧은 문법으로는 key를 줄 수 없습니다.\n- React.Fragment를 명시적으로 사용해야 합니다.\n\n**실무 활용:**\n- API에서 받은 데이터의 ID를 key로 사용합니다.\n- 고유 ID가 없으면 조합하여 만듭니다.\n- 폼을 리셋하려면 key를 바꿔서 컴포넌트를 재생성합니다.\n- 성능 문제가 있으면 key를 먼저 확인합니다.\n- 절대 인덱스를 기본으로 사용하지 않습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-xx1umpd9a",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "불필요한 리렌더링을 방지하는 방법은 무엇인가요?",
      "answer": "**정의:**\n불필요한 리렌더링은 실제로 화면에 변화가 없는데도 컴포넌트가 다시 렌더링되는 것입니다. 성능 저하의 주요 원인이며, 여러 최적화 기법으로 방지할 수 있습니다.\n\n**React.memo 사용:**\n- 함수형 컴포넌트를 메모이제이션합니다.\n- props가 변경되지 않으면 리렌더링을 건너뜁니다.\n- 얕은 비교로 props를 확인합니다.\n- 부모가 리렌더링되어도 자식은 안정적입니다.\n\n**useMemo로 값 메모이제이션:**\n- 계산 비용이 큰 값을 캐싱합니다.\n- 객체나 배열의 참조를 안정적으로 유지합니다.\n- 의존성이 변경될 때만 재계산합니다.\n- props로 전달하는 객체를 메모이제이션합니다.\n\n**useCallback으로 함수 메모이제이션:**\n- 함수의 참조를 안정적으로 유지합니다.\n- 자식에게 전달하는 콜백을 메모이제이션합니다.\n- 의존성이 변경될 때만 새 함수를 생성합니다.\n- React.memo와 함께 사용하면 효과적입니다.\n\n**State 구조 최적화:**\n- 관련 없는 state를 분리합니다.\n- 자주 바뀌는 state와 그렇지 않은 state를 나눕니다.\n- state를 필요한 컴포넌트 가까이 둡니다.\n- 과도하게 끌어올리지 않습니다.\n\n**Component Composition:**\n- children prop을 활용합니다.\n- state를 가진 컴포넌트와 UI를 분리합니다.\n- 리렌더링 범위를 최소화합니다.\n- 구조를 재설계하여 최적화합니다.\n\n**Context 최적화:**\n- Context를 여러 개로 분리합니다.\n- 자주 변경되는 값과 그렇지 않은 값을 나눕니다.\n- Provider value를 메모이제이션합니다.\n- 필요한 컴포넌트만 Context를 구독하게 합니다.\n\n**key를 올바르게 사용:**\n- 안정적인 고유 ID를 key로 사용합니다.\n- 인덱스나 랜덤 값을 피합니다.\n- key가 바뀌면 컴포넌트가 재생성됩니다.\n\n**조건부 렌더링 최적화:**\n- 불필요한 컴포넌트는 렌더링하지 않습니다.\n- 조기 반환으로 렌더링을 건너뜁니다.\n- 조건부 마운트를 활용합니다.\n\n**측정과 검증:**\n- React DevTools Profiler를 사용합니다.\n- 실제로 문제가 있는지 확인합니다.\n- 추측하지 말고 측정합니다.\n- 최적화 전후를 비교합니다.\n\n**실무 활용:**\n- 큰 목록은 가상화 라이브러리를 사용합니다.\n- 무거운 컴포넌트를 React.memo로 감쌉니다.\n- props로 전달하는 값들을 메모이제이션합니다.\n- state 구조를 잘 설계하여 리렌더링 범위를 줄입니다.\n- 과도한 최적화는 피하고 병목만 해결합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-9nk73nq9u",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Higher-Order Component(HOC)란 무엇이고 언제 사용하나요?",
      "answer": "**정의:**\nHigher-Order Component는 컴포넌트를 받아서 새로운 컴포넌트를 반환하는 함수입니다. 컴포넌트 로직을 재사용하는 고급 패턴으로, React의 조합적 특성을 활용합니다.\n\n**HOC의 개념:**\n- 컴포넌트를 인자로 받습니다.\n- 향상된 새 컴포넌트를 반환합니다.\n- 원본 컴포넌트를 수정하지 않습니다.\n- 순수 함수입니다. 부작용이 없습니다.\n- with 접두사를 관례적으로 사용합니다.\n\n**HOC의 용도:**\n- 공통 로직을 재사용합니다. 인증 로깅 데이터 페칭 등입니다.\n- props를 조작하거나 추가합니다.\n- 조건부 렌더링을 추상화합니다.\n- 컴포넌트에 기능을 주입합니다.\n- 횡단 관심사를 분리합니다.\n\n**HOC 작성 패턴:**\n- 함수를 반환하는 함수를 만듭니다.\n- 원본 컴포넌트를 래핑합니다.\n- 추가 props를 전달합니다.\n- 원본 props를 모두 전달합니다.\n- displayName을 설정하여 디버깅을 쉽게 합니다.\n\n**일반적인 HOC 예시:**\n- withAuth: 인증 여부를 확인하고 리다이렉트합니다.\n- withLoading: 로딩 상태를 관리하고 스피너를 표시합니다.\n- withErrorBoundary: 에러 처리를 추가합니다.\n- withLogger: 렌더링을 로깅합니다.\n- Redux의 connect: 스토어를 연결합니다.\n\n**HOC의 장점:**\n- 로직을 재사용할 수 있습니다.\n- 컴포넌트를 깔끔하게 유지합니다.\n- 여러 HOC를 조합할 수 있습니다.\n- 원본 컴포넌트를 수정하지 않습니다.\n- 횡단 관심사를 효과적으로 분리합니다.\n\n**HOC의 단점:**\n- 래퍼 지옥이 발생할 수 있습니다. 여러 HOC를 중첩하면 복잡해집니다.\n- props 충돌 가능성이 있습니다.\n- 정적 메서드가 복사되지 않습니다.\n- ref가 전달되지 않습니다. forwardRef가 필요합니다.\n- 디버깅이 어려울 수 있습니다.\n\n**Hooks와의 비교:**\n- Hooks가 등장하면서 HOC 사용이 줄었습니다.\n- Custom Hook이 더 간단하고 직관적입니다.\n- HOC는 컴포넌트 트리를 복잡하게 만듭니다.\n- Hooks는 평평한 구조를 유지합니다.\n- 새 코드는 Hooks를 권장합니다.\n\n**여전히 HOC가 유용한 경우:**\n- 컴포넌트를 조건부로 렌더링할 때입니다.\n- 레거시 코드와 통합할 때입니다.\n- 라이브러리에서 제공하는 HOC를 사용할 때입니다.\n- 컴포넌트 래핑이 필요한 특수한 경우입니다.\n\n**실무 활용:**\n- 기존 HOC를 유지보수합니다.\n- 레거시 라이브러리의 HOC를 사용합니다.\n- 새로운 기능은 Hooks로 구현합니다.\n- HOC를 Custom Hook으로 마이그레이션합니다.\n- 팀의 코드 스타일과 일관성을 유지합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "component"
      ],
      "id": "1763441901803-apnxwrh27",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Render Props 패턴이란 무엇인가요?",
      "answer": "**정의:**\nRender Props는 함수를 prop으로 전달하여 컴포넌트 간에 코드를 공유하는 패턴입니다. 함수가 렌더링할 내용을 결정하며, 컴포넌트 로직을 재사용하면서도 렌더링을 유연하게 제어할 수 있습니다.\n\n**기본 개념:**\n- prop으로 함수를 전달합니다.\n- 컴포넌트가 이 함수를 호출하여 렌더링할 내용을 얻습니다.\n- 데이터나 메서드를 함수의 인자로 전달합니다.\n- 호출하는 쪽에서 UI를 결정합니다.\n- render라는 이름을 사용하지만 다른 이름도 가능합니다.\n\n**Render Props의 작동 방식:**\n- 공통 로직을 가진 컴포넌트를 만듭니다.\n- render prop을 통해 UI를 외부에서 주입받습니다.\n- 로직 실행 결과를 render 함수에 전달합니다.\n- render 함수가 반환한 JSX를 렌더링합니다.\n\n**일반적인 사용 사례:**\n- 마우스 위치 추적을 여러 방식으로 표시합니다.\n- 데이터 페칭 로직을 재사용하면서 다른 UI를 보여줍니다.\n- 애니메이션 상태를 공유하면서 다른 컴포넌트를 애니메이션합니다.\n- 폼 상태를 관리하면서 다양한 폼 UI를 만듭니다.\n\n**children as function:**\n- children을 함수로 받는 것도 Render Props 패턴입니다.\n- 더 자연스러운 JSX 문법을 제공합니다.\n- render prop과 동일한 원리입니다.\n- React Router나 React Context에서 많이 사용됩니다.\n\n**Render Props의 장점:**\n- 로직과 UI를 명확히 분리합니다.\n- 컴포넌트 재사용성이 높아집니다.\n- HOC의 래퍼 지옥 문제를 해결합니다.\n- 유연성이 뛰어납니다. 다양한 UI를 적용할 수 있습니다.\n- props 이름 충돌이 없습니다.\n\n**Render Props의 단점:**\n- 콜백 지옥처럼 중첩이 깊어질 수 있습니다.\n- 코드가 장황해질 수 있습니다.\n- 성능 최적화가 어려울 수 있습니다. 매번 새 함수가 생성됩니다.\n- PureComponent와 함께 사용 시 주의가 필요합니다.\n\n**Hooks와의 비교:**\n- Hooks가 등장하면서 Render Props 사용이 줄었습니다.\n- Custom Hook이 더 간단하고 깔끔합니다.\n- Render Props는 JSX 중첩을 만듭니다.\n- Hooks는 평평한 구조를 유지합니다.\n- 새 코드는 대부분 Hooks를 사용합니다.\n\n**여전히 유용한 경우:**\n- UI를 외부에서 주입받아야 할 때입니다.\n- 라이브러리에서 유연한 API를 제공할 때입니다.\n- React Router처럼 조건부 렌더링이 필요할 때입니다.\n- 레거시 코드를 유지보수할 때입니다.\n\n**실무 활용:**\n- 데이터 페칭 컴포넌트를 만들어 다양한 UI에 적용합니다.\n- 가상화 라이브러리에서 아이템 렌더링을 위임받습니다.\n- React Router의 Route 컴포넌트를 사용합니다.\n- 기존 Render Props를 점진적으로 Hooks로 마이그레이션합니다.\n- 상황에 맞는 패턴을 선택합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "props"
      ],
      "id": "1763441901803-9i24tjd5i",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Compound Components 패턴이란 무엇인가요?",
      "answer": "**정의:**\nCompound Components는 여러 컴포넌트가 함께 동작하여 하나의 기능을 완성하는 패턴입니다. 내부 상태를 공유하면서도 유연한 API를 제공하며, HTML의 select와 option 관계와 유사합니다.\n\n**기본 개념:**\n- 부모와 자식 컴포넌트가 암묵적으로 상태를 공유합니다.\n- 각 컴포넌트는 독립적으로 사용됩니다.\n- 조합하여 복잡한 UI를 만듭니다.\n- 선언적이고 직관적인 API를 제공합니다.\n\n**구현 방법:**\n- Context API로 상태를 공유합니다.\n- 부모가 Provider로 상태를 제공합니다.\n- 자식들이 useContext로 상태에 접근합니다.\n- 각 하위 컴포넌트를 부모의 속성으로 export 합니다.\n\n**일반적인 예시:**\n- 탭 컴포넌트: Tabs TabList Tab TabPanel로 구성됩니다.\n- 드롭다운 메뉴: Menu MenuButton MenuList MenuItem으로 구성됩니다.\n- 아코디언: Accordion AccordionItem AccordionHeader AccordionPanel로 구성됩니다.\n- 모달: Modal ModalOverlay ModalContent ModalHeader ModalBody ModalFooter로 구성됩니다.\n\n**Compound Components의 장점:**\n- API가 직관적이고 유연합니다.\n- 컴포넌트 구조를 자유롭게 조합할 수 있습니다.\n- 관심사가 명확히 분리됩니다.\n- props drilling이 필요 없습니다.\n- 확장성이 뛰어납니다.\n\n**Context를 활용한 구현:**\n- 부모에서 createContext로 Context를 만듭니다.\n- Provider로 상태와 핸들러를 제공합니다.\n- 자식들이 useContext로 접근합니다.\n- 자식은 부모 없이 사용할 수 없습니다.\n\n**유연성과 제어:**\n- 사용자가 컴포넌트 순서를 바꿀 수 있습니다.\n- 필요한 부분만 사용할 수 있습니다.\n- 커스텀 스타일링이 쉽습니다.\n- 중간에 다른 요소를 추가할 수 있습니다.\n\n**타입 안전성:**\n- TypeScript로 타입을 명확히 정의합니다.\n- Context의 타입을 정의합니다.\n- 각 컴포넌트의 props 타입을 정의합니다.\n- 잘못된 사용을 컴파일 타임에 잡습니다.\n\n**주의사항:**\n- 컴포넌트가 올바른 부모 안에서 사용되는지 확인합니다.\n- Context가 없으면 에러를 던집니다.\n- 문서화를 잘 해야 합니다.\n- 너무 복잡하면 오히려 혼란스러울 수 있습니다.\n\n**실무 활용:**\n- UI 라이브러리에서 많이 사용합니다. Chakra UI Radix UI 등입니다.\n- 재사용 가능한 컴포넌트를 만들 때 적용합니다.\n- 복잡한 인터랙션을 추상화합니다.\n- 디자인 시스템을 구축할 때 활용합니다.\n- 사용자에게 유연한 API를 제공합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "component"
      ],
      "id": "1763441901803-i14jvntau",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Portal은 무엇이고 언제 사용하나요?",
      "answer": "**정의:**\nPortal은 컴포넌트를 부모 DOM 계층 외부의 다른 DOM 노드에 렌더링하는 방법입니다. ReactDOM.createPortal을 사용하며, 논리적 트리 구조는 유지하면서 물리적 위치만 변경합니다.\n\n**Portal의 필요성:**\n- 모달이나 툴팁을 최상위에 렌더링해야 합니다.\n- 부모의 overflow hidden이나 z-index에 영향받지 않아야 합니다.\n- CSS 스타일링 문제를 해결합니다.\n- 접근성을 올바르게 구현합니다.\n\n**Portal 작동 방식:**\n- ReactDOM.createPortal을 사용합니다.\n- 첫 번째 인자는 렌더링할 JSX입니다.\n- 두 번째 인자는 대상 DOM 노드입니다.\n- 물리적으로는 다른 위치에 렌더링됩니다.\n- 논리적으로는 React 트리에 그대로 있습니다.\n\n**이벤트 버블링:**\n- Portal에서 발생한 이벤트는 React 트리를 따라 버블링됩니다.\n- 물리적 DOM 위치가 아닌 논리적 위치를 따릅니다.\n- 부모 컴포넌트에서 이벤트를 캡처할 수 있습니다.\n- 일반 컴포넌트처럼 동작합니다.\n\n**Context와 Portal:**\n- Portal 내부에서도 Context에 접근할 수 있습니다.\n- React 트리 구조가 유지되기 때문입니다.\n- Provider 범위 안에 있으면 사용 가능합니다.\n- 물리적 위치는 상관없습니다.\n\n**일반적인 사용 사례:**\n- 모달 다이얼로그를 body 직속으로 렌더링합니다.\n- 툴팁이나 팝오버를 최상위에 표시합니다.\n- 드롭다운 메뉴를 올바른 위치에 표시합니다.\n- 알림 토스트를 앱 최상위에 표시합니다.\n- 전체 화면 오버레이를 만듭니다.\n\n**구현 패턴:**\n- HTML에 portal용 div를 미리 만듭니다.\n- document.getElementById로 대상 노드를 찾습니다.\n- createPortal로 렌더링합니다.\n- 재사용 가능한 Portal 컴포넌트를 만듭니다.\n\n**접근성 고려사항:**\n- 포커스 관리를 올바르게 해야 합니다.\n- 키보드 내비게이션이 작동해야 합니다.\n- ARIA 속성을 적절히 사용합니다.\n- 스크린 리더가 이해할 수 있게 합니다.\n\n**주의사항:**\n- 대상 DOM 노드가 존재하는지 확인합니다.\n- 서버 사이드 렌더링에서는 조건부로 사용합니다.\n- 메모리 누수를 방지하기 위해 정리합니다.\n- 너무 남용하지 않습니다.\n\n**실무 활용:**\n- 모달 컴포넌트를 구현할 때 필수적입니다.\n- UI 라이브러리의 오버레이 컴포넌트에 사용합니다.\n- z-index 스택 문제를 해결합니다.\n- 고정 위치 요소를 올바르게 배치합니다.\n- React 18의 createRoot와 함께 사용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-nw0pe0l7x",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Controlled Component와 Uncontrolled Component의 차이점은 무엇인가요?",
      "answer": "**정의:**\nControlled Component는 React state로 폼 입력값을 제어하는 컴포넌트이고, Uncontrolled Component는 DOM이 직접 값을 관리하고 ref로 접근하는 컴포넌트입니다.\n\n**Controlled Component 특징:**\n- React state가 유일한 진실 공급원입니다.\n- value prop으로 값을 설정합니다.\n- onChange로 state를 업데이트합니다.\n- 모든 변경이 React를 거칩니다.\n- 실시간 유효성 검사가 가능합니다.\n\n**Controlled Component 장점:**\n- 값을 완전히 제어할 수 있습니다.\n- 즉각적인 피드백을 제공합니다.\n- 조건부 검증이 쉽습니다.\n- 값을 포맷팅할 수 있습니다.\n- 여러 입력을 동기화할 수 있습니다.\n\n**Uncontrolled Component 특징:**\n- DOM이 값을 관리합니다.\n- ref로 필요할 때 값을 읽습니다.\n- defaultValue로 초기값만 설정합니다.\n- React state를 사용하지 않습니다.\n- 기존 HTML 폼과 유사하게 동작합니다.\n\n**Uncontrolled Component 장점:**\n- 코드가 간단합니다.\n- 성능상 이점이 있을 수 있습니다.\n- 레거시 코드와 통합이 쉽습니다.\n- 파일 입력은 항상 uncontrolled입니다.\n- 빠르게 프로토타입을 만들 수 있습니다.\n\n**언제 Controlled를 사용할까:**\n- 실시간 유효성 검사가 필요할 때입니다.\n- 입력값을 포맷팅해야 할 때입니다.\n- 조건부로 입력을 활성화 비활성화할 때입니다.\n- 여러 입력이 상호작용할 때입니다.\n- 대부분의 경우 권장됩니다.\n\n**언제 Uncontrolled를 사용할까:**\n- 폼 제출 시에만 값이 필요할 때입니다.\n- 기존 non-React 코드와 통합할 때입니다.\n- 파일 입력을 다룰 때입니다.\n- 매우 간단한 폼일 때입니다.\n- 성능이 중요하고 실시간 검증이 불필요할 때입니다.\n\n**파일 입력 처리:**\n- 파일 입력은 항상 uncontrolled입니다.\n- value를 프로그래밍 방식으로 설정할 수 없습니다.\n- ref로 파일 객체에 접근합니다.\n- onChange로 변경을 감지할 수는 있습니다.\n\n**Controlled로 전환:**\n- defaultValue 대신 value를 사용합니다.\n- onChange 핸들러를 추가합니다.\n- state로 값을 관리합니다.\n- 점진적으로 마이그레이션할 수 있습니다.\n\n**실무 활용:**\n- 대부분의 폼은 Controlled로 구현합니다.\n- React Hook Form 같은 라이브러리는 Uncontrolled를 활용합니다.\n- 복잡한 폼은 Formik이나 React Hook Form을 사용합니다.\n- 파일 업로드는 ref를 사용합니다.\n- 프로젝트 요구사항에 맞게 선택합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "component"
      ],
      "id": "1763441901803-llf4bqo4o",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Context API는 무엇이고 언제 사용하나요?",
      "answer": "**정의:**\nContext API는 컴포넌트 트리 전체에 데이터를 전달하는 React의 내장 기능입니다. Props를 중간 컴포넌트마다 전달하지 않고도 깊은 레벨의 컴포넌트에 데이터를 제공할 수 있습니다.\n\n**Context API의 구성 요소:**\n- createContext: Context 객체를 생성합니다.\n- Provider: 값을 제공하는 컴포넌트입니다. value prop으로 데이터를 전달합니다.\n- Consumer: 값을 소비하는 방법입니다. 현재는 useContext를 주로 사용합니다.\n- useContext: Hook으로 Context 값을 읽습니다.\n\n**Context가 필요한 상황:**\n- Props drilling 문제를 해결할 때입니다. 여러 레벨을 거쳐 전달해야 하는 데이터입니다.\n- 전역적으로 공유되는 데이터가 있을 때입니다. 테마 언어 사용자 인증 정보 등입니다.\n- 여러 컴포넌트에서 같은 데이터를 사용할 때입니다.\n- 컴포넌트 트리의 깊은 곳에 데이터를 전달할 때입니다.\n\n**일반적인 사용 사례:**\n- 테마 관리: 다크 모드 라이트 모드 전환입니다.\n- 인증 정보: 로그인한 사용자 데이터와 권한입니다.\n- 언어 설정: 다국어 지원을 위한 로케일 정보입니다.\n- UI 상태: 모달이나 사이드바의 열림 닫힘 상태입니다.\n- 설정: 앱 전체 설정값입니다.\n\n**Context 생성과 사용:**\n- createContext로 Context를 만듭니다. 기본값을 제공할 수 있습니다.\n- Provider로 컴포넌트 트리를 감쌉니다.\n- value prop에 공유할 데이터를 전달합니다.\n- 하위 컴포넌트에서 useContext로 값을 읽습니다.\n\n**Provider 패턴:**\n- 별도의 Provider 컴포넌트를 만듭니다.\n- 내부에서 state를 관리합니다.\n- Context.Provider로 감싸서 반환합니다.\n- 로직을 캡슐화하여 재사용성을 높입니다.\n\n**Context의 장점:**\n- Props drilling을 제거합니다.\n- 코드가 깔끔해집니다.\n- React 내장 기능이라 별도 라이브러리가 필요 없습니다.\n- 간단한 전역 상태 관리가 가능합니다.\n- 컴포넌트 재사용성이 향상될 수 있습니다.\n\n**Context의 단점과 한계:**\n- 성능 문제가 있을 수 있습니다. value가 바뀌면 모든 소비자가 리렌더링됩니다.\n- 컴포넌트 재사용성이 떨어질 수 있습니다. Context에 의존하게 됩니다.\n- 디버깅이 어려울 수 있습니다.\n- 복잡한 상태 관리에는 부적합합니다.\n- Redux 같은 전문 라이브러리가 더 나을 수 있습니다.\n\n**언제 Context를 사용하지 말아야 할까:**\n- 자주 변경되는 상태에는 적합하지 않습니다.\n- Props가 2-3 레벨만 전달되면 그냥 전달하는 게 낫습니다.\n- 복잡한 비즈니스 로직이 있으면 상태 관리 라이브러리를 고려합니다.\n- 성능이 중요한 부분에서는 신중해야 합니다.\n\n**실무 활용:**\n- 앱 전체 테마를 Context로 관리합니다.\n- 인증 상태를 Context에 저장합니다.\n- 여러 Context를 조합하여 사용합니다.\n- 성능을 위해 Context를 분리합니다.\n- 상황에 맞는 도구를 선택합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-whxjqo4zu",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Provider와 Consumer의 역할은 무엇인가요?",
      "answer": "**정의:**\nProvider는 Context 값을 제공하는 컴포넌트이고, Consumer는 그 값을 소비하는 컴포넌트입니다. Provider가 감싼 트리 내의 모든 Consumer가 Provider의 value에 접근할 수 있습니다.\n\n**Provider의 역할:**\n- Context 값을 하위 트리에 제공합니다.\n- value prop으로 전달할 데이터를 받습니다.\n- value가 변경되면 모든 구독자에게 알립니다.\n- 여러 Provider를 중첩할 수 있습니다.\n- 가장 가까운 Provider의 값이 사용됩니다.\n\n**Provider 사용 방법:**\n- Context.Provider로 컴포넌트를 감쌉니다.\n- value prop에 공유할 데이터를 전달합니다.\n- children을 렌더링합니다.\n- 보통 앱의 최상위나 필요한 부분에 배치합니다.\n\n**Provider value 최적화:**\n- value가 객체면 메모이제이션해야 합니다.\n- 렌더링마다 새 객체를 만들면 모든 구독자가 리렌더링됩니다.\n- useMemo로 value를 메모이제이션합니다.\n- 의존성이 변경될 때만 새 객체를 생성합니다.\n\n**Consumer의 역할:**\n- Provider가 제공한 값을 읽습니다.\n- 가장 가까운 Provider의 값을 사용합니다.\n- Provider가 없으면 createContext의 기본값을 사용합니다.\n- value가 변경되면 자동으로 리렌더링됩니다.\n\n**Consumer 사용 방법:**\n- Context.Consumer를 사용합니다.\n- children으로 함수를 전달합니다. Render Props 패턴입니다.\n- 함수가 현재 Context 값을 인자로 받습니다.\n- 함수가 JSX를 반환합니다.\n- 클래스 컴포넌트에서 주로 사용됩니다.\n\n**useContext Hook:**\n- Consumer를 대체하는 더 간단한 방법입니다.\n- 함수형 컴포넌트에서 사용합니다.\n- Context 객체를 인자로 받습니다.\n- 현재 Context 값을 직접 반환합니다.\n- Consumer보다 코드가 깔끔합니다.\n\n**Provider 중첩:**\n- 여러 Context를 사용할 수 있습니다.\n- Provider를 중첩하여 여러 값을 제공합니다.\n- 각 Context는 독립적입니다.\n- 같은 Context의 Provider를 중첩하면 가장 가까운 것이 우선입니다.\n\n**기본값의 역할:**\n- createContext의 인자로 전달합니다.\n- Provider가 없을 때 사용됩니다.\n- 컴포넌트를 독립적으로 테스트할 때 유용합니다.\n- 실제 앱에서는 Provider를 항상 사용하는 것이 좋습니다.\n\n**다중 Provider 패턴:**\n- 여러 Provider를 조합합니다.\n- 관심사별로 Context를 분리합니다.\n- Provider 컴포넌트를 만들어 중첩을 추상화합니다.\n- 코드 가독성이 향상됩니다.\n\n**실무 활용:**\n- AuthProvider로 인증 정보를 제공합니다.\n- ThemeProvider로 테마를 제공합니다.\n- 각 Provider는 관련 로직을 캡슐화합니다.\n- useContext로 값을 읽어 사용합니다.\n- value를 항상 메모이제이션하여 성능을 보장합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-nukr6xb9y",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Context API의 성능 문제와 해결 방법은 무엇인가요?",
      "answer": "**정의:**\nContext API의 주요 성능 문제는 Provider의 value가 변경되면 해당 Context를 구독하는 모든 컴포넌트가 리렌더링된다는 것입니다. 이를 해결하기 위한 여러 최적화 기법이 있습니다.\n\n**주요 성능 문제:**\n- value 변경 시 모든 구독자가 리렌더링됩니다.\n- 필요하지 않은 컴포넌트도 리렌더링될 수 있습니다.\n- 자주 변경되는 값에는 적합하지 않습니다.\n- 중간 컴포넌트의 최적화를 무시합니다.\n- 큰 앱에서 성능 병목이 될 수 있습니다.\n\n**해결 방법 1: Context 분리:**\n- 자주 변경되는 값과 그렇지 않은 값을 분리합니다.\n- 여러 개의 작은 Context를 만듭니다.\n- 각 컴포넌트는 필요한 Context만 구독합니다.\n- 변경 영향 범위를 최소화합니다.\n\n**해결 방법 2: value 메모이제이션:**\n- useMemo로 Provider value를 메모이제이션합니다.\n- 의존성이 변경될 때만 새 객체를 생성합니다.\n- 불필요한 리렌더링을 방지합니다.\n- 반드시 적용해야 하는 기본 최적화입니다.\n\n**해결 방법 3: 컴포넌트 최적화:**\n- React.memo로 구독 컴포넌트를 감쌉니다.\n- props가 변경되지 않으면 리렌더링을 건너뜁니다.\n- Context 값 외의 리렌더링을 방지합니다.\n- 선택적으로 적용합니다.\n\n**해결 방법 4: Composition 활용:**\n- children을 Provider 외부에서 생성합니다.\n- Provider가 리렌더링되어도 children은 영향받지 않습니다.\n- 구조를 잘 설계하면 많은 최적화가 자동으로 됩니다.\n\n**해결 방법 5: Selector 패턴:**\n- Context에서 필요한 부분만 선택하는 함수를 만듭니다.\n- 선택한 값이 변경될 때만 리렌더링합니다.\n- use-context-selector 같은 라이브러리를 사용합니다.\n- Redux의 useSelector와 유사한 방식입니다.\n\n**해결 방법 6: 상태 관리 라이브러리 사용:**\n- 복잡한 전역 상태는 Redux Zustand Recoil을 고려합니다.\n- 선택적 구독이 가능합니다.\n- 성능 최적화가 내장되어 있습니다.\n- 개발자 도구가 풍부합니다.\n\n**측정과 프로파일링:**\n- React DevTools Profiler로 리렌더링을 분석합니다.\n- 실제로 문제가 있는지 확인합니다.\n- 추측하지 말고 측정합니다.\n- 병목 지점을 찾아 집중적으로 최적화합니다.\n\n**언제 최적화할까:**\n- 성능 문제가 실제로 관찰될 때입니다.\n- 많은 컴포넌트가 같은 Context를 구독할 때입니다.\n- Context 값이 자주 변경될 때입니다.\n- 사용자 경험에 영향을 줄 때입니다.\n\n**실무 활용:**\n- 테마 Context는 거의 변경되지 않아 최적화가 덜 필요합니다.\n- 폼 상태 Context는 자주 변경되어 분리가 필요합니다.\n- value를 항상 메모이제이션합니다.\n- Context 수를 적절히 분리합니다.\n- 필요하면 전문 상태 관리 라이브러리로 전환합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "performance"
      ],
      "id": "1763441901803-9tdfpvcrz",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Ref는 언제 사용하나요?",
      "answer": "**정의:**\nRef는 렌더링에 필요하지 않은 값을 저장하거나 DOM 요소에 직접 접근하기 위한 React의 기능입니다. useRef Hook이나 createRef로 생성하며, 변경해도 리렌더링을 유발하지 않습니다.\n\n**Ref의 주요 용도:**\n- DOM 요소에 직접 접근합니다. input에 포커스를 주거나 스크롤 위치를 제어합니다.\n- 렌더링과 무관한 값을 저장합니다. 타이머 ID 이전 값 등입니다.\n- 인스턴스 변수처럼 사용합니다. 클래스의 this.x와 유사합니다.\n- 변경 가능한 값이 필요하지만 리렌더링은 원하지 않을 때 사용합니다.\n\n**DOM 접근 사례:**\n- input이나 textarea에 포커스를 설정합니다.\n- 스크롤 위치를 읽거나 설정합니다.\n- 요소의 크기나 위치를 측정합니다.\n- 비디오나 오디오를 제어합니다.\n- 캔버스에 그림을 그립니다.\n- 애니메이션을 직접 제어합니다.\n\n**값 저장 사례:**\n- setInterval이나 setTimeout의 ID를 저장합니다.\n- WebSocket 연결 객체를 보관합니다.\n- 이전 props나 state 값을 추적합니다.\n- 렌더링 횟수를 카운트합니다.\n- 외부 라이브러리 인스턴스를 저장합니다.\n\n**useRef vs useState:**\n- useRef는 변경 시 리렌더링하지 않습니다. useState는 리렌더링합니다.\n- useRef는 동기적으로 즉시 업데이트됩니다. useState는 비동기입니다.\n- useRef는 렌더링과 무관한 값용입니다. useState는 화면에 보이는 데이터용입니다.\n- useRef.current는 직접 수정 가능합니다. state는 불변성을 지켜야 합니다.\n\n**Ref 사용 시 주의사항:**\n- 렌더링 중에 ref.current를 읽거나 쓰면 안 됩니다. 순수성을 해칩니다.\n- 이벤트 핸들러나 useEffect에서만 사용합니다.\n- Ref 변경으로 리렌더링을 유발하고 싶다면 state를 사용해야 합니다.\n- DOM 조작은 최소화하고 선언적 방식을 우선합니다.\n\n**forwardRef와 함께 사용:**\n- 부모가 자식의 DOM 노드에 접근해야 할 때 사용합니다.\n- 자식 컴포넌트를 forwardRef로 감쌉니다.\n- ref를 두 번째 인자로 받습니다.\n- DOM 요소에 ref를 연결합니다.\n- 재사용 가능한 컴포넌트 라이브러리에서 필수입니다.\n\n**callback ref:**\n- 함수를 ref prop에 전달할 수 있습니다.\n- DOM 노드가 마운트되면 함수가 호출됩니다.\n- 언마운트되면 null로 호출됩니다.\n- 동적인 ref 관리가 필요할 때 유용합니다.\n\n**실무 활용:**\n- 폼 제출 시 첫 번째 에러 필드로 포커스를 이동합니다.\n- 무한 스크롤을 구현할 때 스크롤 위치를 추적합니다.\n- 차트 라이브러리를 초기화하고 인스턴스를 저장합니다.\n- 디바운스 타이머 ID를 저장하여 정리합니다.\n- 선언적 방식으로 해결 안 되는 경우에만 사용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-rrg2huctk",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "forwardRef는 무엇이고 왜 필요한가요?",
      "answer": "**정의:**\nforwardRef는 부모 컴포넌트가 자식 컴포넌트의 DOM 노드나 컴포넌트 인스턴스에 접근할 수 있게 해주는 React API입니다. ref를 일반 prop처럼 전달할 수 없는 문제를 해결합니다.\n\n**ref 전달 문제:**\n- ref는 특별한 prop이라 일반적으로 전달되지 않습니다.\n- props.ref로 접근할 수 없습니다.\n- React가 내부적으로 처리하기 때문입니다.\n- 컴포넌트를 감싸면 ref가 래퍼를 가리킵니다.\n- 내부 DOM 요소에 접근하려면 forwardRef가 필요합니다.\n\n**forwardRef 사용 방법:**\n- 컴포넌트를 forwardRef로 감쌉니다.\n- 두 번째 매개변수로 ref를 받습니다.\n- 첫 번째는 props, 두 번째는 ref입니다.\n- ref를 DOM 요소나 useImperativeHandle에 전달합니다.\n- 부모는 일반적인 방식으로 ref를 사용합니다.\n\n**forwardRef가 필요한 경우:**\n- 재사용 가능한 컴포넌트 라이브러리를 만들 때입니다.\n- HOC로 컴포넌트를 감쌀 때 ref를 전달해야 합니다.\n- 입력 컴포넌트에서 DOM 요소에 직접 접근해야 할 때입니다.\n- 부모가 자식의 DOM을 제어해야 할 때입니다.\n\n**재사용 가능한 컴포넌트:**\n- Input, Button 같은 기본 컴포넌트에 사용합니다.\n- 라이브러리 사용자가 ref로 DOM에 접근할 수 있게 합니다.\n- 포커스 제어나 측정이 가능해집니다.\n- 디자인 시스템 구축 시 필수적입니다.\n\n**HOC와 forwardRef:**\n- HOC는 컴포넌트를 감싸므로 ref가 HOC를 가리킵니다.\n- forwardRef로 내부 컴포넌트에 ref를 전달합니다.\n- React.forwardRef를 HOC 내부에서 사용합니다.\n- 원래 컴포넌트의 ref 동작을 유지합니다.\n\n**TypeScript와 함께 사용:**\n- 제네릭 타입을 사용하여 타입을 정의합니다.\n- ref 타입을 명시적으로 지정합니다.\n- props 타입도 함께 정의합니다.\n- 타입 안전성을 보장합니다.\n\n**displayName 설정:**\n- forwardRef로 감싸면 컴포넌트 이름이 사라집니다.\n- displayName을 설정하여 디버깅을 쉽게 합니다.\n- React DevTools에 표시됩니다.\n- 개발 환경에서 유용합니다.\n\n**useImperativeHandle과 조합:**\n- forwardRef와 함께 자주 사용됩니다.\n- 부모에게 노출할 메서드를 제어합니다.\n- 전체 DOM이 아닌 일부 기능만 공개합니다.\n- 캡슐화를 유지하면서 필요한 기능을 제공합니다.\n\n**실무 활용:**\n- UI 라이브러리의 기본 컴포넌트에 적용합니다.\n- 커스텀 Input 컴포넌트에서 포커스를 제어합니다.\n- 모달이나 드롭다운에서 첫 요소로 포커스를 이동합니다.\n- HOC나 래퍼 컴포넌트에서 ref를 전달합니다.\n- 재사용 가능한 컴포넌트를 만들 때 반드시 고려합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-71uj90utf",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useImperativeHandle은 언제 사용하나요?",
      "answer": "**정의:**\nuseImperativeHandle은 부모 컴포넌트에 노출할 인스턴스 값을 커스터마이징하는 Hook입니다. forwardRef와 함께 사용하여 ref로 접근 가능한 메서드를 제어합니다.\n\n**기본 개념:**\n- ref를 통해 노출할 값을 정의합니다.\n- forwardRef와 함께 사용해야 합니다.\n- 전체 DOM 대신 특정 메서드만 공개합니다.\n- 컴포넌트의 내부 구현을 숨깁니다.\n- 명령형 API를 제공합니다.\n\n**사용 방법:**\n- 첫 번째 인자는 forwardRef로 받은 ref입니다.\n- 두 번째 인자는 노출할 값을 반환하는 함수입니다.\n- 세 번째 인자는 의존성 배열입니다. 선택사항입니다.\n- 반환 객체의 메서드를 부모가 호출할 수 있습니다.\n\n**왜 사용할까:**\n- DOM 전체를 노출하고 싶지 않을 때입니다.\n- 추상화 레벨을 유지하고 싶을 때입니다.\n- 컴포넌트의 공개 API를 명확히 정의할 때입니다.\n- 내부 구현을 변경해도 공개 API는 유지할 때입니다.\n- 선언적 방식으로 불가능한 작업을 명령형으로 제공할 때입니다.\n\n**일반적인 사용 사례:**\n- 커스텀 Input에서 focus와 blur만 노출합니다.\n- 비디오 플레이어에서 play pause stop 메서드를 제공합니다.\n- 모달에서 open과 close 메서드를 제공합니다.\n- 애니메이션 컴포넌트에서 start stop reset 메서드를 제공합니다.\n\n**캡슐화와 추상화:**\n- 내부 DOM 구조를 숨깁니다.\n- 필요한 기능만 선택적으로 노출합니다.\n- 컴포넌트 내부를 자유롭게 리팩토링할 수 있습니다.\n- 외부 의존성을 줄입니다.\n- 더 나은 API를 설계할 수 있습니다.\n\n**의존성 배열:**\n- 세 번째 인자로 전달합니다.\n- 의존성이 변경되면 노출된 값이 업데이트됩니다.\n- 생략하면 매 렌더링마다 재생성됩니다.\n- 성능 최적화를 위해 사용합니다.\n\n**남용하지 말아야 할 이유:**\n- 선언적 React의 원칙에 어긋납니다.\n- props로 해결 가능하면 props를 사용합니다.\n- 과도한 명령형 코드는 유지보수를 어렵게 합니다.\n- 정말 필요한 경우에만 사용합니다.\n\n**대안 고려:**\n- 대부분의 경우 props로 충분합니다.\n- 상태를 끌어올려서 부모가 제어하게 합니다.\n- 콜백 props로 이벤트를 전달합니다.\n- useImperativeHandle은 최후의 수단입니다.\n\n**실무 활용:**\n- 폼 라이브러리에서 submit과 reset 메서드를 노출합니다.\n- 커스텀 에디터에서 getValue와 setValue를 제공합니다.\n- 복잡한 위젯에서 제어 메서드를 제공합니다.\n- 라이브러리 컴포넌트에서 공개 API를 정의합니다.\n- 선언적으로 불가능한 작업만 명령형으로 제공합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-shshw91xw",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React Router의 주요 컴포넌트와 기능은 무엇인가요?",
      "answer": "**정의:**\nReact Router는 React 애플리케이션에서 라우팅을 구현하는 가장 인기 있는 라이브러리입니다. 클라이언트 사이드 라우팅을 제공하여 싱글 페이지 애플리케이션에서 페이지 간 탐색을 가능하게 합니다.\n\n**주요 컴포넌트:**\n- BrowserRouter: HTML5 History API를 사용하는 라우터입니다. 가장 일반적으로 사용됩니다.\n- Routes: 여러 Route를 그룹화합니다. v6에서 Switch를 대체했습니다.\n- Route: 경로와 컴포넌트를 매핑합니다. path와 element props를 받습니다.\n- Link: 클라이언트 사이드 탐색을 위한 링크입니다. 페이지 새로고침 없이 이동합니다.\n- NavLink: 활성 상태 스타일링이 가능한 Link입니다.\n- Navigate: 리다이렉트를 수행합니다. v6에서 Redirect를 대체했습니다.\n- Outlet: 중첩 라우트에서 자식을 렌더링합니다.\n\n**라우터 종류:**\n- BrowserRouter: 일반적인 웹 앱에 사용합니다. 깔끔한 URL을 제공합니다.\n- HashRouter: Hash 기반 라우팅입니다. 오래된 브라우저나 정적 서버에 적합합니다.\n- MemoryRouter: 메모리에 히스토리를 저장합니다. 테스트나 React Native에 사용합니다.\n- StaticRouter: 서버 사이드 렌더링에 사용합니다.\n\n**경로 매칭:**\n- 정확한 경로를 먼저 매칭합니다. v6는 자동으로 최적 매칭을 찾습니다.\n- 동적 세그먼트를 지원합니다. :id 형태로 사용합니다.\n- 와일드카드를 지원합니다. 애스터리스크로 모든 경로를 매칭합니다.\n- 중첩 라우트를 지원합니다. 레이아웃과 페이지를 분리합니다.\n\n**Hooks:**\n- useNavigate: 프로그래매틱 탐색을 수행합니다. v6에서 useHistory를 대체했습니다.\n- useParams: URL 파라미터에 접근합니다. 동적 라우트의 값을 읽습니다.\n- useLocation: 현재 위치 객체에 접근합니다. pathname, search, hash 등을 포함합니다.\n- useSearchParams: 쿼리 스트링을 읽고 수정합니다.\n- useMatch: 현재 경로가 특정 패턴과 일치하는지 확인합니다.\n\n**중첩 라우트:**\n- 레이아웃과 페이지를 분리합니다.\n- 부모 Route 안에 자식 Route를 정의합니다.\n- Outlet으로 자식을 렌더링할 위치를 지정합니다.\n- 공통 레이아웃을 재사용합니다.\n\n**보호된 라우트:**\n- 인증이 필요한 페이지를 보호합니다.\n- 조건부로 Navigate를 렌더링합니다.\n- 커스텀 컴포넌트로 래핑합니다.\n- 권한을 체크하고 리다이렉트합니다.\n\n**코드 스플리팅:**\n- React.lazy로 라우트 컴포넌트를 동적 임포트합니다.\n- Suspense로 로딩 상태를 처리합니다.\n- 초기 번들 크기를 줄입니다.\n- 사용자가 방문한 페이지만 로드합니다.\n\n**실무 활용:**\n- SPA의 페이지 탐색을 구현합니다.\n- 중첩 라우트로 복잡한 레이아웃을 관리합니다.\n- 동적 라우트로 상세 페이지를 구현합니다.\n- 보호된 라우트로 인증을 처리합니다.\n- v6의 새로운 API를 사용하여 더 간결한 코드를 작성합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "component"
      ],
      "id": "1763441901803-m9bj49o42",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "동적 라우팅(Dynamic Routing)은 어떻게 구현하나요?",
      "answer": "**정의:**\n동적 라우팅은 URL의 일부를 변수로 사용하여 다양한 콘텐츠를 같은 컴포넌트로 렌더링하는 방식입니다. React Router에서 경로 파라미터를 사용하여 구현합니다.\n\n**경로 파라미터 정의:**\n- 콜론을 사용하여 동적 세그먼트를 정의합니다.\n- /users/:id 형태로 작성합니다.\n- 여러 파라미터를 사용할 수 있습니다. /posts/:category/:id 같은 형태입니다.\n- 선택적 파라미터도 가능합니다.\n\n**useParams Hook 사용:**\n- URL 파라미터 값을 읽습니다.\n- 객체로 모든 파라미터를 반환합니다.\n- 키는 경로에 정의한 파라미터 이름입니다.\n- 컴포넌트 어디서든 사용할 수 있습니다.\n\n**파라미터 활용:**\n- API 호출에 사용합니다. 특정 리소스를 가져옵니다.\n- 데이터 필터링에 사용합니다.\n- 조건부 렌더링에 활용합니다.\n- useEffect의 의존성으로 사용하여 파라미터 변경을 감지합니다.\n\n**쿼리 파라미터:**\n- useSearchParams Hook을 사용합니다.\n- 검색 필터나 페이지네이션에 활용합니다.\n- get 메서드로 값을 읽습니다.\n- set 메서드로 값을 업데이트합니다.\n- URL과 상태를 동기화합니다.\n\n**동적 링크 생성:**\n- Link의 to prop에 동적 값을 전달합니다.\n- 템플릿 리터럴로 URL을 구성합니다.\n- map으로 여러 링크를 생성합니다.\n- 목록에서 상세 페이지로 이동할 때 사용합니다.\n\n**중첩 동적 라우트:**\n- 부모와 자식 모두 동적 파라미터를 가질 수 있습니다.\n- /categories/:categoryId/products/:productId 같은 형태입니다.\n- useParams는 모든 파라미터를 포함합니다.\n- 계층 구조를 URL에 반영합니다.\n\n**데이터 로딩:**\n- useParams로 ID를 받습니다.\n- useEffect에서 API를 호출합니다.\n- 로딩과 에러 상태를 관리합니다.\n- ID가 변경되면 새 데이터를 가져옵니다.\n\n**유효성 검사:**\n- 파라미터 값의 유효성을 확인합니다.\n- 잘못된 값이면 404 페이지로 리다이렉트합니다.\n- 숫자가 필요한 곳에 문자가 오면 처리합니다.\n- 사용자 입력을 신뢰하지 않습니다.\n\n**실무 활용:**\n- 블로그 게시물 상세 페이지를 구현합니다. /posts/:id 형태입니다.\n- 사용자 프로필 페이지를 만듭니다. /users/:username 형태입니다.\n- 전자상거래 상품 페이지를 만듭니다. /products/:id 형태입니다.\n- 쿼리 파라미터로 검색과 필터를 구현합니다.\n- URL을 북마크 가능하게 만들어 공유하기 쉽게 합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-ff7cebu3f",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "프로그래매틱 네비게이션(Programmatic Navigation)은 어떻게 구현하나요?",
      "answer": "**정의:**\n프로그래매틱 네비게이션은 Link 컴포넌트가 아닌 JavaScript 코드로 페이지를 이동하는 방식입니다. React Router의 useNavigate Hook을 사용하여 구현합니다.\n\n**useNavigate Hook:**\n- 탐색 함수를 반환합니다.\n- 함수를 호출하여 다른 경로로 이동합니다.\n- v6에서 useHistory를 대체했습니다.\n- 더 간단하고 직관적인 API를 제공합니다.\n\n**기본 사용법:**\n- useNavigate를 호출하여 함수를 받습니다.\n- 경로를 인자로 전달하여 이동합니다.\n- 상대 경로나 절대 경로를 사용할 수 있습니다.\n- 이벤트 핸들러나 useEffect에서 호출합니다.\n\n**언제 사용할까:**\n- 폼 제출 후 다른 페이지로 이동할 때입니다.\n- 로그인 성공 후 대시보드로 리다이렉트합니다.\n- 조건부로 페이지를 이동해야 할 때입니다.\n- 타이머 후 자동으로 이동할 때입니다.\n- API 응답에 따라 다른 페이지로 이동합니다.\n\n**뒤로 가기와 앞으로 가기:**\n- 음수를 전달하면 뒤로 갑니다. navigate(-1)은 한 페이지 뒤로입니다.\n- 양수를 전달하면 앞으로 갑니다.\n- 브라우저의 뒤로 가기 버튼과 동일하게 동작합니다.\n- 히스토리 스택을 활용합니다.\n\n**replace 옵션:**\n- 두 번째 인자로 옵션 객체를 전달합니다.\n- replace: true로 설정하면 히스토리를 대체합니다.\n- 새 엔트리를 추가하지 않고 현재를 교체합니다.\n- 뒤로 가기로 돌아갈 수 없게 됩니다.\n- 로그인 후 리다이렉트에 유용합니다.\n\n**state 전달:**\n- 두 번째 인자의 state로 데이터를 전달할 수 있습니다.\n- useLocation으로 전달받은 state에 접근합니다.\n- URL에 노출되지 않는 데이터를 전달합니다.\n- 이전 페이지 정보나 메시지를 전달합니다.\n\n**조건부 탐색:**\n- if 문으로 조건을 확인합니다.\n- API 응답 성공 여부에 따라 이동합니다.\n- 인증 상태를 확인하고 리다이렉트합니다.\n- 유효성 검사 통과 시에만 이동합니다.\n\n**Navigate 컴포넌트:**\n- 선언적으로 리다이렉트할 수 있습니다.\n- 렌더링 중에 사용합니다.\n- to prop에 목적지를 지정합니다.\n- replace prop으로 히스토리 대체 여부를 결정합니다.\n- 조건부 렌더링과 함께 사용합니다.\n\n**실무 활용:**\n- 로그인 성공 후 메인 페이지로 이동합니다.\n- 폼 제출 후 목록 페이지로 이동합니다.\n- 결제 완료 후 완료 페이지로 이동합니다.\n- 권한 없는 사용자를 로그인 페이지로 리다이렉트합니다.\n- 404 에러 발생 시 에러 페이지로 이동합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-lohgkp77o",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Redux의 동작 원리와 주요 개념은 무엇인가요?",
      "answer": "**정의:**\nRedux는 JavaScript 애플리케이션의 상태를 관리하는 예측 가능한 상태 컨테이너입니다. Flux 아키텍처를 기반으로 하며, 단일 스토어와 단방향 데이터 흐름을 사용합니다.\n\n**Redux의 세 가지 원칙:**\n- 단일 진실 공급원: 모든 상태를 하나의 스토어에 저장합니다.\n- 상태는 읽기 전용: 액션을 디스패치해야만 변경할 수 있습니다.\n- 순수 함수로 변경: 리듀서는 이전 상태와 액션을 받아 새 상태를 반환합니다.\n\n**주요 개념:**\n- Store: 상태를 보관하는 객체입니다. 앱 전체에 하나만 존재합니다.\n- Action: 무슨 일이 일어났는지 설명하는 객체입니다. type 필드를 반드시 가집니다.\n- Reducer: 액션과 이전 상태를 받아 새 상태를 반환하는 순수 함수입니다.\n- Dispatch: 액션을 스토어에 전달하는 함수입니다.\n\n**데이터 흐름:**\n- 사용자 인터랙션이나 이벤트가 발생합니다.\n- 액션을 디스패치합니다.\n- 리듀서가 액션을 받아 새 상태를 계산합니다.\n- 스토어가 상태를 업데이트합니다.\n- 구독 중인 컴포넌트가 리렌더링됩니다.\n\n**Reducer 작성:**\n- switch 문으로 액션 타입을 분기합니다.\n- 새 상태 객체를 반환합니다. 불변성을 유지합니다.\n- 이전 상태를 직접 수정하면 안 됩니다.\n- default 케이스에서 이전 상태를 반환합니다.\n- 순수 함수여야 합니다. 부작용이 없어야 합니다.\n\n**Action Creator:**\n- 액션을 생성하는 함수입니다.\n- 액션 객체를 반환합니다.\n- 일관성과 재사용성을 높입니다.\n- 타입 실수를 줄입니다.\n\n**Store 생성과 사용:**\n- createStore로 스토어를 만듭니다. 리듀서를 전달합니다.\n- Provider로 React 앱을 감쌉니다.\n- useSelector로 상태를 읽습니다.\n- useDispatch로 액션을 디스패치합니다.\n\n**미들웨어:**\n- Redux의 확장 포인트입니다.\n- 액션과 리듀서 사이에 위치합니다.\n- 로깅 비동기 처리 등을 수행합니다.\n- Redux Thunk와 Redux Saga가 유명합니다.\n\n**Redux의 장점:**\n- 예측 가능한 상태 관리입니다.\n- 디버깅이 쉽습니다. DevTools로 시간 여행이 가능합니다.\n- 테스트하기 쉽습니다. 순수 함수로 구성됩니다.\n- 미들웨어로 확장 가능합니다.\n- 커뮤니티와 생태계가 방대합니다.\n\n**Redux의 단점:**\n- 보일러플레이트가 많습니다.\n- 작은 앱에는 과도할 수 있습니다.\n- 러닝 커브가 있습니다.\n- 간단한 상태는 Context로 충분합니다.\n\n**실무 활용:**\n- 대규모 애플리케이션의 상태를 관리합니다.\n- 복잡한 상태 로직을 체계적으로 관리합니다.\n- Redux Toolkit을 사용하여 보일러플레이트를 줄입니다.\n- 미들웨어로 비동기 로직을 처리합니다.\n- DevTools로 상태 변화를 추적하고 디버깅합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-5om7pp5nl",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Redux Toolkit은 무엇이고 왜 사용하나요?",
      "answer": "**정의:**\nRedux Toolkit은 Redux 공식 권장 도구 세트로, Redux를 더 쉽고 효율적으로 사용하기 위한 라이브러리입니다. 보일러플레이트를 줄이고 모범 사례를 내장하여 개발 경험을 향상시킵니다.\n\n**Redux Toolkit이 해결하는 문제:**\n- Redux 설정이 너무 복잡합니다.\n- 보일러플레이트 코드가 많습니다.\n- 불변성 관리가 번거롭습니다.\n- 미들웨어 설정이 어렵습니다.\n- 액션과 리듀서를 따로 관리해야 합니다.\n\n**주요 API:**\n- configureStore: 스토어를 간편하게 설정합니다. 미들웨어와 DevTools가 자동으로 포함됩니다.\n- createSlice: 리듀서와 액션을 한번에 생성합니다. 가장 강력한 기능입니다.\n- createAsyncThunk: 비동기 액션을 쉽게 만듭니다.\n- createEntityAdapter: 정규화된 상태를 관리합니다.\n\n**createSlice의 장점:**\n- 리듀서와 액션 생성자를 함께 정의합니다.\n- Immer가 내장되어 불변성을 자동으로 처리합니다.\n- 액션 타입을 자동 생성합니다.\n- 보일러플레이트가 크게 줄어듭니다.\n- 코드가 간결하고 읽기 쉽습니다.\n\n**Immer 통합:**\n- 상태를 직접 수정하는 것처럼 쓸 수 있습니다.\n- 내부적으로 불변 업데이트로 변환됩니다.\n- 중첩된 객체 업데이트가 쉬워집니다.\n- 실수로 mutate 해도 안전합니다.\n\n**configureStore 기능:**\n- 미들웨어를 자동으로 추가합니다. Redux Thunk가 기본 포함됩니다.\n- Redux DevTools가 자동 활성화됩니다.\n- 일반적인 실수를 경고합니다.\n- 개발 환경에서 유용한 체크를 수행합니다.\n\n**createAsyncThunk:**\n- 비동기 로직을 간단하게 작성합니다.\n- pending fulfilled rejected 액션을 자동 생성합니다.\n- 로딩 상태를 쉽게 관리할 수 있습니다.\n- 에러 처리가 일관성 있게 됩니다.\n\n**RTK Query:**\n- 데이터 페칭과 캐싱을 자동화합니다.\n- API 엔드포인트를 선언적으로 정의합니다.\n- 로딩 상태와 에러를 자동 관리합니다.\n- 캐시 무효화와 재검증을 지원합니다.\n- React Query와 유사한 기능을 제공합니다.\n\n**TypeScript 지원:**\n- 타입 추론이 우수합니다.\n- 최소한의 타입 정의로 충분합니다.\n- 자동 완성이 잘 됩니다.\n- 타입 안전성이 보장됩니다.\n\n**기존 Redux와의 비교:**\n- 코드량이 절반 이하로 줄어듭니다.\n- 불변성 관리가 자동화됩니다.\n- 설정이 훨씬 간단합니다.\n- 모범 사례가 기본으로 적용됩니다.\n- 러닝 커브가 낮아집니다.\n\n**실무 활용:**\n- 새 Redux 프로젝트는 Redux Toolkit을 사용합니다.\n- 기존 Redux를 점진적으로 마이그레이션합니다.\n- RTK Query로 API 호출을 관리합니다.\n- createSlice로 간결한 상태 관리를 합니다.\n- TypeScript와 함께 사용하여 타입 안전성을 얻습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-husvt7fxy",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Zustand, Recoil, Redux의 차이점과 선택 기준은 무엇인가요?",
      "answer": "**정의:**\nZustand, Recoil, Redux는 모두 React 상태 관리 라이브러리이지만, 각각 다른 철학과 접근 방식을 가지고 있습니다. 프로젝트 요구사항에 맞는 도구를 선택하는 것이 중요합니다.\n\n**Redux 특징:**\n- 가장 오래되고 널리 사용됩니다.\n- 단일 스토어에 모든 상태를 저장합니다.\n- 액션과 리듀서 패턴을 사용합니다.\n- 미들웨어로 확장 가능합니다.\n- 강력한 DevTools를 제공합니다.\n- Redux Toolkit으로 개선되었습니다.\n\n**Zustand 특징:**\n- 매우 작고 간단합니다. 번들 크기가 작습니다.\n- Hooks 기반 API입니다.\n- Provider가 필요 없습니다.\n- 보일러플레이트가 거의 없습니다.\n- 선택적 구독이 가능합니다.\n- 미들웨어를 지원합니다.\n\n**Recoil 특징:**\n- Facebook에서 만들었습니다.\n- Atom과 Selector 개념을 사용합니다.\n- React처럼 사용할 수 있습니다.\n- 분산된 상태 관리가 가능합니다.\n- 파생 상태를 쉽게 만듭니다.\n- 아직 실험적 단계입니다.\n\n**Redux 장점과 단점:**\n- 장점: 강력한 에코시스템, 예측 가능성, DevTools, 대규모 앱에 적합합니다.\n- 단점: 보일러플레이트가 많음, 러닝 커브, 작은 앱에 과도합니다.\n- 사용 시기: 복잡한 상태 로직, 팀이 익숙함, 디버깅이 중요함, 미들웨어 필요합니다.\n\n**Zustand 장점과 단점:**\n- 장점: 간단함, 작은 번들, 빠른 학습, Provider 불필요, 유연합니다.\n- 단점: 생태계가 작음, 고급 기능 부족, DevTools가 약합니다.\n- 사용 시기: 중소 규모 앱, 간단한 전역 상태, 빠른 프로토타이핑, Redux가 과도합니다.\n\n**Recoil 장점과 단점:**\n- 장점: React스러움, 파생 상태 쉬움, 분산 상태, 비동기 지원 좋습니다.\n- 단점: 아직 불안정, 생태계 작음, 프로덕션 사용 주의, 문서 부족입니다.\n- 사용 시기: Facebook 생태계, 복잡한 파생 상태, 실험적 프로젝트입니다.\n\n**선택 기준:**\n- 앱 규모: 작으면 Zustand, 크면 Redux입니다.\n- 복잡도: 간단하면 Zustand, 복잡하면 Redux입니다.\n- 팀 경험: 팀이 아는 것을 선택합니다.\n- 디버깅 중요도: Redux가 가장 강력합니다.\n- 번들 크기: Zustand가 가장 작습니다.\n\n**성능 비교:**\n- 모두 선택적 구독을 지원합니다.\n- Zustand가 가장 가볍고 빠릅니다.\n- Redux는 최적화가 잘 되어 있습니다.\n- Recoil은 세밀한 구독이 가능합니다.\n- 실제 차이는 크지 않습니다.\n\n**마이그레이션:**\n- Redux에서 Zustand로는 쉽게 이동 가능합니다.\n- Context에서 어느 것으로든 이동할 수 있습니다.\n- 점진적 도입이 가능합니다.\n- 한 프로젝트에 여러 개를 함께 사용할 수도 있습니다.\n\n**실무 활용:**\n- 대규모 엔터프라이즈 앱은 Redux를 선택합니다.\n- 중소 규모 프로젝트는 Zustand를 고려합니다.\n- Context로 시작하고 필요할 때 도입합니다.\n- 팀의 선호도와 프로젝트 특성을 고려합니다.\n- 과도한 도구를 사용하지 않습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-mr34bvpq9",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "CSR, SSR, SSG의 차이점은 무엇인가요?",
      "answer": "**정의:**\nCSR, SSR, SSG는 웹 애플리케이션의 렌더링 방식입니다. CSR은 클라이언트에서, SSR은 서버에서 요청마다, SSG는 빌드 시에 HTML을 생성합니다. 각각 장단점이 있으며 상황에 맞게 선택해야 합니다.\n\n**CSR (Client-Side Rendering):**\n- 브라우저에서 JavaScript로 HTML을 생성합니다.\n- 초기 HTML은 거의 비어 있습니다.\n- JavaScript가 다운로드되고 실행되면 UI가 렌더링됩니다.\n- Create React App의 기본 방식입니다.\n- SPA의 전통적인 방식입니다.\n\n**CSR의 장단점:**\n- 장점: 빠른 페이지 전환, 풍부한 인터랙션, 서버 부하 적음, 개발이 단순합니다.\n- 단점: 초기 로딩 느림, SEO 불리, JavaScript 필수, 느린 네트워크에서 문제입니다.\n- 적합한 경우: 대시보드, 관리자 페이지, SEO 불필요한 앱, 인터랙션 많은 앱입니다.\n\n**SSR (Server-Side Rendering):**\n- 서버에서 요청마다 HTML을 생성합니다.\n- 완전한 HTML이 클라이언트로 전송됩니다.\n- Hydration으로 인터랙티브하게 만듭니다.\n- Next.js의 getServerSideProps를 사용합니다.\n- 동적 데이터에 적합합니다.\n\n**SSR의 장단점:**\n- 장점: 빠른 초기 로딩, SEO 우수, 동적 데이터 가능, JavaScript 없이도 작동합니다.\n- 단점: 서버 부하 큼, TTFB 느릴 수 있음, 복잡한 설정, 비용 증가 가능합니다.\n- 적합한 경우: 전자상거래, 뉴스 사이트, 개인화된 콘텐츠, SEO 중요한 페이지입니다.\n\n**SSG (Static Site Generation):**\n- 빌드 타임에 HTML을 미리 생성합니다.\n- 정적 파일을 CDN에서 제공합니다.\n- 매우 빠른 로딩 속도를 제공합니다.\n- Next.js의 getStaticProps를 사용합니다.\n- JAMstack 아키텍처의 핵심입니다.\n\n**SSG의 장단점:**\n- 장점: 최고의 성능, 낮은 비용, 뛰어난 확장성, SEO 우수, 보안 좋습니다.\n- 단점: 빌드 시간 증가, 동적 데이터 불가, 업데이트 시 재빌드, 실시간 데이터 어려움입니다.\n- 적합한 경우: 블로그, 문서 사이트, 마케팅 페이지, 자주 변하지 않는 콘텐츠입니다.\n\n**ISR (Incremental Static Regeneration):**\n- SSG의 발전된 형태입니다.\n- 정적 페이지를 주기적으로 재생성합니다.\n- 최신 데이터를 유지하면서 성능도 좋습니다.\n- Next.js의 revalidate 옵션을 사용합니다.\n- SSG와 SSR의 장점을 결합합니다.\n\n**선택 기준:**\n- SEO가 중요한가: SSR이나 SSG를 선택합니다.\n- 데이터가 자주 변하는가: 자주 변하면 SSR, 아니면 SSG입니다.\n- 성능이 최우선인가: SSG가 가장 빠릅니다.\n- 서버 리소스 제한이 있는가: SSG가 가장 저렴합니다.\n- 개인화가 필요한가: SSR이 적합합니다.\n\n**하이브리드 접근:**\n- Next.js는 페이지별로 다른 방식을 선택할 수 있습니다.\n- 홈페이지는 SSG, 상품 상세는 SSR, 대시보드는 CSR을 사용합니다.\n- 각 페이지의 특성에 맞게 최적화합니다.\n- 유연성이 가장 큰 장점입니다.\n\n**실무 활용:**\n- 블로그는 SSG로 구축합니다.\n- 전자상거래 상품 목록은 SSR을 사용합니다.\n- 사용자 대시보드는 CSR로 충분합니다.\n- Next.js로 하이브리드 접근을 구현합니다.\n- 프로젝트 요구사항에 맞는 방식을 선택합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-kcx15zl52",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Next.js는 무엇이고 왜 사용하나요?",
      "answer": "**정의:**\nNext.js는 React 기반의 프레임워크로, SSR, SSG, ISR을 지원하며 프로덕션 환경에 최적화된 기능을 제공합니다. Vercel에서 개발했으며 풀스택 React 애플리케이션을 쉽게 구축할 수 있게 해줍니다.\n\n**Next.js의 핵심 기능:**\n- 하이브리드 렌더링: 페이지별로 SSR, SSG, CSR을 선택할 수 있습니다.\n- 파일 시스템 기반 라우팅: 파일 구조가 곧 라우트입니다.\n- API 라우트: 서버리스 API를 쉽게 만들 수 있습니다.\n- 자동 코드 스플리팅: 페이지별로 번들이 자동 분리됩니다.\n- 이미지 최적화: next/image로 이미지를 자동 최적화합니다.\n- TypeScript 지원: 설정 없이 바로 사용 가능합니다.\n\n**왜 Next.js를 사용할까:**\n- SEO가 중요한 사이트를 만들 때입니다.\n- 초기 로딩 속도가 중요할 때입니다.\n- 서버와 클라이언트 코드를 함께 관리하고 싶을 때입니다.\n- 라우팅 설정을 간소화하고 싶을 때입니다.\n- 프로덕션 최적화를 자동으로 하고 싶을 때입니다.\n\n**파일 시스템 라우팅:**\n- pages 디렉토리의 구조가 URL이 됩니다.\n- pages/about.js는 /about 경로가 됩니다.\n- pages/blog/[id].js는 동적 라우트입니다.\n- React Router 설정이 필요 없습니다.\n- 직관적이고 관리하기 쉽습니다.\n\n**데이터 페칭 메서드:**\n- getServerSideProps: 요청마다 서버에서 데이터를 가져옵니다.\n- getStaticProps: 빌드 시 데이터를 가져옵니다.\n- getStaticPaths: 동적 SSG 경로를 정의합니다.\n- 페이지 컴포넌트에서만 사용 가능합니다.\n\n**API 라우트:**\n- pages/api 디렉토리에 API를 만듭니다.\n- 서버리스 함수로 배포됩니다.\n- 별도 백엔드 없이 API를 구현할 수 있습니다.\n- 데이터베이스와 직접 연결 가능합니다.\n- 간단한 백엔드 로직에 적합합니다.\n\n**이미지 최적화:**\n- next/image 컴포넌트를 사용합니다.\n- 자동으로 크기를 조정하고 형식을 변환합니다.\n- 지연 로딩을 기본 제공합니다.\n- WebP 같은 최신 형식을 자동 지원합니다.\n- 성능이 크게 향상됩니다.\n\n**자동 최적화:**\n- 코드 스플리팅이 자동으로 됩니다.\n- Tree shaking으로 불필요한 코드를 제거합니다.\n- CSS와 폰트를 최적화합니다.\n- 프리페칭으로 페이지 전환을 빠르게 합니다.\n- 프로덕션 빌드가 고도로 최적화됩니다.\n\n**배포:**\n- Vercel에 원클릭 배포가 가능합니다.\n- 자동 HTTPS와 CDN을 제공받습니다.\n- Git과 연동되어 자동 배포됩니다.\n- 프리뷰 배포로 PR을 미리 확인할 수 있습니다.\n- 다른 플랫폼에도 배포 가능합니다.\n\n**실무 활용:**\n- 기업 웹사이트를 Next.js로 구축합니다.\n- 전자상거래 플랫폼에 적합합니다.\n- 블로그와 콘텐츠 사이트를 만듭니다.\n- SEO가 중요한 마케팅 페이지를 제작합니다.\n- React의 강력함과 SEO를 동시에 얻습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-xae4ar91y",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "getServerSideProps와 getStaticProps의 차이점은 무엇인가요?",
      "answer": "**정의:**\ngetServerSideProps와 getStaticProps는 Next.js에서 데이터를 페칭하는 메서드입니다. getServerSideProps는 요청마다 실행되고, getStaticProps는 빌드 시 한 번만 실행됩니다.\n\n**getServerSideProps 특징:**\n- 매 요청마다 서버에서 실행됩니다.\n- 항상 최신 데이터를 가져올 수 있습니다.\n- context 객체로 쿠키, 쿼리 등에 접근합니다.\n- 서버에서만 실행되므로 데이터베이스 직접 접근 가능합니다.\n- props를 반환하여 페이지에 전달합니다.\n\n**getServerSideProps 사용 시기:**\n- 데이터가 자주 변경될 때입니다.\n- 요청별로 다른 데이터를 보여줘야 할 때입니다.\n- 사용자별 개인화된 콘텐츠가 필요할 때입니다.\n- 쿠키나 헤더를 확인해야 할 때입니다.\n- 실시간성이 중요할 때입니다.\n\n**getServerSideProps 장단점:**\n- 장점: 항상 최신 데이터, 동적 콘텐츠 가능, 사용자 정보 활용 가능합니다.\n- 단점: 서버 부하, TTFB 증가, CDN 캐싱 불가, 비용 높을 수 있습니다.\n- 성능: SSG보다 느리지만 CSR보다 초기 로딩은 빠릅니다.\n\n**getStaticProps 특징:**\n- 빌드 타임에 한 번만 실행됩니다.\n- 정적 HTML 파일을 생성합니다.\n- CDN에서 제공되어 매우 빠릅니다.\n- 개발 모드에서는 매 요청마다 실행됩니다.\n- 프로덕션에서는 빌드 시에만 실행됩니다.\n\n**getStaticProps 사용 시기:**\n- 데이터가 거의 변하지 않을 때입니다.\n- 모든 사용자에게 같은 콘텐츠를 보여줄 때입니다.\n- 빌드 시 데이터를 가져올 수 있을 때입니다.\n- 성능이 최우선일 때입니다.\n- SEO가 중요하지만 동적 데이터는 필요 없을 때입니다.\n\n**getStaticProps 장단점:**\n- 장점: 최고의 성능, 낮은 비용, 뛰어난 확장성, CDN 활용 가능합니다.\n- 단점: 빌드 시간 증가, 데이터 업데이트 어려움, 실시간 불가능합니다.\n- 성능: 가장 빠르지만 데이터가 오래될 수 있습니다.\n\n**revalidate 옵션:**\n- ISR을 활성화합니다.\n- 지정된 시간마다 페이지를 재생성합니다.\n- 초 단위로 설정합니다.\n- 오래된 데이터 문제를 완화합니다.\n- SSG와 SSR의 중간 지점입니다.\n\n**fallback 옵션:**\n- getStaticPaths와 함께 사용합니다.\n- false: 빌드하지 않은 경로는 404입니다.\n- true: 백그라운드에서 생성하고 로딩을 보여줍니다.\n- blocking: 생성될 때까지 기다립니다.\n- 동적 페이지 수에 따라 선택합니다.\n\n**선택 기준:**\n- 데이터 신선도: 중요하면 getServerSideProps, 아니면 getStaticProps입니다.\n- 트래픽: 많으면 getStaticProps가 유리합니다.\n- 개인화: 필요하면 getServerSideProps입니다.\n- 비용: getStaticProps가 저렴합니다.\n- 페이지 수: 많으면 ISR을 고려합니다.\n\n**실무 활용:**\n- 블로그 게시물은 getStaticProps를 사용합니다.\n- 사용자 대시보드는 getServerSideProps를 사용합니다.\n- 상품 목록은 ISR을 사용합니다.\n- 정적 페이지는 getStaticProps로 성능을 최적화합니다.\n- 프로젝트 요구사항에 따라 적절히 선택합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "props"
      ],
      "id": "1763441901803-m7iboj8b4",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "getStaticPaths는 언제 사용하나요?",
      "answer": "**정의:**\ngetStaticPaths는 동적 라우트를 SSG로 생성할 때 어떤 경로를 미리 만들지 지정하는 Next.js 함수입니다. getStaticProps와 함께 사용하여 동적 페이지를 정적으로 생성합니다.\n\n**필요한 이유:**\n- 동적 라우트는 무한히 많을 수 있습니다.\n- 빌드 시 어떤 경로를 생성할지 알려줘야 합니다.\n- params를 반환하여 각 경로를 정의합니다.\n- getStaticProps와 반드시 함께 사용됩니다.\n\n**기본 구조:**\n- paths 배열을 반환합니다. 생성할 경로 목록입니다.\n- 각 경로는 params 객체를 포함합니다.\n- fallback 값을 반환합니다. 빌드하지 않은 경로 처리 방식입니다.\n- 빌드 타임에 실행됩니다.\n\n**paths 생성:**\n- 데이터베이스에서 모든 ID를 가져옵니다.\n- API를 호출하여 목록을 받습니다.\n- map으로 params 배열로 변환합니다.\n- 각 params는 동적 세그먼트 값을 포함합니다.\n\n**fallback 옵션:**\n- false: paths에 없는 경로는 404입니다. 적은 수의 페이지에 적합합니다.\n- true: 백그라운드에서 생성합니다. useRouter의 isFallback으로 로딩을 보여줍니다.\n- blocking: 생성 완료까지 기다립니다. 사용자는 기다리지만 로딩 처리 불필요합니다.\n\n**fallback: false 사용:**\n- 페이지가 적을 때 사용합니다.\n- 모든 경로를 빌드 시 생성합니다.\n- 가장 빠르지만 빌드 시간이 길 수 있습니다.\n- 새 경로는 재배포가 필요합니다.\n\n**fallback: true 사용:**\n- 페이지가 매우 많을 때 사용합니다.\n- 일부만 빌드하고 나머지는 요청 시 생성합니다.\n- 로딩 상태를 처리해야 합니다.\n- 첫 요청은 느리지만 이후는 빠릅니다.\n\n**fallback: blocking 사용:**\n- true와 유사하지만 로딩 처리가 불필요합니다.\n- 서버에서 생성이 완료될 때까지 기다립니다.\n- 사용자 경험이 더 나을 수 있습니다.\n- 간단하지만 TTFB가 증가합니다.\n\n**ISR과 함께 사용:**\n- revalidate와 fallback: true를 조합합니다.\n- 새 경로를 동적으로 추가할 수 있습니다.\n- 기존 경로는 주기적으로 업데이트됩니다.\n- 최고의 유연성을 제공합니다.\n\n**성능 고려사항:**\n- 너무 많은 경로를 빌드하면 시간이 오래 걸립니다.\n- 인기 있는 페이지만 미리 생성합니다.\n- 나머지는 fallback으로 처리합니다.\n- 빌드 시간과 사용자 경험의 균형을 맞춥니다.\n\n**실무 활용:**\n- 블로그는 모든 게시물을 미리 생성합니다. fallback: false입니다.\n- 전자상거래는 인기 상품만 생성합니다. fallback: true입니다.\n- 사용자 프로필은 fallback: blocking을 사용합니다.\n- 페이지 수와 업데이트 빈도에 따라 전략을 선택합니다.\n- ISR과 조합하여 최적의 성능을 얻습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-q362hfph6",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React 컴포넌트 테스트는 어떻게 작성하나요?",
      "answer": "**정의:**\nReact 컴포넌트 테스트는 컴포넌트가 예상대로 렌더링되고 동작하는지 확인하는 자동화된 테스트입니다. React Testing Library가 가장 권장되는 도구이며, 사용자 관점에서 테스트하는 것을 강조합니다.\n\n**테스트의 중요성:**\n- 버그를 조기에 발견합니다.\n- 리팩토링 시 안전성을 보장합니다.\n- 코드 품질을 향상시킵니다.\n- 문서 역할을 합니다. 컴포넌트 사용법을 보여줍니다.\n- 자신감을 가지고 배포할 수 있습니다.\n\n**React Testing Library 철학:**\n- 구현이 아닌 동작을 테스트합니다.\n- 사용자가 보고 하는 것을 테스트합니다.\n- 내부 state나 props를 직접 테스트하지 않습니다.\n- 실제 DOM을 사용합니다.\n- 접근성을 고려한 쿼리를 권장합니다.\n\n**기본 테스트 구조:**\n- render로 컴포넌트를 렌더링합니다.\n- screen으로 렌더링된 요소를 찾습니다.\n- 쿼리 메서드로 요소를 선택합니다.\n- expect로 단언을 작성합니다.\n- userEvent로 사용자 인터랙션을 시뮬레이션합니다.\n\n**쿼리 메서드:**\n- getBy: 요소를 찾습니다. 없으면 에러입니다.\n- queryBy: 요소를 찾습니다. 없으면 null입니다.\n- findBy: 비동기로 요소를 찾습니다. Promise를 반환합니다.\n- AllBy 변형: 여러 요소를 배열로 반환합니다.\n- 역할 이름 텍스트 등으로 찾습니다.\n\n**쿼리 우선순위:**\n- getByRole: 가장 권장됩니다. 접근성을 고려합니다.\n- getByLabelText: 폼 요소에 적합합니다.\n- getByPlaceholderText: 대안적 방법입니다.\n- getByText: 텍스트 콘텐츠로 찾습니다.\n- getByTestId: 최후의 수단입니다.\n\n**사용자 인터랙션 테스트:**\n- userEvent를 사용합니다. fireEvent보다 권장됩니다.\n- 클릭 타이핑 호버 등을 시뮬레이션합니다.\n- 실제 사용자 동작과 유사하게 작동합니다.\n- 여러 이벤트를 순차적으로 발생시킬 수 있습니다.\n\n**비동기 테스트:**\n- findBy 쿼리를 사용합니다. Promise를 반환합니다.\n- waitFor로 조건이 만족될 때까지 기다립니다.\n- async/await를 사용합니다.\n- 타임아웃을 설정할 수 있습니다.\n- API 호출이나 지연 렌더링을 테스트합니다.\n\n**모킹:**\n- API 호출을 모킹합니다. MSW를 권장합니다.\n- 외부 의존성을 제어합니다.\n- Jest의 jest.fn과 jest.mock을 사용합니다.\n- 일관되고 빠른 테스트를 만듭니다.\n\n**스냅샷 테스트:**\n- 렌더링 결과를 저장하고 비교합니다.\n- 의도치 않은 변경을 감지합니다.\n- 과도하게 사용하지 않습니다.\n- 중요한 부분만 스냅샷을 찍습니다.\n\n**실무 활용:**\n- 주요 사용자 플로우를 테스트합니다.\n- 버튼 클릭 폼 제출 등을 검증합니다.\n- 조건부 렌더링을 테스트합니다.\n- 에러 상태와 로딩 상태를 확인합니다.\n- 테스트 커버리지보다 의미 있는 테스트에 집중합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트",
        "component"
      ],
      "id": "1763441901803-d4n2s1ycd",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React Testing Library와 Enzyme의 차이점은 무엇인가요?",
      "answer": "**정의:**\nReact Testing Library와 Enzyme은 모두 React 컴포넌트 테스트 도구이지만, 근본적으로 다른 철학을 가지고 있습니다. React Testing Library는 사용자 관점의 테스트를, Enzyme은 구현 세부사항 테스트를 강조합니다.\n\n**React Testing Library 철학:**\n- 사용자가 보는 것을 테스트합니다.\n- 구현 세부사항을 피합니다.\n- 접근성을 중요하게 생각합니다.\n- 실제 DOM을 사용합니다.\n- 리팩토링에 강합니다.\n\n**Enzyme 철학:**\n- 컴포넌트 내부를 테스트합니다.\n- state와 props에 직접 접근합니다.\n- 라이프사이클 메서드를 테스트합니다.\n- 얕은 렌더링을 지원합니다.\n- 구현에 의존적입니다.\n\n**테스트 접근 방식:**\n- RTL: 사용자처럼 텍스트나 역할로 요소를 찾습니다.\n- Enzyme: 클래스명이나 컴포넌트 타입으로 찾습니다.\n- RTL: 실제 동작을 검증합니다.\n- Enzyme: state 변경이나 props 전달을 확인합니다.\n\n**렌더링 방식:**\n- RTL: 전체 렌더링만 지원합니다. 실제와 동일합니다.\n- Enzyme: 얕은 렌더링 전체 렌더링 정적 렌더링을 제공합니다.\n- RTL: JSDOM을 사용합니다.\n- Enzyme: 다양한 렌더러를 지원합니다.\n\n**장단점 비교:**\n- RTL 장점: 리팩토링에 강함, 접근성 고려, 실제와 유사, React 팀 권장입니다.\n- RTL 단점: 구현 테스트 어려움, 러닝 커브, 내부 상태 접근 불가입니다.\n- Enzyme 장점: 세밀한 제어, 얕은 렌더링, 익숙함, 많은 API입니다.\n- Enzyme 단점: 구현 의존적, Hooks 지원 약함, 유지보수 문제, 더 이상 권장되지 않습니다.\n\n**커뮤니티와 지원:**\n- RTL: React 팀이 공식 권장합니다. 활발한 개발이 이루어집니다.\n- Enzyme: 업데이트가 느립니다. React 18 지원이 불확실합니다.\n- RTL: 문서가 잘 되어 있습니다.\n- Enzyme: 레거시로 간주됩니다.\n\n**Hooks 지원:**\n- RTL: Hooks를 완벽하게 지원합니다. 자연스럽게 테스트됩니다.\n- Enzyme: Hooks 테스트가 어렵습니다. 어댑터가 필요합니다.\n- RTL: 최신 React 기능을 즉시 지원합니다.\n- Enzyme: 업데이트가 지연됩니다.\n\n**마이그레이션:**\n- Enzyme에서 RTL로 전환이 권장됩니다.\n- 테스트 방식의 패러다임 전환이 필요합니다.\n- 구현이 아닌 동작을 테스트하도록 변경합니다.\n- 점진적 마이그레이션이 가능합니다.\n\n**선택 기준:**\n- 새 프로젝트: React Testing Library를 선택합니다.\n- 레거시 프로젝트: 유지하거나 점진적 마이그레이션을 고려합니다.\n- 팀 역량: RTL의 철학을 이해하고 따를 수 있어야 합니다.\n- React 버전: 최신 버전은 RTL이 필수적입니다.\n\n**실무 활용:**\n- 모든 새 테스트는 RTL로 작성합니다.\n- 기존 Enzyme 테스트를 점진적으로 전환합니다.\n- 사용자 시나리오 중심으로 테스트합니다.\n- 구현 세부사항에 의존하지 않습니다.\n- 접근성을 고려한 쿼리를 사용합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-his21ae2k",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Error Boundary란 무엇이고 어떻게 구현하나요?",
      "answer": "**정의:**\nError Boundary는 하위 컴포넌트 트리에서 발생한 JavaScript 에러를 잡아내고 대체 UI를 보여주는 React 컴포넌트입니다. 에러가 전체 앱을 중단시키지 않도록 방어합니다.\n\n**Error Boundary의 필요성:**\n- 하위 컴포넌트의 에러가 전체 앱을 망가뜨리는 것을 방지합니다.\n- 사용자에게 우아한 에러 메시지를 보여줍니다.\n- 에러를 로깅하여 모니터링할 수 있습니다.\n- 프로덕션 환경의 안정성을 높입니다.\n- 일부 기능 실패가 전체에 영향을 주지 않습니다.\n\n**구현 방법:**\n- 클래스 컴포넌트로만 구현 가능합니다.\n- getDerivedStateFromError 정적 메서드를 정의합니다. 에러 발생 시 state를 업데이트합니다.\n- componentDidCatch 메서드를 정의합니다. 에러 정보를 로깅합니다.\n- state에 따라 에러 UI나 children을 렌더링합니다.\n\n**getDerivedStateFromError:**\n- 에러가 발생하면 호출됩니다.\n- 에러를 인자로 받습니다.\n- 새 state를 반환하여 UI를 업데이트합니다.\n- 렌더 단계에서 호출되므로 부작용이 없어야 합니다.\n- 대체 UI를 표시하는 데 사용합니다.\n\n**componentDidCatch:**\n- 에러와 에러 정보를 인자로 받습니다.\n- 커밋 단계에서 호출되므로 부작용을 허용합니다.\n- 에러 로깅 서비스로 전송합니다.\n- Sentry나 LogRocket 같은 도구와 연동합니다.\n- 에러 스택 추적 정보를 받을 수 있습니다.\n\n**Error Boundary 배치:**\n- 최상위에 하나를 두어 전체 앱을 보호합니다.\n- 각 주요 섹션에 배치하여 격리합니다.\n- 중요한 컴포넌트를 개별적으로 감쌉니다.\n- 세밀도는 앱 구조에 따라 결정합니다.\n\n**잡을 수 있는 에러:**\n- 렌더링 중 발생하는 에러입니다.\n- 라이프사이클 메서드의 에러입니다.\n- 생성자의 에러입니다.\n- 하위 트리 전체의 에러입니다.\n\n**잡을 수 없는 에러:**\n- 이벤트 핸들러의 에러입니다. try-catch를 사용해야 합니다.\n- 비동기 코드의 에러입니다. setTimeout이나 Promise 등입니다.\n- 서버 사이드 렌더링의 에러입니다.\n- Error Boundary 자신의 에러입니다.\n\n**대체 UI 설계:**\n- 사용자에게 친절한 메시지를 보여줍니다.\n- 재시도 버튼을 제공합니다.\n- 홈으로 돌아가는 링크를 제공합니다.\n- 에러 상세 정보는 개발 모드에서만 표시합니다.\n\n**함수형 컴포넌트 대안:**\n- react-error-boundary 라이브러리를 사용합니다.\n- ErrorBoundary 컴포넌트를 제공합니다.\n- FallbackComponent prop으로 UI를 지정합니다.\n- onError 콜백으로 에러를 처리합니다.\n- 선언적이고 사용하기 쉽습니다.\n\n**실무 활용:**\n- 프로덕션 앱에 반드시 구현합니다.\n- 에러 모니터링 도구와 연동합니다.\n- 각 라우트를 Error Boundary로 감쌉니다.\n- 써드파티 위젯을 격리합니다.\n- 우아한 저하를 구현하여 사용자 경험을 보호합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-ebqxnno3r",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Error Boundary의 한계점은 무엇인가요?",
      "answer": "**정의:**\nError Boundary는 강력한 에러 처리 메커니즘이지만 모든 에러를 잡을 수 없는 한계가 있습니다. 특정 상황에서는 다른 에러 처리 방법을 함께 사용해야 합니다.\n\n**이벤트 핸들러 에러:**\n- Error Boundary가 잡지 못합니다.\n- 렌더링 중이 아니라 이벤트 응답 중 발생하기 때문입니다.\n- try-catch로 직접 처리해야 합니다.\n- 에러 상태를 state로 관리합니다.\n- 사용자에게 피드백을 제공합니다.\n\n**비동기 코드 에러:**\n- setTimeout, Promise, async/await의 에러를 잡지 못합니다.\n- 렌더링 사이클 밖에서 발생하기 때문입니다.\n- try-catch나 .catch로 처리합니다.\n- 비동기 에러도 state로 관리합니다.\n- useEffect에서 발생한 에러도 마찬가지입니다.\n\n**서버 사이드 렌더링 에러:**\n- SSR 중 에러는 Error Boundary로 잡히지 않습니다.\n- 서버 측 에러 처리 메커니즘이 필요합니다.\n- Next.js의 getServerSideProps에서 처리합니다.\n- 클라이언트 hydration 에러는 다릅니다.\n\n**Error Boundary 자신의 에러:**\n- Error Boundary 컴포넌트 내부의 에러는 잡을 수 없습니다.\n- 무한 루프를 방지하기 위함입니다.\n- 상위 Error Boundary가 필요합니다.\n- 최상위에 안전망을 두어야 합니다.\n\n**함수형 컴포넌트 제한:**\n- Error Boundary를 함수형으로 만들 수 없습니다.\n- getDerivedStateFromError와 componentDidCatch가 클래스 전용입니다.\n- Hooks에 대응하는 API가 없습니다.\n- 라이브러리를 사용하거나 클래스로 구현해야 합니다.\n\n**세밀한 제어 어려움:**\n- 어떤 에러인지 구분하기 어렵습니다.\n- 에러 타입별로 다르게 처리하기 복잡합니다.\n- 재시도 로직 구현이 번거롭습니다.\n- 복잡한 에러 복구 시나리오에는 부족합니다.\n\n**개발 환경에서의 혼란:**\n- React는 에러를 다시 던집니다. 개발 모드에서만입니다.\n- 콘솔에 빨간 화면이 나타납니다.\n- Error Boundary가 작동했는지 확인하기 어렵습니다.\n- 프로덕션에서는 정상 작동합니다.\n\n**보완 방법:**\n- 이벤트 핸들러에 try-catch를 추가합니다.\n- 전역 에러 핸들러를 설정합니다. window.onerror입니다.\n- 비동기 코드에 에러 처리를 추가합니다.\n- React Query 같은 라이브러리가 에러를 잘 처리합니다.\n- Sentry 같은 모니터링 도구를 사용합니다.\n\n**대안과 보완책:**\n- react-error-boundary 라이브러리를 사용합니다.\n- 각 에러 타입별로 처리 전략을 세웁니다.\n- 로깅과 모니터링을 철저히 합니다.\n- 사용자에게 명확한 피드백을 제공합니다.\n- 여러 방어선을 구축합니다.\n\n**실무 활용:**\n- Error Boundary와 try-catch를 조합합니다.\n- 중요한 이벤트 핸들러에 에러 처리를 추가합니다.\n- 비동기 작업의 에러를 별도로 관리합니다.\n- 전역 에러 핸들러로 예상치 못한 에러를 잡습니다.\n- 포괄적인 에러 처리 전략을 수립합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-64fsg8t61",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Reconciliation 알고리즘이란 무엇인가요?",
      "answer": "**정의:**\nReconciliation은 React가 Virtual DOM의 변경사항을 실제 DOM에 효율적으로 반영하는 알고리즘입니다. 이전 트리와 새 트리를 비교하여 최소한의 DOM 조작으로 업데이트를 수행합니다.\n\n**Reconciliation의 필요성:**\n- DOM 조작은 비용이 비쌉니다. 최소화해야 합니다.\n- 전체 트리를 비교하면 O(n³) 복잡도입니다. 매우 느립니다.\n- 효율적인 알고리즘으로 O(n)으로 줄입니다.\n- 빠른 업데이트로 좋은 사용자 경험을 제공합니다.\n\n**Diffing 알고리즘:**\n- 두 가지 가정을 기반으로 합니다.\n- 다른 타입의 요소는 다른 트리를 생성합니다.\n- key prop으로 자식 요소를 식별합니다.\n- 이 휴리스틱으로 성능과 정확성의 균형을 맞춥니다.\n\n**요소 타입 비교:**\n- 타입이 다르면 이전 트리를 파괴하고 새로 만듭니다.\n- componentWillUnmount가 호출됩니다.\n- 새 DOM 노드가 삽입됩니다.\n- componentDidMount가 호출됩니다.\n- state도 모두 사라집니다.\n\n**같은 타입의 DOM 요소:**\n- 속성만 업데이트합니다.\n- className이나 style 등의 변경만 적용합니다.\n- 자식 요소를 재귀적으로 처리합니다.\n- DOM 노드는 유지됩니다.\n\n**같은 타입의 컴포넌트:**\n- 인스턴스는 유지되어 state가 보존됩니다.\n- props를 업데이트합니다.\n- componentDidUpdate가 호출됩니다.\n- render를 호출하여 새 결과를 얻습니다.\n- 재귀적으로 하위를 비교합니다.\n\n**자식 요소 재조정:**\n- 기본적으로 순서대로 비교합니다.\n- 끝에 추가하는 것은 효율적입니다.\n- 앞에 추가하면 모든 자식을 다시 만듭니다.\n- key가 없으면 비효율적입니다.\n\n**key의 역할:**\n- 자식을 고유하게 식별합니다.\n- key가 같으면 같은 요소로 인식합니다.\n- 위치가 바뀌어도 재사용할 수 있습니다.\n- 효율적인 리스트 업데이트가 가능합니다.\n- 안정적이고 예측 가능해야 합니다.\n\n**최적화 전략:**\n- shouldComponentUpdate로 불필요한 비교를 건너뜁니다.\n- PureComponent는 얕은 비교를 수행합니다.\n- React.memo로 함수형 컴포넌트를 최적화합니다.\n- key를 올바르게 사용합니다.\n\n**Fiber와의 관계:**\n- Fiber는 Reconciliation의 새로운 구현입니다.\n- 작업을 중단하고 재개할 수 있습니다.\n- 우선순위를 설정할 수 있습니다.\n- 더 유연하고 강력합니다.\n\n**실무 활용:**\n- 컴포넌트 타입을 안정적으로 유지합니다.\n- key를 올바르게 사용하여 성능을 최적화합니다.\n- 불필요한 리렌더링을 방지합니다.\n- React가 내부적으로 처리하므로 대부분 신경 쓸 필요 없습니다.\n- 성능 문제가 있을 때만 깊이 이해하면 됩니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-ymxz9x4o0",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React Fiber 아키텍처란 무엇인가요?",
      "answer": "**정의:**\nReact Fiber는 React 16에서 도입된 새로운 재조정 엔진입니다. 렌더링 작업을 작은 단위로 나누고 우선순위를 지정하여 중단하고 재개할 수 있게 만듭니다.\n\n**Fiber 이전의 문제:**\n- 동기적 렌더링으로 한번 시작하면 멈출 수 없었습니다.\n- 큰 컴포넌트 트리는 메인 스레드를 블로킹했습니다.\n- 애니메이션이 끊기고 입력이 지연되었습니다.\n- 우선순위를 조정할 수 없었습니다.\n- 사용자 경험이 저하되었습니다.\n\n**Fiber의 핵심 개념:**\n- 작업을 작은 단위로 분할합니다. Fiber 노드 단위입니다.\n- 우선순위를 할당할 수 있습니다.\n- 작업을 중단하고 나중에 재개할 수 있습니다.\n- 완료된 작업을 재사용할 수 있습니다.\n- 다른 타입의 업데이트에 다른 우선순위를 줍니다.\n\n**Fiber 노드:**\n- 각 컴포넌트나 요소마다 하나의 Fiber가 있습니다.\n- Virtual DOM의 노드와 유사합니다.\n- 작업 단위로 기능합니다.\n- 추가 정보를 저장합니다. 우선순위, 상태 등입니다.\n\n**두 단계 렌더링:**\n- Render Phase: Virtual DOM을 생성하고 변경사항을 계산합니다. 중단 가능합니다.\n- Commit Phase: 실제 DOM에 변경사항을 적용합니다. 중단 불가능합니다.\n- 분리로 유연성이 생깁니다.\n\n**우선순위 스케줄링:**\n- 사용자 인터랙션이 가장 높은 우선순위입니다.\n- 애니메이션이 다음 우선순위입니다.\n- 데이터 페칭은 낮은 우선순위입니다.\n- 긴급한 작업을 먼저 처리합니다.\n- 부드러운 사용자 경험을 제공합니다.\n\n**시간 분할:**\n- 브라우저에 제어권을 주기적으로 돌려줍니다.\n- requestIdleCallback을 활용합니다.\n- 메인 스레드를 블로킹하지 않습니다.\n- 60fps를 유지할 수 있습니다.\n\n**Concurrent 기능:**\n- Fiber가 Concurrent Mode의 기반입니다.\n- 여러 업데이트를 동시에 준비할 수 있습니다.\n- 더 중요한 업데이트로 전환할 수 있습니다.\n- 사용자 경험이 크게 향상됩니다.\n\n**개발자 관점:**\n- 대부분 투명하게 작동합니다.\n- API 변경이 거의 없었습니다.\n- 기존 코드가 그대로 작동합니다.\n- 성능 향상을 자동으로 얻습니다.\n- 새로운 기능의 기반이 됩니다.\n\n**실무 영향:**\n- React 16 이상을 사용하면 자동으로 적용됩니다.\n- 대부분의 경우 직접 다룰 필요가 없습니다.\n- Concurrent 기능을 사용하면 더 큰 이점을 얻습니다.\n- 성능 개선이 눈에 띄게 나타납니다.\n- 미래 React 기능의 토대입니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-krcfik1lm",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Suspense는 무엇이고 어떻게 사용하나요?",
      "answer": "**정의:**\nSuspense는 컴포넌트가 렌더링할 준비가 될 때까지 기다리고 그동안 폴백 UI를 보여주는 React 컴포넌트입니다. 비동기 작업의 로딩 상태를 선언적으로 처리합니다.\n\n**Suspense의 목적:**\n- 로딩 상태를 선언적으로 처리합니다.\n- 여러 컴포넌트의 로딩을 조율할 수 있습니다.\n- 코드 스플리팅을 쉽게 만듭니다.\n- 데이터 페칭을 우아하게 처리합니다.\n- 사용자 경험을 향상시킵니다.\n\n**기본 사용법:**\n- Suspense로 컴포넌트를 감쌉니다.\n- fallback prop에 로딩 UI를 지정합니다.\n- 자식이 준비될 때까지 fallback을 보여줍니다.\n- 준비되면 자식을 렌더링합니다.\n\n**코드 스플리팅과 함께:**\n- React.lazy와 함께 사용합니다.\n- 동적 import로 컴포넌트를 로드합니다.\n- 로딩 중에 스피너를 보여줍니다.\n- 번들 크기를 줄일 수 있습니다.\n- 필요할 때만 코드를 로드합니다.\n\n**중첩 Suspense:**\n- 여러 Suspense를 중첩할 수 있습니다.\n- 세밀한 로딩 상태 제어가 가능합니다.\n- 가장 가까운 Suspense가 활성화됩니다.\n- 부분적 로딩을 구현할 수 있습니다.\n\n**데이터 페칭:**\n- Suspense for Data Fetching은 실험적 기능입니다.\n- Relay나 React Query와 통합됩니다.\n- Promise를 throw하면 Suspense가 잡습니다.\n- 데이터가 준비되면 컴포넌트를 렌더링합니다.\n- 선언적 데이터 로딩이 가능해집니다.\n\n**Error Boundary와 조합:**\n- 에러 처리와 로딩 처리를 분리합니다.\n- Suspense는 로딩을 Error Boundary는 에러를 처리합니다.\n- 함께 사용하면 강력합니다.\n- 포괄적인 비동기 처리가 가능합니다.\n\n**SSR과 Suspense:**\n- React 18에서 SSR Suspense를 지원합니다.\n- 선택적 hydration이 가능합니다.\n- 스트리밍 SSR을 구현할 수 있습니다.\n- 페이지 일부를 먼저 보여줄 수 있습니다.\n\n**현재 상태와 미래:**\n- 코드 스플리팅은 안정적입니다.\n- 데이터 페칭은 실험적입니다.\n- React 18에서 많은 개선이 있었습니다.\n- 점진적으로 더 많은 기능이 추가됩니다.\n\n**실무 활용:**\n- 라우트 레벨 코드 스플리팅에 사용합니다.\n- 무거운 컴포넌트를 지연 로딩합니다.\n- 로딩 상태를 일관되게 처리합니다.\n- React Query나 Relay와 함께 사용합니다.\n- 안정적인 기능부터 도입합니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-9l4j3c25z",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "Concurrent Mode(동시성 모드)란 무엇인가요?",
      "answer": "**정의:**\nConcurrent Mode는 React 18의 핵심 기능으로, 여러 작업을 동시에 준비하고 우선순위에 따라 전환할 수 있게 하는 렌더링 모드입니다. 사용자 경험을 크게 향상시키는 강력한 기능입니다.\n\n**Concurrent의 의미:**\n- 여러 작업을 번갈아 수행합니다.\n- 병렬 처리가 아닌 동시성입니다.\n- 중요한 작업을 우선 처리합니다.\n- 덜 중요한 작업을 중단하고 나중에 재개합니다.\n- 메인 스레드를 효율적으로 사용합니다.\n\n**주요 이점:**\n- 앱이 더 반응적입니다. 입력이 즉시 반영됩니다.\n- 긴 렌더링이 UI를 블로킹하지 않습니다.\n- 부드러운 애니메이션을 유지합니다.\n- 우선순위에 따라 작업을 조절합니다.\n- 사용자 경험이 크게 향상됩니다.\n\n**핵심 기능들:**\n- useTransition: 덜 긴급한 업데이트를 표시합니다.\n- useDeferredValue: 값 업데이트를 지연시킵니다.\n- Suspense: 로딩 상태를 선언적으로 처리합니다.\n- Automatic Batching: 모든 업데이트를 자동 배치합니다.\n- startTransition: 비긴급 업데이트를 표시합니다.\n\n**useTransition:**\n- 상태 업데이트를 transition으로 표시합니다.\n- isPending으로 로딩 상태를 알 수 있습니다.\n- 긴급한 업데이트가 있으면 중단됩니다.\n- 검색이나 필터링에 유용합니다.\n- UI를 차단하지 않습니다.\n\n**useDeferredValue:**\n- 값의 업데이트를 지연시킵니다.\n- 이전 값을 유지하다가 시간이 되면 업데이트합니다.\n- 무거운 컴포넌트 렌더링을 지연시킵니다.\n- 입력 응답성을 유지합니다.\n- Throttling이나 Debouncing의 선언적 대안입니다.\n\n**Automatic Batching:**\n- 여러 상태 업데이트를 자동으로 묶습니다.\n- 이벤트 핸들러뿐 아니라 모든 곳에서 작동합니다.\n- Promise, setTimeout에서도 배치됩니다.\n- 리렌더링 횟수가 줄어듭니다.\n- 성능이 자동으로 향상됩니다.\n\n**사용 시나리오:**\n- 큰 리스트 필터링: 입력은 즉시 반응하고 리스트는 천천히 업데이트됩니다.\n- 탭 전환: 새 탭 내용을 준비하면서 이전 탭을 유지합니다.\n- 검색: 타이핑은 빠르게 반응하고 결과는 지연 표시됩니다.\n- 복잡한 렌더링: 우선순위가 높은 UI를 먼저 처리합니다.\n\n**활성화 방법:**\n- React 18의 createRoot를 사용합니다.\n- 별도 모드 설정이 필요 없습니다.\n- 자동으로 활성화됩니다.\n- 새로운 Hook을 사용하여 기능을 활용합니다.\n\n**하위 호환성:**\n- 기존 코드는 그대로 작동합니다.\n- 점진적으로 새 기능을 도입할 수 있습니다.\n- 필요한 곳에서만 사용하면 됩니다.\n- 파괴적 변경이 거의 없습니다.\n\n**실무 활용:**\n- React 18로 업그레이드합니다.\n- createRoot를 사용하여 Concurrent 기능을 활성화합니다.\n- 검색이나 필터에 useTransition을 적용합니다.\n- 무거운 렌더링에 useDeferredValue를 사용합니다.\n- 사용자 경험 개선이 눈에 띄게 나타납니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-jzvq0dso2",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "React 18의 주요 변경사항은 무엇인가요?",
      "answer": "React 18은 동시성(Concurrency)을 핵심으로 하는 메이저 업데이트입니다. 사용자 경험을 향상시키고 성능을 개선하는 여러 기능이 추가되었습니다.\n\n**1. Automatic Batching (자동 배칭)**\n\n**변경 전 (React 17):**\n```javascript\n// Promise, setTimeout 등에서는 배칭이 안 됨\nsetTimeout(() => {\n  setCount(c => c + 1);  // 리렌더링 발생\n  setFlag(f => !f);      // 리렌더링 발생\n  // 총 2번 리렌더링\n}, 1000);\n```\n\n**변경 후 (React 18):**\n```javascript\n// 모든 상황에서 자동 배칭\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // 총 1번만 리렌더링 (자동으로 배칭됨)\n}, 1000);\n\n// 배칭을 원하지 않을 때\nimport { flushSync } from 'react-dom';\n\nflushSync(() => {\n  setCount(c => c + 1);  // 즉시 리렌더링\n});\nsetFlag(f => !f);  // 별도로 리렌더링\n```\n\n**2. Transitions (트랜지션)**\n\n긴급하지 않은 업데이트를 마킹하여 사용자 인터랙션의 우선순위를 관리합니다.\n\n```javascript\nimport { useTransition } from 'react';\n\nfunction SearchResults() {\n  const [isPending, startTransition] = useTransition();\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  const handleChange = (e) => {\n    const value = e.target.value;\n    setQuery(value);  // 긴급: 즉시 업데이트\n\n    // 비긴급: 백그라운드에서 업데이트\n    startTransition(() => {\n      setResults(searchData(value));  // 무거운 작업\n    });\n  };\n\n  return (\n    <>\n      <input value={query} onChange={handleChange} />\n      {isPending && <Spinner />}\n      <ResultsList results={results} />\n    </>\n  );\n}\n```\n\n**3. Suspense 개선**\n\n서버 사이드 렌더링과 함께 사용할 수 있게 되었습니다.\n\n```javascript\nimport { Suspense } from 'react';\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <UserProfile />\n      <Suspense fallback={<PostsLoading />}>\n        <UserPosts />\n      </Suspense>\n    </Suspense>\n  );\n}\n\n// 데이터 fetching\nfunction UserProfile() {\n  const user = use(fetchUser());  // Suspense와 연동\n  return <div>{user.name}</div>;\n}\n```\n\n**4. 새로운 Root API**\n\n```javascript\n// React 17\nimport ReactDOM from 'react-dom';\nReactDOM.render(<App />, document.getElementById('root'));\n\n// React 18\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n// Unmount도 변경\nroot.unmount();\n```\n\n**5. Strict Mode 강화**\n\n개발 모드에서 컴포넌트를 두 번 마운트하여 side effect를 감지합니다.\n\n```javascript\n<React.StrictMode>\n  <App />\n</React.StrictMode>\n\n// Effect가 두 번 실행됨\nuseEffect(() => {\n  console.log('Mount');  // 개발 모드에서 2번 출력\n  return () => console.log('Unmount');\n}, []);\n```\n\n**6. useId Hook**\n\n서버/클라이언트에서 일관된 고유 ID를 생성합니다.\n\n```javascript\nfunction FormField() {\n  const id = useId();\n\n  return (\n    <>\n      <label htmlFor={id}>Name:</label>\n      <input id={id} type=\"text\" />\n    </>\n  );\n}\n```\n\n**7. useSyncExternalStore Hook**\n\n외부 스토어와 동기화하는 Hook입니다.\n\n```javascript\nimport { useSyncExternalStore } from 'react';\n\nfunction useOnlineStatus() {\n  return useSyncExternalStore(\n    (callback) => {\n      window.addEventListener('online', callback);\n      window.addEventListener('offline', callback);\n      return () => {\n        window.removeEventListener('online', callback);\n        window.removeEventListener('offline', callback);\n      };\n    },\n    () => navigator.onLine,\n    () => true  // 서버 사이드 스냅샷\n  );\n}\n\nfunction App() {\n  const isOnline = useOnlineStatus();\n  return <div>{isOnline ? 'Online' : 'Offline'}</div>;\n}\n```\n\n**8. Server Components (실험적)**\n\n서버에서만 실행되는 컴포넌트를 작성할 수 있습니다.\n\n```javascript\n// Note.server.js\nasync function Note({ id }) {\n  const note = await db.notes.get(id);  // 서버에서만 실행\n  return <div>{note.content}</div>;\n}\n```\n\n**성능 개선:**\n\n- **Automatic Batching**: 불필요한 리렌더링 50% 감소\n- **Transitions**: 인터랙션 응답성 향상\n- **SSR with Suspense**: 초기 로딩 시간 단축\n\n**마이그레이션:**\n\n대부분의 앱은 코드 변경 없이 업그레이드 가능합니다. `ReactDOM.render`를 `createRoot`로 변경하면 됩니다.\n\nReact 18은 동시성 렌더링을 통해 더 부드러운 사용자 경험을 제공하며, 앞으로의 React 발전을 위한 기반을 마련했습니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-cqqmll5oh",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    },
    {
      "question": "useTransition과 useDeferredValue는 언제 사용하나요?",
      "answer": "useTransition과 useDeferredValue는 React 18의 동시성 기능으로, UI 업데이트의 우선순위를 관리합니다. 비슷해 보이지만 사용 시나리오가 다릅니다.\n\n**useTransition**\n\n**개념:**\n상태 업데이트를 \"긴급하지 않은\" 업데이트로 마킹합니다. React는 더 중요한 업데이트를 먼저 처리합니다.\n\n**사용 시점:**\n자신이 **제어하는 상태 업데이트**를 지연시키고 싶을 때 사용합니다.\n\n**기본 사용법:**\n```javascript\nimport { useState, useTransition } from 'react';\n\nfunction SearchBox() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSearch = (e) => {\n    const value = e.target.value;\n\n    // 긴급: 입력 필드 즉시 업데이트\n    setQuery(value);\n\n    // 비긴급: 검색 결과는 나중에 업데이트\n    startTransition(() => {\n      const filtered = hugeList.filter(item =>\n        item.includes(value)\n      );\n      setResults(filtered);\n    });\n  };\n\n  return (\n    <>\n      <input value={query} onChange={handleSearch} />\n      {isPending && <Spinner />}\n      <SearchResults results={results} />\n    </>\n  );\n}\n```\n\n**실전 예제 - 탭 전환:**\n```javascript\nfunction Tabs() {\n  const [tab, setTab] = useState('about');\n  const [isPending, startTransition] = useTransition();\n\n  const selectTab = (nextTab) => {\n    startTransition(() => {\n      setTab(nextTab);  // 무거운 탭도 UI를 블로킹하지 않음\n    });\n  };\n\n  return (\n    <>\n      <button onClick={() => selectTab('about')}>About</button>\n      <button onClick={() => selectTab('posts')}>\n        Posts {isPending && <Spinner />}\n      </button>\n      <button onClick={() => selectTab('contact')}>Contact</button>\n\n      {tab === 'about' && <AboutTab />}\n      {tab === 'posts' && <PostsTab />}  {/* 매우 무거운 컴포넌트 */}\n      {tab === 'contact' && <ContactTab />}\n    </>\n  );\n}\n```\n\n**useDeferredValue**\n\n**개념:**\n값의 업데이트를 지연시킵니다. React는 긴급한 업데이트를 먼저 처리하고 나중에 이 값을 업데이트합니다.\n\n**사용 시점:**\n**외부에서 받은 prop이나 값**을 지연시키고 싶을 때 사용합니다. 상태 업데이트를 직접 제어할 수 없을 때 유용합니다.\n\n**기본 사용법:**\n```javascript\nimport { useState, useDeferredValue } from 'react';\n\nfunction App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n\n  return (\n    <>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n      <SearchResults query={deferredQuery} />\n    </>\n  );\n}\n\nfunction SearchResults({ query }) {\n  // query가 변경되어도 긴급한 업데이트가 끝날 때까지 대기\n  const results = useMemo(() => {\n    return hugeList.filter(item => item.includes(query));\n  }, [query]);\n\n  return <div>{results.map(...)}</div>;\n}\n```\n\n**실전 예제 - 실시간 검색:**\n```javascript\nfunction ProductSearch() {\n  const [input, setInput] = useState('');\n  const deferredInput = useDeferredValue(input);\n  const isStale = input !== deferredInput;\n\n  return (\n    <>\n      <input\n        value={input}\n        onChange={(e) => setInput(e.target.value)}\n        placeholder=\"Search products...\"\n      />\n      <div style={{ opacity: isStale ? 0.5 : 1 }}>\n        <ProductList query={deferredInput} />\n      </div>\n    </>\n  );\n}\n```\n\n**두 Hook의 비교:**\n\n| 특징 | useTransition | useDeferredValue |\n|------|---------------|------------------|\n| **제어 대상** | 상태 업데이트 함수 | 값 자체 |\n| **사용 상황** | setState를 감싸서 사용 | prop이나 값을 지연 |\n| **isPending** | 제공됨 | 제공 안 됨 (직접 비교) |\n| **예제** | 버튼 클릭, 탭 전환 | 검색 입력, 필터링 |\n\n**언제 어떤 것을 사용할까?**\n\n**useTransition을 사용하세요:**\n```javascript\n// 1. 상태 업데이트를 직접 제어할 때\nconst [tab, setTab] = useState('home');\nstartTransition(() => {\n  setTab('profile');  // ✅ 직접 제어\n});\n\n// 2. 로딩 상태가 필요할 때\nconst [isPending, startTransition] = useTransition();\n{isPending && <Spinner />}  // ✅ 로딩 표시\n\n// 3. 사용자 액션에 반응할 때\n<button onClick={() => startTransition(() => setPage(2))}>\n  Next Page\n</button>\n```\n\n**useDeferredValue를 사용하세요:**\n```javascript\n// 1. 외부 prop을 받을 때\nfunction ChildComponent({ externalValue }) {\n  const deferred = useDeferredValue(externalValue);  // ✅ prop 지연\n  // ...\n}\n\n// 2. 값만 지연하고 싶을 때\nconst deferredQuery = useDeferredValue(searchQuery);  // ✅ 값만 지연\n\n// 3. 의존성이 복잡할 때\nconst deferredFilters = useDeferredValue(complexFilters);  // ✅ 객체도 가능\n```\n\n**실무 팁:**\n\n**1. 디바운스 대체:**\n```javascript\n// 기존 디바운스\nconst [query, setQuery] = useState('');\nconst debouncedQuery = useDebounce(query, 500);\n\n// useDeferredValue로 대체 (더 스마트함)\nconst [query, setQuery] = useState('');\nconst deferredQuery = useDeferredValue(query);\n// React가 자동으로 최적의 타이밍 결정\n```\n\n**2. 조합 사용:**\n```javascript\nfunction App() {\n  const [query, setQuery] = useState('');\n  const [isPending, startTransition] = useTransition();\n  const deferredQuery = useDeferredValue(query);\n\n  const handleChange = (e) => {\n    const value = e.target.value;\n    setQuery(value);  // 즉시 업데이트\n\n    startTransition(() => {\n      // 추가 무거운 작업\n      updateAnalytics(value);\n    });\n  };\n\n  return (\n    <>\n      <input value={query} onChange={handleChange} />\n      {isPending && <Spinner />}\n      <Results query={deferredQuery} />\n    </>\n  );\n}\n```\n\n**3. 성능 측정:**\n```javascript\nimport { Profiler } from 'react';\n\n<Profiler id=\"search\" onRender={(id, phase, duration) => {\n  console.log(`${id} ${phase}: ${duration}ms`);\n}}>\n  <SearchResults query={deferredQuery} />\n</Profiler>\n```\n\n**주의사항:**\n\n1. **남용 금지**: 모든 상태 업데이트에 사용하지 마세요. 정말 무거운 작업에만 사용하세요.\n\n2. **접근성**: 로딩 상태를 명확히 표시하여 사용자가 앱이 작동 중임을 알 수 있게 하세요.\n\n3. **Memoization 필수**: useDeferredValue와 함께 useMemo를 사용하지 않으면 효과가 없습니다.\n\n```javascript\n// ❌ 나쁜 예\nfunction List({ query }) {\n  const items = heavyComputation(query);  // 매번 계산\n  return <div>{items}</div>;\n}\n\n// ✅ 좋은 예\nfunction List({ query }) {\n  const items = useMemo(() => heavyComputation(query), [query]);\n  return <div>{items}</div>;\n}\n```\n\nuseTransition과 useDeferredValue는 사용자 경험을 크게 향상시킬 수 있는 강력한 도구입니다. 앱이 항상 반응성 있게 느껴지도록 도와줍니다.",
      "type": "essay",
      "tags": [
        "React",
        "리액트"
      ],
      "id": "1763441901803-iznddm36w",
      "createdAt": "2025-11-18T04:58:21.802880",
      "studyCount": 0
    }
  ]
}