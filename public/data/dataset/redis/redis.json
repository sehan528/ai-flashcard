{
  "name": "Redis",
  "description": "Redis 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "Redis의 기본 개념과 주요 특징은 무엇인가요?",
      "answer": "**Redis(Remote Dictionary Server)**는 인메모리 키-값 데이터 저장소입니다.\n\n**주요 특징:**\n\n1. **인메모리 기반**: 모든 데이터를 메모리에 저장하여 매우 빠른 읽기/쓰기 속도 제공\n\n2. **다양한 데이터 구조**: String, List, Set, Sorted Set, Hash, Bitmap, HyperLogLog, Stream 등 지원\n\n3. **영속성(Persistence)**: RDB 스냅샷, AOF 로그를 통해 데이터를 디스크에 저장 가능\n\n4. **고가용성**: Redis Sentinel을 통한 자동 장애 조치, Redis Cluster를 통한 샤딩과 복제\n\n5. **원자적 연산**: 단일 명령어가 원자적으로 실행되어 동시성 제어 용이\n\n6. **Pub/Sub 메시징**: 실시간 메시지 브로커 기능 제공\n\n7. **트랜잭션 지원**: MULTI/EXEC를 통한 명령어 묶음 실행\n\n8. **Lua 스크립팅**: 서버 측에서 복잡한 로직을 원자적으로 실행\n\n9. **복제(Replication)**: Master-Slave 구조로 데이터 복사 및 읽기 부하 분산\n\n**주요 사용 사례:**\n- 캐싱 (세션, API 응답, DB 쿼리 결과)\n- 실시간 리더보드 (Sorted Set)\n- 메시지 큐\n- 속도 제한(Rate Limiting)\n- 실시간 분석",
      "type": "essay",
      "tags": ["Redis", "기본개념", "인메모리", "NoSQL"],
      "id": "redis-001",
      "createdAt": "2025-11-17T13:00:00.000000",
      "studyCount": 0
    },
    {
      "question": "Redis가 메모리 기반 데이터 저장소로서 제공하는 장점은 무엇이며, 이로 인한 단점은 무엇인가요?",
      "answer": "**장점:**\n\n1. **매우 빠른 속도**: 디스크 I/O 없이 메모리에서 직접 읽기/쓰기하여 마이크로초 단위 응답 시간 (평균 1ms 미만)\n\n2. **낮은 지연시간**: 네트워크 지연을 제외하면 거의 즉시 응답\n\n3. **높은 처리량**: 초당 수십만~수백만 건의 명령어 처리 가능\n\n4. **단순한 데이터 모델**: 복잡한 조인 없이 키로 직접 접근\n\n5. **동시성 처리 우수**: 단일 스레드 이벤트 루프로 경합 조건 최소화\n\n**단점:**\n\n1. **메모리 용량 제한**: 물리적 메모리 크기에 제한됨. 대용량 데이터 저장 불가\n\n2. **높은 비용**: 디스크 대비 GB당 비용이 매우 높음 (메모리가 디스크보다 10~20배 비쌈)\n\n3. **휘발성**: 전원 차단 시 영속성 설정 없으면 데이터 손실 위험\n\n4. **영속성 오버헤드**: RDB/AOF 사용 시 성능 저하 발생 가능\n\n5. **메모리 단편화**: 장기 운영 시 메모리 효율이 떨어질 수 있음\n\n6. **확장 한계**: 단일 노드 메모리 한계 초과 시 샤딩 필요 (관리 복잡도 증가)\n\n**활용 전략:**\n- 자주 접근하는 핫 데이터만 Redis에 저장\n- TTL 설정으로 자동 만료\n- 영구 저장이 필요한 데이터는 별도 DB와 병행 사용",
      "type": "essay",
      "tags": ["Redis", "메모리", "장단점", "성능"],
      "id": "redis-002",
      "createdAt": "2025-11-17T13:00:00.000001",
      "studyCount": 0
    },
    {
      "question": "Redis에서 제공하는 데이터 타입(스트링, 리스트, 셋, 정렬된 셋, 해시 등)에 대해 설명해주세요.",
      "answer": "**1. String (문자열)**\n- 가장 기본적인 타입, 최대 512MB\n- 숫자, JSON, 바이너리 데이터 저장 가능\n- 원자적 증감 연산 지원 (INCR, DECR)\n- 용도: 캐싱, 카운터, 세션 데이터\n\n**2. List (리스트)**\n- 순서가 있는 문자열 컬렉션 (Linked List 구현)\n- 양쪽 끝에서 삽입/삭제가 빠름 (LPUSH, RPUSH, LPOP, RPOP)\n- 중간 접근은 느림\n- 용도: 메시지 큐, 최근 항목 목록, 타임라인\n\n**3. Set (집합)**\n- 중복 없는 문자열 컬렉션\n- 순서 보장 안 됨\n- 집합 연산 지원 (합집합, 교집합, 차집합)\n- 용도: 태그, 고유 방문자 추적, 중복 제거\n\n**4. Sorted Set (정렬된 집합)**\n- Score(점수)로 정렬된 집합\n- 각 멤버에 score 값 연결\n- 범위 조회, 순위 조회 빠름\n- 용도: 리더보드, 우선순위 큐, 시간 기반 데이터\n\n**5. Hash (해시)**\n- 필드-값 쌍의 컬렉션\n- 객체를 표현하기 적합\n- 개별 필드만 조회/수정 가능\n- 메모리 효율적\n- 용도: 사용자 프로필, 제품 정보, 설정값\n\n**6. Bitmap**\n- String의 비트 단위 연산\n- 메모리 효율적인 불리언 플래그\n- 용도: 출석 체크, 기능 플래그, 실시간 분석\n\n**7. HyperLogLog**\n- 확률적 카운팅 자료구조\n- 매우 적은 메모리로 고유 원소 개수 추정\n- 오차율 약 0.81%\n- 용도: 대규모 고유 방문자 수 추정\n\n**8. Stream**\n- 로그 형태의 메시지 저장소\n- 시간 순서 보장\n- 소비자 그룹 지원\n- 용도: 이벤트 소싱, 감사 로그, 메시지 브로커\n\n**9. Geospatial (지리 공간)**\n- 경도/위도 좌표 저장\n- 거리 계산, 반경 검색\n- 내부적으로 Sorted Set 사용\n- 용도: 위치 기반 서비스",
      "type": "essay",
      "tags": ["Redis", "데이터타입", "자료구조"],
      "id": "redis-003",
      "createdAt": "2025-11-17T13:00:00.000002",
      "studyCount": 0
    },
    {
      "question": "Redis의 키-값 구조와 다른 NoSQL 데이터베이스와의 차이점은 무엇인가요?",
      "answer": "**Redis의 키-값 구조 특징:**\n\n1. **단순한 접근 방식**: 키로 직접 접근 (O(1) 시간복잡도)\n2. **다양한 값 타입**: String뿐 아니라 List, Set, Hash 등 복잡한 구조 지원\n3. **원자적 연산**: 복잡한 데이터 구조에 대한 원자적 조작\n4. **인메모리**: 모든 데이터가 메모리에 상주\n\n**다른 NoSQL과 비교:**\n\n**vs Document DB (MongoDB):**\n- MongoDB: 문서(JSON) 기반, 복잡한 쿼리 지원, 인덱싱, 집계\n- Redis: 단순 키 접근, 쿼리 언어 없음, 인메모리로 더 빠름\n- MongoDB는 영구 저장에 적합, Redis는 캐시/임시 데이터에 적합\n\n**vs Column-family DB (Cassandra):**\n- Cassandra: 컬럼 패밀리 구조, 대용량 쓰기 최적화, 분산 저장\n- Redis: 단순 키-값, 읽기 최적화, 단일 노드 또는 소규모 클러스터\n- Cassandra는 페타바이트급 데이터, Redis는 기가바이트급\n\n**vs Key-Value Store (DynamoDB):**\n- DynamoDB: 디스크 기반, 완전 관리형, 자동 확장\n- Redis: 메모리 기반, 직접 관리, 수동 확장\n- DynamoDB는 안정성, Redis는 성능 우선\n\n**vs Wide-column Store (HBase):**\n- HBase: HDFS 기반, 배치 처리, 대용량 분석\n- Redis: 메모리 기반, 실시간 처리, 저지연\n\n**Redis의 독특한 점:**\n- 다양한 데이터 구조 네이티브 지원\n- Pub/Sub 메시징 내장\n- Lua 스크립팅으로 서버 측 로직 실행\n- 트랜잭션 및 파이프라이닝\n- 밀리초 미만 응답시간\n\n**선택 기준:**\n- Redis: 캐싱, 세션, 실시간 분석, 리더보드\n- MongoDB: 유연한 스키마, 복잡한 쿼리\n- Cassandra: 대규모 쓰기, 시계열 데이터\n- DynamoDB: 서버리스, 완전 관리형",
      "type": "essay",
      "tags": ["Redis", "NoSQL", "비교", "키-값"],
      "id": "redis-004",
      "createdAt": "2025-11-17T13:00:00.000003",
      "studyCount": 0
    },
    {
      "question": "Redis에서 Persistence를 위해 지원하는 RDB와 AOF 방식의 차이점과 각각의 장단점은 무엇인가요?",
      "answer": "**RDB (Redis Database Snapshot):**\n\n**동작 방식:**\n- 특정 시점의 메모리 스냅샷을 디스크에 저장\n- fork()로 자식 프로세스 생성하여 백그라운드 저장\n- 바이너리 형식으로 압축 저장\n\n**장점:**\n- 파일 크기가 작음 (압축됨)\n- 백업/복구 용이\n- 재시작 시 빠른 로딩\n- AOF보다 디스크 I/O 적음\n\n**단점:**\n- 데이터 손실 가능 (마지막 스냅샷 이후 데이터)\n- fork() 시 메모리 2배 필요 가능 (Copy-on-Write)\n- 대용량 데이터셋에서 스냅샷 시간 오래 걸림\n- 정전 시 최대 몇 분 데이터 손실\n\n**설정:**\n- save 900 1 (900초 동안 1개 이상 변경)\n- save 300 10 (300초 동안 10개 이상 변경)\n- save 60 10000 (60초 동안 10000개 이상 변경)\n\n---\n\n**AOF (Append Only File):**\n\n**동작 방식:**\n- 모든 쓰기 명령어를 로그에 추가\n- 재시작 시 로그를 재실행하여 데이터 복원\n- 주기적으로 리라이트(재작성)하여 크기 최적화\n\n**장점:**\n- 데이터 손실 최소화 (초 단위 또는 명령어 단위)\n- fsync 정책 선택 가능 (always, everysec, no)\n- 사람이 읽을 수 있는 형식\n- 파일 손상 시 복구 도구 사용 가능\n\n**단점:**\n- 파일 크기가 RDB보다 큼\n- 재시작 시 로딩 느림\n- 쓰기 성능 오버헤드 (fsync 정책에 따라)\n- 리라이트 중 디스크 I/O 증가\n\n**fsync 정책:**\n- always: 모든 명령마다 동기화 (가장 안전, 가장 느림)\n- everysec: 1초마다 동기화 (권장, 최대 1초 손실)\n- no: OS에 맡김 (빠르지만 위험)\n\n---\n\n**혼합 사용 (권장):**\n\nRedis 4.0+에서는 RDB+AOF 혼합 방식 지원:\n- RDB 스냅샷 + 이후 변경사항을 AOF로 기록\n- 빠른 재시작 + 최소 데이터 손실\n- aof-use-rdb-preamble yes\n\n**선택 가이드:**\n- **RDB만**: 약간의 데이터 손실 허용, 빠른 재시작 필요\n- **AOF만**: 데이터 손실 최소화 필요, 느린 재시작 허용\n- **RDB+AOF**: 안전성과 성능 모두 중요 (권장)\n- **둘 다 끔**: 순수 캐시로만 사용 (휘발성)",
      "type": "essay",
      "tags": ["Redis", "Persistence", "RDB", "AOF", "영속성"],
      "id": "redis-005",
      "createdAt": "2025-11-17T13:00:00.000004",
      "studyCount": 0
    },
    {
      "question": "Redis의 Pub/Sub 기능은 어떻게 동작하며, 이를 활용한 메시징 시스템 구현 사례에 대해 설명해주세요.",
      "answer": "**Pub/Sub 동작 원리:**\n\n**기본 개념:**\n- Publisher(발행자): 메시지를 특정 채널에 발행\n- Subscriber(구독자): 관심 있는 채널을 구독하여 메시지 수신\n- Channel(채널): 메시지가 전달되는 논리적 경로\n\n**특징:**\n1. **Fire-and-Forget**: 구독자가 없어도 발행 가능 (메시지 손실)\n2. **실시간 전달**: 메시지가 즉시 모든 구독자에게 전달\n3. **1:N 통신**: 하나의 메시지를 여러 구독자가 수신\n4. **영속성 없음**: 메시지가 저장되지 않음\n5. **패턴 구독**: 와일드카드로 여러 채널 동시 구독 가능\n\n**주요 명령어:**\n- PUBLISH: 채널에 메시지 발행\n- SUBSCRIBE: 채널 구독\n- PSUBSCRIBE: 패턴으로 구독 (예: news.*)\n- UNSUBSCRIBE: 구독 해제\n- PUBSUB: 채널 정보 조회\n\n**패턴 매칭:**\n- \\* : 단일 레벨 (news.* → news.sports, news.tech)\n- ? : 단일 문자\n- [abc] : 문자 집합\n\n---\n\n**실제 활용 사례:**\n\n**1. 실시간 알림 시스템:**\n- 사용자별 채널 생성 (user:123:notifications)\n- 새 이벤트 발생 시 해당 채널에 발행\n- 웹소켓 서버가 구독하여 클라이언트에 전달\n\n**2. 채팅 애플리케이션:**\n- 채팅방마다 채널 생성 (room:456)\n- 메시지 발행 시 해당 방 참여자 모두에게 전달\n- 프라이빗 메시지는 개별 채널 사용\n\n**3. 마이크로서비스 이벤트 버스:**\n- 서비스 간 이벤트 전파\n- 주문 완료 → 재고, 배송, 알림 서비스 모두 구독\n- 느슨한 결합 유지\n\n**4. 캐시 무효화:**\n- 데이터 변경 시 invalidation 채널에 발행\n- 모든 캐시 서버가 구독하여 로컬 캐시 갱신\n\n**5. 실시간 대시보드:**\n- 메트릭 수집 서버가 stats 채널에 발행\n- 대시보드가 구독하여 실시간 차트 업데이트\n\n**6. 로그 수집:**\n- 각 서비스가 logs.servicename 채널에 발행\n- 로그 수집기가 logs.* 패턴으로 구독\n\n---\n\n**제약사항 및 대안:**\n\n**제약:**\n- 메시지 영속성 없음 (구독자 오프라인 시 손실)\n- 순서 보장 없음 (여러 발행자)\n- 전달 보장 없음 (at-most-once)\n- 메시지 재생 불가\n\n**보완 방법:**\n- **Redis Streams**: 메시지 영속성, 소비자 그룹, 재생 가능\n- **외부 메시지 큐**: RabbitMQ, Kafka 병행 사용\n- **하이브리드**: Pub/Sub로 알림, DB에 영구 저장\n\n**Redis Streams vs Pub/Sub:**\n- Streams: 메시지 저장, ACK, 재시도, 소비자 그룹\n- Pub/Sub: 실시간만, 더 단순, 더 빠름\n\n**선택 기준:**\n- 실시간 알림만 필요 → Pub/Sub\n- 메시지 손실 불허 → Streams 또는 Kafka\n- 대규모 메시징 → Kafka, RabbitMQ",
      "type": "essay",
      "tags": ["Redis", "Pub/Sub", "메시징", "실시간"],
      "id": "redis-006",
      "createdAt": "2025-11-17T13:00:00.000005",
      "studyCount": 0
    },
    {
      "question": "Redis Cluster의 기본 아키텍처와 데이터 샤딩(sharding) 방식에 대해 설명해주세요.",
      "answer": "**Redis Cluster 아키텍처:**\n\n**핵심 개념:**\n- 데이터를 여러 노드에 분산 저장 (수평 확장)\n- 자동 샤딩 및 리밸런싱\n- 고가용성 (마스터-슬레이브 복제)\n- 일부 노드 장애 시에도 계속 동작\n\n**구성 요소:**\n1. **마스터 노드**: 실제 데이터를 저장하고 쓰기 처리\n2. **슬레이브(복제본) 노드**: 마스터 데이터 복제, 읽기 처리, 장애 시 승격\n3. **최소 구성**: 마스터 3개 (과반수 필요)\n4. **권장 구성**: 마스터 3개 + 각 슬레이브 1개 이상 = 최소 6개 노드\n\n---\n\n**데이터 샤딩 방식:**\n\n**해시 슬롯 (Hash Slot):**\n- 전체 키 공간을 16,384개 슬롯으로 분할\n- 각 마스터 노드가 일부 슬롯 담당\n- 키의 CRC16 해시값 mod 16384 = 슬롯 번호\n- 슬롯 → 노드 매핑으로 데이터 위치 결정\n\n**예시:**\n- 3개 마스터: 각각 약 5,461개 슬롯 담당\n- 마스터 A: 슬롯 0-5460\n- 마스터 B: 슬롯 5461-10922\n- 마스터 C: 슬롯 10923-16383\n\n**해시 태그 (Hash Tag):**\n- 중괄호 {}로 특정 부분만 해싱\n- {user:123}:profile, {user:123}:cart → 같은 슬롯 (같은 노드)\n- 관련 데이터를 같은 노드에 저장 가능\n- 다중 키 연산 가능하게 함\n\n---\n\n**클러스터 통신:**\n\n**가십 프로토콜 (Gossip Protocol):**\n- 노드 간 상태 정보 교환\n- 노드 추가/제거, 장애 감지\n- 클러스터 토폴로지 동기화\n\n**리다이렉션:**\n- 클라이언트가 잘못된 노드에 접근 시\n- MOVED: 영구 이동 (슬롯이 다른 노드에 할당됨)\n- ASK: 임시 이동 (리샤딩 진행 중)\n- 스마트 클라이언트는 슬롯 맵 캐싱으로 직접 접근\n\n---\n\n**장애 처리:**\n\n**장애 감지:**\n- 과반수 노드가 특정 마스터 응답 없음 감지\n- PFAIL (가능한 장애) → FAIL (확정 장애)\n\n**자동 Failover:**\n1. 마스터 장애 감지\n2. 슬레이브 중 하나를 새 마스터로 승격\n3. 다른 슬레이브들이 새 마스터 복제\n4. 클러스터 토폴로지 업데이트\n\n**과반수 원칙:**\n- 과반수 마스터 살아있어야 클러스터 동작\n- 3개 마스터: 1개까지 장애 허용\n- 5개 마스터: 2개까지 장애 허용\n\n---\n\n**리샤딩 (Resharding):**\n\n**스케일 아웃:**\n- 새 노드 추가 후 슬롯 재분배\n- 실시간 마이그레이션 (서비스 중단 없음)\n- 점진적 이동 (슬롯 단위)\n\n**스케일 인:**\n- 노드 제거 전 슬롯을 다른 노드로 이동\n- 빈 노드 제거\n\n---\n\n**제약사항:**\n\n1. **다중 키 연산 제한**: 같은 슬롯(노드)에 있는 키만 가능\n2. **데이터베이스 선택 불가**: 단일 DB만 사용 (SELECT 명령 없음)\n3. **복제 지연**: 비동기 복제로 일시적 불일치 가능\n4. **네트워크 분할**: Split-brain 위험\n5. **클라이언트 지원**: 클러스터 인식 클라이언트 필요\n\n**vs Sentinel:**\n- Cluster: 샤딩 + 고가용성\n- Sentinel: 고가용성만 (단일 마스터, 샤딩 없음)",
      "type": "essay",
      "tags": ["Redis", "Cluster", "샤딩", "분산", "고가용성"],
      "id": "redis-007",
      "createdAt": "2025-11-17T13:00:00.000006",
      "studyCount": 0
    },
    {
      "question": "Redis Sentinel의 역할은 무엇이며, 이를 통해 어떻게 고가용성을 보장할 수 있나요?",
      "answer": "**Redis Sentinel 개요:**\n\nRedis Sentinel은 Redis의 고가용성(High Availability) 솔루션으로, 자동 장애 감지 및 장애 조치 시스템입니다.\n\n---\n\n**주요 역할:**\n\n**1. 모니터링 (Monitoring):**\n- 마스터와 슬레이브 노드들의 상태 지속 확인\n- 정기적으로 PING 전송하여 응답 체크\n- 성능 및 복제 지연 모니터링\n\n**2. 알림 (Notification):**\n- 노드 장애 시 관리자에게 경고\n- 이메일, SMS, 스크립트 실행 등\n- 시스템 이벤트 로깅\n\n**3. 자동 장애 조치 (Automatic Failover):**\n- 마스터 장애 감지 시 슬레이브를 새 마스터로 자동 승격\n- 다른 슬레이브들을 새 마스터에 재연결\n- 클라이언트에 새 마스터 정보 제공\n\n**4. 구성 제공자 (Configuration Provider):**\n- 클라이언트에게 현재 마스터 주소 제공\n- 장애 조치 후 자동으로 새 마스터 정보 전달\n- 서비스 디스커버리 역할\n\n---\n\n**동작 원리:**\n\n**Sentinel 구성:**\n- 최소 3개의 Sentinel 인스턴스 권장 (과반수 필요)\n- 홀수 개 권장 (3, 5, 7)\n- 서로 다른 물리적 서버에 배치\n\n**장애 감지 프로세스:**\n\n1. **주관적 다운 (SDOWN - Subjectively Down):**\n   - 단일 Sentinel이 마스터 응답 없음 감지\n   - 설정된 시간(down-after-milliseconds) 동안 무응답\n\n2. **객관적 다운 (ODOWN - Objectively Down):**\n   - 정족수(quorum) 이상의 Sentinel이 동의\n   - 실제 장애로 판단\n\n3. **Failover 시작:**\n   - Sentinel 중 리더 선출 (Raft 알고리즘)\n   - 리더가 Failover 진행\n\n**Failover 절차:**\n\n1. **슬레이브 선택:**\n   - 우선순위(slave-priority) 확인\n   - 복제 오프셋이 가장 최신인 슬레이브\n   - 응답 속도가 빠른 슬레이브\n\n2. **승격 (Promotion):**\n   - 선택된 슬레이브를 SLAVEOF NO ONE으로 마스터화\n   - 읽기 전용 해제\n\n3. **재구성 (Reconfiguration):**\n   - 나머지 슬레이브들을 새 마스터에 연결\n   - SLAVEOF <new-master-ip> <port>\n\n4. **업데이트:**\n   - 모든 Sentinel의 설정 업데이트\n   - 클라이언트 리다이렉션\n\n**일반적인 장애 조치 시간:**\n- 장애 감지: 수십 초 (설정에 따라)\n- Failover 실행: 수 초\n- 전체 과정: 보통 30초~1분\n\n---\n\n**고가용성 보장 방법:**\n\n**1. 자동 복구:**\n- 사람 개입 없이 자동 Failover\n- 24/7 무중단 운영 가능\n\n**2. 데이터 보호:**\n- 슬레이브에 데이터 복제본 유지\n- 마스터 장애 시 데이터 손실 최소화 (복제 지연만큼만)\n\n**3. 서비스 연속성:**\n- 클라이언트가 Sentinel 통해 마스터 위치 자동 파악\n- 투명한 Failover (클라이언트 재시작 불필요)\n\n**4. 네트워크 분할 대응:**\n- 과반수 원칙으로 Split-brain 방지\n- 소수파 파티션은 쓰기 중단 (min-slaves-to-write)\n\n---\n\n**제약사항 및 고려사항:**\n\n**제약:**\n- 비동기 복제로 인한 약간의 데이터 손실 가능\n- Failover 중 수십 초 쓰기 중단\n- 수평 확장(샤딩) 지원 안 함\n\n**구성 팁:**\n- Sentinel 3개 이상 홀수 개\n- 서로 다른 가용 영역에 배치\n- Sentinel과 Redis를 다른 서버에\n- down-after-milliseconds 적절히 설정 (30000ms 권장)\n- parallel-syncs 1 (Failover 후 동시 동기화 노드 수)\n\n**vs Redis Cluster:**\n- Sentinel: 고가용성만, 샤딩 없음, 단일 마스터\n- Cluster: 고가용성 + 샤딩, 여러 마스터\n- 소규모 → Sentinel, 대규모 → Cluster",
      "type": "essay",
      "tags": ["Redis", "Sentinel", "고가용성", "Failover"],
      "id": "redis-008",
      "createdAt": "2025-11-17T13:00:00.000007",
      "studyCount": 0
    },
    {
      "question": "Redis의 캐시 만료(expiration) 정책 설정 방법과, 실제 운영 시 고려해야 할 점은 무엇인가요?",
      "answer": "**캐시 만료 설정 방법:**\n\n**TTL 설정 명령어:**\n1. **EXPIRE**: 초 단위 TTL 설정\n2. **PEXPIRE**: 밀리초 단위 TTL\n3. **EXPIREAT**: Unix timestamp로 만료 시각 지정\n4. **PEXPIREAT**: 밀리초 단위 timestamp\n5. **SET with EX/PX**: 생성과 동시에 TTL 설정\n\n**TTL 확인 및 제거:**\n- TTL key: 남은 시간(초) 확인\n- PTTL key: 남은 시간(밀리초) 확인\n- PERSIST key: TTL 제거 (영구 키로 변경)\n\n---\n\n**만료 처리 메커니즘:**\n\n**1. 수동 만료 (Passive Expiration):**\n- 키 접근 시 만료 여부 확인\n- 만료되었으면 삭제 후 없음 반환\n- 접근하지 않는 키는 메모리에 남음\n\n**2. 능동 만료 (Active Expiration):**\n- 주기적으로 랜덤 키 샘플링 (초당 10회)\n- 만료된 키 발견 시 삭제\n- 만료 키가 25% 이상이면 즉시 재시도\n- CPU 사용률 제한 (최대 25%)\n\n**3. 메모리 부족 시:**\n- eviction 정책에 따라 강제 삭제\n\n---\n\n**운영 시 고려사항:**\n\n**1. TTL 설정 전략:**\n\n**짧은 TTL (초~분):**\n- 실시간성 중요 데이터\n- 자주 변경되는 데이터\n- 예: 세션, 실시간 순위, API 레이트 리밋\n\n**중간 TTL (분~시간):**\n- 일반적인 캐시 데이터\n- 예: API 응답, 쿼리 결과, 계산 결과\n\n**긴 TTL (시간~일):**\n- 거의 변하지 않는 데이터\n- 예: 설정값, 카테고리 목록\n\n**무한 TTL (영구):**\n- 명시적 삭제 전까지 유지\n- 예: 중요 설정, 카운터\n\n**2. 캐시 스탬피드 방지:**\n\n**문제:** 인기 있는 키가 만료될 때 다수 요청이 동시에 DB 접근\n\n**해결책:**\n- **Lock 사용**: 첫 요청만 DB 접근, 나머지는 대기\n- **Probabilistic Early Expiration**: 만료 전 확률적으로 미리 갱신\n- **Staggered Expiration**: 비슷한 키들의 TTL을 약간씩 다르게\n\n**3. 만료 시간 분산:**\n\n**문제:** 모든 키가 동시에 만료되면 CPU 스파이크\n\n**해결:** TTL에 랜덤 지터 추가\n- 예: 3600초 + random(0, 300) → 3600~3900초\n\n**4. 메모리 관리:**\n\n**만료되지 않은 키 누적:**\n- 접근 빈도 낮은 키는 수동 만료 안 됨\n- 능동 만료로도 샘플링 누락 가능\n- maxmemory-policy 설정 필수\n\n**메모리 오버헤드:**\n- TTL 저장에 추가 메모리 필요 (키당 약 8바이트)\n- 만료 처리에 CPU 사용\n\n**5. AOF 영속성과 만료:**\n\n- 만료된 키 삭제도 AOF에 기록 (DEL 명령)\n- 능동 만료 시 AOF 크기 증가\n- 정기적인 AOF 리라이트 필요\n\n**6. 복제 환경에서의 만료:**\n\n**마스터-슬레이브:**\n- 슬레이브는 자체적으로 만료 처리 안 함\n- 마스터가 만료 감지 시 DEL 명령을 슬레이브에 전송\n- 복제 지연 시 슬레이브에 만료된 키 존재 가능\n\n**일관성 문제:**\n- 슬레이브 읽기 시 만료된 키 읽힐 수 있음\n- 로직에서 TTL 확인 필요\n\n**7. 모니터링:**\n\n**주요 메트릭:**\n- expired_keys (누적 만료 키 수)\n- evicted_keys (강제 삭제 키 수)\n- keyspace_hits/misses (캐시 적중률)\n- used_memory (메모리 사용량)\n\n**8. 테스트 및 검증:**\n\n- 만료 로직 단위 테스트\n- 부하 테스트로 만료 영향 확인\n- 모의 장애 테스트 (마스터 장애 시 만료 동작)\n\n---\n\n**Best Practices:**\n\n1. **적절한 TTL 설정**: 데이터 특성에 맞게\n2. **지터 추가**: 동시 만료 방지\n3. **모니터링**: expired_keys 추적\n4. **eviction 정책**: maxmemory-policy 설정\n5. **캐시 워밍**: 서비스 시작 시 주요 캐시 미리 로드\n6. **Graceful Degradation**: 캐시 실패 시 DB로 폴백\n7. **문서화**: TTL 설정 이유와 기준 명시",
      "type": "essay",
      "tags": ["Redis", "캐시", "TTL", "만료정책"],
      "id": "redis-009",
      "createdAt": "2025-11-17T13:00:00.000008",
      "studyCount": 0
    },
    {
      "question": "Redis의 캐시 eviction 정책(LRU, LFU, TTL 등) 간의 차이점과 선택 기준에 대해 설명해주세요.",
      "answer": "**Eviction 정책 개요:**\n\nRedis가 maxmemory 한계에 도달했을 때 어떤 키를 삭제할지 결정하는 정책입니다.\n\n---\n\n**주요 정책:**\n\n**1. noeviction (기본값):**\n- 메모리 가득 차면 쓰기 명령 거부\n- 읽기는 계속 가능\n- OOM 에러 반환\n- 사용: 데이터 손실 절대 불허\n\n**2. allkeys-lru:**\n- 모든 키 중 가장 오래 사용되지 않은 키(Least Recently Used) 삭제\n- 범용 캐시에 가장 적합\n- 사용: 일반적인 캐싱\n\n**3. volatile-lru:**\n- TTL이 설정된 키 중 LRU 삭제\n- TTL 없는 키는 유지\n- 사용: 영구 데이터 + 캐시 혼용\n\n**4. allkeys-lfu:**\n- 모든 키 중 가장 적게 사용된 키(Least Frequently Used) 삭제\n- 접근 빈도 기반\n- 사용: 핫 데이터 보호 (Redis 4.0+)\n\n**5. volatile-lfu:**\n- TTL 설정된 키 중 LFU 삭제\n- 사용: TTL 키의 빈도 기반 관리 (Redis 4.0+)\n\n**6. allkeys-random:**\n- 모든 키 중 무작위 삭제\n- 빠르지만 비효율적\n- 사용: 키 접근 패턴 예측 불가\n\n**7. volatile-random:**\n- TTL 설정된 키 중 무작위 삭제\n- 사용: TTL 키의 단순 관리\n\n**8. volatile-ttl:**\n- TTL이 짧게 남은 키부터 삭제\n- 만료 임박 키 우선 제거\n- 사용: 만료 시간 기반 관리\n\n---\n\n**LRU vs LFU 비교:**\n\n**LRU (Least Recently Used):**\n- 마지막 접근 시간 기반\n- 최근 접근 안 된 키 삭제\n- 구현 간단, 오버헤드 낮음\n- 일시적 접근도 \"최근\" 으로 간주\n- 한번만 쓰이고 버려지는 데이터에 취약\n\n**LFU (Least Frequently Used):**\n- 접근 빈도(횟수) 기반\n- 자주 안 쓰인 키 삭제\n- 오버헤드 약간 높음\n- 핫 데이터 더 잘 보호\n- 과거 빈도가 높았던 \"좀비\" 키 문제 (decay로 해결)\n\n**Redis LFU 특징:**\n- Morris counter: 확률적 카운터로 메모리 절약\n- Decay: 시간에 따라 빈도 감소\n- lfu-log-factor, lfu-decay-time으로 조정\n\n---\n\n**선택 가이드:**\n\n**allkeys-lru (가장 일반적):**\n- ✅ 범용 캐시\n- ✅ 균등한 접근 패턴\n- ✅ 메모리 제한 엄격\n- 예: 웹 페이지 캐시, API 응답\n\n**allkeys-lfu:**\n- ✅ 명확한 핫/콜드 데이터 구분\n- ✅ 인기 데이터 보호 중요\n- ✅ 일시적 스파이크 많음\n- 예: 인기 상품, 추천 피드\n\n**volatile-lru:**\n- ✅ 영구 데이터 + 캐시 혼용\n- ✅ TTL 있는 키만 evict\n- ✅ 중요 설정 데이터 보호\n- 예: 세션(TTL) + 설정(영구)\n\n**volatile-ttl:**\n- ✅ TTL 기반 정리\n- ✅ 만료 임박 키 우선 제거\n- 예: 시간 제한 이벤트, 임시 데이터\n\n**noeviction:**\n- ✅ 데이터 손실 불허\n- ✅ 메모리 full 시 알림 필요\n- ⚠️ 쓰기 실패 처리 필요\n- 예: 결제 정보, 중요 세션\n\n---\n\n**실제 운영 고려사항:**\n\n**1. 정책 설정:**\n- redis.conf: maxmemory-policy allkeys-lru\n- CONFIG SET: 런타임 변경 가능\n\n**2. 메모리 제한:**\n- maxmemory 설정 필수\n- 물리 메모리의 75~80% 권장\n- 복제 환경은 더 여유있게 (버퍼 필요)\n\n**3. 샘플링:**\n- Redis는 전체 키 스캔 안 함\n- maxmemory-samples 5 (기본값)\n- 높을수록 정확하지만 느림\n- 3~10 사이 권장\n\n**4. 성능 영향:**\n- Eviction 발생 시 약간의 지연\n- 빈번한 eviction은 성능 저하 신호\n- 메모리 부족 전에 스케일 아웃 고려\n\n**5. 모니터링:**\n- evicted_keys: 누적 삭제 키 수\n- 급증 시 메모리 부족 신호\n- used_memory_peak: 최대 사용량\n\n**6. TTL과 Eviction 조합:**\n- TTL 설정으로 자동 만료\n- Eviction은 최후 수단\n- 적절한 TTL로 eviction 빈도 감소\n\n**7. Keyspace 분리:**\n- 중요도별 Redis 인스턴스 분리\n- 영구 데이터 전용 인스턴스\n- 캐시 전용 인스턴스\n\n---\n\n**Best Practices:**\n\n1. **allkeys-lru를 기본으로**: 대부분 상황에 적합\n2. **메모리 모니터링**: 80% 이상 시 경고\n3. **적절한 maxmemory**: 물리 메모리의 80%\n4. **TTL 활용**: Eviction 부담 감소\n5. **테스트**: 부하 테스트로 정책 검증\n6. **문서화**: 정책 선택 이유 기록\n7. **알림 설정**: evicted_keys 급증 시 알림",
      "type": "essay",
      "tags": ["Redis", "Eviction", "LRU", "LFU", "캐시정책"],
      "id": "redis-010",
      "createdAt": "2025-11-17T13:00:00.000009",
      "studyCount": 0
    },
    {
      "question": "Redis의 트랜잭션 기능(MULTI, EXEC, WATCH 등)을 활용하여 동시성 문제를 어떻게 해결할 수 있는지 설명해주세요.",
      "answer": "**Redis 트랜잭션 개요:**\n\nRedis는 MULTI/EXEC를 통해 여러 명령어를 하나의 원자적 단위로 실행할 수 있습니다.\n\n---\n\n**기본 명령어:**\n\n**MULTI:**\n- 트랜잭션 시작\n- 이후 명령어들을 큐에 저장\n- 즉시 실행되지 않고 QUEUED 응답\n\n**EXEC:**\n- 큐에 저장된 모든 명령어를 순차적으로 실행\n- 원자적 실행 (중간에 다른 클라이언트 명령 끼어들 수 없음)\n- 모든 명령어의 결과 배열 반환\n\n**DISCARD:**\n- 트랜잭션 취소\n- 큐 비우기\n- MULTI 이전 상태로 복귀\n\n**WATCH:**\n- 낙관적 잠금(Optimistic Locking)\n- 키 변경 감시\n- EXEC 전에 감시 키가 변경되면 트랜잭션 실패\n\n**UNWATCH:**\n- 모든 WATCH 해제\n- 새 트랜잭션 시작 전 정리\n\n---\n\n**특징:**\n\n**원자성 보장:**\n- 모든 명령어가 실행되거나, 하나도 실행 안 됨\n- 부분 실패 없음 (전부 또는 전무)\n- 중간에 다른 명령어 끼어들 수 없음\n\n**격리성 제한:**\n- 트랜잭션 내에서도 다른 클라이언트 읽기 가능\n- 완벽한 격리는 아님\n\n**Rollback 없음:**\n- 명령어 실패해도 계속 진행\n- 이전 명령어 되돌리기 안 함\n- 오류는 결과에 포함\n\n---\n\n**동시성 문제 해결:**\n\n**1. Race Condition 방지:**\n\n**문제 시나리오:** 카운터 증가\n- 클라이언트 A: GET counter (100)\n- 클라이언트 B: GET counter (100)\n- 클라이언트 A: SET counter 101\n- 클라이언트 B: SET counter 101\n- 결과: 102가 아닌 101 (하나 손실)\n\n**해결: 원자적 연산 사용**\n- INCR counter (원자적)\n- 트랜잭션 필요 없음\n\n**복잡한 경우: WATCH 사용**\n- WATCH counter\n- MULTI\n- GET counter (현재 값 확인)\n- SET counter (새 값)\n- EXEC\n- EXEC 실패 시 재시도\n\n**2. 낙관적 잠금 (Optimistic Locking):**\n\n**동작 방식:**\n1. WATCH로 키 감시 시작\n2. 현재 값 읽기\n3. 새 값 계산\n4. MULTI로 트랜잭션 시작\n5. 계산된 값 저장\n6. EXEC 실행\n7. EXEC 실패 시 (다른 클라이언트가 수정) 재시도\n\n**장점:**\n- 경합이 적을 때 효율적\n- 잠금 대기 없음\n\n**단점:**\n- 경합 많으면 재시도 빈번\n- CAS(Compare-And-Swap) 패턴\n\n**3. 재고 관리 예제:**\n\n**시나리오:** 재고 차감\n\n**잘못된 방법:**\n- GET stock:item123 (읽기)\n- 재고 확인\n- SET stock:item123 (차감)\n- → 동시 접근 시 over-selling\n\n**올바른 방법:**\n- WATCH stock:item123\n- GET stock:item123\n- 재고 충분 확인\n- MULTI\n- DECR stock:item123\n- (주문 정보 저장)\n- EXEC\n- 실패 시 재시도\n\n**4. 계좌 이체 예제:**\n\n**시나리오:** A → B로 송금\n\n**원자적 실행 필요:**\n- A 잔액 감소\n- B 잔액 증가\n- 둘 다 성공하거나, 둘 다 실패해야 함\n\n**구현:**\n- WATCH account:A account:B\n- GET account:A (잔액 확인)\n- 충분한지 체크\n- MULTI\n- DECRBY account:A 1000\n- INCRBY account:B 1000\n- EXEC\n\n---\n\n**제약사항:**\n\n**1. Rollback 없음:**\n- 중간 명령어 실패해도 계속 진행\n- 오류 처리 로직 필수\n- 논리적 일관성은 애플리케이션에서 보장\n\n**2. 조건부 실행 제한:**\n- 트랜잭션 내에서 조건문 불가\n- 모든 명령어가 큐에 들어가면 무조건 실행\n- Lua 스크립트로 해결 가능\n\n**3. 성능 고려:**\n- WATCH는 낙관적 잠금 (경합 시 재시도)\n- 높은 경합 환경에서 비효율적\n- 단일 원자적 명령어 사용 권장 (INCR, HINCRBY 등)\n\n**4. Pipeline과의 차이:**\n- Pipeline: 네트워크 왕복 최소화 (원자성 보장 안 함)\n- Transaction: 원자성 보장 (네트워크는 별개)\n- Pipeline 내에서 Transaction 사용 가능\n\n---\n\n**Best Practices:**\n\n**1. 원자적 명령어 우선:**\n- INCR, HINCRBY, SADD 등\n- 트랜잭션보다 빠르고 단순\n\n**2. WATCH 재시도 로직:**\n- 최대 재시도 횟수 제한\n- 지수 백오프 적용\n- 무한 루프 방지\n\n**3. Lua 스크립트 활용:**\n- 복잡한 로직은 Lua로\n- 조건부 실행 가능\n- 트랜잭션보다 유연\n\n**4. 키 최소화:**\n- WATCH 하는 키 최소한으로\n- 경합 범위 축소\n\n**5. 에러 처리:**\n- EXEC 결과 확인 (nil = 실패)\n- 각 명령어 결과 확인\n- 재시도 또는 롤백 로직\n\n**6. 문서화:**\n- 트랜잭션 범위 명시\n- 실패 시나리오 정리\n- 재시도 정책 문서화",
      "type": "essay",
      "tags": ["Redis", "트랜잭션", "MULTI", "EXEC", "WATCH", "동시성"],
      "id": "redis-011",
      "createdAt": "2025-11-17T13:00:00.000010",
      "studyCount": 0
    },
    {
      "question": "Redis에서 Lua 스크립트를 사용하는 이유와, 스크립팅 기능이 주는 이점은 무엇인가요?",
      "answer": "**Lua 스크립트 개요:**\n\nRedis는 서버 측에서 Lua 스크립트를 실행하여 복잡한 로직을 원자적으로 처리할 수 있습니다.\n\n---\n\n**사용하는 이유:**\n\n**1. 원자성 보장:**\n- 스크립트 전체가 원자적으로 실행\n- 중간에 다른 명령어 끼어들 수 없음\n- 트랜잭션보다 강력한 원자성\n\n**2. 조건부 로직:**\n- if/else, loop 등 프로그래밍 구조 사용 가능\n- MULTI/EXEC는 조건 처리 불가\n- 복잡한 비즈니스 로직 구현 가능\n\n**3. 네트워크 왕복 감소:**\n- 여러 명령어를 하나의 요청으로\n- 클라이언트-서버 간 통신 최소화\n- 지연시간 대폭 감소\n\n**4. 성능 향상:**\n- 서버 측 실행으로 빠른 처리\n- 메모리 접근 직접\n- 네트워크 오버헤드 제거\n\n**5. 일관성 보장:**\n- 데이터 조회와 수정을 단일 단위로\n- Race condition 방지\n- 데이터 무결성 유지\n\n---\n\n**주요 이점:**\n\n**1. 복잡한 연산:**\n- 여러 키에 걸친 조건부 로직\n- 반복문으로 대량 처리\n- 계산 집약적 작업\n\n**2. 트랜잭션 한계 극복:**\n- 동적 명령어 생성\n- 실행 중 결과 기반 분기\n- 부분 롤백 구현 가능\n\n**3. 재사용 가능:**\n- SCRIPT LOAD로 스크립트 등록\n- SHA1 해시로 재사용\n- 네트워크 전송량 감소\n\n**4. 캐시 로직 서버화:**\n- 애플리케이션 로직을 Redis로 이동\n- 일관된 캐시 관리\n- 다국어 클라이언트 간 로직 공유\n\n---\n\n**실제 활용 사례:**\n\n**1. Rate Limiting (속도 제한):**\n- 특정 사용자 요청 수 제한\n- 시간 윈도우 내 카운트 증가\n- 임계값 초과 시 거부\n- 모두 원자적으로 처리\n\n**2. 조건부 업데이트:**\n- 현재 값 확인 후 조건 만족 시만 업데이트\n- CAS(Compare-And-Swap) 패턴\n- 낙관적 잠금\n\n**3. 복잡한 점수 계산:**\n- 여러 요소 조합한 점수\n- Sorted Set 업데이트\n- 리더보드 갱신\n\n**4. 분산 잠금:**\n- RedLock 알고리즘 구현\n- 잠금 획득/해제의 원자성\n- 타임아웃 처리\n\n**5. 세션 연장:**\n- 세션 존재 확인\n- TTL 연장\n- 메타데이터 업데이트\n- 한 번의 요청으로 처리\n\n**6. 재고 관리:**\n- 재고 확인\n- 충분하면 차감 및 예약\n- 부족하면 실패 반환\n- 오버셀링 방지\n\n**7. 배치 처리:**\n- 다수 키 일괄 처리\n- 조건에 맞는 키만 수정\n- 반복문으로 대량 작업\n\n---\n\n**명령어:**\n\n**EVAL:**\n- 스크립트 직접 실행\n- 매번 전체 스크립트 전송\n- 개발/테스트용\n\n**EVALSHA:**\n- SHA1 해시로 실행\n- 스크립트 사전 로드 필요\n- 프로덕션 권장\n\n**SCRIPT LOAD:**\n- 스크립트 등록 및 SHA1 반환\n- 클라이언트가 해시 캐싱\n\n**SCRIPT EXISTS:**\n- 스크립트 존재 여부 확인\n\n**SCRIPT FLUSH:**\n- 모든 스크립트 제거\n\n**SCRIPT KILL:**\n- 실행 중인 스크립트 강제 종료\n- 쓰기 작업 없을 때만 가능\n\n---\n\n**제약사항:**\n\n**1. 결정적(Deterministic) 실행:**\n- 같은 입력 → 항상 같은 출력\n- 랜덤 함수, 시간 함수 제한\n- 복제 일관성 위해 필수\n\n**2. 실행 시간:**\n- 기본 5초 타임아웃 (lua-time-limit)\n- 긴 작업은 서버 블로킹\n- 타임아웃 후 SCRIPT KILL로 종료\n\n**3. 메모리:**\n- 스크립트 결과는 메모리에\n- 대량 데이터 반환 시 주의\n- 메모리 부족 위험\n\n**4. 디버깅:**\n- 에러 메시지 제한적\n- 로깅 어려움\n- 테스트 환경 필수\n\n**5. 복제:**\n- 스크립트 효과만 복제 (명령어로)\n- 비결정적 스크립트는 위험\n- redis.replicate_commands() 사용 권장\n\n---\n\n**Best Practices:**\n\n**1. EVALSHA 사용:**\n- 프로덕션에서는 SHA1 해시 사용\n- 네트워크 절약\n- 성능 향상\n\n**2. 짧은 실행 시간:**\n- 복잡한 로직 최소화\n- 긴 반복문 지양\n- 필요 시 배치 분할\n\n**3. 키 명시:**\n- KEYS 배열에 모든 키 전달\n- Redis Cluster 호환\n- 명확한 의존성\n\n**4. 에러 처리:**\n- redis.call vs redis.pcall\n- pcall은 에러를 반환값으로\n- 적절한 에러 핸들링\n\n**5. 테스트:**\n- 단위 테스트 작성\n- 다양한 입력 검증\n- 성능 테스트\n\n**6. 문서화:**\n- 스크립트 목적 명시\n- 입력/출력 스펙 정의\n- 사용 예제 제공\n\n**7. 버전 관리:**\n- 스크립트를 코드베이스에 포함\n- 변경 이력 추적\n- 배포 전략 수립\n\n**8. 모니터링:**\n- SLOWLOG로 느린 스크립트 추적\n- lua-time-limit 모니터링\n- 에러 로깅",
      "type": "essay",
      "tags": ["Redis", "Lua", "스크립트", "원자성", "성능"],
      "id": "redis-012",
      "createdAt": "2025-11-17T13:00:00.000011",
      "studyCount": 0
    },
    {
      "question": "Redis의 메모리 관리 전략과, 메모리 부족 시 발생할 수 있는 문제 및 해결 방법에 대해 설명해주세요.",
      "answer": "**Redis 메모리 관리 전략:**\n\n**1. 메모리 할당:**\n- jemalloc 사용 (기본값)\n- 효율적인 메모리 할당/해제\n- 단편화 최소화 노력\n\n**2. 메모리 구성:**\n- 데이터: 실제 키-값 데이터\n- 메타데이터: 키 이름, 타입 정보, TTL 등\n- 버퍼: 복제, AOF, 클라이언트 출력 버퍼\n- 오버헤드: 구조체, 포인터 등\n\n**3. 메모리 제한:**\n- maxmemory: 최대 사용 메모리 설정\n- 미설정 시 물리 메모리까지 사용 (위험)\n- 물리 메모리의 75~80% 권장\n\n**4. Eviction 정책:**\n- maxmemory 도달 시 키 삭제\n- LRU, LFU, TTL, Random 등\n- noeviction: 쓰기 거부\n\n---\n\n**메모리 부족 시 발생 문제:**\n\n**1. OOM (Out Of Memory) 에러:**\n- 쓰기 명령 실패\n- 애플리케이션 에러\n- 서비스 장애\n\n**2. Eviction 과다:**\n- 유효 데이터 삭제\n- 캐시 미스 증가\n- DB 부하 증가\n- 성능 저하\n\n**3. Swap 사용:**\n- 메모리 → 디스크 스왑\n- 극심한 성능 저하 (100배 이상)\n- 응답 시간 급증\n\n**4. Fork 실패:**\n- RDB/AOF 저장 실패\n- 백그라운드 저장 불가\n- 데이터 손실 위험\n\n**5. 복제 지연:**\n- 버퍼 부족으로 복제 실패\n- 마스터-슬레이브 불일치\n- Failover 위험\n\n**6. 메모리 단편화:**\n- 실제 사용량보다 더 많은 메모리 점유\n- 가용 메모리 감소\n- 효율 저하\n\n---\n\n**해결 방법:**\n\n**1. maxmemory 설정:**\n- 적절한 한계 설정\n- 물리 메모리의 75% 권장\n- 복제 환경은 더 여유있게\n\n**2. Eviction 정책 설정:**\n- allkeys-lru 권장\n- 애플리케이션 특성에 맞게\n- 모니터링으로 효과 검증\n\n**3. TTL 적극 사용:**\n- 임시 데이터에 만료 시간 설정\n- 자동 정리로 메모리 확보\n- Eviction 부담 감소\n\n**4. 데이터 구조 최적화:**\n\n**Hash 최적화:**\n- 작은 해시는 ziplist로 저장 (메모리 효율)\n- hash-max-ziplist-entries 512\n- hash-max-ziplist-value 64\n\n**List 최적화:**\n- quicklist 사용\n- list-max-ziplist-size\n- list-compress-depth\n\n**Set/Zset 최적화:**\n- intset, ziplist 활용\n- 작은 컬렉션 압축 저장\n\n**5. 키 네이밍 최적화:**\n- 짧은 키 이름 사용\n- 불필요한 prefix 제거\n- 메모리 절약 (키도 메모리 차지)\n\n**6. 메모리 압축:**\n- Hash, List, Set의 압축 인코딩\n- 설정값 조정으로 최적화\n\n**7. 메모리 모니터링:**\n\n**주요 메트릭:**\n- used_memory: 실제 사용 메모리\n- used_memory_rss: OS가 보는 메모리 (RSS)\n- mem_fragmentation_ratio: 단편화 비율\n- evicted_keys: 삭제된 키 수\n- maxmemory: 설정된 한계\n\n**명령어:**\n- INFO MEMORY: 메모리 상세 정보\n- MEMORY STATS: 메모리 통계\n- MEMORY DOCTOR: 메모리 진단\n- MEMORY USAGE key: 특정 키 메모리 사용량\n\n**8. 메모리 단편화 해결:**\n\n**단편화 비율:**\n- used_memory_rss / used_memory\n- 1.0~1.5: 정상\n- 1.5 이상: 단편화 심각\n- 1.0 미만: Swap 사용 중 (위험)\n\n**해결책:**\n- Redis 재시작 (가장 확실)\n- activedefrag yes (Redis 4.0+)\n- 자동 조각 모음\n- 부하 낮을 때 실행\n\n**9. 스케일링:**\n\n**수직 확장:**\n- 더 큰 메모리 인스턴스\n- 비용 증가\n- 한계 존재\n\n**수평 확장:**\n- Redis Cluster로 샤딩\n- 여러 인스턴스로 분산\n- 복잡도 증가\n\n**데이터 분리:**\n- 용도별 Redis 인스턴스\n- 캐시 전용 / 영구 데이터 전용\n- 리소스 격리\n\n**10. Swap 방지:**\n- overcommit_memory 설정\n- Swap 비활성화 고려\n- 충분한 물리 메모리\n\n---\n\n**Best Practices:**\n\n**1. 사전 계획:**\n- 예상 데이터 크기 계산\n- 적절한 인스턴스 크기 선택\n- 여유 30% 확보\n\n**2. 정기 모니터링:**\n- used_memory 추이 관찰\n- evicted_keys 추적\n- 단편화 비율 확인\n\n**3. 알림 설정:**\n- 메모리 80% 이상 시 경고\n- eviction 발생 시 알림\n- 단편화 심각 시 알림\n\n**4. 부하 테스트:**\n- 최대 부하 시나리오 테스트\n- 메모리 사용량 측정\n- 적정 용량 결정\n\n**5. 정기 리뷰:**\n- 불필요한 데이터 정리\n- TTL 정책 검토\n- 데이터 구조 최적화\n\n**6. 장애 대응:**\n- Failover 계획 수립\n- 백업 인스턴스 준비\n- 빠른 스케일링 방안",
      "type": "essay",
      "tags": ["Redis", "메모리관리", "OOM", "Eviction", "최적화"],
      "id": "redis-013",
      "createdAt": "2025-11-17T13:00:00.000012",
      "studyCount": 0
    },
    {
      "question": "Redis에서 Key 네임스페이스(예: Key prefix)를 사용하는 이유와 장점은 무엇인가요?",
      "answer": "**Key 네임스페이스 개요:**\n\nRedis는 단일 플랫 키 공간을 사용하므로, prefix를 통해 논리적 네임스페이스를 구성합니다.\n\n**일반적인 패턴:**\n- user:123:profile\n- session:abc123\n- cache:product:456\n- counter:page:views:789\n\n---\n\n**사용하는 이유:**\n\n**1. 논리적 분리:**\n- 관련 데이터를 그룹화\n- 도메인별 구분\n- 기능별 구분\n\n**2. 충돌 방지:**\n- 다른 애플리케이션 간 키 충돌 방지\n- 같은 ID라도 prefix로 구분\n- user:123 vs product:123\n\n**3. 관리 용이:**\n- 특정 그룹 키 일괄 처리\n- 패턴 매칭으로 검색\n- 삭제, 조회, 만료 설정\n\n**4. 디버깅:**\n- 키 이름만으로 용도 파악\n- 문제 키 추적 용이\n- 로깅 및 모니터링 개선\n\n**5. 권한 관리:**\n- ACL로 prefix별 접근 제어 (Redis 6.0+)\n- 팀별, 서비스별 권한 분리\n\n---\n\n**장점:**\n\n**1. 가독성:**\n- 명확한 키 의미\n- 계층 구조 표현\n- 문서화 효과\n\n**2. 유지보수:**\n- 관련 키 쉽게 식별\n- 리팩토링 용이\n- 마이그레이션 계획 수립\n\n**3. 성능 최적화:**\n- 관련 키를 같은 해시 슬롯에 배치 (Cluster)\n- Hash tag 활용: {user:123}:profile, {user:123}:cart\n- 다중 키 연산 가능\n\n**4. TTL 관리:**\n- prefix별 만료 정책 설정\n- 그룹 단위 캐시 무효화\n- 일관된 수명 주기\n\n**5. 모니터링:**\n- prefix별 메모리 사용량 추적\n- 키 개수 통계\n- 성능 분석\n\n**6. 테스트:**\n- 테스트 데이터 분리\n- test:* prefix 사용\n- 테스트 후 일괄 정리\n\n---\n\n**네이밍 컨벤션:**\n\n**계층 구조:**\n- 콜론(:) 구분자 사용\n- entity:id:attribute\n- service:module:resource:id\n\n**예시:**\n- user:123:profile\n- order:456:items\n- cache:api:users:789\n- session:prod:abc123\n\n**환경 구분:**\n- dev:user:123\n- staging:user:123\n- prod:user:123\n\n**버전 관리:**\n- v1:api:users:123\n- v2:api:users:123\n\n---\n\n**패턴 매칭 활용:**\n\n**KEYS 명령:**\n- KEYS user:* (모든 사용자 키)\n- KEYS cache:product:* (제품 캐시)\n- KEYS session:* (모든 세션)\n- ⚠️ 프로덕션에서 주의 (O(N), 블로킹)\n\n**SCAN 명령 (권장):**\n- SCAN cursor MATCH user:*\n- 점진적 반복\n- 블로킹 없음\n\n**일괄 삭제:**\n- redis-cli --scan --pattern \"temp:*\" | xargs redis-cli DEL\n- 특정 prefix 키 모두 삭제\n\n---\n\n**Redis Cluster 고려:**\n\n**Hash Tag:**\n- {user:123}:profile\n- {user:123}:cart\n- 중괄호 안의 부분만 해싱\n- 같은 노드에 저장 보장\n- 다중 키 연산 가능\n\n**일관된 해싱:**\n- prefix가 다르면 다른 슬롯\n- 관련 데이터 분산\n- Hash Tag로 해결\n\n---\n\n**단점 및 주의사항:**\n\n**1. 키 길이:**\n- prefix가 긴 경우 메모리 낭비\n- 네트워크 오버헤드\n- 적절한 길이 유지 필요\n\n**2. 타이핑:**\n- 오타 위험\n- 상수 또는 헬퍼 함수 사용 권장\n\n**3. 리팩토링:**\n- prefix 변경 시 마이그레이션 필요\n- 기존 키 rename 또는 복사\n- 다운타임 최소화 전략\n\n**4. KEYS 명령:**\n- O(N) 시간복잡도\n- 전체 키 스캔\n- 프로덕션에서 SCAN 사용\n\n---\n\n**Best Practices:**\n\n**1. 일관된 컨벤션:**\n- 팀 전체가 동일한 규칙 사용\n- 문서화\n- 코드 리뷰\n\n**2. 짧고 명확하게:**\n- 불필요하게 길지 않게\n- 약어 사용 고려\n- usr: vs user:\n\n**3. 계층 제한:**\n- 너무 깊은 계층 지양\n- 3~4 레벨 권장\n- user:123:settings:notification:email (너무 김)\n\n**4. 예약어 피하기:**\n- Redis 명령어와 중복 피함\n- 혼란 방지\n\n**5. 환경 분리:**\n- 개발/스테이징/프로덕션 구분\n- 또는 별도 Redis 인스턴스\n\n**6. 헬퍼 함수:**\n- 키 생성 유틸리티\n- 타이핑 오류 방지\n- 일관성 유지\n\n**7. 모니터링:**\n- prefix별 메모리 사용량\n- redis-cli --bigkeys\n- 정기적인 감사\n\n**8. 정리 전략:**\n- 사용하지 않는 prefix 정리\n- TTL 설정으로 자동 만료\n- 정기적인 cleanup 스크립트",
      "type": "essay",
      "tags": ["Redis", "네임스페이스", "키관리", "네이밍"],
      "id": "redis-014",
      "createdAt": "2025-11-17T13:00:00.000013",
      "studyCount": 0
    },
    {
      "question": "Redis를 활용한 세션 관리 구현의 장점과 고려해야 할 단점은 무엇인가요?",
      "answer": "**Redis 세션 관리 개요:**\n\nRedis를 중앙 세션 저장소로 활용하여 여러 애플리케이션 서버가 세션을 공유합니다.\n\n---\n\n**장점:**\n\n**1. 수평 확장 가능:**\n- 애플리케이션 서버 추가/제거 자유\n- 로드 밸런서가 아무 서버로 요청 전달 가능\n- Sticky Session 불필요\n\n**2. 고속 접근:**\n- 메모리 기반으로 매우 빠름\n- 세션 조회 1ms 미만\n- DB보다 10~100배 빠름\n\n**3. 자동 만료:**\n- TTL 설정으로 자동 세션 정리\n- 메모리 누수 방지\n- 별도 cleanup 작업 불필요\n\n**4. 단순한 API:**\n- 키-값 구조로 직관적\n- 다양한 언어 클라이언트 지원\n- 학습 곡선 낮음\n\n**5. 데이터 구조 활용:**\n- Hash로 세션 필드 저장\n- 부분 업데이트 가능 (HSET, HGET)\n- 메모리 효율적\n\n**6. 고가용성:**\n- Sentinel/Cluster로 자동 Failover\n- 데이터 복제로 안정성\n- 서비스 중단 최소화\n\n**7. 통합 편의:**\n- Spring Session, Express-session 등 프레임워크 지원\n- 설정만으로 Redis 세션 사용\n- 코드 변경 최소\n\n---\n\n**단점 및 고려사항:**\n\n**1. 네트워크 의존성:**\n- 모든 세션 접근이 네트워크 통신\n- 네트워크 지연 발생 가능\n- 로컬 메모리보다 느림\n- Redis 장애 시 세션 접근 불가\n\n**2. 단일 장애점 (SPOF):**\n- Redis 다운 시 모든 세션 손실\n- 고가용성 구성 필수 (Sentinel/Cluster)\n- 추가 인프라 복잡도\n\n**3. 메모리 제약:**\n- 세션 수 증가 시 메모리 부족\n- 대규모 사용자 시 비용 증가\n- 적절한 TTL 설정 필요\n\n**4. 직렬화 오버헤드:**\n- 객체를 JSON/Pickle 등으로 직렬화\n- 직렬화/역직렬화 CPU 사용\n- 복잡한 객체는 느릴 수 있음\n\n**5. 보안:**\n- 네트워크로 세션 데이터 전송\n- 암호화 필요 (TLS/SSL)\n- 민감 정보 저장 주의\n- Redis 인증 설정 필수\n\n**6. 비용:**\n- 추가 Redis 인프라 비용\n- 메모리 비용 (디스크보다 비쌈)\n- 관리 리소스 필요\n\n**7. 데이터 손실 가능성:**\n- 영속성 설정 없으면 재시작 시 손실\n- RDB/AOF 설정 필요\n- 하지만 세션은 일시적이므로 허용 가능한 경우 많음\n\n---\n\n**구현 패턴:**\n\n**1. 단순 String 저장:**\n- 세션 ID → 직렬화된 세션 객체\n- SET session:abc123 \"serialized_data\" EX 3600\n- 간단하지만 부분 업데이트 불가\n\n**2. Hash 사용 (권장):**\n- 세션 ID → Hash (필드-값 쌍)\n- HSET session:abc123 username \"alice\"\n- HSET session:abc123 email \"alice@example.com\"\n- 부분 조회/업데이트 가능\n- 메모리 효율적\n\n**3. 이중 저장:**\n- String에 전체 세션\n- Hash에 자주 조회하는 필드\n- 성능과 유연성 균형\n\n---\n\n**TTL 관리:**\n\n**슬라이딩 윈도우:**\n- 활동 시마다 TTL 갱신\n- EXPIRE session:abc123 3600\n- 비활성 시간 기준 만료\n\n**절대 만료:**\n- 로그인 시각부터 고정 시간\n- EXPIREAT로 특정 시각 설정\n- 보안 강화 (최대 세션 시간)\n\n**혼합 방식:**\n- 슬라이딩 + 절대 만료 모두 적용\n- 더 짧은 시간에 만료\n\n---\n\n**세션 전략:**\n\n**1. Stateless 토큰:**\n- JWT 등으로 클라이언트에 저장\n- Redis 부담 없음\n- 하지만 즉시 무효화 어려움\n\n**2. 하이브리드:**\n- JWT + Redis 블랙리스트\n- 정상: 토큰만 검증\n- 로그아웃: Redis에 토큰 ID 저장\n- 빠르면서 무효화 가능\n\n**3. 전통적 세션:**\n- 세션 ID만 클라이언트 전달\n- 모든 데이터 Redis에\n- 무효화 즉시 가능\n- 서버 측 제어 완전\n\n---\n\n**Best Practices:**\n\n**1. 적절한 TTL:**\n- 30분~2시간 권장\n- 활동 시 갱신\n- 보안과 UX 균형\n\n**2. 데이터 최소화:**\n- 필수 정보만 저장\n- 민감 정보는 별도 저장소\n- 메모리 절약\n\n**3. 압축:**\n- 큰 세션 객체는 압축\n- gzip, snappy 등\n- 네트워크/메모리 절약\n\n**4. 접두사 사용:**\n- session:, sess: 등 prefix\n- 관리 용이\n- 일괄 삭제 가능\n\n**5. 고가용성:**\n- Sentinel 또는 Cluster\n- 최소 3노드\n- 자동 Failover\n\n**6. 모니터링:**\n- 세션 수 추적\n- 메모리 사용량\n- 만료율\n\n**7. 백업:**\n- 중요 세션은 DB 동기화\n- Redis 장애 대비\n- 또는 빠른 복구 계획\n\n**8. 보안:**\n- TLS 연결\n- requirepass 설정\n- 민감 정보 암호화\n- 네트워크 격리\n\n**9. 성능:**\n- Connection pooling\n- Pipeline 사용 고려\n- 불필요한 조회 최소화\n\n**10. 테스트:**\n- 세션 만료 시나리오\n- Redis 장애 시나리오\n- 동시 접속 부하 테스트",
      "type": "essay",
      "tags": ["Redis", "세션관리", "캐시", "확장성"],
      "id": "redis-015",
      "createdAt": "2025-11-17T13:00:00.000014",
      "studyCount": 0
    },
    {
      "question": "Redis의 데이터 복제(replication) 메커니즘과 이를 통한 데이터 가용성 확보 방법에 대해 설명해주세요.",
      "answer": "**Redis 복제 개요:**\n\nRedis는 Master-Slave 복제를 통해 데이터를 여러 노드에 복사하여 가용성과 읽기 성능을 향상시킵니다.\n\n---\n\n**복제 구조:**\n\n**Master (마스터):**\n- 쓰기 및 읽기 처리\n- 단일 마스터 (Write 단일 진입점)\n- 모든 데이터 변경 발생\n\n**Slave (슬레이브/복제본):**\n- 마스터 데이터 복제\n- 주로 읽기 전용 (replica-read-only yes)\n- 여러 개 가능\n- 계층적 복제 가능 (Slave의 Slave)\n\n---\n\n**복제 메커니즘:**\n\n**1. 초기 동기화 (Full Synchronization):**\n\n**과정:**\n1. Slave가 PSYNC 명령으로 마스터에 연결\n2. 마스터가 백그라운드에서 RDB 스냅샷 생성 (BGSAVE)\n3. 스냅샷 생성 중의 쓰기 명령은 버퍼에 저장\n4. 스냅샷을 Slave에 전송\n5. Slave가 스냅샷 로드\n6. 버퍼의 명령어들 전송 및 적용\n7. 동기화 완료\n\n**부하:**\n- 마스터: fork(), 디스크 I/O, 네트워크\n- Slave: 기존 데이터 삭제, 스냅샷 로드\n- 대용량 데이터셋에서 시간 소요\n\n**2. 부분 재동기화 (Partial Resynchronization):**\n\n**Redis 2.8+ 기능:**\n- 연결 끊김 후 재연결 시\n- 전체 동기화 대신 누락 부분만 전송\n- Replication ID와 offset 사용\n- 마스터가 백로그 버퍼에 최근 명령 보관\n\n**조건:**\n- 백로그 버퍼에 누락 데이터 존재\n- Replication ID 일치\n- 그렇지 않으면 Full Sync\n\n**3. 스트리밍 복제 (Continuous Replication):**\n\n**정상 동기화 후:**\n- 마스터의 모든 쓰기 명령을 실시간 전송\n- Slave가 명령 재실행\n- 지속적인 데이터 동기화\n- 비동기 방식 (약간의 지연 존재)\n\n---\n\n**복제 설정:**\n\n**Slave 설정:**\n- replicaof <master-ip> <master-port>\n- 또는 REPLICAOF 명령어 (런타임)\n\n**읽기 전용:**\n- replica-read-only yes (기본값)\n- Slave에 쓰기 방지\n\n**백로그 크기:**\n- repl-backlog-size 1mb (기본)\n- 크게 설정하면 부분 재동기화 확률 증가\n\n**타임아웃:**\n- repl-timeout 60 (기본 60초)\n- 응답 없으면 연결 재설정\n\n---\n\n**데이터 가용성 확보:**\n\n**1. 읽기 부하 분산:**\n- Slave에서 읽기 처리\n- 마스터 부하 감소\n- 수평 확장 (Slave 추가)\n- 애플리케이션에서 읽기 쿼리를 Slave로 라우팅\n\n**2. 장애 복구 (Failover):**\n\n**수동 Failover:**\n- 마스터 장애 시 수동으로 Slave 승격\n- REPLICAOF NO ONE (Slave를 마스터로)\n- 다른 Slave들을 새 마스터에 연결\n- 다운타임 발생\n\n**자동 Failover:**\n- Redis Sentinel 사용\n- 자동 장애 감지\n- 자동 Slave 승격\n- 클라이언트 자동 리다이렉션\n- 다운타임 최소화 (초~분)\n\n**3. 데이터 백업:**\n- Slave에서 RDB/AOF 저장\n- 마스터 부하 없이 백업\n- 재해 복구 대비\n\n**4. 지리적 분산:**\n- 다른 데이터센터에 Slave 배치\n- 재해 복구\n- 지역별 읽기 성능 향상\n\n**5. 계층적 복제:**\n- Slave가 또 다른 Slave 가짐\n- 마스터 부하 감소\n- 대규모 복제 가능\n\n---\n\n**복제 지연:**\n\n**원인:**\n- 네트워크 지연\n- 마스터 쓰기 부하 높음\n- Slave 처리 능력 부족\n- 비동기 복제의 특성\n\n**확인:**\n- INFO replication\n- master_repl_offset vs slave_repl_offset\n- lag 값\n\n**영향:**\n- Slave 읽기 시 오래된 데이터\n- 일관성 문제\n- Failover 시 데이터 손실 가능\n\n**완화:**\n- 빠른 네트워크\n- Slave 하드웨어 충분히\n- 쓰기 부하 분산\n- 모니터링으로 조기 감지\n\n---\n\n**제약사항:**\n\n**1. 비동기 복제:**\n- 마스터 쓰기 즉시 응답\n- Slave 복제는 비동기\n- 마스터 장애 시 일부 데이터 손실 가능\n\n**2. 쓰기 확장 불가:**\n- 마스터가 모든 쓰기 처리\n- 쓰기 성능은 단일 노드 한계\n- 샤딩 필요 시 Redis Cluster\n\n**3. 복제 오버헤드:**\n- 초기 동기화 시 마스터 부하\n- 네트워크 대역폭 사용\n- Slave 메모리 필요\n\n---\n\n**Best Practices:**\n\n**1. 최소 1개 Slave:**\n- 고가용성 기본\n- 마스터 장애 대비\n\n**2. 다수 Slave:**\n- 읽기 부하 분산\n- 장애 조치 옵션 증가\n\n**3. Sentinel 사용:**\n- 자동 Failover\n- 24/7 가용성\n\n**4. 모니터링:**\n- 복제 지연 추적\n- lag, offset 확인\n- 이상 시 알림\n\n**5. 네트워크:**\n- 빠르고 안정적인 연결\n- 전용 네트워크 고려\n\n**6. 백로그 크기:**\n- 충분히 크게 설정\n- 일시적 연결 끊김 대비\n\n**7. 테스트:**\n- Failover 시나리오 테스트\n- 복제 지연 측정\n- 백업 복원 검증\n\n**8. 문서화:**\n- 복제 토폴로지 문서화\n- Failover 절차 명시\n- 연락처 및 책임자",
      "type": "essay",
      "tags": ["Redis", "복제", "Replication", "고가용성", "Failover"],
      "id": "redis-016",
      "createdAt": "2025-11-17T13:00:00.000015",
      "studyCount": 0
    }
  ]
}
