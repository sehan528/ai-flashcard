{
  "name": "네트워크",
  "description": "네트워크 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "쿠키와 세션의 차이에 대해 설명해 주세요.",
      "answer": "쿠키와 세션은 모두 HTTP의 Stateless 특성을 보완하여 사용자의 상태 정보를 유지하기 위한 기술입니다. 하지만 저장 위치와 보안성, 생명주기에서 중요한 차이가 있습니다.\n\n**쿠키(Cookie)의 특징:**\n\n첫째, 클라이언트 측에 저장됩니다. 사용자의 브라우저에 텍스트 파일 형태로 저장됩니다. 브라우저가 종료되어도 유지될 수 있습니다. 사용자가 직접 삭제하거나 만료 시간이 지나면 사라집니다.\n\n둘째, 용량 제한이 있습니다. 하나의 쿠키는 최대 4KB까지 저장할 수 있습니다. 하나의 도메인에는 보통 20개 정도의 쿠키를 저장할 수 있습니다. 브라우저 전체로는 약 300개 정도의 쿠키가 제한됩니다.\n\n셋째, 자동으로 전송됩니다. 해당 도메인에 HTTP 요청을 보낼 때마다 쿠키가 자동으로 포함됩니다. 매 요청마다 네트워크 트래픽이 발생합니다. 불필요한 쿠키도 함께 전송될 수 있습니다.\n\n넷째, 보안에 취약합니다. 클라이언트에 저장되므로 사용자가 조작할 수 있습니다. 중요한 정보를 평문으로 저장하면 위험합니다. XSS 공격에 노출될 수 있습니다. HttpOnly와 Secure 플래그로 보안을 강화할 수 있습니다.\n\n다섯째, 만료 시간을 설정할 수 있습니다. Expires나 Max-Age 속성으로 지정합니다. 설정하지 않으면 세션 쿠키가 되어 브라우저 종료 시 삭제됩니다. 장기간 유지되는 영구 쿠키를 만들 수 있습니다.\n\n**세션(Session)의 특징:**\n\n첫째, 서버 측에 저장됩니다. 서버의 메모리나 데이터베이스에 저장됩니다. 클라이언트는 세션 ID만 가지고 있습니다. 실제 데이터는 서버에서 안전하게 관리됩니다.\n\n둘째, 용량 제한이 거의 없습니다. 서버의 메모리가 허용하는 만큼 저장할 수 있습니다. 쿠키보다 많은 정보를 저장할 수 있습니다. 하지만 너무 많이 저장하면 서버 메모리 부담이 증가합니다.\n\n셋째, 세션 ID만 전송됩니다. 클라이언트는 세션 ID를 쿠키에 저장합니다. 매 요청마다 세션 ID만 전송되므로 트래픽이 적습니다. 서버는 세션 ID로 실제 데이터를 조회합니다.\n\n넷째, 상대적으로 보안이 우수합니다. 실제 데이터는 서버에 있어 클라이언트가 조작할 수 없습니다. 세션 ID가 탈취되면 위험하지만, ID 자체는 의미 없는 값입니다. 세션 하이재킹을 방지하기 위한 추가 조치가 필요합니다.\n\n다섯째, 서버 부담이 있습니다. 모든 사용자의 세션 데이터를 서버가 관리해야 합니다. 사용자가 많아지면 메모리 사용량이 증가합니다. 서버가 여러 대인 경우 세션 공유 문제가 발생합니다.\n\n**주요 차이점 비교:**\n\n저장 위치는 쿠키가 클라이언트, 세션이 서버입니다. 보안성은 세션이 더 우수합니다. 서버 부담은 쿠키가 없고 세션은 있습니다. 속도는 쿠키가 더 빠릅니다. 서버 조회가 불필요하기 때문입니다. 용량은 세션이 더 큽니다.\n\n**사용 사례:**\n\n쿠키는 자동 로그인 정보, 장바구니 정보, 사용자 설정, 광고 추적 등에 사용됩니다. 덜 민감한 정보를 저장합니다.\n\n세션은 로그인 상태 유지, 인증 정보, 장바구니(중요한 경우), 임시 데이터 등에 사용됩니다. 보안이 중요한 정보를 저장합니다.\n\n**함께 사용:**\n\n실제로는 쿠키와 세션을 함께 사용합니다. 세션 ID를 쿠키에 저장합니다. 클라이언트는 세션 ID 쿠키를 전송하고, 서버는 이를 통해 세션 데이터를 조회합니다. 이 방식이 가장 일반적입니다.\n\n**대안 기술:**\n\n최근에는 JWT(JSON Web Token)도 많이 사용됩니다. Stateless 방식으로 서버 부담이 없습니다. 토큰에 정보를 담아 전송합니다. 하지만 토큰 크기가 커질 수 있고, 토큰 폐기가 어렵다는 단점이 있습니다.\n\n쿠키와 세션은 각각 장단점이 명확하므로, 상황에 맞게 적절히 선택하거나 조합하여 사용해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633065-cocciqsp",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "세션 방식의 로그인 과정에 대해 설명해 주세요.",
      "answer": "세션 기반 인증은 전통적이고 널리 사용되는 방식으로, 서버가 사용자의 인증 상태를 기억하는 방법입니다.\n\n**로그인 과정:**\n\n첫째, 사용자가 로그인 폼을 제출합니다. 아이디와 비밀번호를 입력합니다. POST 요청으로 서버에 전송합니다. HTTPS를 사용하여 암호화된 통신을 합니다.\n\n둘째, 서버가 인증 정보를 검증합니다. 데이터베이스에서 사용자 정보를 조회합니다. 저장된 비밀번호 해시와 입력된 비밀번호를 비교합니다. bcrypt, scrypt 같은 단방향 해시 함수를 사용합니다. 솔트(salt)를 함께 사용하여 보안을 강화합니다.\n\n셋째, 인증이 성공하면 세션을 생성합니다. 서버 메모리나 세션 저장소에 세션 데이터를 저장합니다. 고유한 세션 ID를 생성합니다. 랜덤하고 예측 불가능한 값이어야 합니다. UUID나 암호학적으로 안전한 난수를 사용합니다.\n\n넷째, 세션에 사용자 정보를 저장합니다. 사용자 ID, 권한, 로그인 시간 등을 저장합니다. 필요한 최소한의 정보만 저장합니다. 비밀번호 같은 민감한 정보는 저장하지 않습니다.\n\n다섯째, 세션 ID를 클라이언트에 전달합니다. Set-Cookie 헤더로 세션 ID를 쿠키에 저장합니다. 쿠키 이름은 보통 JSESSIONID, PHPSESSID 등입니다. HttpOnly 플래그를 설정하여 JavaScript 접근을 차단합니다. Secure 플래그를 설정하여 HTTPS에서만 전송되도록 합니다. SameSite 속성으로 CSRF 공격을 방지합니다.\n\n여섯째, 클라이언트가 세션 ID를 저장합니다. 브라우저가 쿠키에 세션 ID를 저장합니다. 이후 모든 요청에 자동으로 포함됩니다.\n\n**이후 요청 과정:**\n\n첫째, 클라이언트가 요청을 보냅니다. 자동으로 세션 ID 쿠키가 함께 전송됩니다. Cookie 헤더에 포함됩니다.\n\n둘째, 서버가 세션 ID를 확인합니다. 쿠키에서 세션 ID를 추출합니다. 세션 저장소에서 해당 세션을 조회합니다.\n\n셋째, 세션이 유효한지 검증합니다. 세션이 존재하는지 확인합니다. 만료 시간이 지나지 않았는지 확인합니다. IP 주소나 User-Agent를 검증할 수도 있습니다.\n\n넷째, 세션 데이터를 사용합니다. 세션에서 사용자 정보를 가져옵니다. 권한을 확인하여 접근 제어를 수행합니다. 요청을 처리합니다.\n\n다섯째, 응답을 반환합니다. 필요한 데이터를 응답으로 보냅니다. 세션의 만료 시간을 갱신할 수 있습니다.\n\n**로그아웃 과정:**\n\n첫째, 사용자가 로그아웃을 요청합니다. 로그아웃 버튼을 클릭하거나 엔드포인트를 호출합니다.\n\n둘째, 서버가 세션을 삭제합니다. 세션 저장소에서 해당 세션을 제거합니다. 메모리나 데이터베이스에서 삭제합니다.\n\n셋째, 클라이언트의 쿠키를 삭제합니다. Set-Cookie 헤더로 만료 시간을 과거로 설정합니다. 브라우저가 쿠키를 삭제합니다.\n\n넷째, 로그인 페이지로 리다이렉트합니다. 사용자는 로그아웃 상태가 됩니다.\n\n**세션 만료:**\n\n세션은 일정 시간 후 자동으로 만료됩니다. 보안과 리소스 관리를 위해 필요합니다. 보통 30분에서 1시간 정도로 설정합니다. 활동이 있을 때마다 만료 시간을 연장할 수 있습니다. 완전히 만료되면 다시 로그인해야 합니다.\n\n**보안 고려사항:**\n\n세션 ID는 예측 불가능해야 합니다. 충분히 길고 랜덤한 값을 사용합니다. 최소 128비트 이상의 엔트로피가 권장됩니다.\n\n세션 고정 공격을 방지해야 합니다. 로그인 성공 시 새로운 세션 ID를 발급합니다. 기존 세션 ID를 무효화합니다.\n\n세션 하이재킹을 방지해야 합니다. HTTPS를 사용하여 세션 ID 탈취를 방지합니다. IP 주소나 User-Agent를 추가로 검증합니다. 하지만 이는 동적 IP 환경에서 문제가 될 수 있습니다.\n\n**세션 저장소:**\n\n메모리에 저장하는 것이 가장 빠릅니다. 하지만 서버 재시작 시 모두 사라집니다. 서버가 여러 대면 공유가 어렵습니다.\n\n데이터베이스에 저장하면 영구적입니다. 하지만 매 요청마다 조회하므로 느릴 수 있습니다.\n\nRedis 같은 인메모리 DB를 많이 사용합니다. 빠르면서도 영구적입니다. 여러 서버가 공유할 수 있습니다. TTL을 설정하여 자동 만료가 가능합니다.\n\n**확장성 문제:**\n\n서버가 여러 대일 때 세션 공유가 필요합니다. Sticky Session으로 같은 서버로 라우팅할 수 있습니다. 하지만 로드 밸런싱이 비효율적입니다. Session Clustering으로 모든 서버가 세션을 공유합니다. 중앙 세션 저장소를 사용하는 것이 일반적입니다.\n\n세션 방식은 구현이 간단하고 검증된 방법입니다. 하지만 서버 부담과 확장성 문제가 있어 최근에는 JWT 같은 대안도 함께 고려됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633065-5wjy2o3w",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP의 특성인 Stateless에 대해 설명해 주세요.",
      "answer": "Stateless는 HTTP 프로토콜의 핵심 특성으로, 서버가 클라이언트의 상태를 유지하지 않는다는 의미입니다.\n\n**Stateless의 정의:**\n\n첫째, 각 요청이 독립적입니다. 이전 요청과 다음 요청 간에 연관성이 없습니다. 서버는 과거의 요청을 기억하지 않습니다. 모든 요청은 그 자체로 완전해야 합니다.\n\n둘째, 서버가 상태를 저장하지 않습니다. 클라이언트의 세션 정보를 서버에 저장하지 않습니다. 요청을 처리한 후 그 정보를 버립니다. 다음 요청에서 이전 정보를 사용하지 않습니다.\n\n셋째, 필요한 모든 정보를 요청에 포함해야 합니다. 클라이언트가 컨텍스트를 제공해야 합니다. 헤더, 바디, 쿼리 파라미터 등에 모든 정보를 담습니다. 서버는 요청만 보고 처리할 수 있어야 합니다.\n\n**Stateless의 장점:**\n\n첫째, 확장성이 뛰어납니다. 어떤 서버든 요청을 처리할 수 있습니다. 서버 간 상태 동기화가 불필요합니다. 로드 밸런서가 자유롭게 요청을 분산할 수 있습니다. 서버를 쉽게 추가하거나 제거할 수 있습니다.\n\n둘째, 서버가 단순해집니다. 상태 관리 로직이 필요 없습니다. 메모리 사용량이 줄어듭니다. 복잡도가 낮아집니다. 버그가 줄어듭니다.\n\n셋째, 장애 복구가 쉽습니다. 서버가 다운되어도 다른 서버가 대신 처리합니다. 상태 정보가 없어 복구가 빠릅니다. 무중단 배포가 용이합니다.\n\n넷째, 캐싱이 효율적입니다. 같은 요청은 같은 응답을 반환합니다. 프록시 서버나 CDN에서 캐싱하기 좋습니다. 네트워크 효율성이 높아집니다.\n\n**Stateless의 단점:**\n\n첫째, 매번 인증이 필요합니다. 사용자 식별 정보를 매 요청에 포함해야 합니다. 토큰이나 세션 ID를 계속 전송해야 합니다. 네트워크 오버헤드가 발생합니다.\n\n둘째, 요청이 커질 수 있습니다. 모든 컨텍스트 정보를 포함해야 하므로 크기가 증가합니다. 반복적인 정보를 계속 전송합니다.\n\n셋째, 사용자 경험 유지가 어렵습니다. 로그인 상태, 장바구니, 세션 등을 구현하기 복잡합니다. 추가적인 메커니즘이 필요합니다.\n\n**Stateless를 보완하는 방법:**\n\n쿠키를 사용합니다. 클라이언트가 상태 정보를 저장합니다. 매 요청에 자동으로 포함됩니다. 서버는 여전히 Stateless를 유지합니다.\n\n세션을 사용합니다. 엄밀히는 Stateful 방식입니다. 하지만 세션 ID만 주고받으므로 부분적으로 Stateless 특성을 유지합니다.\n\n토큰을 사용합니다. JWT 같은 토큰에 상태 정보를 담습니다. 클라이언트가 토큰을 저장하고 전송합니다. 서버는 토큰을 검증만 하고 저장하지 않습니다. 완전한 Stateless를 유지합니다.\n\n**Stateful과의 비교:**\n\nStateful 프로토콜은 연결을 유지합니다. FTP, Telnet 등이 해당합니다. 서버가 클라이언트 상태를 기억합니다. 연결이 끊기면 상태가 사라집니다.\n\nStateless는 연결과 무관합니다. 매 요청이 새로운 연결입니다. 또는 연결을 재사용해도 상태는 유지하지 않습니다.\n\n**HTTP/1.1의 Keep-Alive:**\n\nTCP 연결을 재사용하는 기능입니다. 하지만 이는 성능 최적화일 뿐입니다. HTTP 자체는 여전히 Stateless입니다. 연결은 유지되지만 상태는 유지되지 않습니다.\n\n**RESTful API와 Stateless:**\n\nREST 아키텍처의 핵심 제약 조건입니다. 서버는 클라이언트 상태를 저장하지 않아야 합니다. 각 요청은 자체 완결적이어야 합니다. 이를 통해 확장성과 신뢰성을 얻습니다.\n\n**실무에서의 적용:**\n\n완전한 Stateless를 유지하기는 어렵습니다. 대부분 세션이나 캐시를 사용합니다. 하지만 가능한 한 Stateless에 가깝게 설계합니다. 상태 정보를 최소화하고, 클라이언트가 많은 정보를 관리하도록 합니다.\n\n마이크로서비스 아키텍처에서는 Stateless가 특히 중요합니다. 각 서비스가 독립적이어야 하기 때문입니다.\n\nStateless는 HTTP의 단순함과 확장성을 가능하게 하는 핵심 설계 철학입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "동기화"
      ],
      "id": "1763437633065-rduf6jul",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?",
      "answer": "이 질문은 HTTP의 Stateless 원칙과 세션 기반 인증의 모순을 지적하는 통찰력 있는 질문입니다.\n\n**세션이 Stateless 원칙에 위배되는 이유:**\n\n첫째, 서버가 상태를 저장합니다. 세션 데이터를 서버 메모리나 저장소에 보관합니다. 클라이언트의 로그인 상태, 권한 등을 기억합니다. 이는 명백히 Stateful 방식입니다.\n\n둘째, 요청 간 연관성이 생깁니다. 세션 ID로 이전 상태를 참조합니다. 첫 로그인 요청과 이후 요청이 연결됩니다. 독립적이지 않습니다.\n\n셋째, 서버 의존성이 생깁니다. 세션을 생성한 서버만 해당 세션을 알고 있을 수 있습니다. Sticky Session이 필요할 수 있습니다. 완전한 수평 확장이 어렵습니다.\n\n**그럼에도 세션을 사용하는 이유:**\n\n첫째, 현실적인 필요 때문입니다. 사용자 인증 상태를 유지해야 합니다. 매 요청마다 아이디와 비밀번호를 보낼 수 없습니다. 보안상 위험하고 사용자 경험이 나쁩니다. 어떤 형태로든 상태 유지가 필요합니다.\n\n둘째, 보안성이 우수합니다. 중요한 정보를 서버에 저장합니다. 클라이언트가 조작할 수 없습니다. 세션 ID만 탈취되면 대응이 가능합니다.\n\n셋째, 즉시 무효화가 가능합니다. 로그아웃 시 세션을 바로 삭제할 수 있습니다. 계정 정지 시 모든 세션을 무효화할 수 있습니다. 토큰 방식에서는 어렵습니다.\n\n넷째, 검증된 방법입니다. 오랜 기간 사용되어 왔습니다. 구현이 간단하고 안정적입니다. 많은 프레임워크가 기본 지원합니다.\n\n**Stateless를 유지하는 대안:**\n\nJWT(JSON Web Token)를 사용합니다. 모든 정보를 토큰에 담습니다. 서버는 토큰을 저장하지 않습니다. 서명을 검증하여 위변조를 방지합니다. 완전한 Stateless를 유지합니다.\n\n하지만 JWT에도 단점이 있습니다. 토큰 크기가 큽니다. 매 요청에 전송되어 네트워크 부담이 있습니다. 토큰을 즉시 무효화하기 어렵습니다. 만료 전까지는 유효합니다. 블랙리스트를 유지하면 결국 Stateful이 됩니다.\n\n**절충안:**\n\n실무에서는 완전한 Stateless를 추구하기보다 실용성을 택합니다. 세션을 사용하되 확장성을 고려합니다. Redis 같은 공유 세션 저장소를 사용합니다. 모든 서버가 세션에 접근할 수 있습니다.\n\n또는 JWT와 세션을 혼용합니다. JWT로 기본 인증을 하고, 중요한 작업에만 추가 검증을 합니다.\n\n**Stateless의 재해석:**\n\n엄밀히 말하면 HTTP 프로토콜 자체는 Stateless를 유지합니다. 각 HTTP 요청과 응답은 독립적입니다. 프로토콜 레벨에서는 상태를 저장하지 않습니다.\n\n애플리케이션 레벨에서 세션을 사용하는 것은 다른 문제입니다. HTTP 위에 Stateful한 애플리케이션을 구축하는 것입니다. 이는 HTTP 프로토콜의 Stateless 원칙을 위반하는 것이 아닙니다.\n\n**트레이드오프:**\n\n완전한 Stateless는 이상적이지만 현실적으로 어렵습니다. 세션은 Stateful하지만 실용적입니다. 각 방식의 장단점을 이해하고 상황에 맞게 선택해야 합니다.\n\n확장성이 최우선이면 JWT 같은 Stateless 방식을 선택합니다. 보안과 제어가 중요하면 세션을 선택합니다. 대부분의 경우 세션 방식으로 충분합니다.\n\n**마이크로서비스 환경:**\n\n서비스 간 통신에서는 Stateless가 중요합니다. JWT를 많이 사용합니다. 각 서비스가 독립적으로 토큰을 검증합니다. 중앙 세션 저장소에 의존하지 않습니다.\n\n하지만 클라이언트와의 첫 인증은 세션을 사용할 수 있습니다. 내부 서비스 호출은 JWT를 사용합니다. 하이브리드 방식입니다.\n\n**결론:**\n\n세션은 HTTP의 Stateless 원칙에는 어긋나지만, 웹 애플리케이션의 실제 요구사항을 만족시키는 실용적인 방법입니다. 적절하지 않다기보다는, 필요에 따라 Stateless 원칙을 유연하게 적용한 것입니다. 중요한 것은 각 방식의 트레이드오프를 이해하고, 시스템의 요구사항에 맞는 선택을 하는 것입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633065-pqeyf2or",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?",
      "answer": "서버가 여러 대로 확장되면 세션 관리가 복잡해집니다. 사용자가 첫 번째 요청은 서버 A로, 두 번째 요청은 서버 B로 보낼 때 세션 정보가 없어 로그인이 풀리는 문제가 발생할 수 있습니다. 이를 해결하는 주요 방법들은 다음과 같습니다.\n\n**Sticky Session (Session Affinity):**\n\n로드밸런서가 특정 사용자의 모든 요청을 항상 같은 서버로 전달하는 방식입니다. 일반적으로 사용자의 IP 주소나 세션 ID를 해싱하여 서버를 결정합니다.\n\n장점은 구현이 간단하고 추가 인프라가 필요 없다는 것입니다. 각 서버가 독립적으로 세션을 관리하면 됩니다.\n\n단점은 로드밸런싱이 불균등해질 수 있다는 것입니다. 특정 서버에 트래픽이 몰릴 수 있고, 해당 서버가 다운되면 그 서버의 모든 세션이 유실됩니다. 서버 증설 시 기존 사용자들의 세션이 깨질 수 있습니다.\n\n**Session Clustering:**\n\n여러 서버의 세션을 동기화하여 모든 서버가 같은 세션 정보를 공유하는 방식입니다. WAS(Web Application Server)들이 클러스터를 구성하고 세션 복제를 수행합니다.\n\n장점은 고가용성을 제공한다는 것입니다. 한 서버가 다운되어도 다른 서버에 세션 정보가 있어 서비스가 계속됩니다.\n\n단점은 서버 간 세션 복제 오버헤드가 크다는 것입니다. 네트워크 트래픽이 증가하고, 서버 수가 많아질수록 복제 비용이 기하급수적으로 늘어납니다. 세션 데이터가 크면 성능 저하가 심각할 수 있습니다.\n\n**중앙 세션 저장소:**\n\n가장 일반적이고 권장되는 방식으로, Redis나 Memcached 같은 인메모리 데이터베이스를 중앙 세션 저장소로 사용합니다. 모든 서버가 이 저장소에서 세션을 읽고 씁니다.\n\n장점은 확장성이 뛰어나다는 것입니다. 서버를 추가하거나 제거해도 세션에 영향이 없습니다. 로드밸런싱이 자유롭고, 서버가 다운되어도 세션이 유지됩니다. Redis는 영속성 옵션을 제공하여 Redis 자체가 재시작되어도 세션을 보존할 수 있습니다.\n\n단점은 추가 인프라가 필요하고, 중앙 저장소가 단일 장애점(SPOF)이 될 수 있다는 것입니다. 하지만 Redis Cluster나 Sentinel을 사용하면 고가용성을 확보할 수 있습니다. 네트워크 지연이 약간 추가됩니다.\n\n**토큰 기반 인증으로 전환:**\n\nJWT 같은 토큰을 사용하면 서버가 세션을 저장할 필요가 없습니다. 토큰 자체에 필요한 정보가 들어있어 완전히 Stateless하게 동작합니다.\n\n장점은 서버 확장이 매우 쉽고, 세션 관리 인프라가 필요 없다는 것입니다. 마이크로서비스 환경에 적합합니다.\n\n단점은 토큰 무효화가 어렵다는 것입니다. 토큰이 탈취되면 만료 전까지 막을 방법이 없습니다. 토큰 갱신 전략이 복잡하고, 토큰 크기가 세션 ID보다 훨씬 커서 매 요청마다 오버헤드가 있습니다.\n\n**실무 권장사항:**\n\n대부분의 현대 웹 애플리케이션은 Redis 같은 중앙 세션 저장소를 사용합니다. 구현이 비교적 간단하고, 확장성과 안정성이 검증되었기 때문입니다. Spring Session, Express Session 같은 라이브러리들이 Redis 통합을 기본 지원하여 구현이 쉽습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633065-95xtrw6d",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP 응답코드에 대해 설명해 주세요.",
      "answer": "HTTP 응답코드는 서버가 클라이언트의 요청을 어떻게 처리했는지를 나타내는 세 자리 숫자입니다. 응답코드는 다섯 가지 클래스로 분류됩니다.\n\n**1xx (Informational - 정보 응답):**\n\n요청을 받았으며 프로세스를 계속 진행한다는 의미입니다. 실무에서는 거의 사용되지 않습니다.\n\n100 Continue는 클라이언트가 요청을 계속 전송해도 된다는 의미입니다. 대용량 파일 업로드 시 헤더를 먼저 보내고 100을 받은 후 본문을 전송하는 방식으로 사용됩니다.\n\n101 Switching Protocols는 프로토콜을 전환한다는 의미로, WebSocket 연결 시 HTTP에서 WebSocket으로 업그레이드할 때 사용됩니다.\n\n**2xx (Success - 성공):**\n\n요청이 성공적으로 처리되었음을 나타냅니다.\n\n200 OK는 가장 일반적인 성공 응답으로, 요청이 성공했다는 의미입니다. GET 요청에 대한 리소스 반환, POST 요청의 처리 완료 등에 사용됩니다.\n\n201 Created는 요청이 성공했고 새로운 리소스가 생성되었음을 나타냅니다. POST 요청으로 새 데이터를 생성했을 때 사용하며, Location 헤더로 생성된 리소스의 URI를 전달하는 것이 일반적입니다.\n\n204 No Content는 요청은 성공했지만 응답 본문이 없다는 의미입니다. DELETE 요청이나 업데이트 후 반환할 내용이 없을 때 사용됩니다.\n\n**3xx (Redirection - 리다이렉션):**\n\n클라이언트가 요청을 완료하기 위해 추가 동작이 필요함을 나타냅니다.\n\n301 Moved Permanently는 리소스가 영구적으로 이동했다는 의미입니다. 검색엔진이 새 URL을 색인하고, 브라우저는 새 URL을 북마크합니다.\n\n302 Found는 리소스가 일시적으로 다른 위치에 있다는 의미입니다. 원래 URL로 계속 요청해야 합니다.\n\n304 Not Modified는 캐시된 버전을 사용해도 된다는 의미입니다. 조건부 GET 요청에서 리소스가 변경되지 않았을 때 사용하여 대역폭을 절약합니다.\n\n**4xx (Client Error - 클라이언트 오류):**\n\n클라이언트의 요청에 오류가 있음을 나타냅니다.\n\n400 Bad Request는 잘못된 문법으로 서버가 요청을 이해할 수 없다는 의미입니다. 필수 파라미터 누락, 잘못된 JSON 형식 등에 사용됩니다.\n\n401 Unauthorized는 인증이 필요하다는 의미입니다. 로그인이 필요하거나 인증 토큰이 유효하지 않을 때 사용됩니다.\n\n403 Forbidden은 서버가 요청을 이해했지만 권한이 없어 거부한다는 의미입니다. 인증은 되었지만 해당 리소스에 접근할 권한이 없을 때 사용됩니다.\n\n404 Not Found는 요청한 리소스를 찾을 수 없다는 의미입니다. 존재하지 않는 URL이나 삭제된 리소스에 접근할 때 사용됩니다.\n\n**5xx (Server Error - 서버 오류):**\n\n서버가 유효한 요청을 처리하지 못했음을 나타냅니다.\n\n500 Internal Server Error는 서버에 오류가 발생했다는 일반적인 메시지입니다. 예상치 못한 예외, 데이터베이스 연결 실패 등에 사용됩니다.\n\n502 Bad Gateway는 게이트웨이나 프록시 서버가 업스트림 서버로부터 잘못된 응답을 받았다는 의미입니다. 리버스 프록시 뒤의 애플리케이션 서버가 다운되었을 때 발생합니다.\n\n503 Service Unavailable은 서버가 일시적으로 요청을 처리할 수 없다는 의미입니다. 과부하, 유지보수 등의 상황에서 사용하며, Retry-After 헤더로 재시도 시점을 안내할 수 있습니다.\n\n**적절한 응답코드 선택의 중요성:**\n\n명확한 응답코드는 API 사용자가 오류를 빠르게 이해하고 대응할 수 있게 합니다. 또한 모니터링 시스템이 문제를 정확히 감지하고 분류할 수 있게 하며, RESTful API 설계 원칙을 준수하는 데 필수적입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633065-bifckbdg",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?",
      "answer": "401과 403은 모두 접근이 거부되는 상황이지만, 그 이유와 해결 방법이 다릅니다.\n\n**401 Unauthorized - 인증 필요:**\n\n사용자가 누구인지 확인되지 않았다는 의미입니다. 즉, 신원을 증명하지 않았거나 잘못된 인증 정보를 제공한 상황입니다.\n\n이 응답은 \"당신이 누구인지 모르겠으니 로그인하세요\"라는 메시지와 같습니다. WWW-Authenticate 헤더를 포함하여 어떤 인증 방법을 사용해야 하는지 알려줍니다.\n\n일반적인 사례는 로그인하지 않은 상태에서 보호된 페이지에 접근할 때, 인증 토큰이 만료되었을 때, 잘못된 비밀번호를 입력했을 때 등입니다.\n\n해결 방법은 올바른 인증 정보(아이디, 비밀번호, 토큰 등)를 제공하는 것입니다. 인증에 성공하면 같은 요청을 다시 보낼 수 있습니다.\n\n**403 Forbidden - 권한 부족:**\n\n사용자의 신원은 확인되었지만, 해당 리소스에 접근할 권한이 없다는 의미입니다. 즉, 서버가 당신이 누구인지는 알지만, 당신은 이 작업을 할 수 없다는 것입니다.\n\n이 응답은 \"당신이 누군지는 알지만, 이 리소스는 접근할 수 없습니다\"라는 메시지와 같습니다.\n\n일반적인 사례는 일반 사용자가 관리자 페이지에 접근할 때, 다른 사용자의 개인 정보를 조회하려 할 때, 읽기 권한만 있는 사용자가 삭제를 시도할 때 등입니다.\n\n해결 방법은 인증 정보를 다시 제공해도 소용없습니다. 권한 자체가 없기 때문에 관리자에게 권한을 요청하거나, 접근 가능한 다른 리소스를 이용해야 합니다.\n\n**실무에서의 구분:**\n\nRESTful API 설계 시 이 둘을 명확히 구분하는 것이 중요합니다. 클라이언트가 적절한 대응을 할 수 있기 때문입니다.\n\n401을 받으면 클라이언트는 로그인 페이지로 리다이렉트하거나 토큰을 갱신해야 합니다. 자동으로 재인증을 시도할 수 있습니다.\n\n403을 받으면 클라이언트는 사용자에게 \"권한이 없습니다\" 메시지를 보여주고, 재시도하지 않아야 합니다. 같은 요청을 반복해도 결과는 같기 때문입니다.\n\n**보안 고려사항:**\n\n때로는 보안을 위해 403 대신 404를 반환하기도 합니다. 예를 들어, 사용자에게 특정 리소스의 존재 여부조차 알리고 싶지 않을 때입니다. 403을 반환하면 \"이 리소스는 존재하지만 당신은 볼 수 없다\"는 정보를 주는 셈이므로, 존재하지 않는 것처럼 404를 반환하는 것입니다.\n\n**이름의 모순:**\n\n흥미롭게도 401의 이름은 \"Unauthorized\"이지만 실제로는 \"Unauthenticated\"가 더 정확한 표현입니다. 역사적인 이유로 이렇게 명명되었으나, 실무에서는 인증 실패를 의미한다는 것을 이해하고 사용해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "동기화"
      ],
      "id": "1763437633065-21su3srv",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.",
      "answer": "200과 201은 모두 성공을 나타내지만, 요청의 결과가 무엇인지에 따라 구분됩니다.\n\n**200 OK - 일반적인 성공:**\n\n요청이 성공적으로 처리되었다는 가장 일반적인 응답입니다. 다양한 HTTP 메서드에 사용할 수 있습니다.\n\nGET 요청에서는 요청한 리소스를 응답 본문에 담아 반환합니다. 예를 들어 사용자 정보를 조회하면 200과 함께 사용자 데이터를 받습니다.\n\nPOST 요청에서는 작업이 완료되었고 그 결과를 응답 본문에 담아 반환합니다. 새 리소스를 생성하지 않는 POST 요청, 예를 들어 계산이나 검색 같은 작업에 적합합니다.\n\nPUT 요청에서는 기존 리소스가 업데이트되었음을 나타냅니다.\n\nDELETE 요청에서는 삭제가 성공했음을 나타내며, 삭제된 리소스 정보를 응답 본문에 포함할 수 있습니다.\n\n**201 Created - 리소스 생성 성공:**\n\n요청이 성공했고 그 결과로 새로운 리소스가 생성되었음을 나타냅니다. 주로 POST 요청과 함께 사용됩니다.\n\nLocation 헤더에 생성된 리소스의 URI를 포함하는 것이 관례입니다. 클라이언트가 생성된 리소스에 바로 접근할 수 있도록 합니다.\n\n응답 본문에는 생성된 리소스의 표현을 포함할 수 있습니다. 서버가 생성 시 자동으로 부여한 ID나 타임스탬프 등의 정보를 클라이언트에게 전달합니다.\n\n**실무에서의 사용:**\n\nRESTful API 설계 시 명확한 의미 전달을 위해 구분합니다.\n\nPOST로 새 사용자를 등록하면 201을 반환하고, Location 헤더에 새 사용자의 URI를 포함합니다. 본문에는 생성된 사용자 정보와 자동 생성된 ID를 담습니다.\n\nPOST로 로그인 처리를 하면 200을 반환합니다. 새 리소스가 생성되는 것이 아니라 인증 토큰을 발급하는 작업이기 때문입니다.\n\nPUT으로 기존 리소스를 업데이트하면 200을 반환합니다. 이미 존재하는 리소스를 수정한 것이므로 새로 생성한 것이 아닙니다.\n\n**의미론적 중요성:**\n\nHTTP 응답코드는 단순한 숫자가 아니라 API의 의미를 전달하는 중요한 수단입니다. 201을 사용하면 클라이언트는 \"새 리소스가 생성되었구나\"를 명확히 알 수 있고, Location 헤더를 확인하여 생성된 리소스에 접근할 수 있습니다.\n\n모니터링 관점에서도 201 응답을 추적하면 시스템에서 얼마나 많은 리소스가 생성되는지 파악할 수 있습니다.\n\n**캐싱 동작:**\n\n200 응답은 조건에 따라 캐싱될 수 있습니다. GET 요청의 200 응답은 캐시 헤더에 따라 브라우저나 프록시에 캐싱됩니다.\n\n201 응답은 일반적으로 캐싱되지 않습니다. 새 리소스 생성은 매번 고유한 작업이므로 캐싱이 적절하지 않습니다.\n\n**클라이언트 동작:**\n\n200을 받으면 클라이언트는 응답 본문의 데이터를 사용합니다.\n\n201을 받으면 클라이언트는 Location 헤더를 확인하여 생성된 리소스의 위치를 파악하고, 필요시 해당 URI로 GET 요청을 보내 최신 상태를 확인할 수 있습니다. 많은 프레임워크가 201 응답 시 자동으로 리다이렉트하는 기능을 제공합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "프로세스"
      ],
      "id": "1763437633065-jy0r3kej",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.",
      "answer": "기술적으로는 가능하지만, 실무에서는 절대 권장되지 않습니다.\n\n**기술적 가능성:**\n\nHTTP는 프로토콜 수준에서 세 자리 숫자면 어떤 값이든 응답코드로 사용할 수 있습니다. 서버가 285를 반환하고 클라이언트가 이를 받아 처리할 수 있습니다.\n\n첫 자리 숫자는 응답의 클래스를 나타냅니다. 2xx는 성공, 3xx는 리다이렉션, 4xx는 클라이언트 오류, 5xx는 서버 오류입니다. 만약 285를 사용한다면 클라이언트는 이를 \"2xx이므로 성공\"으로 분류할 것입니다.\n\n**실무에서 사용하면 안 되는 이유:**\n\n표준을 위반하면 호환성 문제가 발생합니다. HTTP 프록시, 로드밸런서, 캐시, 브라우저, 모니터링 도구 등 중간 계층들이 표준 응답코드를 가정하고 동작합니다. 비표준 코드를 사용하면 예상치 못한 동작이나 오류가 발생할 수 있습니다.\n\n클라이언트 라이브러리가 혼란스러워집니다. Axios, Fetch API, HttpClient 같은 HTTP 클라이언트 라이브러리들은 표준 응답코드에 대한 처리 로직을 가지고 있습니다. 비표준 코드는 의도대로 처리되지 않을 수 있습니다.\n\n개발자가 혼란스러워집니다. 팀원이나 API 사용자가 285가 무엇을 의미하는지 알 수 없습니다. 표준 코드는 모두가 알고 있는 공통 언어이지만, 커스텀 코드는 별도 문서가 필요하고 학습 비용이 발생합니다.\n\n디버깅이 어려워집니다. 로그나 모니터링 도구에서 비표준 응답코드를 보면 무엇이 잘못되었는지 즉시 파악하기 어렵습니다.\n\n**표준 코드만으로 충분합니다:**\n\nHTTP 표준은 이미 매우 다양한 상황을 커버하는 응답코드를 제공합니다. 대부분의 경우 적절한 표준 코드가 존재합니다.\n\n세밀한 정보가 필요하다면 응답 본문에 포함하면 됩니다. 응답코드는 넓은 범주를 나타내고, 구체적인 정보는 JSON 본문의 error code나 message 필드로 전달하는 것이 일반적입니다.\n\n예를 들어 비밀번호가 틀렸을 때와 계정이 잠겼을 때를 구분하고 싶다면, 둘 다 401을 사용하되 응답 본문에 errorCode를 다르게 주면 됩니다.\n\n**비표준 코드의 역사적 사례:**\n\n일부 대형 서비스들이 비표준 코드를 사용한 적이 있지만, 대부분 표준 코드로 마이그레이션했습니다. 호환성과 유지보수의 어려움이 커스텀 코드의 이점을 넘어섰기 때문입니다.\n\n**올바른 접근 방법:**\n\n표준 응답코드를 사용하고, 응답 본문에 상세 정보를 포함합니다. 예를 들어 400 Bad Request와 함께 본문에 어떤 필드가 잘못되었는지 명시합니다.\n\n커스텀 헤더를 사용할 수 있습니다. 표준 응답코드는 유지하되, X-Custom-Error-Code 같은 헤더로 추가 정보를 전달할 수 있습니다.\n\nAPI 문서에 어떤 응답코드가 언제 반환되는지 명확히 기술합니다. 이것만으로도 대부분의 경우 충분합니다.\n\n따라서 커스텀 응답코드는 기술적으로 가능하지만, 표준 준수와 호환성을 위해 절대 사용하지 말아야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "가상메모리"
      ],
      "id": "1763437633065-nghw6w0x",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP Method 에 대해 설명해 주세요.",
      "answer": "HTTP Method는 클라이언트가 서버에 요청할 때 어떤 작업을 원하는지 나타내는 동사입니다. 각 메서드는 특정한 의미와 특성을 가지고 있습니다.\n\n**GET - 리소스 조회:**\n\n서버로부터 리소스를 조회할 때 사용합니다. 데이터를 요청만 하고 변경하지 않는 읽기 전용 작업입니다.\n\n요청 파라미터는 URL의 쿼리 스트링으로 전달됩니다. 브라우저 히스토리에 남고, 북마크가 가능하며, 캐싱될 수 있습니다.\n\n안전(Safe)하고 멱등(Idempotent)한 메서드입니다. 여러 번 호출해도 결과가 같고 서버 상태를 변경하지 않습니다.\n\n**POST - 리소스 생성 및 데이터 처리:**\n\n새로운 리소스를 생성하거나 데이터를 처리할 때 사용합니다. 가장 유연한 메서드로 다양한 용도로 활용됩니다.\n\n요청 데이터는 본문(body)에 포함되어 전송됩니다. URL에 노출되지 않아 민감한 데이터 전송에 적합합니다.\n\n안전하지도 멱등하지도 않습니다. 같은 요청을 여러 번 보내면 여러 개의 리소스가 생성될 수 있습니다.\n\n회원가입, 로그인, 파일 업로드, 주문 생성 등에 사용됩니다.\n\n**PUT - 리소스 전체 업데이트:**\n\n리소스를 완전히 대체할 때 사용합니다. 기존 리소스가 있으면 덮어쓰고, 없으면 생성할 수 있습니다.\n\n클라이언트가 리소스의 정확한 URI를 알고 있어야 합니다. 리소스의 모든 필드를 포함한 완전한 데이터를 전송해야 합니다.\n\n멱등성을 가집니다. 같은 요청을 여러 번 보내도 결과는 동일합니다.\n\n**PATCH - 리소스 부분 업데이트:**\n\n리소스의 일부만 수정할 때 사용합니다. 변경하고자 하는 필드만 전송하면 됩니다.\n\nPUT보다 효율적입니다. 전체 데이터가 아닌 변경 사항만 전송하므로 네트워크 대역폭을 절약할 수 있습니다.\n\n멱등성은 구현에 따라 다를 수 있습니다. 일반적으로 멱등하게 구현하는 것이 권장됩니다.\n\n**DELETE - 리소스 삭제:**\n\n지정한 리소스를 삭제할 때 사용합니다.\n\n멱등성을 가집니다. 같은 리소스를 여러 번 삭제 요청해도 결과는 같습니다. 두 번째 요청부터는 404를 반환할 수 있지만, 서버 상태는 동일합니다.\n\n**HEAD - 메타데이터 조회:**\n\nGET과 동일하지만 응답 본문 없이 헤더만 받습니다. 리소스의 존재 여부 확인, 파일 크기 확인, 최종 수정 시간 확인 등에 사용됩니다.\n\n대역폭을 절약할 수 있고, 링크 유효성 검사나 캐시 검증에 유용합니다.\n\n**OPTIONS - 통신 옵션 확인:**\n\n서버가 지원하는 메서드를 확인할 때 사용합니다. CORS preflight 요청에서 주로 사용됩니다.\n\nAllow 헤더에 허용된 메서드 목록을 반환합니다.\n\n**TRACE - 경로 추적:**\n\n요청이 프록시를 거쳐 서버까지 도달하는 경로를 확인합니다. 디버깅 용도이며, 보안상 이유로 대부분의 서버에서 비활성화되어 있습니다.\n\n**CONNECT - 터널링:**\n\n프록시를 통한 SSL 터널을 설정할 때 사용합니다. 주로 HTTPS 연결에서 프록시가 사용하며, 일반 애플리케이션 개발에서는 거의 사용하지 않습니다.\n\n**RESTful API에서의 활용:**\n\n올바른 HTTP 메서드 사용은 RESTful API 설계의 핵심입니다. 각 메서드의 의미론을 존중하면 API가 직관적이고 예측 가능해집니다.\n\nGET /users - 사용자 목록 조회\nGET /users/123 - 특정 사용자 조회\nPOST /users - 새 사용자 생성\nPUT /users/123 - 사용자 123 전체 정보 업데이트\nPATCH /users/123 - 사용자 123 일부 정보 업데이트\nDELETE /users/123 - 사용자 123 삭제\n\n이러한 일관된 패턴은 API 사용자가 직관적으로 이해하고 사용할 수 있게 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "캐시"
      ],
      "id": "1763437633065-vz7jbphv",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP Method의 멱등성에 대해 설명해 주세요.",
      "answer": "멱등성(Idempotency)은 동일한 요청을 여러 번 수행해도 결과가 동일함을 의미합니다. HTTP Method 중 일부는 멱등성을 가지며, 이는 안전한 재시도와 시스템 설계에 중요합니다.\n\n**멱등성의 정의:**\n\n첫째, 여러 번 호출해도 결과가 같습니다. 한 번 호출하나 열 번 호출하나 서버 상태가 동일합니다. 부작용이 반복되지 않습니다. 클라이언트 입장에서 안전하게 재시도할 수 있습니다.\n\n둘째, 서버의 상태 변화가 중요합니다. 응답 코드나 응답 바디는 달라질 수 있습니다. 하지만 서버의 리소스 상태는 동일해야 합니다. 예를 들어 첫 DELETE는 200을 반환하고, 두 번째는 404를 반환할 수 있지만 리소스는 이미 삭제된 상태로 동일합니다.\n\n**멱등성을 가지는 Method:**\n\n첫째, GET입니다. 리소스를 조회만 합니다. 서버 상태를 변경하지 않습니다. 몇 번을 조회해도 같은 결과입니다. 안전(Safe)하기도 합니다.\n\n둘째, PUT입니다. 리소스를 완전히 대체합니다. 같은 데이터로 여러 번 PUT해도 결과는 동일합니다. 첫 번째 호출에서 리소스가 생성되거나 수정됩니다. 이후 호출은 같은 상태를 유지합니다.\n\n셋째, DELETE입니다. 리소스를 삭제합니다. 첫 번째 호출에서 삭제됩니다. 이후 호출에서도 리소스는 없는 상태입니다. 상태는 동일하므로 멱등성을 가집니다.\n\n넷째, HEAD입니다. GET과 유사하지만 바디 없이 헤더만 반환합니다. 서버 상태를 변경하지 않습니다. 멱등성과 안전성을 모두 가집니다.\n\n다섯째, OPTIONS입니다. 서버가 지원하는 메서드를 조회합니다. 상태를 변경하지 않습니다. 멱등성과 안전성을 가집니다.\n\n**멱등성을 가지지 않는 Method:**\n\n첫째, POST입니다. 새로운 리소스를 생성합니다. 매번 호출할 때마다 새 리소스가 생성됩니다. 동일한 요청을 두 번 보내면 중복 데이터가 생깁니다. 멱등하지 않습니다.\n\n둘째, PATCH입니다. 리소스를 부분적으로 수정합니다. 구현에 따라 멱등할 수도 있고 아닐 수도 있습니다. 일반적으로는 멱등하지 않다고 간주합니다. 예를 들어 \"값을 1 증가\"라는 PATCH는 호출할 때마다 값이 변합니다.\n\n**멱등성의 중요성:**\n\n첫째, 안전한 재시도입니다. 네트워크 오류로 응답을 받지 못한 경우 재시도할 수 있습니다. 멱등한 요청은 여러 번 보내도 안전합니다. 중복 실행을 걱정하지 않아도 됩니다.\n\n둘째, 분산 시스템의 안정성입니다. 메시지가 중복 전달될 수 있습니다. 멱등성이 보장되면 중복을 무시할 수 있습니다. 시스템이 더 견고해집니다.\n\n셋째, 캐싱과 최적화입니다. 멱등한 요청은 캐싱하기 좋습니다. 프록시나 CDN에서 안전하게 처리할 수 있습니다.\n\n**실무에서의 고려사항:**\n\nGET 요청에 부작용을 넣으면 안 됩니다. 조회수 증가 같은 것도 엄밀히는 부작용입니다. 하지만 실무에서는 허용하는 경우가 많습니다.\n\nPUT은 전체 교체를 의미합니다. 부분 수정에 PUT을 사용하면 멱등성이 깨질 수 있습니다. 명확하게 전체 데이터를 보내야 합니다.\n\nDELETE는 이미 없는 리소스를 삭제하는 것도 허용합니다. 404를 반환할 수 있지만 멱등성은 유지됩니다.\n\nPOST는 멱등하지 않으므로 재시도에 주의해야 합니다. 중복 방지를 위해 별도의 메커니즘이 필요합니다. 멱등성 키(Idempotency Key)를 사용할 수 있습니다.\n\n**멱등성 키 패턴:**\n\n클라이언트가 고유한 키를 생성하여 헤더에 포함합니다. 서버는 같은 키의 요청을 중복으로 간주합니다. 첫 요청만 처리하고 이후는 같은 응답을 반환합니다. POST 같은 비멱등 요청을 멱등하게 만들 수 있습니다.\n\n**안전성과의 차이:**\n\n안전(Safe)한 메서드는 서버 상태를 전혀 변경하지 않습니다. GET, HEAD, OPTIONS가 해당합니다.\n\n멱등한 메서드는 상태를 변경할 수 있지만, 여러 번 호출해도 최종 상태는 같습니다. PUT, DELETE가 해당합니다.\n\n안전하면 항상 멱등하지만, 멱등하다고 항상 안전한 것은 아닙니다.\n\n멱등성은 HTTP의 신뢰성과 확장성을 위한 중요한 개념입니다. RESTful API 설계 시 반드시 고려해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "캐시"
      ],
      "id": "1763437633065-nyzlkfse",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "GET과 POST의 차이는 무엇인가요?",
      "answer": "GET과 POST는 가장 많이 사용되는 HTTP 메서드로, 용도와 특성에서 명확한 차이가 있습니다.\n\n**GET의 특징:**\n\n첫째, 리소스 조회 목적입니다. 데이터를 가져오는 데 사용합니다. 서버의 상태를 변경하지 않습니다. 읽기 전용 작업입니다.\n\n둘째, URL에 데이터를 포함합니다. 쿼리 스트링으로 파라미터를 전달합니다. URL에 모든 정보가 노출됩니다. 북마크하거나 공유할 수 있습니다.\n\n셋째, 길이 제한이 있습니다. URL 길이에 제한이 있습니다. 브라우저마다 다르지만 보통 2048자 정도입니다. 많은 데이터를 전송하기 어렵습니다.\n\n넷째, 캐싱이 가능합니다. 같은 URL은 같은 결과를 반환합니다. 브라우저, 프록시, CDN에서 캐시합니다. 성능 향상에 도움이 됩니다.\n\n다섯째, 멱등성과 안전성을 가집니다. 여러 번 호출해도 결과가 같습니다. 서버 상태를 변경하지 않습니다. 재시도해도 안전합니다.\n\n여섯째, 브라우저 히스토리에 남습니다. 뒤로 가기 버튼으로 다시 요청할 수 있습니다. 새로고침해도 경고가 없습니다.\n\n**POST의 특징:**\n\n첫째, 리소스 생성 목적입니다. 새로운 데이터를 서버에 전송합니다. 서버의 상태를 변경합니다. 생성, 업데이트, 삭제 등에 사용합니다.\n\n둘째, 바디에 데이터를 포함합니다. HTTP 메시지 바디에 데이터를 담습니다. URL에 노출되지 않습니다. 보안상 유리합니다.\n\n셋째, 길이 제한이 거의 없습니다. 바디에 담을 수 있는 크기는 서버 설정에 따릅니다. 일반적으로 매우 큽니다. 파일 업로드 등 대용량 데이터 전송에 적합합니다.\n\n넷째, 캐싱되지 않습니다. 기본적으로 캐시하지 않습니다. 매번 서버에 요청이 전달됩니다. 항상 최신 데이터를 처리합니다.\n\n다섯째, 멱등하지 않습니다. 같은 요청을 여러 번 보내면 중복 생성될 수 있습니다. 재시도에 주의가 필요합니다.\n\n여섯째, 브라우저 히스토리 처리가 다릅니다. 뒤로 가기 시 재전송 여부를 묻습니다. 새로고침 시에도 경고가 표시됩니다.\n\n**주요 차이점 정리:**\n\n목적이 다릅니다. GET은 조회, POST는 생성입니다.\n\n데이터 위치가 다릅니다. GET은 URL, POST는 바디입니다.\n\n보안성이 다릅니다. GET은 URL에 노출, POST는 바디에 숨김입니다.\n\n캐싱 여부가 다릅니다. GET은 가능, POST는 불가능입니다.\n\n멱등성이 다릅니다. GET은 멱등, POST는 비멱등입니다.\n\n**보안 측면:**\n\nGET은 URL에 데이터가 노출됩니다. 서버 로그, 브라우저 히스토리, 프록시 로그에 남습니다. 민감한 정보를 전송하면 안 됩니다. 비밀번호나 개인정보는 POST를 사용해야 합니다.\n\nPOST도 HTTPS 없이는 안전하지 않습니다. 평문으로 전송되므로 중간에서 탈취될 수 있습니다. HTTPS를 사용해야 진정한 보안이 보장됩니다.\n\n**잘못된 사용 예:**\n\nGET으로 데이터를 생성하거나 수정하면 안 됩니다. 검색 엔진 크롤러가 실수로 작업을 실행할 수 있습니다. 브라우저가 자동으로 재시도하면서 의도치 않은 동작이 발생합니다.\n\nPOST로 단순 조회를 하는 것도 비효율적입니다. 캐싱의 이점을 잃습니다. RESTful하지 않습니다.\n\n**RESTful API에서의 사용:**\n\nGET은 리소스 조회에만 사용합니다. 목록 조회, 상세 조회 등입니다.\n\nPOST는 리소스 생성에 사용합니다. 새로운 사용자 등록, 새로운 게시글 작성 등입니다.\n\n수정은 PUT이나 PATCH를 사용하는 것이 더 적절합니다. 삭제는 DELETE를 사용합니다.\n\n**실무 팁:**\n\n검색 기능은 GET을 사용합니다. 검색 결과를 북마크하거나 공유할 수 있습니다. 캐싱으로 성능이 향상됩니다.\n\n폼 제출은 POST를 사용합니다. 회원가입, 로그인, 글쓰기 등입니다. 중복 제출을 방지하는 로직이 필요합니다.\n\n파일 업로드는 반드시 POST를 사용합니다. GET으로는 불가능합니다.\n\nGET과 POST는 각각 명확한 목적이 있으므로, 적절히 구분하여 사용해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "캐시"
      ],
      "id": "1763437633065-kd5neng5",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "POST와 PUT, PATCH의 차이는 무엇인가요?",
      "answer": "POST, PUT, PATCH는 모두 데이터를 서버로 전송하지만, 의미와 동작 방식에서 차이가 있습니다.\n\n**POST의 특징:**\n\n첫째, 리소스 생성입니다. 새로운 엔티티를 만듭니다. 서버가 리소스의 URI를 결정합니다. 클라이언트는 어디에 생성될지 모릅니다.\n\n둘째, 비멱등적입니다. 같은 요청을 여러 번 보내면 여러 리소스가 생성됩니다. 중복 실행을 조심해야 합니다.\n\n셋째, 201 Created를 반환합니다. Location 헤더에 생성된 리소스 URI를 포함합니다.\n\n넷째, 컬렉션에 요청합니다. 예를 들어 POST /users는 users 컬렉션에 새 사용자를 추가합니다.\n\n다섯째, 다목적으로 사용됩니다. 생성 외에도 복잡한 연산, 컨트롤러 역할 등에 사용됩니다.\n\n**PUT의 특징:**\n\n첫째, 리소스 교체입니다. 기존 리소스를 완전히 대체합니다. 리소스가 없으면 생성하고, 있으면 덮어씁니다.\n\n둘째, 멱등적입니다. 같은 요청을 여러 번 보내도 결과는 동일합니다. 안전하게 재시도할 수 있습니다.\n\n셋째, 클라이언트가 URI를 알고 있습니다. 특정 리소스에 직접 요청합니다. 예를 들어 PUT /users/123은 ID가 123인 사용자를 대체합니다.\n\n넷째, 전체 데이터를 전송합니다. 부분 데이터만 보내면 나머지는 null이나 기본값으로 덮어씁니다. 명시하지 않은 필드도 영향을 받습니다.\n\n다섯째, 200 OK나 204 No Content를 반환합니다. 생성된 경우 201 Created를 반환할 수도 있습니다.\n\n**PATCH의 특징:**\n\n첫째, 부분 수정입니다. 리소스의 일부만 변경합니다. 명시한 필드만 수정하고 나머지는 유지합니다.\n\n둘째, 일반적으로 비멱등적입니다. 구현에 따라 다를 수 있습니다. 절대값 설정은 멱등하지만, 증감 연산은 비멱등합니다.\n\n셋째, 유연한 수정이 가능합니다. 하나의 필드만 바꿀 수 있습니다. 전체 데이터를 보낼 필요가 없습니다.\n\n넷째, 200 OK나 204 No Content를 반환합니다.\n\n다섯째, JSON Patch 같은 표준 형식이 있습니다. 작업을 명시적으로 기술할 수 있습니다.\n\n**주요 차이점 비교:**\n\nPOST는 생성, PUT은 교체, PATCH는 부분 수정입니다.\n\nPOST는 컬렉션에, PUT과 PATCH는 특정 리소스에 요청합니다.\n\nPOST와 PATCH는 비멱등, PUT은 멱등입니다.\n\nPUT은 전체 데이터 필요, PATCH는 변경 부분만 필요합니다.\n\n**실제 사용 예시:**\n\n회원가입은 POST를 사용합니다. POST /users로 새 사용자를 생성합니다. 서버가 ID를 할당합니다.\n\n사용자 정보 전체 수정은 PUT을 사용합니다. PUT /users/123으로 모든 정보를 보냅니다. 이름, 이메일, 주소 등 전체를 포함합니다.\n\n이메일만 변경은 PATCH를 사용합니다. PATCH /users/123으로 이메일만 보냅니다. 다른 필드는 그대로 유지됩니다.\n\n**PUT 사용 시 주의점:**\n\n전체 데이터를 보내야 합니다. 일부만 보내면 나머지가 삭제될 수 있습니다. 예를 들어 이름만 보내면 이메일이 null이 될 수 있습니다.\n\n클라이언트가 리소스 URI를 알아야 합니다. 보통 GET으로 먼저 조회한 후 수정합니다.\n\n**PATCH 사용 시 주의점:**\n\n서버가 PATCH를 지원해야 합니다. 모든 서버가 지원하는 것은 아닙니다.\n\n부분 수정 로직이 복잡할 수 있습니다. null과 명시하지 않음을 구분해야 합니다.\n\n멱등성이 보장되지 않을 수 있습니다. 재시도에 주의가 필요합니다.\n\n**POST vs PUT 생성:**\n\nPOST는 서버가 URI를 정합니다. POST /articles로 새 글을 만들면 서버가 ID를 할당합니다. /articles/456 같은 URI가 생성됩니다.\n\nPUT도 생성할 수 있습니다. PUT /articles/999로 특정 ID의 글을 생성합니다. 클라이언트가 URI를 결정합니다. 일반적이지는 않습니다.\n\n**멱등성의 실제 의미:**\n\nPUT /users/123으로 같은 데이터를 10번 보내도 사용자 123은 같은 상태입니다. 첫 요청이든 열 번째 요청이든 결과는 동일합니다.\n\nPOST /users를 10번 보내면 10명의 사용자가 생성됩니다. 각각 다른 ID를 가집니다.\n\nPATCH /users/123으로 \"나이 +1\"을 10번 보내면 나이가 10 증가합니다. 비멱등적입니다.\n\n**RESTful API 설계:**\n\n명확한 의미를 가지도록 사용해야 합니다. POST는 생성, PUT은 전체 교체, PATCH는 부분 수정입니다. 각 메서드의 의미를 존중해야 합니다.\n\n실무에서는 POST를 과도하게 사용하는 경향이 있습니다. 모든 수정을 POST로 하는 것은 RESTful하지 않습니다. 적절한 메서드를 선택해야 합니다.\n\nPOST, PUT, PATCH를 올바르게 구분하여 사용하면 API가 직관적이고 예측 가능해집니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP"
      ],
      "id": "1763437633065-v6xx4e69",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?",
      "answer": "HTTP/1.1 명세는 기술적으로 GET 요청에 바디를 허용하지만, 실무에서는 강력히 권장되지 않습니다. 여러 실용적인 이유가 있습니다.\n\n**명세상의 모호함:**\n\n첫째, 의미가 불명확합니다. HTTP 명세는 GET 바디를 금지하지 않지만, 서버가 무시할 수 있다고 명시합니다. 바디가 있어도 처리하지 않을 수 있습니다. 동작이 보장되지 않습니다.\n\n둘째, RFC 7231의 표현입니다. GET 요청에 바디를 포함하는 것은 \"정의되지 않은 의미론\"을 가진다고 합니다. 서버는 바디를 무시하거나 거부할 수 있습니다. 명확한 지침이 없습니다.\n\n**인프라의 제한:**\n\n첫째, 프록시와 게이트웨이 문제입니다. 많은 프록시 서버가 GET 바디를 지원하지 않습니다. 바디를 삭제하거나 요청을 거부할 수 있습니다. Nginx, Apache 등 일부 웹 서버도 마찬가지입니다.\n\n둘째, 로드 밸런서 문제입니다. GET 요청을 특별하게 처리하는 경우가 많습니다. 바디가 있으면 예상치 못한 동작이 발생할 수 있습니다. 캐싱 레이어에서 문제가 생깁니다.\n\n셋째, CDN과 캐시 문제입니다. GET은 캐싱 가능한 메서드입니다. 하지만 바디를 고려하지 않고 캐시합니다. URL만 보고 캐시 키를 만듭니다. 같은 URL에 다른 바디를 보내도 같은 결과를 반환할 수 있습니다.\n\n**라이브러리와 도구의 제약:**\n\n첫째, HTTP 클라이언트 라이브러리입니다. 많은 라이브러리가 GET 바디를 지원하지 않거나 복잡합니다. fetch, axios, curl 등에서 불편하거나 불가능합니다. 코드가 복잡해지고 가독성이 떨어집니다.\n\n둘째, 브라우저의 제한입니다. 일부 브라우저는 GET 바디를 무시합니다. XMLHttpRequest나 fetch API에서도 일관되지 않습니다. 크로스 브라우저 호환성 문제가 있습니다.\n\n셋째, 테스트 도구 문제입니다. Postman, Swagger 등 도구가 GET 바디를 잘 지원하지 않을 수 있습니다. API 문서화와 테스트가 어려워집니다.\n\n**의미론적 문제:**\n\n첫째, GET의 의미와 충돌합니다. GET은 안전하고 멱등한 조회 작업입니다. 바디는 서버에 데이터를 전송하는 것을 의미합니다. 의미가 상충됩니다.\n\n둘째, RESTful 원칙 위반입니다. REST에서 GET은 리소스 식별을 URL로 합니다. 바디에 조건을 넣으면 리소스 식별이 모호해집니다. API가 직관적이지 않습니다.\n\n셋째, 예측 가능성이 떨어집니다. 대부분의 개발자가 GET은 바디가 없다고 가정합니다. 예상을 벗어나는 API는 이해하기 어렵습니다. 유지보수가 힘들어집니다.\n\n**캐싱 문제:**\n\nGET은 URL 기반으로 캐싱됩니다. 바디는 캐시 키에 포함되지 않습니다. 같은 URL이지만 다른 바디를 보내면 잘못된 캐시를 받을 수 있습니다. 데이터 정합성 문제가 발생합니다.\n\n**로깅과 모니터링:**\n\n많은 시스템이 GET 요청은 URL만 로깅합니다. 바디를 로깅하지 않습니다. 디버깅이 어려워집니다. 문제 추적이 힘들어집니다.\n\n**대안:**\n\n첫째, 쿼리 파라미터를 사용합니다. GET /search?q=keyword&category=book처럼 URL에 포함합니다. 표준적이고 안정적입니다.\n\n둘째, POST로 변경합니다. 복잡한 검색 조건은 POST로 보낼 수 있습니다. POST /search로 바디에 조건을 담습니다. 멱등하지 않지만 실용적입니다.\n\n셋째, GraphQL을 사용합니다. POST 메서드로 쿼리를 바디에 담습니다. 복잡한 조회에 적합합니다.\n\n**특수한 경우:**\n\nElasticsearch 같은 일부 시스템은 GET 바디를 사용합니다. 검색 쿼리가 복잡하고 길기 때문입니다. 하지만 이것도 논란의 여지가 있습니다. POST를 사용하는 것이 더 안전합니다.\n\n**실무 권장사항:**\n\nGET 바디는 사용하지 마세요. 기술적으로 가능해도 실용적이지 않습니다. 호환성, 예측 가능성, 유지보수성 모두 떨어집니다.\n\n쿼리 파라미터가 길어지면 POST 사용을 고려하세요. RESTful 원칙과 충돌하지만 현실적인 해결책입니다.\n\n표준을 따르세요. 대부분의 개발자가 이해하는 방식으로 API를 설계해야 합니다.\n\n기술적 가능성과 실용성은 다릅니다. GET 바디는 피해야 할 안티패턴입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "캐시"
      ],
      "id": "1763437633065-y04jmwvu",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP에 대해 설명해 주세요.",
      "answer": "**HTTP(HyperText Transfer Protocol)**는 클라이언트와 서버 간에 데이터를 주고받기 위한 애플리케이션 계층의 프로토콜입니다.\n\n**주요 특징:**\n- **무상태성(Stateless)**: 각 요청은 독립적이며, 이전 요청의 정보를 저장하지 않습니다\n- **비연결성(Connectionless)**: 요청과 응답이 완료되면 연결을 끊습니다\n- **텍스트 기반 프로토콜**: 사람이 읽을 수 있는 형태로 메시지를 구성합니다\n- **요청-응답 구조**: 클라이언트가 요청을 보내면 서버가 응답하는 단방향 통신입니다\n\n**구성 요소:**\n- **요청 메시지**: 요청 라인(메서드, URI, 버전), 헤더, 본문으로 구성\n- **응답 메시지**: 상태 라인(버전, 상태 코드, 상태 메시지), 헤더, 본문으로 구성\n- **메서드**: GET, POST, PUT, DELETE 등 클라이언트의 의도를 나타냅니다\n- **상태 코드**: 2xx(성공), 3xx(리다이렉션), 4xx(클라이언트 오류), 5xx(서버 오류)\n\n**버전별 발전:**\n- **HTTP/0.9**: 단순한 GET 메서드만 지원\n- **HTTP/1.0**: 헤더, 메서드, 상태 코드 도입\n- **HTTP/1.1**: 지속 연결, 파이프라이닝, 호스트 헤더 추가\n- **HTTP/2**: 멀티플렉싱, 헤더 압축, 서버 푸시 지원\n- **HTTP/3**: QUIC 프로토콜 기반, UDP 사용\n\n**실무 활용:**\n웹 브라우저와 웹 서버 간의 통신, RESTful API 설계, 웹 서비스 구축의 기반 프로토콜로 활용됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP"
      ],
      "id": "1763437633065-8qdkip68",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "공개키와 대칭키에 대해 설명해 주세요.",
      "answer": "**대칭키(Symmetric Key) 암호화**는 암호화와 복호화에 동일한 키를 사용하는 방식입니다.\n\n**대칭키의 특징:**\n- **빠른 속도**: 알고리즘이 단순하여 암호화/복호화 속도가 빠릅니다\n- **키 관리의 어려움**: 통신 상대방과 안전하게 키를 공유해야 합니다\n- **키 배포 문제**: N명이 통신하려면 N(N-1)/2개의 키가 필요합니다\n- **대표 알고리즘**: AES, DES, 3DES, ChaCha20\n\n**공개키(Public Key) 암호화**는 암호화와 복호화에 서로 다른 키를 사용하는 비대칭 암호화 방식입니다.\n\n**공개키의 구성:**\n- **공개키(Public Key)**: 누구나 알 수 있으며, 암호화에 사용됩니다\n- **개인키(Private Key)**: 소유자만 가지고 있으며, 복호화에 사용됩니다\n- **수학적 관계**: 두 키는 수학적으로 연관되어 있지만, 공개키로 개인키를 유추할 수 없습니다\n\n**공개키의 특징:**\n- **키 배포 용이**: 공개키는 누구에게나 공개해도 안전합니다\n- **느린 속도**: 복잡한 수학 연산으로 인해 대칭키보다 느립니다\n- **디지털 서명**: 개인키로 암호화하여 신원을 증명할 수 있습니다\n- **대표 알고리즘**: RSA, ECC, DSA\n\n**하이브리드 방식:**\n실무에서는 두 방식을 결합하여 사용합니다. 공개키로 대칭키를 안전하게 교환하고, 실제 데이터는 빠른 대칭키로 암호화합니다. HTTPS가 대표적인 예입니다.\n\n**장단점 비교:**\n- **대칭키**: 빠르지만 키 관리가 어렵습니다\n- **공개키**: 키 관리가 쉽지만 느립니다\n- **따라서**: 키 교환은 공개키, 데이터 암호화는 대칭키를 사용합니다",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "캐시"
      ],
      "id": "1763437633065-icaqkfqq",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?",
      "answer": "HTTPS Handshake에서 인증서를 사용하는 이유는 **중간자 공격(Man-in-the-Middle Attack)을 방지**하기 위함입니다.\n\n**인증서가 없을 때의 문제점:**\n공개키 암호화만 사용하면, 클라이언트는 서버가 보낸 공개키가 진짜 서버의 것인지 확인할 수 없습니다. 공격자가 중간에서 자신의 공개키를 보낼 수 있고, 이 경우 모든 통신 내용이 노출됩니다.\n\n**인증서의 역할:**\n- **서버 신원 확인**: 인증서를 통해 서버의 도메인과 공개키의 소유자를 확인합니다\n- **제3자 검증**: 신뢰할 수 있는 인증 기관(CA)이 서버의 신원을 보증합니다\n- **무결성 보장**: 인증서에 포함된 디지털 서명으로 위변조를 감지합니다\n\n**인증서의 구성 요소:**\n- **서버 정보**: 도메인 이름, 조직 정보\n- **서버의 공개키**: 실제 암호화에 사용될 키\n- **발급 기관 정보**: 어느 CA가 발급했는지\n- **유효 기간**: 인증서의 시작/만료 날짜\n- **디지털 서명**: CA의 개인키로 서명하여 무결성 보장\n\n**검증 과정:**\n1. 클라이언트가 서버로부터 인증서를 받습니다\n2. 클라이언트는 브라우저에 내장된 CA의 공개키로 인증서의 서명을 검증합니다\n3. 인증서의 도메인이 접속한 도메인과 일치하는지 확인합니다\n4. 인증서의 유효 기간을 확인합니다\n5. 인증서가 폐기되지 않았는지 확인합니다\n\n**신뢰 체인:**\n루트 CA가 중간 CA를 인증하고, 중간 CA가 서버 인증서를 인증하는 계층적 신뢰 구조를 형성합니다. 이를 통해 전 세계적으로 통일된 신뢰 체계를 구축합니다.\n\n**실무적 중요성:**\n인증서가 없다면 피싱 사이트와 정상 사이트를 구별할 수 없으며, 온라인 뱅킹이나 전자상거래 같은 보안이 중요한 서비스를 안전하게 제공할 수 없습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "UDP"
      ],
      "id": "1763437633065-0i4auhs0",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "SSL과 TLS의 차이는 무엇인가요?",
      "answer": "**SSL(Secure Sockets Layer)**과 **TLS(Transport Layer Security)**는 모두 네트워크 통신의 보안을 제공하는 암호화 프로토콜이며, TLS는 SSL의 후속 버전입니다.\n\n**역사적 발전 과정:**\n- **SSL 1.0**: 넷스케이프에서 개발했으나 공개되지 않음\n- **SSL 2.0(1995)**: 최초 공개 버전이나 심각한 보안 취약점 존재\n- **SSL 3.0(1996)**: 보안 개선, 가장 널리 사용된 SSL 버전\n- **TLS 1.0(1999)**: SSL 3.0 기반, IETF 표준으로 채택\n- **TLS 1.1(2006)**: CBC 공격 방어 기능 추가\n- **TLS 1.2(2008)**: 더 강력한 암호화 알고리즘 지원\n- **TLS 1.3(2018)**: 핸드셰이크 간소화, 보안 강화\n\n**주요 차이점:**\n- **명칭과 관리**: SSL은 넷스케이프의 프로토콜, TLS는 IETF 표준\n- **암호화 알고리즘**: TLS는 더 강력하고 다양한 암호화 방식 지원\n- **메시지 인증**: SSL은 MAC을 사용, TLS는 HMAC을 사용하여 더 안전함\n- **핸드셰이크 프로세스**: TLS 1.3은 1-RTT 또는 0-RTT로 연결 속도 개선\n- **경고 메시지**: TLS는 더 세분화된 경고 코드 제공\n\n**보안 측면의 차이:**\n- **SSL 3.0 이하**: POODLE 공격 등 심각한 취약점으로 더 이상 사용 금지\n- **TLS 1.0/1.1**: BEAST, CRIME 등의 취약점 존재, 점차 지원 중단\n- **TLS 1.2**: 현재 가장 널리 사용되는 안전한 버전\n- **TLS 1.3**: 취약한 암호화 제거, 완전 순방향 비밀성(PFS) 강제\n\n**핸드셰이크 효율성:**\n- **SSL/TLS 1.2**: 2-RTT 필요 (왕복 2회)\n- **TLS 1.3**: 1-RTT로 단축, 재연결 시 0-RTT 가능\n\n**현재 상황:**\n실무에서는 \"SSL 인증서\"나 \"SSL/TLS\"라는 용어를 흔히 사용하지만, 실제로는 TLS 프로토콜을 의미합니다. SSL은 역사적 용어로만 남아있으며, 모든 현대 시스템은 TLS를 사용합니다.\n\n**실무 권장사항:**\n- 최소 TLS 1.2 이상 사용\n- 가능하면 TLS 1.3 사용\n- SSL 2.0, 3.0, TLS 1.0, 1.1은 비활성화\n- 강력한 암호화 스위트만 허용",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP"
      ],
      "id": "1763437633065-4andh15x",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.",
      "answer": "**소켓(Socket) 통신**은 네트워크 상에서 두 프로그램 간의 양방향 통신을 위한 저수준 인터페이스입니다.\n\n**소켓 통신의 특징:**\n- **TCP/UDP 기반**: 전송 계층 프로토콜을 직접 사용합니다\n- **저수준 제어**: IP 주소와 포트 번호를 직접 지정하여 통신합니다\n- **자유로운 프로토콜**: 애플리케이션이 원하는 형태로 데이터를 주고받을 수 있습니다\n- **플랫폼 독립적**: 다양한 언어와 환경에서 사용 가능합니다\n\n**웹소켓(WebSocket)**은 웹 브라우저와 서버 간의 실시간 양방향 통신을 위한 프로토콜입니다.\n\n**웹소켓의 특징:**\n- **HTTP 기반 시작**: HTTP 연결을 웹소켓으로 업그레이드합니다\n- **지속적 연결**: 한 번 연결되면 명시적으로 끊기 전까지 유지됩니다\n- **양방향 통신**: 서버와 클라이언트가 자유롭게 메시지를 주고받습니다\n- **낮은 오버헤드**: HTTP 폴링보다 효율적입니다\n\n**프로토콜 계층 차이:**\n- **소켓**: 전송 계층(TCP/UDP) 위에서 동작\n- **웹소켓**: 애플리케이션 계층(HTTP) 위에서 동작하며 ws:// 또는 wss:// 스킴 사용\n\n**연결 수립 과정:**\n- **소켓**: 직접 TCP 3-way handshake 수행\n- **웹소켓**: HTTP 요청으로 시작하여 Upgrade 헤더를 통해 프로토콜 전환\n\n**방화벽/프록시 통과:**\n- **소켓**: 임의의 포트 사용 시 방화벽에서 차단될 수 있습니다\n- **웹소켓**: HTTP(80/443 포트) 기반이라 방화벽 통과가 쉽습니다\n\n**사용 환경:**\n- **소켓**: 서버 간 통신, 데스크톱 애플리케이션, 게임 서버 등\n- **웹소켓**: 웹 브라우저 기반 실시간 서비스(채팅, 알림, 주식 시세 등)\n\n**데이터 형식:**\n- **소켓**: 바이트 스트림으로 자유롭게 정의\n- **웹소켓**: 텍스트(UTF-8) 또는 바이너리 프레임 구조\n\n**실무 선택 기준:**\n웹 브라우저와의 실시간 통신이 필요하면 웹소켓을, 서버 간 통신이나 네이티브 앱에서는 소켓을 사용합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP"
      ],
      "id": "1763437633065-cpf0dfnz",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "소켓과 포트의 차이가 무엇인가요?",
      "answer": "**포트(Port)**는 네트워크 통신에서 특정 프로세스나 서비스를 식별하기 위한 논리적인 번호입니다.\n\n**포트의 특징:**\n- **16비트 정수**: 0부터 65535까지의 번호로 표현됩니다\n- **Well-Known Ports(0-1023)**: 시스템이 예약한 포트(HTTP:80, HTTPS:443)\n- **Registered Ports(1024-49151)**: 특정 애플리케이션이 등록한 포트\n- **Dynamic Ports(49152-65535)**: 임시로 사용하는 포트\n- **주소의 일부**: IP 주소와 함께 네트워크 종단점을 식별합니다\n\n**소켓(Socket)**은 네트워크 통신을 위한 엔드포인트로, 실제 통신을 수행하는 프로그래밍 인터페이스입니다.\n\n**소켓의 구성:**\n- **프로토콜**: TCP, UDP 등\n- **로컬 IP 주소**: 호스트의 IP 주소\n- **로컬 포트 번호**: 호스트의 포트 번호\n- **원격 IP 주소**: 상대방의 IP 주소\n- **원격 포트 번호**: 상대방의 포트 번호\n\n**관계성:**\n포트는 소켓을 구성하는 요소 중 하나입니다. 소켓은 5-tuple(프로토콜, 로컬 IP, 로컬 포트, 원격 IP, 원격 포트)로 고유하게 식별됩니다.\n\n**비유:**\n- **포트**: 건물의 문 번호\n- **소켓**: 실제 통신을 위한 문과 통로\n- **IP 주소**: 건물의 주소\n\n**사용 관점:**\n- **포트**: 서비스를 제공하는 애플리케이션을 찾기 위한 식별자\n- **소켓**: 실제 데이터를 주고받기 위한 프로그래밍 객체\n\n**서버 측 예시:**\n웹 서버가 80번 포트에서 리스닝하고 있을 때, 각 클라이언트 연결마다 별도의 소켓이 생성됩니다. 포트는 하나(80)지만 소켓은 여러 개가 됩니다.\n\n**클라이언트 측 예시:**\n클라이언트는 임의의 포트(예: 50123)를 사용하여 서버의 80번 포트로 연결합니다. 이때 생성되는 소켓은 (TCP, 클라이언트IP, 50123, 서버IP, 80)로 식별됩니다.\n\n**핵심 차이:**\n포트는 단순한 번호이고, 소켓은 통신을 위한 실체입니다. 하나의 포트에 여러 소켓이 연결될 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "프로세스"
      ],
      "id": "1763437633065-jkcf1xhw",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?",
      "answer": "아니요, **여러 소켓이 같은 포트 번호를 공유할 수 있습니다**. 이는 서버 프로그래밍에서 매우 일반적인 상황입니다.\n\n**소켓의 고유 식별:**\n소켓은 5-tuple로 고유하게 식별됩니다:\n- 프로토콜(TCP/UDP)\n- 로컬 IP 주소\n- 로컬 포트 번호\n- 원격 IP 주소\n- 원격 포트 번호\n\n**서버에서의 포트 공유:**\n웹 서버가 80번 포트에서 수백 개의 클라이언트 요청을 처리할 때, 모든 소켓이 로컬 포트 80번을 사용하지만, 각 소켓은 서로 다른 클라이언트 IP/포트와 연결되어 있어 구별됩니다.\n\n**예시 상황:**\n서버(192.168.1.100:80)에 세 클라이언트가 접속한 경우:\n- 소켓1: (TCP, 192.168.1.100, 80, 1.2.3.4, 50000)\n- 소켓2: (TCP, 192.168.1.100, 80, 1.2.3.5, 50001)\n- 소켓3: (TCP, 192.168.1.100, 80, 1.2.3.6, 50002)\n\n세 소켓 모두 로컬 포트 80을 사용하지만, 원격 주소가 달라 구별됩니다.\n\n**리스닝 소켓과 연결 소켓:**\n- **리스닝 소켓**: 새로운 연결을 기다리는 소켓 (하나만 존재)\n- **연결 소켓**: 실제 클라이언트와 통신하는 소켓 (여러 개 존재)\n- 둘 다 같은 포트 번호를 사용합니다\n\n**클라이언트 측:**\n클라이언트가 동일 서버에 여러 연결을 만들 때는 각각 다른 로컬 포트를 사용합니다. 운영체제가 사용 가능한 임시 포트를 자동으로 할당합니다.\n\n**SO_REUSEADDR 옵션:**\n이 소켓 옵션을 사용하면 TIME_WAIT 상태의 소켓이 사용하던 포트를 즉시 재사용할 수 있습니다. 서버 재시작 시 유용합니다.\n\n**SO_REUSEPORT 옵션:**\n리눅스와 일부 시스템에서는 여러 프로세스가 동일한 포트에서 리스닝할 수 있도록 하여 로드 밸런싱을 구현합니다.\n\n**UDP의 경우:**\nUDP는 연결 개념이 없어 하나의 소켓으로 여러 클라이언트와 통신할 수 있습니다. 각 데이터그램의 송신자 주소로 구별합니다.\n\n**멀티플렉싱:**\n운영체제의 전송 계층이 도착한 패킷의 5-tuple을 확인하여 올바른 소켓으로 전달하는 과정을 디멀티플렉싱이라고 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-0p753jeg",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?",
      "answer": "네, **이론적으로는 사용자 요청마다 소켓이 생성되지만**, 실무에서는 여러 최적화 기법으로 소켓 수를 제한합니다.\n\n**전통적인 서버 모델의 문제:**\n각 연결마다 소켓을 생성하면 다음과 같은 문제가 발생합니다:\n- **메모리 부족**: 각 소켓은 커널 메모리를 소비합니다\n- **파일 디스크립터 고갈**: 운영체제의 파일 디스크립터 제한에 도달합니다\n- **컨텍스트 스위칭 오버헤드**: 스레드 기반 모델에서 스레드 수가 증가하면 성능 저하가 발생합니다\n- **C10K 문제**: 1만 개 이상의 동시 연결 처리의 어려움\n\n**HTTP/1.1의 Keep-Alive:**\n- **지속 연결**: 한 소켓으로 여러 요청/응답을 처리합니다\n- **연결 재사용**: 매번 새 소켓을 생성하지 않아 오버헤드 감소\n- **타임아웃 설정**: 일정 시간 사용하지 않으면 연결을 종료합니다\n\n**HTTP/2의 멀티플렉싱:**\n- **단일 연결**: 하나의 TCP 연결(소켓)로 여러 요청을 동시에 처리합니다\n- **스트림**: 각 요청/응답을 별도의 스트림으로 관리합니다\n- **효율성**: 소켓 수를 크게 줄이면서도 높은 성능을 유지합니다\n\n**커넥션 풀(Connection Pool):**\n클라이언트 측에서는 미리 생성한 연결을 재사용하여 소켓 생성 비용을 줄입니다.\n\n**이벤트 기반 아키텍처:**\n- **Non-blocking I/O**: 하나의 스레드로 여러 소켓을 관리합니다\n- **epoll/kqueue**: 효율적인 이벤트 모니터링으로 많은 연결을 처리합니다\n- **Nginx, Node.js**: 이벤트 기반 모델로 적은 리소스로 많은 연결 처리\n\n**로드 밸런서:**\n여러 서버로 요청을 분산하여 개별 서버의 소켓 수를 제한합니다.\n\n**운영체제 레벨 제한:**\n- **ulimit**: 프로세스당 최대 파일 디스크립터 수 설정\n- **sysctl**: 시스템 전체의 소켓 관련 파라미터 조정\n- **tcp_max_syn_backlog**: SYN 큐의 크기 조정\n\n**애플리케이션 레벨 제어:**\n- **연결 수 제한**: 최대 동시 연결 수를 설정합니다\n- **큐잉**: 초과 요청은 대기열에 넣습니다\n- **타임아웃**: 유휴 연결을 적극적으로 종료합니다\n\n**실무 권장사항:**\n무한정 소켓을 생성하기보다는 연결 재사용, 멀티플렉싱, 이벤트 기반 모델 등을 활용하여 제한된 리소스로 많은 요청을 처리하는 것이 바람직합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-x7isaw7x",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?",
      "answer": "**HTTP/1.1**과 **HTTP/2**는 웹 통신 프로토콜의 서로 다른 버전으로, 성능과 효율성 면에서 큰 차이가 있습니다.\n\n**연결 처리 방식:**\n- **HTTP/1.1**: 한 번에 하나의 요청만 처리하거나, 파이프라이닝을 사용해도 응답 순서가 보장되어야 합니다\n- **HTTP/2**: 멀티플렉싱으로 하나의 연결에서 여러 요청/응답을 동시에 처리합니다\n\n**멀티플렉싱:**\n- **HTTP/1.1**: 여러 리소스를 동시에 받으려면 여러 TCP 연결을 생성해야 합니다\n- **HTTP/2**: 단일 TCP 연결 내에서 여러 스트림을 병렬로 처리하여 효율적입니다\n\n**헤더 압축:**\n- **HTTP/1.1**: 모든 요청마다 중복된 헤더를 텍스트 형태로 전송합니다\n- **HTTP/2**: HPACK 압축을 사용하여 헤더 크기를 대폭 줄입니다. 이전에 보낸 헤더를 참조하여 변경된 부분만 전송합니다\n\n**데이터 형식:**\n- **HTTP/1.1**: 텍스트 기반 프로토콜로 사람이 읽을 수 있습니다\n- **HTTP/2**: 바이너리 프레이밍으로 파싱이 빠르고 오류가 적습니다\n\n**서버 푸시:**\n- **HTTP/1.1**: 클라이언트가 요청한 리소스만 응답합니다\n- **HTTP/2**: 서버가 클라이언트 요청 전에 필요할 것으로 예상되는 리소스를 미리 전송할 수 있습니다\n\n**우선순위 지정:**\n- **HTTP/1.1**: 요청 순서에 따라 처리됩니다\n- **HTTP/2**: 각 스트림에 우선순위와 의존성을 부여하여 중요한 리소스를 먼저 전달합니다\n\n**도메인 샤딩의 필요성:**\n- **HTTP/1.1**: 브라우저의 동시 연결 제한을 우회하기 위해 여러 도메인 사용이 권장됩니다\n- **HTTP/2**: 단일 연결로 충분하므로 도메인 샤딩이 오히려 성능을 저하시킬 수 있습니다\n\n**리소스 인라이닝:**\n- **HTTP/1.1**: 작은 CSS/JS를 HTML에 직접 포함하여 요청 수를 줄입니다\n- **HTTP/2**: 멀티플렉싱으로 요청이 저렴하므로 파일을 분리하는 것이 캐싱에 유리합니다\n\n**HOL Blocking:**\n- **HTTP/1.1**: 애플리케이션 레벨에서 HOL Blocking 발생 (앞선 응답을 기다려야 함)\n- **HTTP/2**: 애플리케이션 레벨 HOL Blocking은 해결했지만, TCP 레벨 HOL Blocking은 여전히 존재합니다\n\n**성능 개선 효과:**\n페이지 로딩 속도가 15-50% 향상되며, 특히 지연 시간이 큰 네트워크에서 효과가 큽니다. 헤더 압축으로 모바일 환경에서 데이터 사용량도 감소합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-vgd8x2oq",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HOL Blocking 에 대해 설명해 주세요.",
      "answer": "**HOL Blocking(Head-of-Line Blocking)**은 순차적 처리가 필요한 시스템에서 앞선 작업이 지연되어 뒤따르는 모든 작업이 대기하게 되는 현상입니다.\n\n**HTTP/1.1의 HOL Blocking:**\nHTTP/1.1에서는 하나의 TCP 연결에서 요청을 순차적으로 처리합니다. 첫 번째 응답이 완료되기 전까지 두 번째 응답은 대기해야 합니다.\n\n**파이프라이닝의 한계:**\nHTTP/1.1 파이프라이닝은 여러 요청을 순차적으로 보낼 수 있지만, 응답은 요청 순서대로 받아야 합니다. 첫 번째 응답이 지연되면 이미 준비된 두 번째 응답도 대기해야 합니다.\n\n**문제점:**\n큰 이미지 파일 하나가 로딩되는 동안 작은 CSS 파일들이 모두 대기하게 되어 전체 페이지 로딩이 느려집니다.\n\n**HTTP/1.1의 해결 방법:**\n- **다중 연결**: 브라우저가 도메인당 6-8개의 병렬 연결을 생성합니다\n- **도메인 샤딩**: 여러 도메인을 사용하여 더 많은 병렬 연결을 확보합니다\n- **한계**: 연결 수가 많아지면 메모리와 CPU 오버헤드가 증가합니다\n\n**HTTP/2의 개선:**\nHTTP/2는 멀티플렉싱을 통해 애플리케이션 계층의 HOL Blocking을 해결했습니다. 하나의 연결에서 여러 스트림이 독립적으로 동작하여 하나의 응답 지연이 다른 응답에 영향을 주지 않습니다.\n\n**TCP 레벨 HOL Blocking:**\nHTTP/2도 TCP를 사용하므로 전송 계층의 HOL Blocking은 여전히 존재합니다. TCP는 패킷 손실 시 재전송을 기다려야 하며, 이는 모든 스트림에 영향을 줍니다.\n\n**TCP HOL Blocking의 메커니즘:**\nTCP는 순서 보장을 위해 패킷을 순차적으로 전달합니다. 중간 패킷이 손실되면 이후 도착한 패킷들이 버퍼에 쌓여 대기하게 됩니다. 이는 서로 무관한 HTTP/2 스트림에도 영향을 미칩니다.\n\n**실제 영향:**\n패킷 손실률이 2%인 네트워크에서 HTTP/2가 HTTP/1.1보다 느릴 수 있습니다. 손실된 패킷 하나가 모든 스트림을 지연시키기 때문입니다.\n\n**HTTP/3의 해결책:**\nHTTP/3는 UDP 기반의 QUIC 프로토콜을 사용하여 스트림 레벨에서 독립적인 재전송을 구현합니다. 하나의 스트림에서 패킷 손실이 발생해도 다른 스트림은 영향을 받지 않습니다.\n\n**QUIC의 접근 방식:**\n각 스트림이 독립적인 순서 보장과 재전송 메커니즘을 가지므로, 완전히 HOL Blocking을 해결합니다.\n\n**실무적 고려사항:**\n네트워크 품질이 좋은 환경에서는 HTTP/2가 충분하지만, 패킷 손실이 잦은 모바일 환경에서는 HTTP/3가 더 나은 성능을 보입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633066-lrkwwg03",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "HTTP/3.0의 주요 특징에 대해 설명해 주세요.",
      "answer": "**HTTP/3**는 UDP 기반의 QUIC 프로토콜을 사용하는 차세대 HTTP 프로토콜입니다.\n\n**QUIC 프로토콜 사용:**\nTCP 대신 UDP 위에 구현된 QUIC을 전송 프로토콜로 사용합니다. QUIC은 TCP의 신뢰성과 UDP의 속도를 결합한 프로토콜입니다.\n\n**HOL Blocking 완전 해결:**\n스트림별 독립적인 전송으로 하나의 스트림에서 패킷 손실이 발생해도 다른 스트림은 영향을 받지 않습니다. TCP의 HOL Blocking 문제를 근본적으로 해결했습니다.\n\n**연결 수립 속도 개선:**\n- **0-RTT 재연결**: 이전에 연결했던 서버라면 핸드셰이크 없이 즉시 데이터 전송이 가능합니다\n- **1-RTT 초기 연결**: 처음 연결 시에도 TLS 핸드셰이크와 전송 계층 핸드셰이크를 결합하여 1-RTT만 필요합니다\n- **TCP+TLS**: 기존에는 3-RTT(TCP 핸드셰이크 + TLS 핸드셰이크)가 필요했습니다\n\n**연결 마이그레이션:**\nConnection ID를 사용하여 IP 주소나 포트가 변경되어도 연결이 유지됩니다. Wi-Fi에서 모바일 네트워크로 전환될 때도 연결이 끊어지지 않습니다.\n\n**내장된 암호화:**\nQUIC은 기본적으로 TLS 1.3 암호화를 포함하고 있어 별도의 암호화 계층이 필요 없습니다. 모든 QUIC 연결은 암호화되어 보안이 강화됩니다.\n\n**향상된 혼잡 제어:**\nQUIC은 더 정확한 RTT 측정과 ACK 피드백을 제공하여 네트워크 상태에 더 빠르게 적응합니다. 패킷 손실 감지와 회복이 더 효율적입니다.\n\n**유연한 프로토콜 발전:**\nQUIC은 사용자 공간에서 구현되어 운영체제 업데이트 없이 프로토콜을 개선할 수 있습니다. TCP는 커널에 구현되어 업데이트가 어렵습니다.\n\n**멀티플렉싱 유지:**\nHTTP/2의 멀티플렉싱 기능을 그대로 유지하면서 TCP의 한계를 극복했습니다.\n\n**패킷 번호 공간:**\n각 패킷이 고유한 번호를 가져 재전송된 패킷과 원본 패킷을 명확히 구분할 수 있습니다. 이를 통해 RTT 측정이 더 정확해집니다.\n\n**도입 현황:**\n구글, 페이스북, 클라우드플레어 등 주요 기업들이 이미 HTTP/3를 지원하고 있습니다. 크롬, 파이어폭스, 사파리 등 주요 브라우저도 지원합니다.\n\n**장점 요약:**\n빠른 연결 수립, HOL Blocking 해결, 연결 마이그레이션, 향상된 보안, 모바일 환경 최적화가 주요 장점입니다.\n\n**과제:**\nUDP 기반이라 일부 방화벽이나 미들박스에서 차단될 수 있으며, 새로운 프로토콜이라 생태계 성숙도가 아직 발전 중입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-6591k27v",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "TCP와 UDP의 차이에 대해 설명해 주세요.",
      "answer": "**TCP(Transmission Control Protocol)**와 **UDP(User Datagram Protocol)**는 전송 계층의 대표적인 프로토콜로, 신뢰성과 성능 면에서 다른 특성을 가집니다.\n\n**연결 방식:**\n- **TCP**: 연결 지향형 프로토콜로, 통신 전에 3-way handshake로 연결을 수립합니다\n- **UDP**: 비연결형 프로토콜로, 연결 수립 없이 바로 데이터를 전송합니다\n\n**신뢰성:**\n- **TCP**: 데이터 전송의 신뢰성을 보장합니다. 손실, 중복, 순서 오류를 모두 처리합니다\n- **UDP**: 신뢰성을 보장하지 않습니다. 패킷이 손실되거나 순서가 바뀔 수 있습니다\n\n**순서 보장:**\n- **TCP**: 송신한 순서대로 데이터가 수신됨을 보장합니다\n- **UDP**: 순서를 보장하지 않으며, 먼저 보낸 패킷이 나중에 도착할 수 있습니다\n\n**속도와 오버헤드:**\n- **TCP**: 신뢰성 보장을 위한 메커니즘으로 인해 오버헤드가 크고 상대적으로 느립니다\n- **UDP**: 최소한의 오버헤드로 빠른 전송이 가능합니다\n\n**혼잡 제어:**\n- **TCP**: 네트워크 상황에 따라 전송 속도를 조절하는 혼잡 제어를 수행합니다\n- **UDP**: 혼잡 제어를 하지 않아 네트워크가 혼잡해도 계속 전송합니다\n\n**흐름 제어:**\n- **TCP**: 수신자의 처리 능력에 맞춰 전송 속도를 조절합니다\n- **UDP**: 흐름 제어를 하지 않습니다\n\n**헤더 크기:**\n- **TCP**: 20-60 바이트의 가변 크기 헤더를 가집니다\n- **UDP**: 8 바이트의 고정 크기 헤더로 단순합니다\n\n**전송 단위:**\n- **TCP**: 바이트 스트림으로 데이터를 처리합니다. 경계가 없습니다\n- **UDP**: 데이터그램 단위로 전송하며, 메시지 경계가 보존됩니다\n\n**오류 검출:**\n- **TCP**: Checksum으로 오류를 검출하고 재전송으로 복구합니다\n- **UDP**: Checksum으로 오류를 검출하지만 복구하지 않습니다\n\n**사용 사례:**\n- **TCP**: 웹 브라우징(HTTP/HTTPS), 이메일(SMTP, POP3), 파일 전송(FTP), 원격 접속(SSH)\n- **UDP**: 실시간 스트리밍(영상, 음성), DNS 쿼리, 온라인 게임, IoT 센서 데이터\n\n**실시간 성능:**\n- **TCP**: 재전송으로 인한 지연이 발생하여 실시간 애플리케이션에 부적합할 수 있습니다\n- **UDP**: 낮은 지연 시간으로 실시간 애플리케이션에 적합합니다\n\n**브로드캐스트/멀티캐스트:**\n- **TCP**: 일대일 통신만 지원합니다\n- **UDP**: 일대다, 다대다 통신을 지원합니다\n\n**선택 기준:**\n데이터의 정확성이 중요하고 손실이 허용되지 않으면 TCP를, 속도가 중요하고 일부 손실이 허용되면 UDP를 선택합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633066-ws9eelgq",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "Checksum이 무엇인가요?",
      "answer": "**Checksum**은 데이터의 무결성을 검증하기 위해 계산되는 값으로, 전송 중 오류가 발생했는지 확인하는 데 사용됩니다.\n\n**기본 원리:**\n송신자가 데이터로부터 특정 알고리즘을 사용하여 checksum 값을 계산하고 데이터와 함께 전송합니다. 수신자는 받은 데이터로 동일한 알고리즘을 적용하여 checksum을 계산하고, 수신한 checksum과 비교합니다.\n\n**계산 방법:**\n- **단순 합산**: 데이터 바이트들을 모두 더하고 오버플로우를 처리합니다\n- **1의 보수 합**: TCP/UDP에서 사용하는 방식으로, 16비트 단위로 더한 후 1의 보수를 취합니다\n- **CRC(Cyclic Redundancy Check)**: 다항식 나눗셈을 이용한 더 강력한 방법입니다\n\n**네트워크에서의 활용:**\n여러 프로토콜 계층에서 checksum을 사용하여 데이터 무결성을 검증합니다:\n- **IP 계층**: IP 헤더의 무결성 검증\n- **전송 계층**: TCP/UDP 세그먼트의 무결성 검증\n- **데이터링크 계층**: 이더넷 프레임의 CRC 검증\n\n**검출 가능한 오류:**\n- 비트 반전 오류\n- 일부 다중 비트 오류\n- 전송 중 데이터 손상\n\n**한계:**\n- **오류 정정 불가**: 오류를 발견할 수는 있지만 수정할 수는 없습니다\n- **완벽하지 않음**: 일부 오류 패턴은 검출하지 못할 수 있습니다\n- **충돌 가능성**: 서로 다른 데이터가 같은 checksum을 가질 수 있습니다\n\n**pseudo-header:**\nTCP와 UDP는 checksum 계산 시 IP 헤더의 일부 정보(송신/수신 IP 주소, 프로토콜 번호)를 포함하는 pseudo-header를 사용합니다. 이는 잘못된 목적지로 전달되는 것을 방지합니다.\n\n**성능 고려사항:**\nchecksum 계산은 CPU 자원을 소모하지만, 현대 하드웨어에서는 오프로딩 기능을 통해 네트워크 카드가 직접 계산하여 CPU 부담을 줄입니다.\n\n**보안 측면:**\nchecksum은 무결성 검증용이지 보안용이 아닙니다. 의도적인 변조를 막기 위해서는 암호학적 해시(SHA, MD5 등)나 MAC(Message Authentication Code)를 사용해야 합니다.\n\n**IPv6의 변화:**\nIPv6는 IP 헤더에서 checksum을 제거했습니다. 상위 계층(TCP/UDP)과 하위 계층(데이터링크)에서 이미 검증하므로 중복이라고 판단했기 때문입니다.\n\n**UDP checksum:**\nIPv4에서는 UDP checksum이 선택사항이었지만, IPv6에서는 필수가 되었습니다.\n\n**실무적 의미:**\nchecksum은 네트워크 통신의 기본적인 신뢰성 메커니즘으로, 물리적 전송 오류를 조기에 발견하여 상위 계층으로 전달되는 것을 방지합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-ajmcr1n3",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?",
      "answer": "**TCP와 UDP 모두 checksum을 수행**합니다. 두 프로토콜 모두 전송 계층에서 데이터 무결성을 검증합니다.\n\n**TCP의 Checksum:**\nTCP는 항상 필수적으로 checksum을 계산하고 검증합니다. TCP 헤더와 데이터를 포함한 전체 세그먼트에 대해 checksum을 수행합니다.\n\n**TCP Checksum의 필수성:**\nTCP는 신뢰성 있는 전송을 보장해야 하므로, checksum은 필수 항목입니다. checksum 검증에 실패하면 해당 세그먼트를 폐기하고 재전송을 요청합니다.\n\n**UDP의 Checksum:**\nUDP도 checksum 필드를 가지고 있으며, IPv6에서는 필수이지만 IPv4에서는 선택사항입니다.\n\n**IPv4에서의 UDP Checksum:**\nIPv4 환경에서 UDP checksum은 선택사항입니다. 계산하지 않으면 checksum 필드를 0으로 설정합니다. 하지만 대부분의 현대 구현은 성능보다 안정성을 위해 checksum을 수행합니다.\n\n**IPv6에서의 UDP Checksum:**\nIPv6는 IP 계층에서 checksum을 제거했기 때문에, UDP checksum이 필수가 되었습니다. 신뢰성 검증 계층이 하나 줄어들었으므로 UDP에서 반드시 검증해야 합니다.\n\n**Checksum 계산 범위:**\n두 프로토콜 모두:\n- Pseudo-header (송신/수신 IP, 프로토콜, 길이)\n- 프로토콜 헤더\n- 데이터 부분\n\n**오류 처리 차이:**\n- **TCP**: Checksum 오류 발견 시 세그먼트를 폐기하고 재전송을 통해 복구합니다\n- **UDP**: Checksum 오류 발견 시 데이터그램을 폐기하지만 재전송 메커니즘이 없습니다\n\n**성능 영향:**\nchecksum 계산은 약간의 오버헤드를 발생시키지만, 현대 시스템에서는 하드웨어 가속(offloading)을 통해 영향을 최소화합니다.\n\n**실시간 애플리케이션:**\n일부 실시간 스트리밍 애플리케이션에서는 UDP checksum을 비활성화하여 지연을 최소화하기도 했지만, 현재는 하드웨어 성능 향상으로 대부분 활성화합니다.\n\n**ICMPv6의 변화:**\nIPv6 환경에서는 ICMP도 checksum이 필수가 되었습니다. 전반적으로 IPv6는 상위 계층의 checksum을 더 강조합니다.\n\n**결론:**\nTCP와 UDP 모두 checksum을 수행하지만, TCP는 항상 필수이고 UDP는 IPv6에서만 필수입니다. 두 프로토콜 모두 데이터 무결성 검증의 기본 메커니즘으로 checksum을 사용합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-80d1oye7",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "그렇다면, Checksum을 통해 오류를 정정할 수 있나요?",
      "answer": "아니요, **checksum은 오류를 검출만 할 수 있고 정정할 수는 없습니다**.\n\n**오류 검출과 오류 정정의 차이:**\n- **오류 검출(Error Detection)**: 데이터에 오류가 있는지 확인만 합니다\n- **오류 정정(Error Correction)**: 오류가 어디에 있고 원래 값이 무엇인지 찾아 수정합니다\n\n**Checksum의 한계:**\nchecksum은 데이터가 손상되었다는 사실만 알려줄 뿐, 어느 비트가 잘못되었는지, 원래 값이 무엇인지는 알 수 없습니다. 단순히 계산된 값과 수신한 값이 다르다는 것만 확인합니다.\n\n**오류 발견 시 처리:**\n- **TCP**: 오류가 발견된 세그먼트를 폐기하고 재전송을 요청합니다\n- **UDP**: 오류가 발견된 데이터그램을 폐기하고 끝입니다 (재전송 없음)\n- **IP**: 오류가 발견된 패킷을 폐기합니다\n\n**왜 정정하지 않을까:**\nchecksum은 단순한 알고리즘으로 오버헤드가 적지만, 이는 정정에 필요한 충분한 정보를 제공하지 못합니다. 정정을 위해서는 더 많은 중복 데이터가 필요합니다.\n\n**오류 정정 코드(ECC):**\n실제로 오류를 정정하려면 다음과 같은 기법이 필요합니다:\n- **해밍 코드(Hamming Code)**: 단일 비트 오류 정정 가능\n- **Reed-Solomon 코드**: 다중 비트 오류 정정 가능\n- **Turbo 코드, LDPC 코드**: 무선 통신에서 사용\n\n**네트워크에서의 오류 정정:**\n물리 계층과 데이터링크 계층에서는 일부 오류 정정 기법을 사용하기도 합니다:\n- **무선 통신**: FEC(Forward Error Correction)로 재전송 없이 오류 복구\n- **위성 통신**: 높은 지연 때문에 재전송 대신 오류 정정 사용\n- **저장 장치**: RAID, SSD 등에서 ECC 메모리 사용\n\n**재전송 방식의 장점:**\n네트워크 환경에서는 오류 정정보다 재전송이 더 효율적입니다:\n- **낮은 오류율**: 대부분의 패킷이 정상 전송되므로 정정 코드의 오버헤드가 낭비됩니다\n- **단순성**: 구현이 간단하고 오버헤드가 적습니다\n- **유연성**: 필요한 경우에만 재전송하면 됩니다\n\n**ARQ(Automatic Repeat reQuest):**\nTCP는 ARQ 방식을 사용하여 오류를 처리합니다. 오류를 정정하는 대신 재전송을 요청하는 것이 더 효율적입니다.\n\n**CRC의 경우:**\n이더넷에서 사용하는 CRC도 강력한 오류 검출 능력을 가지지만 정정은 하지 못합니다. 오류 발견 시 프레임을 폐기합니다.\n\n**하이브리드 접근:**\n일부 시스템은 FEC와 ARQ를 결합하여 작은 오류는 정정하고, 큰 오류는 재전송합니다. 이를 Hybrid ARQ라고 합니다.\n\n**실무적 의미:**\nchecksum은 빠르고 효율적인 오류 검출 메커니즘이며, 정정은 재전송이나 상위 계층에서 처리하는 것이 네트워크 프로토콜의 일반적인 설계 철학입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633066-mzgesywx",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.",
      "answer": "TCP는 여러 메커니즘을 결합하여 **신뢰성 있는 데이터 전송**을 보장합니다.\n\n**순서 번호(Sequence Number):**\n송신하는 모든 바이트에 순서 번호를 부여합니다. 수신자는 이를 통해 데이터를 올바른 순서로 재조립하고 중복을 제거할 수 있습니다.\n\n**확인 응답(Acknowledgment):**\n수신자는 정상적으로 받은 데이터에 대해 ACK를 보냅니다. ACK 번호는 다음에 받기를 기대하는 바이트의 번호를 나타냅니다. 송신자는 ACK를 받아야 전송이 성공했음을 확인합니다.\n\n**재전송 메커니즘:**\n일정 시간(RTO, Retransmission Timeout) 내에 ACK를 받지 못하면 데이터를 재전송합니다. 타임아웃 시간은 네트워크 상태에 따라 동적으로 조정됩니다.\n\n**체크섬(Checksum):**\n헤더와 데이터의 무결성을 검증합니다. 체크섬이 맞지 않으면 세그먼트를 폐기하고, 송신자는 ACK를 받지 못해 재전송하게 됩니다.\n\n**흐름 제어(Flow Control):**\n수신자의 버퍼 크기를 고려하여 전송 속도를 조절합니다. 수신 윈도우(Receive Window) 필드를 통해 수신 가능한 데이터 양을 알립니다. 송신자는 수신자가 처리할 수 있는 만큼만 전송합니다.\n\n**혼잡 제어(Congestion Control):**\n네트워크의 혼잡 상황을 감지하고 전송 속도를 조절합니다. 주요 알고리즘으로 Slow Start, Congestion Avoidance, Fast Retransmit, Fast Recovery가 있습니다.\n\n**연결 지향:**\n3-way handshake로 연결을 수립하고, 4-way handshake로 안전하게 종료합니다. 연결 수립 시 초기 순서 번호를 교환하고 양쪽이 준비되었음을 확인합니다.\n\n**중복 ACK 처리:**\n같은 ACK를 여러 번 받으면 (일반적으로 3번) 패킷 손실로 판단하고 타임아웃을 기다리지 않고 즉시 재전송합니다 (Fast Retransmit).\n\n**누적 확인응답:**\nACK는 누적 방식으로, 특정 순서 번호까지의 모든 데이터를 받았음을 의미합니다. 이는 ACK 자체가 손실되어도 이후 ACK로 확인될 수 있게 합니다.\n\n**선택적 확인응답(SACK):**\nTCP 옵션으로 SACK를 사용하면 순서가 맞지 않게 도착한 데이터 블록을 구체적으로 알릴 수 있어, 불필요한 재전송을 줄입니다.\n\n**타임스탬프 옵션:**\nRTT를 정확히 측정하여 재전송 타임아웃을 최적화하고, PAWS(Protection Against Wrapped Sequence numbers)로 오래된 세그먼트를 구별합니다.\n\n**지속 타이머:**\n수신 윈도우가 0이 되어 전송이 중단된 상태에서 윈도우 업데이트 메시지가 손실될 경우를 대비한 타이머입니다.\n\n**상태 관리:**\n연결의 각 상태(ESTABLISHED, FIN_WAIT, TIME_WAIT 등)를 명확히 관리하여 예외 상황에서도 안정적으로 동작합니다.\n\n**결합된 신뢰성:**\n이러한 메커니즘들이 계층적으로 결합되어 패킷 손실, 손상, 중복, 순서 변경 등 모든 전송 오류에 대응하여 완벽한 신뢰성을 제공합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633066-tqp2keqb",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.",
      "answer": "**TCP 혼잡 제어(Congestion Control)**는 네트워크의 혼잡을 방지하고 효율적인 대역폭 사용을 위해 전송 속도를 조절하는 메커니즘입니다.\n\n**혼잡 윈도우(Congestion Window, cwnd):**\n송신자가 ACK를 받지 않고 전송할 수 있는 데이터의 양을 나타냅니다. 실제 전송량은 혼잡 윈도우와 수신 윈도우 중 작은 값으로 결정됩니다.\n\n**Slow Start(느린 시작):**\n연결 초기에 cwnd를 작은 값(일반적으로 1-10 MSS)에서 시작하여 지수적으로 증가시킵니다. ACK를 받을 때마다 cwnd를 1 MSS씩 증가시켜, 매 RTT마다 윈도우가 2배로 증가합니다. ssthresh(slow start threshold) 값에 도달하거나 패킷 손실이 발생할 때까지 계속됩니다.\n\n**Congestion Avoidance(혼잡 회피):**\ncwnd가 ssthresh에 도달하면 선형적으로 증가합니다. 매 RTT마다 cwnd를 1 MSS씩만 증가시켜 조심스럽게 탐색합니다. 네트워크 용량에 근접하면서도 혼잡을 피하기 위한 단계입니다.\n\n**Fast Retransmit(빠른 재전송):**\n3개의 중복 ACK를 받으면 타임아웃을 기다리지 않고 즉시 손실된 세그먼트를 재전송합니다. 타임아웃보다 빠르게 손실을 감지하여 효율성을 높입니다.\n\n**Fast Recovery(빠른 회복):**\nFast Retransmit 후 Slow Start로 돌아가지 않고 혼잡 회피 단계로 진입합니다. ssthresh를 현재 cwnd의 절반으로 설정하고, cwnd를 ssthresh 값으로 설정합니다. 중복 ACK는 패킷이 네트워크를 빠져나갔다는 증거이므로 완전한 혼잡 상태는 아니라고 판단합니다.\n\n**타임아웃 발생 시:**\n가장 심각한 혼잡 신호로 간주합니다. ssthresh를 현재 cwnd의 절반으로 설정하고, cwnd를 초기값(1 MSS)으로 줄입니다. Slow Start부터 다시 시작합니다.\n\n**혼잡 제어 알고리즘 변형:**\n- **Tahoe**: Fast Retransmit 후 Slow Start로 돌아갑니다\n- **Reno**: Fast Recovery를 도입하여 효율성을 개선했습니다\n- **New Reno**: 여러 패킷 손실을 더 잘 처리합니다\n- **CUBIC**: 대역폭이 큰 환경에서 효율적이며, 리눅스의 기본 알고리즘입니다\n- **BBR**: Google이 개발한 알고리즘으로, RTT와 대역폭을 기반으로 최적화합니다\n\n**CUBIC의 특징:**\n윈도우 크기를 3차 함수로 조정하여 고속 네트워크에서 더 빠르게 대역폭을 활용합니다. 손실 이벤트 시점을 기준으로 윈도우를 조정합니다.\n\n**BBR의 접근:**\n패킷 손실이 아닌 RTT와 전송률을 측정하여 네트워크의 실제 용량을 파악합니다. 버퍼 bloat 문제를 해결하고 더 낮은 지연과 높은 처리량을 제공합니다.\n\n**ECN(Explicit Congestion Notification):**\n라우터가 혼잡을 감지하면 패킷을 폐기하지 않고 IP 헤더에 표시합니다. 수신자는 이를 ACK에 표시하여 송신자에게 알립니다. 패킷 손실 없이 혼잡을 조기에 감지할 수 있습니다.\n\n**공평성(Fairness):**\n여러 TCP 연결이 같은 병목 링크를 공유할 때 대역폭을 공평하게 분배하도록 설계되었습니다. AIMD(Additive Increase Multiplicative Decrease) 방식이 이를 보장합니다.\n\n**실무적 의미:**\n혼잡 제어는 인터넷 전체의 안정성을 유지하는 핵심 메커니즘입니다. 모든 호스트가 협력하여 네트워크 붕괴를 방지합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "TCP"
      ],
      "id": "1763437633066-5o189zcx",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "왜 HTTP는 TCP를 사용하나요?",
      "answer": "HTTP가 TCP를 사용하는 이유는 **신뢰성 있는 데이터 전송**이 필요하기 때문입니다.\n\n**데이터 무결성 보장:**\n웹 페이지의 HTML, CSS, JavaScript, 이미지 등은 정확하게 전달되어야 합니다. 하나의 바이트라도 손실되거나 순서가 바뀌면 페이지가 깨지거나 스크립트가 오작동할 수 있습니다.\n\n**순서 보장의 중요성:**\nHTTP 응답은 순서대로 조립되어야 의미가 있습니다. HTML 파일의 앞부분이 뒷부분보다 나중에 도착하면 브라우저가 올바르게 렌더링할 수 없습니다.\n\n**완전한 전송 보장:**\n파일 다운로드, 폼 제출, API 요청 등은 모든 데이터가 완전히 전달되어야 합니다. 일부만 전달되면 작업이 실패하거나 잘못된 결과를 초래합니다.\n\n**TCP의 재전송 메커니즘:**\n네트워크 상황이 좋지 않아 패킷이 손실되어도 TCP가 자동으로 재전송하여 복구합니다. 애플리케이션 레벨에서 별도로 처리할 필요가 없습니다.\n\n**흐름 제어:**\n서버와 클라이언트의 처리 속도가 다를 때 TCP의 흐름 제어로 수신자가 감당할 수 있는 속도로 전송합니다. 버퍼 오버플로우를 방지합니다.\n\n**혼잡 제어:**\n네트워크가 혼잡할 때 전송 속도를 자동으로 조절하여 네트워크 붕괴를 방지합니다. 전체 인터넷의 안정성에 기여합니다.\n\n**연결 지향 특성:**\nHTTP/1.1 이전에는 요청마다 연결을 새로 만들었지만, HTTP/1.1부터는 Keep-Alive로 연결을 재사용합니다. TCP의 연결 개념이 이를 자연스럽게 지원합니다.\n\n**포트 기반 서비스 식별:**\nTCP의 포트 번호로 여러 서비스를 구분할 수 있습니다. HTTP는 80번, HTTPS는 443번 포트를 사용하여 명확하게 식별됩니다.\n\n**보안 계층 통합:**\nHTTPS는 TLS/SSL 보안 계층을 TCP 위에 구축합니다. TCP의 연결 지향 특성이 보안 핸드셰이크와 잘 맞습니다.\n\n**방화벽 통과:**\nTCP 80/443 포트는 거의 모든 방화벽에서 허용됩니다. 기업 환경에서도 문제없이 동작합니다.\n\n**UDP를 사용하지 않는 이유:**\nUDP는 빠르지만 신뢰성이 없습니다. 웹 페이지의 일부가 누락되는 것은 허용될 수 없으므로 UDP는 부적합합니다. 애플리케이션 레벨에서 신뢰성을 구현하는 것은 복잡하고 비효율적입니다.\n\n**역사적 배경:**\nHTTP가 설계될 당시(1990년대 초) TCP는 이미 성숙한 프로토콜이었고, 신뢰성 있는 전송의 표준이었습니다. 새로운 프로토콜을 만들 필요가 없었습니다.\n\n**멀티플렉싱의 발전:**\nHTTP/2는 TCP 위에서 멀티플렉싱을 구현하여 성능을 개선했습니다. TCP의 신뢰성을 유지하면서도 병렬 처리가 가능해졌습니다.\n\n**예외 사례 - HTTP/3:**\nHTTP/3는 QUIC(UDP 기반)을 사용하지만, 이는 QUIC이 TCP의 신뢰성 기능을 모두 재구현했기 때문입니다. 여전히 신뢰성 있는 전송이 필요합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-jh8q3he4",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?",
      "answer": "HTTP/3가 UDP를 사용하는 이유는 **TCP의 한계를 극복**하기 위함이며, QUIC 프로토콜이 UDP 위에서 TCP의 모든 신뢰성 기능을 재구현했습니다.\n\n**TCP의 근본적 한계:**\nTCP는 운영체제 커널에 구현되어 있어 프로토콜 개선이 어렵습니다. 새로운 기능을 추가하려면 모든 서버와 클라이언트의 운영체제를 업데이트해야 하는데, 이는 수년이 걸리거나 불가능합니다.\n\n**HOL Blocking 문제:**\nTCP는 패킷 손실 시 순서를 보장하기 위해 모든 스트림이 대기해야 합니다. HTTP/2는 애플리케이션 레벨 멀티플렉싱을 구현했지만, TCP 레벨의 HOL Blocking은 해결하지 못했습니다.\n\n**느린 연결 수립:**\nTCP 핸드셰이크(1-RTT)와 TLS 핸드셰이크(1-2 RTT)를 순차적으로 수행하여 총 2-3 RTT가 필요합니다. 모바일 환경에서는 지연이 크게 느껴집니다.\n\n**연결 마이그레이션 불가:**\nTCP는 연결을 IP 주소와 포트로 식별하므로, Wi-Fi에서 모바일로 전환 시 연결이 끊어집니다. 사용자 경험이 저하됩니다.\n\n**UDP를 선택한 이유:**\nUDP는 최소한의 기능만 제공하는 단순한 프로토콜입니다. 이를 기반으로 사용자 공간에서 필요한 기능을 자유롭게 구현할 수 있습니다. 운영체제 업데이트 없이 애플리케이션 업데이트만으로 프로토콜을 개선할 수 있습니다.\n\n**QUIC의 신뢰성 구현:**\nQUIC은 UDP 위에서 다음 기능들을 구현하여 TCP의 신뢰성을 완전히 재현했습니다:\n- **순서 보장**: 스트림별 독립적인 순서 보장\n- **재전송**: 패킷 손실 감지 및 재전송\n- **흐름 제어**: 스트림별, 연결별 흐름 제어\n- **혼잡 제어**: TCP와 유사한 혼잡 제어 알고리즘\n\n**스트림별 독립성:**\nQUIC은 각 스트림이 독립적으로 동작하여, 하나의 스트림에서 패킷 손실이 발생해도 다른 스트림은 영향을 받지 않습니다. 이로써 TCP의 HOL Blocking을 완전히 해결했습니다.\n\n**0-RTT 연결:**\n이전에 연결했던 서버라면 핸드셰이크 없이 즉시 데이터를 전송할 수 있습니다. 첫 패킷부터 실제 데이터를 포함할 수 있어 지연이 최소화됩니다.\n\n**연결 ID 사용:**\nIP 주소와 포트 대신 Connection ID로 연결을 식별하여, 네트워크가 변경되어도 연결이 유지됩니다. 모바일 환경에서 끊김 없는 경험을 제공합니다.\n\n**내장된 암호화:**\nQUIC은 TLS 1.3을 기본으로 통합하여 항상 암호화된 통신을 제공합니다. 별도의 핸드셰이크 단계가 필요 없어 지연이 줄어듭니다.\n\n**향상된 손실 복구:**\n각 패킷에 고유 번호를 부여하여 재전송 패킷과 원본 패킷을 명확히 구분합니다. RTT 측정이 정확해지고 재전송 효율이 향상됩니다.\n\n**유연한 발전:**\n사용자 공간 구현으로 새로운 기능을 빠르게 추가할 수 있습니다. 혼잡 제어 알고리즘 개선, 새로운 기능 추가 등이 용이합니다.\n\n**UDP의 문제 해결:**\nQUIC은 UDP의 모든 단점(신뢰성 없음, 순서 없음, 흐름제어 없음)을 애플리케이션 레벨에서 해결했습니다. UDP의 장점(유연성, 낮은 오버헤드)만 활용했습니다.\n\n**결론:**\nHTTP/3는 UDP를 직접 사용하는 것이 아니라, UDP 위에 구축된 QUIC이라는 완전한 전송 프로토콜을 사용합니다. QUIC은 TCP의 모든 신뢰성과 UDP의 유연성을 결합한 차세대 프로토콜입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-sodce1bw",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?",
      "answer": "브라우저는 여러 메커니즘을 통해 서버가 지원하는 프로토콜을 **협상(Negotiation)**하고 감지합니다.\n\n**Alt-Svc 헤더(Alternative Service):**\nHTTP/2를 사용하는 서버는 응답에 Alt-Svc 헤더를 포함하여 HTTP/3를 지원함을 알립니다. 예를 들어, \"h3=\\\":443\\\"\"는 동일한 443 포트에서 HTTP/3(QUIC)을 지원한다는 의미입니다. 브라우저는 이 정보를 캐싱하여 다음 연결부터 HTTP/3를 시도합니다.\n\n**초기 연결 과정:**\n처음 방문하는 사이트의 경우, 브라우저는 먼저 전통적인 TCP 기반 HTTP/1.1 또는 HTTP/2로 연결합니다. 서버가 Alt-Svc 헤더를 보내면, 브라우저는 다음 요청부터 HTTP/3를 시도합니다.\n\n**DNS HTTPS 레코드:**\nDNS에 HTTPS 레코드를 설정하여 해당 도메인이 지원하는 프로토콜 정보를 제공할 수 있습니다. 브라우저는 DNS 조회 시점에 HTTP/3 지원 여부를 미리 알 수 있어 첫 연결부터 최적의 프로토콜을 선택할 수 있습니다.\n\n**Happy Eyeballs 알고리즘:**\n브라우저는 TCP와 QUIC(UDP) 연결을 동시에 시도하는 경우가 있습니다. 먼저 성공하는 연결을 사용하고 다른 연결은 취소합니다. 이를 통해 빠른 연결과 폴백을 동시에 보장합니다.\n\n**연결 캐싱:**\n브라우저는 성공한 프로토콜 정보를 캐싱합니다. 같은 도메인에 다시 접속할 때 마지막으로 성공한 프로토콜을 우선 시도합니다.\n\n**QUIC 버전 협상:**\n클라이언트가 QUIC 연결을 시도할 때 지원하는 QUIC 버전 목록을 보냅니다. 서버가 지원하지 않는 버전이면 Version Negotiation 패킷으로 지원 버전을 알립니다.\n\n**폴백 메커니즘:**\nHTTP/3(QUIC) 연결이 실패하면 자동으로 HTTP/2(TCP)로 폴백합니다. 일부 방화벽이 UDP를 차단하는 경우를 대비한 안전장치입니다.\n\n**UDP 차단 감지:**\n브라우저는 QUIC 연결 시도가 타임아웃되면 해당 네트워크에서 UDP가 차단되었다고 판단합니다. 이 정보를 저장하여 다음 연결부터는 TCP만 시도합니다.\n\n**프로토콜 우선순위:**\n현대 브라우저의 기본 전략은 HTTP/3 → HTTP/2 → HTTP/1.1 순서로 시도합니다. 가장 최신이고 빠른 프로토콜을 우선합니다.\n\n**TLS ALPN(Application-Layer Protocol Negotiation):**\nTLS 핸드셰이크 시 클라이언트가 지원하는 프로토콜 목록을 보내고, 서버가 선택한 프로토콜을 응답합니다. HTTP/2는 이 방식으로 협상됩니다.\n\n**포트 번호:**\n일반적으로 HTTP/3도 443 포트를 사용하지만, Alt-Svc 헤더로 다른 포트를 지정할 수 있습니다. 브라우저는 이 정보를 따릅니다.\n\n**실제 동작 예시:**\n사용자가 처음 사이트에 접속하면 TCP/443으로 HTTP/2 연결을 합니다. 서버가 Alt-Svc 헤더를 보내면 브라우저가 캐싱합니다. 다음 방문 시 UDP/443으로 HTTP/3를 시도하며, 실패하면 TCP로 폴백합니다.\n\n**개발자 도구:**\n브라우저 개발자 도구의 Network 탭에서 사용된 프로토콜(h2, h3 등)을 확인할 수 있습니다. 실제 어떤 프로토콜이 협상되었는지 투명하게 보여줍니다.\n\n**점진적 도입:**\n이러한 협상 메커니즘 덕분에 HTTP/3를 점진적으로 도입할 수 있습니다. 지원하는 클라이언트는 HTTP/3를 사용하고, 지원하지 않는 클라이언트는 이전 버전을 사용합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-16213fr5",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?",
      "answer": "새로운 통신 프로토콜을 설계할 때는 **애플리케이션의 요구사항**을 분석하여 TCP와 UDP 중 적합한 것을 선택해야 합니다.\n\n**신뢰성 요구사항:**\n데이터의 완전한 전달이 필수적인가를 먼저 고려합니다. 금융 거래, 파일 전송, 데이터베이스 동기화 등은 단 하나의 바이트도 손실되어서는 안 되므로 TCP를 선택합니다. 실시간 스트리밍, 온라인 게임, VoIP 등은 일부 손실을 허용할 수 있으므로 UDP가 적합합니다.\n\n**지연 시간의 중요성:**\n실시간성이 중요한 애플리케이션은 UDP를 고려합니다. 게임에서 100ms 이전의 위치 정보는 무의미하며, 재전송받기보다 최신 데이터를 받는 것이 낫습니다. 음성/영상 통화도 약간의 품질 저하는 감수하더라도 낮은 지연이 중요합니다.\n\n**순서 보장의 필요성:**\n데이터 순서가 중요하면 TCP를 선택합니다. 텍스트 기반 프로토콜, 파일 다운로드, 데이터베이스 복제 등은 순서가 바뀌면 의미가 달라집니다. 독립적인 메시지 단위로 처리 가능하면 UDP로 애플리케이션 레벨에서 처리할 수 있습니다.\n\n**연결 상태 관리:**\n연결 개념이 필요한가를 판단합니다. 세션 기반 서비스, 인증이 필요한 서비스는 TCP의 연결 지향 특성이 유리합니다. 요청-응답 모델의 단순한 질의는 UDP로 충분합니다(예: DNS).\n\n**처리량 대 지연:**\n높은 처리량이 목표라면 TCP의 혼잡 제어가 유리합니다. 네트워크를 효율적으로 사용하며 공평성을 보장합니다. 낮은 지연이 목표라면 UDP로 오버헤드를 최소화합니다.\n\n**브로드캐스트/멀티캐스트:**\n일대다 통신이 필요하면 UDP를 선택해야 합니다. 네트워크 발견 프로토콜, 실시간 데이터 배포, IoT 센서 네트워크 등에서 활용됩니다.\n\n**네트워크 환경:**\n안정적인 데이터센터 내부 통신은 UDP로 오버헤드를 줄일 수 있습니다. 불안정한 무선 네트워크나 인터넷 환경은 TCP의 신뢰성이 필요합니다.\n\n**구현 복잡도:**\n빠른 프로토타이핑이 필요하면 TCP를 선택합니다. 신뢰성, 순서 보장 등을 직접 구현할 필요가 없습니다. UDP는 이러한 기능이 필요하면 애플리케이션에서 직접 구현해야 하므로 복잡도가 증가합니다.\n\n**방화벽 통과:**\n공공 인터넷을 통한 서비스라면 TCP가 유리합니다. 일부 네트워크에서 UDP를 차단하는 경우가 있습니다. 내부 네트워크에서는 제약이 적습니다.\n\n**기존 인프라:**\n로드밸런서, 프록시, 모니터링 도구 등의 지원을 고려합니다. TCP는 생태계가 성숙하여 다양한 도구가 있습니다.\n\n**하이브리드 접근:**\n때로는 두 프로토콜을 함께 사용하는 것이 최선입니다. 제어 메시지는 TCP로, 실시간 데이터는 UDP로 전송하는 방식입니다. 게임 서버가 대표적인 예입니다.\n\n**실제 선택 예시:**\n- **채팅 애플리케이션**: 메시지 전달 보장이 중요하므로 TCP\n- **실시간 주식 시세**: 최신 정보가 중요하고 이전 데이터는 불필요하므로 UDP\n- **파일 동기화**: 완벽한 복제가 필요하므로 TCP\n- **온라인 FPS 게임**: 낮은 지연이 핵심이므로 UDP\n- **REST API**: 신뢰성과 간단한 구현을 위해 TCP\n\n**성능 측정의 중요성:**\n이론적 분석 후 실제 환경에서 프로토타입을 테스트하여 성능을 측정하고 검증하는 것이 중요합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-jwriqjdz",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DHCP가 무엇인지 설명해 주세요.",
      "answer": "**DHCP(Dynamic Host Configuration Protocol)**는 네트워크에 연결된 장치에게 IP 주소와 네트워크 설정 정보를 자동으로 할당하는 프로토콜입니다.\n\n**기본 목적:**\n네트워크 관리자가 모든 장치에 수동으로 IP 주소를 설정하는 것은 비효율적이고 오류가 발생하기 쉽습니다. DHCP는 이를 자동화하여 네트워크 관리를 단순화합니다.\n\n**제공하는 정보:**\n- **IP 주소**: 네트워크에서 고유한 주소\n- **서브넷 마스크**: 네트워크와 호스트 부분을 구분\n- **기본 게이트웨이**: 외부 네트워크로 나가는 라우터 주소\n- **DNS 서버 주소**: 도메인 이름을 IP 주소로 변환하는 서버\n- **임대 시간(Lease Time)**: 할당된 IP 주소를 사용할 수 있는 기간\n\n**동적 할당의 장점:**\nIP 주소를 효율적으로 사용할 수 있습니다. 동시 접속자가 전체 장치 수보다 적다면 적은 수의 IP 주소 풀로도 운영 가능합니다. 사용자가 네트워크에서 나가면 IP 주소가 반환되어 다른 사용자가 사용할 수 있습니다.\n\n**자동 구성의 편리성:**\n새 장치를 네트워크에 연결하면 자동으로 설정됩니다. 사용자는 복잡한 네트워크 설정을 알 필요가 없습니다. 노트북을 집, 사무실, 카페에서 사용할 때 자동으로 적절한 설정을 받습니다.\n\n**중앙 집중 관리:**\n네트워크 설정을 DHCP 서버에서 중앙 관리합니다. DNS 서버 주소를 변경하려면 DHCP 서버 설정만 수정하면 모든 클라이언트에 반영됩니다. 수동 설정의 경우 모든 장치를 일일이 변경해야 합니다.\n\n**IP 주소 충돌 방지:**\nDHCP 서버가 할당된 주소를 추적하여 중복 할당을 방지합니다. 수동 설정에서는 실수로 같은 IP를 두 장치에 할당할 수 있습니다.\n\n**임대(Lease) 개념:**\nIP 주소는 영구적이 아닌 일정 기간 임대됩니다. 임대 기간의 절반이 지나면 클라이언트는 갱신을 요청합니다. 장치가 오프라인이 되면 임대 만료 후 주소가 회수되어 재사용됩니다.\n\n**예약(Reservation) 기능:**\n특정 장치에게 항상 같은 IP 주소를 할당할 수 있습니다. 프린터, 서버 등은 고정 IP가 필요한데, DHCP 예약으로 자동화하면서도 일관된 주소를 유지합니다.\n\n**활용 사례:**\n- **가정용 공유기**: 연결된 기기에 자동으로 IP 할당\n- **기업 네트워크**: 수천 대의 컴퓨터를 자동 구성\n- **공공 Wi-Fi**: 불특정 다수에게 임시 IP 제공\n- **IoT 기기**: 설정 없이 네트워크에 자동 연결\n\n**보안 고려사항:**\nDHCP는 인증 메커니즘이 약하여 무단 DHCP 서버(Rogue DHCP)가 잘못된 정보를 배포할 수 있습니다. DHCP Snooping 같은 보안 기능으로 대응합니다.\n\n**고가용성:**\n중요한 네트워크에서는 여러 DHCP 서버를 운영하여 장애 시에도 서비스를 유지합니다.\n\n**실무적 의미:**\nDHCP는 현대 네트워크의 필수 요소로, 사용자 경험을 개선하고 관리 비용을 크게 줄입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-dtb8t9jb",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DHCP는 몇 계층 프로토콜인가요?",
      "answer": "DHCP는 **애플리케이션 계층(7계층) 프로토콜**입니다.\n\n**OSI 7계층 모델에서의 위치:**\n애플리케이션 계층은 최상위 계층으로, 사용자나 애플리케이션에 직접적인 서비스를 제공하는 프로토콜들이 위치합니다. DHCP는 IP 주소 할당이라는 특정 서비스를 제공하므로 이 계층에 속합니다.\n\n**전송 계층 프로토콜:**\nDHCP는 전송을 위해 UDP를 사용합니다. 서버는 67번 포트를, 클라이언트는 68번 포트를 사용합니다.\n\n**왜 애플리케이션 계층인가:**\n계층 분류는 프로토콜이 제공하는 서비스의 성격으로 결정됩니다. DHCP는 네트워크 설정이라는 고수준의 서비스를 제공하므로 애플리케이션 계층입니다. 단순히 데이터 전송이나 라우팅 같은 하위 계층의 기능이 아닙니다.\n\n**UDP 사용의 이유:**\nDHCP는 연결 수립 전에 동작해야 하므로 TCP의 연결 지향 특성이 적합하지 않습니다. 클라이언트가 아직 IP 주소가 없는 상태에서 동작해야 하므로 가벼운 UDP가 적합합니다.\n\n**브로드캐스트 통신:**\n초기 DHCP Discover 메시지는 브로드캐스트로 전송됩니다. UDP는 브로드캐스트를 지원하지만 TCP는 지원하지 않습니다.\n\n**다른 애플리케이션 계층 프로토콜과의 유사성:**\nDNS, HTTP, FTP 등과 같은 계층에 속하며, 모두 특정 서비스를 제공하는 고수준 프로토콜입니다.\n\n**프로토콜 스택:**\nDHCP 메시지는 다음과 같이 캡슐화됩니다:\n- 애플리케이션 계층: DHCP 메시지\n- 전송 계층: UDP 헤더 추가\n- 네트워크 계층: IP 헤더 추가\n- 데이터링크 계층: 이더넷 프레임 추가\n\n**부트스트랩 문제:**\nDHCP는 흥미로운 부트스트랩 문제를 다룹니다. 네트워크 통신을 위해서는 IP 주소가 필요한데, IP 주소를 받기 위해서는 네트워크 통신이 필요합니다. 이를 브로드캐스트와 특수한 주소(0.0.0.0, 255.255.255.255)로 해결합니다.\n\n**상위 프로토콜:**\nDHCP는 BOOTP(Bootstrap Protocol)를 확장한 것으로, 두 프로토콜은 같은 포트 번호를 사용하여 호환성을 유지합니다.\n\n**실무적 의미:**\n계층 구분을 이해하면 네트워크 문제 해결 시 적절한 레벨에서 진단할 수 있습니다. DHCP 문제는 애플리케이션 레벨 설정을 확인해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "동기화",
        "TCP"
      ],
      "id": "1763437633066-3zmvbwzl",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DHCP는 어떻게 동작하나요?",
      "answer": "DHCP는 **4단계 프로세스**를 통해 IP 주소를 할당합니다. 이를 **DORA(Discover, Offer, Request, Acknowledge)**라고 합니다.\n\n**1단계: DHCP Discover (발견)**\n클라이언트가 네트워크에 연결되면 DHCP 서버를 찾기 위해 브로드캐스트 메시지를 전송합니다. 송신 주소는 0.0.0.0(자신의 주소가 없음), 수신 주소는 255.255.255.255(브로드캐스트)입니다. 이 메시지는 같은 네트워크의 모든 장치에게 전달됩니다.\n\n**2단계: DHCP Offer (제안)**\nDHCP 서버들이 Discover 메시지를 받으면 사용 가능한 IP 주소를 제안합니다. Offer 메시지에는 제안하는 IP 주소, 서브넷 마스크, 임대 시간, DHCP 서버 주소 등이 포함됩니다. 여러 DHCP 서버가 있다면 각각 Offer를 보낼 수 있습니다.\n\n**3단계: DHCP Request (요청)**\n클라이언트는 받은 Offer 중 하나를 선택하여 해당 서버에게 정식으로 IP 주소를 요청합니다. 이 메시지도 브로드캐스트로 전송되어, 선택되지 않은 서버들도 자신의 제안이 거절되었음을 알 수 있습니다. 클라이언트 ID와 요청하는 IP 주소 정보가 포함됩니다.\n\n**4단계: DHCP Acknowledge (확인)**\n선택된 DHCP 서버가 IP 주소 할당을 확정하고 ACK 메시지를 보냅니다. 이 메시지에는 최종 네트워크 설정 정보가 모두 포함됩니다: IP 주소, 서브넷 마스크, 게이트웨이, DNS 서버, 임대 시간 등. 클라이언트는 이 정보를 받아 네트워크 인터페이스를 구성합니다.\n\n**임대 갱신 과정:**\nIP 주소는 영구적이 아닌 임시 할당입니다. 임대 시간의 50%가 경과하면 클라이언트는 갱신을 시도합니다(T1 타이머). 이때는 브로드캐스트가 아닌 유니캐스트로 해당 DHCP 서버에 직접 Request를 보냅니다. 서버가 ACK로 응답하면 임대가 갱신됩니다.\n\n**임대 재바인딩:**\n갱신 시도가 실패하고 임대 시간의 87.5%가 경과하면(T2 타이머) 재바인딩을 시도합니다. 이때는 브로드캐스트로 Request를 보내 다른 DHCP 서버의 응답도 받을 수 있습니다.\n\n**임대 만료:**\n모든 갱신 시도가 실패하고 임대가 완전히 만료되면 클라이언트는 IP 주소 사용을 중단합니다. 네트워크 연결이 끊기고, 처음부터 DORA 과정을 다시 시작합니다.\n\n**IP 주소 해제:**\n클라이언트가 정상적으로 네트워크를 떠날 때는 DHCP Release 메시지를 보내 IP 주소를 반환합니다. 서버는 즉시 이 주소를 다른 클라이언트에게 할당할 수 있습니다.\n\n**빠른 재연결:**\n이전에 사용하던 IP 주소가 있는 클라이언트는 Discover를 생략하고 바로 Request를 보낼 수 있습니다. 서버가 ACK하면 즉시 사용 가능하며, NACK하면 처음부터 다시 시작합니다.\n\n**DHCP Relay Agent:**\nDHCP는 브로드캐스트를 사용하므로 같은 네트워크 세그먼트에서만 동작합니다. 다른 네트워크의 DHCP 서버를 사용하려면 라우터가 DHCP Relay Agent 역할을 하여 메시지를 전달합니다.\n\n**상태 확인:**\n일부 DHCP 서버는 IP 주소를 할당하기 전에 ICMP Echo(ping)를 보내 해당 주소가 이미 사용 중인지 확인합니다. 충돌을 방지하기 위한 추가 안전장치입니다.\n\n**실무 활용:**\n대부분의 사용자는 이 과정을 인식하지 못하지만, Wi-Fi에 연결할 때 몇 초의 대기 시간이 바로 DHCP 과정입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-5ikhiiu3",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DHCP에서 UDP를 사용하는 이유가 무엇인가요?",
      "answer": "DHCP가 UDP를 사용하는 이유는 **클라이언트가 아직 IP 주소를 받지 못한 상태**에서 동작해야 하기 때문입니다.\n\n**부트스트랩 문제:**\nDHCP의 목적 자체가 IP 주소를 할당하는 것인데, TCP는 연결 수립을 위해 이미 IP 주소가 필요합니다. 3-way handshake를 수행하려면 양쪽 모두 유효한 IP 주소가 있어야 하는데, 클라이언트는 아직 IP가 없는 상태입니다.\n\n**브로드캐스트 지원:**\nDHCP 초기 단계에서는 서버의 위치를 모르므로 브로드캐스트로 메시지를 보내야 합니다. UDP는 브로드캐스트를 지원하지만 TCP는 일대일 연결만 가능합니다. Discover 메시지를 255.255.255.255로 보내 모든 DHCP 서버가 받을 수 있도록 합니다.\n\n**단순한 요청-응답 구조:**\nDHCP는 복잡한 연결 관리가 필요 없는 단순한 요청-응답 패턴입니다. Discover-Offer-Request-Acknowledge의 4단계 메시지 교환만으로 충분합니다. TCP의 연결 설정, 유지, 종료 오버헤드가 불필요합니다.\n\n**낮은 오버헤드:**\nIP 주소 할당은 빠르게 완료되어야 합니다. 네트워크에 연결할 때마다 수행되므로 지연이 사용자 경험에 직접 영향을 줍니다. UDP의 낮은 오버헤드로 빠른 처리가 가능합니다.\n\n**상태 비저장:**\nDHCP 서버는 수천 대의 클라이언트를 처리해야 할 수 있습니다. UDP의 비연결 특성으로 각 클라이언트마다 연결 상태를 유지할 필요가 없어 서버 부담이 줄어듭니다.\n\n**신뢰성 보장 방법:**\nUDP는 신뢰성이 없지만 DHCP는 애플리케이션 레벨에서 재전송을 구현합니다. 클라이언트가 일정 시간 내에 응답을 받지 못하면 요청을 재전송합니다. 지수 백오프(exponential backoff)로 재전송 간격을 늘려 네트워크 부담을 줄입니다.\n\n**멀티캐스트 가능성:**\n일부 DHCP 구현은 멀티캐스트도 활용합니다. UDP는 멀티캐스트를 지원하지만 TCP는 불가능합니다.\n\n**특수한 주소 사용:**\n클라이언트는 송신 주소로 0.0.0.0을 사용할 수 있어야 합니다. TCP는 유효한 IP 주소가 필요하지만 UDP는 이러한 특수 주소를 허용합니다.\n\n**역사적 배경:**\nDHCP의 전신인 BOOTP도 UDP를 사용했습니다. DHCP는 BOOTP와 호환성을 유지하기 위해 같은 포트(67, 68)와 프로토콜(UDP)을 사용합니다.\n\n**포트 번호의 의미:**\n서버는 67번, 클라이언트는 68번 포트를 사용합니다. 클라이언트 포트가 고정된 이유는 브로드캐스트 응답을 받기 위함입니다. IP 주소가 없는 상태에서 특정 클라이언트에게 유니캐스트할 수 없으므로 고정 포트로 브로드캐스트합니다.\n\n**방화벽 설정:**\nUDP 67, 68번 포트만 허용하면 DHCP 트래픽을 제어할 수 있습니다. TCP를 사용했다면 더 복잡한 상태 추적이 필요했을 것입니다.\n\n**네트워크 부하:**\n대규모 네트워크에서 수백 대가 동시에 부팅할 때, TCP 연결 설정의 오버헤드는 상당한 부하를 발생시킵니다. UDP는 이를 최소화합니다.\n\n**결론:**\nDHCP의 특수한 동작 환경(IP 주소가 없는 상태, 브로드캐스트 필요, 단순한 교환)을 고려하면 UDP가 필수적이고 자연스러운 선택입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-qtg4r132",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?",
      "answer": "네, DHCP는 IP 주소 외에도 **네트워크 동작에 필요한 다양한 설정 정보**를 제공합니다.\n\n**서브넷 마스크(Subnet Mask):**\nIP 주소의 네트워크 부분과 호스트 부분을 구분하는 정보입니다. 클라이언트가 같은 네트워크 내의 장치를 식별하는 데 필수적입니다. 예를 들어 255.255.255.0은 /24 네트워크를 의미합니다.\n\n**기본 게이트웨이(Default Gateway):**\n외부 네트워크로 패킷을 보낼 때 사용하는 라우터의 IP 주소입니다. 클라이언트가 인터넷에 접속하려면 반드시 필요합니다. 일반적으로 공유기나 라우터의 IP 주소가 됩니다.\n\n**DNS 서버 주소:**\n도메인 이름을 IP 주소로 변환하는 DNS 서버의 주소입니다. 여러 DNS 서버를 제공할 수 있으며, 우선순위에 따라 사용합니다. 이것이 없으면 도메인 이름으로 접속할 수 없고 IP 주소를 직접 입력해야 합니다.\n\n**임대 시간(Lease Time):**\n할당된 IP 주소를 사용할 수 있는 기간입니다. 초 단위로 표현되며, 일반적으로 몇 시간에서 며칠입니다. 임대 시간이 지나면 클라이언트는 갱신을 요청하거나 새로운 주소를 받아야 합니다.\n\n**도메인 이름(Domain Name):**\n클라이언트가 속한 도메인의 이름입니다. 예를 들어 \"company.local\" 같은 값입니다. FQDN(Fully Qualified Domain Name) 구성에 사용됩니다.\n\n**NTP 서버(Time Server):**\n시간 동기화를 위한 NTP 서버의 주소입니다. 시스템 시간을 정확하게 유지하는 데 사용됩니다. 로그 분석, 인증서 검증 등에서 중요합니다.\n\n**WINS 서버(NetBIOS Name Server):**\nWindows 환경에서 NetBIOS 이름 해석을 위한 서버 주소입니다. 레거시 시스템 지원을 위해 여전히 제공되는 경우가 있습니다.\n\n**TFTP 서버와 부트 파일명:**\n네트워크 부팅(PXE Boot)을 위한 정보입니다. 디스크가 없는 씬 클라이언트나 서버 설치 시 사용됩니다.\n\n**라우터 목록:**\n여러 라우터가 있을 때 사용 가능한 라우터 목록을 제공합니다. 장애 대응이나 로드 밸런싱에 활용됩니다.\n\n**MTU(Maximum Transmission Unit):**\n네트워크 인터페이스에서 사용할 최대 전송 단위를 지정합니다. 네트워크 환경에 맞는 최적값을 설정하여 단편화를 줄입니다.\n\n**브로드캐스트 주소:**\n해당 네트워크의 브로드캐스트 주소입니다. 서브넷 마스크로 계산할 수 있지만 명시적으로 제공하기도 합니다.\n\n**Static Routes(정적 라우트):**\n특정 목적지로 가는 경로를 지정합니다. 복잡한 네트워크 토폴로지에서 라우팅을 최적화합니다.\n\n**Vendor-Specific Information:**\n특정 벤더의 장비가 필요로 하는 사용자 정의 옵션입니다. IP 전화기, 셋톱박스 등이 자신에게 필요한 특수 설정을 받습니다.\n\n**Proxy Auto-Configuration URL:**\n웹 브라우저가 프록시 설정을 자동으로 받을 수 있는 URL입니다. 기업 환경에서 프록시 관리를 자동화합니다.\n\n**DHCP 옵션 코드:**\n이러한 정보들은 DHCP 옵션으로 구현됩니다. 각 정보는 고유한 옵션 번호를 가지며, 표준(RFC 2132) 또는 벤더별로 정의됩니다.\n\n**실무 활용:**\n가정용 네트워크에서는 IP, 서브넷, 게이트웨이, DNS 정도만 제공하지만, 기업 환경에서는 수십 가지 옵션을 설정하여 복잡한 네트워크를 자동 구성합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "프로세스"
      ],
      "id": "1763437633066-eixq8mmi",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DHCP의 유효기간은 얼마나 긴가요?",
      "answer": "DHCP 임대 시간(Lease Time)은 **환경과 정책에 따라 다르며**, 일반적으로 **몇 시간에서 며칠** 사이입니다.\n\n**일반적인 설정값:**\n- **가정용 공유기**: 24시간(1일)이 가장 일반적입니다\n- **기업 사무실**: 8시간에서 7일 사이\n- **공공 Wi-Fi**: 30분에서 2시간\n- **데이터센터**: 며칠에서 몇 주\n- **무한대**: 이론적으로 가능하지만 권장되지 않습니다\n\n**짧은 임대 시간의 장점:**\nIP 주소가 빠르게 회수되어 재사용됩니다. 모바일 장치가 많은 환경에서 제한된 주소 풀을 효율적으로 사용합니다. 카페, 공항 등 사용자 이동이 잦은 곳에 적합합니다. 네트워크 설정 변경 시 빠르게 반영됩니다.\n\n**짧은 임대 시간의 단점:**\n갱신 트래픽이 증가하여 DHCP 서버와 네트워크 부하가 커집니다. 클라이언트가 자주 갱신 요청을 보내야 합니다. 서버 장애 시 임대 만료로 인한 영향이 빨리 나타납니다.\n\n**긴 임대 시간의 장점:**\nDHCP 서버 부하가 줄어듭니다. 네트워크 트래픽이 감소합니다. 서버가 일시적으로 다운되어도 클라이언트는 계속 동작합니다. 안정적인 환경에서 관리가 편리합니다.\n\n**긴 임대 시간의 단점:**\nIP 주소가 오래 묶여 있어 효율성이 떨어집니다. 오프라인 장치의 주소가 임대 만료까지 회수되지 않습니다. 네트워크 설정 변경이 천천히 반영됩니다.\n\n**최적 값 선정 기준:**\n- **사용자 이동성**: 높을수록 짧게 설정\n- **IP 주소 풀 크기**: 부족할수록 짧게 설정\n- **네트워크 안정성**: 안정적일수록 길게 설정\n- **DHCP 서버 성능**: 성능이 좋을수록 짧게 설정 가능\n- **정책 변경 빈도**: 잦을수록 짧게 설정\n\n**갱신 타이밍:**\n클라이언트는 임대 시간의 50%(T1 타이머)가 지나면 갱신을 시도합니다. 임대가 24시간이면 12시간 후 갱신을 요청합니다. 갱신에 실패하면 87.5%(T2 타이머) 시점에 재시도합니다. 최종 만료 전까지 여러 번 기회가 있어 안정적입니다.\n\n**무한 임대:**\n일부 시스템은 무한대(0xFFFFFFFF 초) 임대를 지원하지만 권장되지 않습니다. 네트워크 유연성이 떨어지고 관리가 어려워집니다. 예약(Reservation) 기능을 사용하는 것이 더 적절합니다.\n\n**예약 vs 임대:**\n서버, 프린터 등 고정 IP가 필요한 장치는 DHCP 예약을 사용합니다. 긴 임대 시간 대신 MAC 주소 기반 예약으로 동적 관리의 이점을 유지하면서 일관된 주소를 제공합니다.\n\n**클라이언트 동작:**\n임대가 만료되면 클라이언트는 IP 주소 사용을 중단하고 네트워크 연결이 끊어집니다. 갱신을 놓친 경우 처음부터 DORA 과정을 다시 시작합니다.\n\n**실무 권장사항:**\n대부분의 환경에서 24시간이 적절한 균형점입니다. 특수한 요구사항이 있는 경우에만 조정하며, 너무 짧거나 길게 설정하지 않도록 합니다.\n\n**모니터링:**\nDHCP 로그를 분석하여 주소 풀 사용률과 갱신 패턴을 파악하고, 필요시 임대 시간을 조정합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633066-tx6rdtrr",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "IP 주소는 무엇이며, 어떤 기능을 하고 있나요?",
      "answer": "**IP 주소(Internet Protocol Address)**는 네트워크에 연결된 장치를 고유하게 식별하는 논리적 주소입니다.\n\n**기본 기능:**\nIP 주소의 핵심 기능은 **식별(Identification)**과 **위치 지정(Location Addressing)**입니다. 인터넷 상의 무수히 많은 장치 중 특정 장치를 찾아내고, 그 장치까지 데이터를 전달할 수 있게 합니다.\n\n**식별자 역할:**\n각 장치는 고유한 IP 주소를 가지므로 네트워크에서 구별할 수 있습니다. 마치 집 주소가 특정 건물을 식별하듯이, IP 주소는 특정 컴퓨터나 서버를 식별합니다.\n\n**라우팅 기능:**\nIP 주소는 계층적 구조로 되어 있어 효율적인 라우팅이 가능합니다. 네트워크 부분은 어느 네트워크에 속하는지, 호스트 부분은 그 네트워크 내에서 어느 장치인지를 나타냅니다. 라우터는 네트워크 부분을 보고 패킷을 전달할 방향을 결정합니다.\n\n**IPv4 주소 구조:**\n32비트로 구성되며 일반적으로 점으로 구분된 4개의 십진수로 표현됩니다(예: 192.168.1.100). 각 부분은 0부터 255까지의 값을 가집니다. 이론적으로 약 43억 개의 주소가 가능합니다.\n\n**IPv6 주소 구조:**\n128비트로 구성되며 콜론으로 구분된 8개의 16진수 그룹으로 표현됩니다(예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334). 약 340언데실리언 개의 주소가 가능하여 사실상 무한대입니다.\n\n**주소 클래스:**\n전통적으로 IPv4는 A, B, C, D, E 클래스로 분류되었습니다. 현재는 CIDR(Classless Inter-Domain Routing)로 유연하게 할당합니다.\n\n**공인 IP vs 사설 IP:**\n- **공인 IP**: 인터넷에서 유일하게 식별되는 주소로, ISP가 할당합니다\n- **사설 IP**: 내부 네트워크에서만 사용되는 주소로, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 범위입니다\n\n**특수 IP 주소:**\n- **127.0.0.1**: 루프백 주소로 자기 자신을 가리킵니다\n- **0.0.0.0**: 모든 인터페이스 또는 알 수 없는 주소를 의미합니다\n- **255.255.255.255**: 제한된 브로드캐스트 주소입니다\n- **169.254.x.x**: APIPA로 DHCP 실패 시 자동 할당됩니다\n\n**동적 vs 정적 할당:**\n- **정적 IP**: 수동으로 설정되어 변하지 않습니다. 서버, 네트워크 장비에 사용됩니다\n- **동적 IP**: DHCP로 자동 할당되며 변할 수 있습니다. 일반 사용자 장치에 사용됩니다\n\n**서브넷팅:**\n큰 네트워크를 작은 서브넷으로 나누어 효율적으로 관리합니다. 서브넷 마스크로 네트워크 경계를 정의합니다.\n\n**NAT(Network Address Translation):**\n사설 IP를 공인 IP로 변환하여 제한된 공인 IP 주소를 효율적으로 사용합니다. 가정이나 기업의 여러 장치가 하나의 공인 IP를 공유합니다.\n\n**OSI 모델에서의 위치:**\nIP는 네트워크 계층(3계층) 프로토콜입니다. 데이터링크 계층의 MAC 주소와 함께 사용되어 패킷을 목적지까지 전달합니다.\n\n**실무 활용:**\n웹 사이트 접속, 이메일 전송, 파일 공유 등 모든 네트워크 통신의 기반입니다. 보안, 접근 제어, 트래픽 분석 등에도 활용됩니다.\n\n**IPv4 고갈 문제:**\n인터넷 성장으로 IPv4 주소가 고갈되어 IPv6 전환이 진행 중입니다. NAT, CIDR 등으로 IPv4 수명을 연장하고 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "동기화"
      ],
      "id": "1763437633066-6fmahdez",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?",
      "answer": "IPv4 주소 고갈 문제는 여러 **기술적 해결책**을 통해 완화되고 있습니다.\n\n**NAT(Network Address Translation):**\n가장 효과적인 해결책으로, 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유하도록 합니다. 가정이나 기업에서 수십, 수백 대의 장치가 하나의 공인 IP로 인터넷에 접속합니다. 이를 통해 필요한 공인 IP 수를 대폭 줄였습니다.\n\n**CIDR(Classless Inter-Domain Routing):**\n고정된 클래스 기반 할당에서 벗어나 필요한 만큼만 정확하게 할당합니다. 과거 C 클래스는 256개, B 클래스는 65536개로 비효율적이었지만, CIDR로 32개, 64개 등 필요한 크기로 할당할 수 있습니다. IP 주소 낭비를 크게 줄였습니다.\n\n**IPv6 전환(Dual Stack):**\n많은 시스템이 IPv4와 IPv6를 동시에 지원하는 듀얼 스택으로 운영됩니다. IPv6가 가능한 경우 사용하고, 그렇지 않으면 IPv4로 폴백합니다. 점진적인 전환을 가능하게 합니다.\n\n**주소 재활용:**\n사용되지 않는 IP 주소를 회수하여 재할당합니다. DHCP 임대 시간 관리로 유휴 주소를 신속하게 회수합니다. 기업이 필요 이상으로 보유한 주소 블록을 반납하거나 거래하는 시장도 형성되었습니다.\n\n**Carrier-Grade NAT(CGN):**\nISP 레벨에서 대규모 NAT를 구현합니다. 여러 가정이 하나의 공인 IP를 공유하는 이중 NAT 구조입니다. 추가적인 IP 절약 효과가 있지만 일부 애플리케이션 호환성 문제가 있을 수 있습니다.\n\n**IPv4 주소 거래 시장:**\n사용하지 않는 IPv4 주소 블록을 판매하거나 임대하는 시장이 형성되었습니다. 수요와 공급에 따라 가격이 결정되며, 효율적인 재분배를 촉진합니다.\n\n**Private IP 확대 사용:**\n내부 네트워크는 사설 IP만 사용하고, 외부 통신이 필요한 서비스만 공인 IP를 할당합니다. 대부분의 IoT 기기, 내부 서버는 사설 IP로 충분합니다.\n\n**Load Balancer와 Reverse Proxy:**\n여러 서버가 하나의 공인 IP 주소를 공유하도록 합니다. 대규모 웹 서비스도 소수의 공인 IP로 운영 가능합니다.\n\n**IPv4as(IPv4 as a Service):**\n터널링 기술로 IPv6 네트워크 위에서 IPv4 서비스를 제공합니다. IPv4 주소를 더 효율적으로 공유할 수 있습니다.\n\n**포트 기반 구분:**\nNAT의 포트 포워딩 기능으로 하나의 IP 주소에서 여러 서비스를 제공합니다. 포트 번호로 서로 다른 서버를 구별합니다.\n\n**IPv6 우선 정책:**\n새로운 서비스는 IPv6를 기본으로 설계하고 IPv4는 레거시 지원으로 제공합니다. 클라우드 서비스, CDN 등이 IPv6를 적극 도입하고 있습니다.\n\n**실무 현황:**\n이러한 기술들의 조합으로 IPv4 주소 고갈이 예상보다 심각한 문제가 되지 않았습니다. 하지만 근본적 해결은 IPv6 완전 전환입니다.\n\n**전환의 어려움:**\nIPv6 전환이 느린 이유는 기존 인프라, 애플리케이션, 교육 비용 등의 문제입니다. 하지만 모바일 네트워크를 중심으로 IPv6 채택이 증가하고 있습니다.\n\n**미래 전망:**\n당분간은 IPv4와 IPv6가 공존하며, 위의 기술들로 IPv4를 계속 활용할 것입니다. 장기적으로는 IPv6가 주류가 될 것으로 예상됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-r168nk3m",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "IPv4와 IPv6의 차이에 대해 설명해 주세요.",
      "answer": "**IPv4(Internet Protocol version 4)**와 **IPv6(Internet Protocol version 6)**는 인터넷 프로토콜의 서로 다른 버전으로, 여러 측면에서 차이가 있습니다.\n\n**주소 공간:**\n- **IPv4**: 32비트 주소로 약 43억 개(2^32)의 주소 제공\n- **IPv6**: 128비트 주소로 약 340언데실리언 개(2^128)의 주소 제공, 사실상 무한대\n\n**주소 표현:**\n- **IPv4**: 점으로 구분된 십진수 4개 (예: 192.168.0.1)\n- **IPv6**: 콜론으로 구분된 16진수 8개 (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334)\n- **IPv6 축약**: 연속된 0은 ::로 생략 가능 (예: 2001:db8::1)\n\n**헤더 구조:**\n- **IPv4**: 가변 길이 헤더(20-60 바이트), 12개 필드\n- **IPv6**: 고정 길이 헤더(40 바이트), 8개 필드로 단순화\n- **IPv6 효율성**: 라우터 처리 속도가 향상됩니다\n\n**주소 설정:**\n- **IPv4**: DHCP 또는 수동 설정 필요\n- **IPv6**: SLAAC(Stateless Address Autoconfiguration)로 자동 설정 가능\n- **IPv6 플러그 앤 플레이**: 라우터만 있으면 자동으로 주소 생성\n\n**브로드캐스트:**\n- **IPv4**: 브로드캐스트 지원 (255.255.255.255)\n- **IPv6**: 브로드캐스트 없음, 멀티캐스트로 대체\n- **IPv6 효율성**: 불필요한 트래픽 감소\n\n**Checksum:**\n- **IPv4**: IP 헤더에 checksum 포함\n- **IPv6**: IP 헤더에서 checksum 제거\n- **이유**: 상위/하위 계층에서 이미 검증하므로 중복 제거\n\n**단편화(Fragmentation):**\n- **IPv4**: 라우터가 패킷을 단편화할 수 있음\n- **IPv6**: 송신자만 단편화 가능, 라우터는 불가\n- **Path MTU Discovery**: IPv6는 경로 MTU 발견을 권장\n\n**보안:**\n- **IPv4**: IPsec이 선택사항\n- **IPv6**: IPsec이 표준으로 통합 (초기 설계 목표, 현재는 선택사항)\n- **기본 암호화**: IPv6는 보안을 염두에 두고 설계됨\n\n**NAT 필요성:**\n- **IPv4**: 주소 부족으로 NAT 필수적\n- **IPv6**: 충분한 주소로 NAT 불필요\n- **엔드투엔드 연결**: IPv6는 진정한 엔드투엔드 통신 가능\n\n**QoS 지원:**\n- **IPv4**: ToS(Type of Service) 필드\n- **IPv6**: Traffic Class와 Flow Label로 개선\n- **실시간 트래픽**: IPv6가 더 나은 QoS 제공\n\n**모바일 지원:**\n- **IPv4**: Mobile IP로 복잡한 구현\n- **IPv6**: 모바일 지원이 기본 설계에 포함\n- **이동성**: IPv6가 모바일 환경에 더 적합\n\n**주소 유형:**\n- **IPv4**: 유니캐스트, 브로드캐스트, 멀티캐스트\n- **IPv6**: 유니캐스트, 멀티캐스트, 애니캐스트 (브로드캐스트 없음)\n\n**설정 복잡도:**\n- **IPv4**: 상대적으로 단순하고 익숙함\n- **IPv6**: 초기에는 복잡하지만 자동 설정 기능이 우수\n\n**호환성:**\nIPv4와 IPv6는 호환되지 않습니다. 듀얼 스택, 터널링, 변환 기술로 공존합니다.\n\n**채택 현황:**\n- **IPv4**: 여전히 대부분의 인터넷 트래픽\n- **IPv6**: 모바일 네트워크, 클라우드 서비스를 중심으로 증가 중\n\n**미래:**\nIPv6가 궁극적인 해결책이지만, 완전한 전환에는 수십 년이 걸릴 것으로 예상됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-vif2lwgq",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?",
      "answer": "공유기의 \"고정 IP\" 기능은 실제로는 **DHCP 예약(DHCP Reservation)**을 의미하며, 진정한 고정 IP와는 다릅니다.\n\n**DHCP 예약의 원리:**\n공유기는 특정 MAC 주소에게 항상 같은 IP 주소를 할당하도록 설정할 수 있습니다. 장치가 DHCP 요청을 보내면, 공유기는 MAC 주소를 확인하고 미리 지정된 IP를 할당합니다. 동적 할당의 편리함과 고정 IP의 일관성을 동시에 제공합니다.\n\n**MAC 주소 기반 식별:**\n각 네트워크 장치는 고유한 MAC 주소를 가집니다. 공유기는 이를 기준으로 장치를 구별합니다. 같은 장치가 연결될 때마다 같은 IP를 받게 됩니다.\n\n**내부 네트워크 vs 외부 네트워크:**\n공유기가 제공하는 \"고정 IP\"는 내부 네트워크(사설 IP)에서만 유효합니다. 외부 인터넷에서 보는 IP는 ISP가 제공하는 공인 IP로, 여전히 유동적일 수 있습니다. 공유기 뒤의 모든 장치는 NAT를 통해 하나의 공인 IP를 공유합니다.\n\n**진정한 고정 IP와의 차이:**\n- **DHCP 예약**: 동적 프로토콜을 사용하지만 결과가 일정함\n- **정적 IP**: 장치에 직접 설정하여 DHCP를 거치지 않음\n- **DHCP 예약의 장점**: 중앙에서 관리하고 변경이 쉬움\n\n**설정 방법:**\n관리자가 공유기 관리 페이지에서 MAC 주소와 원하는 IP 주소를 매핑합니다. 예: MAC 주소 AA:BB:CC:DD:EE:FF는 항상 192.168.1.100을 받도록 설정합니다.\n\n**왜 DHCP 예약을 사용하나:**\n장치에 직접 정적 IP를 설정하면 관리가 어렵습니다. 네트워크 설정이 바뀌면 모든 장치를 일일이 수정해야 합니다. DHCP 예약은 공유기에서만 변경하면 되므로 관리가 편리합니다.\n\n**활용 사례:**\n- **네트워크 프린터**: 항상 같은 주소로 접근 가능\n- **NAS(Network Attached Storage)**: 파일 공유 경로가 일정함\n- **서버**: 포트 포워딩 설정이 유지됨\n- **스마트 홈 기기**: 앱에서 고정 주소로 제어\n\n**IP 주소 풀 관리:**\n공유기는 IP 주소 범위를 예약용과 동적 할당용으로 나눕니다. 예: 192.168.1.2-100은 동적 할당, 192.168.1.101-200은 예약용으로 사용합니다.\n\n**충돌 방지:**\nDHCP 예약으로 할당된 주소는 다른 장치에게 동적으로 할당되지 않습니다. 공유기가 주소 풀을 관리하여 충돌을 방지합니다.\n\n**재연결 시 동작:**\n장치가 네트워크를 떠났다가 다시 연결되어도 같은 IP를 받습니다. 임대가 만료되어도 갱신 시 같은 주소가 할당됩니다.\n\n**외부 접근의 제한:**\n내부 고정 IP만으로는 인터넷에서 접근할 수 없습니다. 외부 접근이 필요하면 포트 포워딩과 DDNS를 추가로 설정해야 합니다. ISP의 공인 IP가 변경되면 DDNS가 자동으로 업데이트합니다.\n\n**DDNS(Dynamic DNS):**\n유동 공인 IP 환경에서 도메인 이름을 자동으로 업데이트하는 서비스입니다. 공유기가 공인 IP 변경을 감지하면 DDNS 서버에 알립니다. 외부에서 도메인 이름으로 접속 가능합니다.\n\n**실무 권장사항:**\n일반 사용자 기기는 동적 할당으로 충분하지만, 서버 역할을 하는 장치는 DHCP 예약을 설정하는 것이 좋습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-trqmpy58",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?",
      "answer": "IPv4와 IPv6는 **기본적으로 호환되지 않지만**, 여러 **전환 기술**을 통해 통신이 가능합니다.\n\n**기본적인 비호환성:**\nIPv4와 IPv6는 완전히 다른 프로토콜입니다. 주소 체계, 헤더 구조, 패킷 형식이 다르므로 직접 통신할 수 없습니다. IPv4 전용 장비는 IPv6 패킷을 이해하지 못하고, 그 반대도 마찬가지입니다.\n\n**듀얼 스택(Dual Stack):**\n가장 일반적인 방법으로, 장비가 IPv4와 IPv6를 동시에 지원합니다. 하나의 인터페이스에 IPv4 주소와 IPv6 주소를 모두 할당합니다. 상대방이 지원하는 프로토콜에 따라 자동으로 선택합니다. 현대 운영체제와 라우터는 대부분 듀얼 스택을 지원합니다.\n\n**듀얼 스택 동작 방식:**\nDNS 조회 시 A 레코드(IPv4)와 AAAA 레코드(IPv6)를 모두 요청합니다. 양쪽 모두 사용 가능하면 일반적으로 IPv6를 우선합니다. 한쪽만 가능하면 해당 프로토콜을 사용합니다. Happy Eyeballs 알고리즘으로 빠른 연결을 선택합니다.\n\n**터널링(Tunneling):**\n한 프로토콜의 패킷을 다른 프로토콜 패킷 안에 캡슐화하여 전송합니다. IPv6 패킷을 IPv4 네트워크를 통해 전달하거나 그 반대가 가능합니다.\n\n**6to4 터널링:**\nIPv6 주소를 IPv4 주소에 매핑하여 IPv4 인프라를 통해 IPv6 패킷을 전송합니다. IPv6 주소의 일부에 IPv4 주소를 포함시킵니다. 특별한 중계 라우터 없이 자동으로 구성됩니다.\n\n**6in4 터널:**\nIPv6 패킷을 IPv4 패킷의 페이로드로 캡슐화합니다. 수동 설정이 필요하지만 안정적입니다. 터널 엔드포인트에서 캡슐화와 역캡슐화를 수행합니다.\n\n**Teredo:**\nNAT 뒤의 IPv6 호스트가 IPv4 인터넷을 통해 통신할 수 있게 합니다. UDP를 사용하여 IPv6 패킷을 전송합니다. Windows에 기본 내장되어 있습니다.\n\n**ISATAP(Intra-Site Automatic Tunnel Addressing Protocol):**\n기업 내부 네트워크에서 IPv4 인프라 위에 IPv6를 배포합니다. 가상 IPv6 링크를 IPv4 네트워크 위에 생성합니다.\n\n**NAT64:**\nIPv6 전용 클라이언트가 IPv4 전용 서버와 통신할 수 있게 합니다. 네트워크 계층에서 IPv6 주소를 IPv4 주소로 변환합니다. 상태 저장(Stateful) 또는 상태 비저장(Stateless) 방식이 있습니다.\n\n**DNS64:**\nNAT64와 함께 사용되어 IPv4 주소를 IPv6 주소로 변환합니다. IPv4 전용 서버의 A 레코드를 AAAA 레코드로 변환합니다. IPv6 클라이언트는 IPv4 서버를 인식하지 못한 채 통신합니다.\n\n**프록시(Proxy):**\n애플리케이션 레벨에서 프로토콜을 변환합니다. 프록시 서버가 양쪽 프로토콜을 모두 지원하여 중계합니다. HTTP 프록시, SOCKS 프록시 등이 사용됩니다.\n\n**Translation 게이트웨이:**\n네트워크 경계에서 패킷 헤더를 변환합니다. NAT-PT(Network Address Translation - Protocol Translation)가 대표적이지만 현재는 권장되지 않습니다.\n\n**실무 선택:**\n- **새로운 네트워크**: 듀얼 스택 권장\n- **레거시 시스템 많음**: 터널링 사용\n- **IPv6 전용 네트워크**: NAT64/DNS64 사용\n- **임시 해결책**: 프록시 또는 게이트웨이\n\n**성능 고려사항:**\n터널링과 변환은 오버헤드를 발생시킵니다. 가능하면 듀얼 스택으로 네이티브 통신이 최선입니다.\n\n**미래 방향:**\n장기적으로는 IPv6 완전 전환이 목표이지만, 당분간은 이러한 전환 기술들이 필수적입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-mppjhv5v",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?",
      "answer": "아니요, **IP 프로토콜 자체는 신뢰성을 보장하지 않습니다**. IP는 최선형 전달(Best Effort Delivery) 방식을 사용합니다.\n\n**Best Effort의 의미:**\nIP는 패킷을 목적지까지 전달하기 위해 최선을 다하지만, 성공을 보장하지는 않습니다. 패킷이 손실되거나, 순서가 바뀌거나, 중복되거나, 손상될 수 있습니다. 이러한 문제들을 감지하거나 복구하는 메커니즘이 없습니다.\n\n**발생 가능한 문제들:**\n- **패킷 손실**: 네트워크 혼잡, 버퍼 오버플로우, 물리적 오류로 패킷이 사라집니다\n- **순서 변경**: 서로 다른 경로로 전송되어 순서가 바뀔 수 있습니다\n- **중복**: 네트워크 장비 오류로 같은 패킷이 여러 번 전달될 수 있습니다\n- **손상**: 전송 중 비트 오류가 발생할 수 있습니다\n- **지연**: 도착 시간이 보장되지 않습니다\n\n**IP의 역할:**\nIP는 라우팅과 주소 지정만 담당합니다. 송신자와 수신자를 식별하고, 네트워크 간 패킷을 전달하는 경로를 찾습니다. 전달의 성공 여부는 상위 계층(전송 계층)의 책임입니다.\n\n**왜 신뢰성을 제공하지 않나:**\n네트워크 계층을 단순하고 빠르게 유지하기 위함입니다. 신뢰성 메커니즘은 복잡하고 오버헤드가 크므로, 필요한 애플리케이션만 상위 계층에서 구현하는 것이 효율적입니다. 실시간 스트리밍 같은 애플리케이션은 신뢰성보다 속도가 중요합니다.\n\n**계층적 설계 철학:**\nOSI 모델의 계층적 접근에 따라, 각 계층은 특정 책임만 가집니다. IP는 주소 지정과 라우팅, TCP/UDP는 전송 제어, 애플리케이션은 비즈니스 로직을 담당합니다. 이러한 분리로 유연성과 확장성이 향상됩니다.\n\n**TCP의 보완:**\n신뢰성이 필요한 애플리케이션은 TCP를 사용합니다. TCP는 IP 위에서 순서 보장, 재전송, 흐름 제어, 혼잡 제어를 구현합니다. IP의 비신뢰적 전달을 TCP가 신뢰적으로 변환합니다.\n\n**UDP의 선택:**\n신뢰성이 불필요한 애플리케이션은 UDP를 사용합니다. UDP도 IP처럼 최선형 전달이지만 포트 번호와 간단한 checksum을 추가합니다. 실시간 영상, 음성, 게임 등이 해당됩니다.\n\n**IP Checksum의 한계:**\nIPv4는 헤더에 checksum을 가지지만, 이는 헤더의 무결성만 확인합니다. 데이터 부분은 검증하지 않으며, 오류를 발견해도 복구하지 않고 폐기만 합니다.\n\n**라우팅 불확실성:**\n인터넷은 동적으로 변하는 네트워크입니다. 라우팅 테이블이 불완전하거나 업데이트 중이면 패킷이 목적지에 도달하지 못할 수 있습니다. TTL이 0이 되면 패킷이 폐기됩니다.\n\n**실제 신뢰성:**\n실무에서는 현대 네트워크의 품질이 좋아 IP 패킷의 대부분이 성공적으로 전달됩니다. 하지만 완벽하지 않으므로 중요한 데이터는 반드시 TCP를 사용해야 합니다.\n\n**엔드투엔드 원칙:**\n네트워크 설계의 기본 원칙으로, 신뢰성 같은 고급 기능은 네트워크 내부가 아닌 엔드포인트에서 구현되어야 합니다. 이를 통해 네트워크는 단순하고, 다양한 요구사항에 유연하게 대응할 수 있습니다.\n\n**ICMP의 역할:**\nIP는 오류 보고를 위해 ICMP를 사용합니다. 패킷 전달 실패 시 ICMP 메시지로 송신자에게 알리지만, 이마저도 보장되지 않습니다.\n\n**결론:**\nIP는 의도적으로 신뢰성을 제공하지 않으며, 이는 설계 철학의 일부입니다. 신뢰성이 필요한 경우 TCP를 사용하고, 불필요한 경우 UDP를 사용하는 것이 올바른 접근입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "가상메모리"
      ],
      "id": "1763437633066-rixhji9s",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?",
      "answer": "IPv4와 TCP의 checksum은 **검증 범위와 목적**에서 차이가 있습니다.\n\n**검증 범위의 차이:**\n- **IPv4 Checksum**: IP 헤더만 검증합니다. 20-60 바이트의 헤더 정보만 대상입니다. 데이터 부분(페이로드)은 검증하지 않습니다\n- **TCP Checksum**: TCP 헤더와 데이터 전체를 검증합니다. pseudo-header, TCP 헤더, 전체 페이로드를 포함합니다\n\n**Pseudo-Header:**\nTCP checksum 계산 시 IP 계층의 일부 정보를 포함한 가상 헤더를 사용합니다. 송신자 IP 주소, 수신자 IP 주소, 프로토콜 번호, TCP 세그먼트 길이가 포함됩니다. 이를 통해 잘못된 목적지로의 전달을 감지할 수 있습니다.\n\n**목적의 차이:**\n- **IPv4**: 라우팅 중 헤더 손상을 감지하여 잘못된 목적지로 전달되는 것을 방지합니다. TTL, 주소 등의 헤더 필드가 올바른지 확인합니다\n- **TCP**: 엔드투엔드 데이터 무결성을 보장합니다. 전송된 데이터가 손상되지 않았음을 확인합니다\n\n**계층적 책임:**\n- **IPv4**: 네트워크 계층으로, 패킷 전달 과정의 무결성을 담당합니다\n- **TCP**: 전송 계층으로, 전체 통신의 엔드투엔드 무결성을 담당합니다\n\n**처리 위치:**\n- **IPv4 Checksum**: 모든 라우터가 패킷을 받을 때마다 재계산합니다. TTL이 변경되므로 checksum도 업데이트됩니다\n- **TCP Checksum**: 송신자와 수신자(엔드포인트)만 계산합니다. 중간 라우터는 TCP checksum을 확인하거나 변경하지 않습니다\n\n**재계산 필요성:**\n- **IPv4**: 라우터가 TTL을 감소시키므로 매 홉마다 checksum 재계산이 필요합니다\n- **TCP**: 세그먼트가 변경되지 않으므로 재계산이 불필요합니다\n\n**오류 발견 시 동작:**\n- **IPv4**: Checksum 오류가 발견되면 패킷을 즉시 폐기합니다. ICMP 메시지를 보낼 수도 있지만 보장되지 않습니다\n- **TCP**: Checksum 오류가 발견되면 세그먼트를 폐기하고, ACK를 보내지 않아 재전송을 유도합니다\n\n**IPv6에서의 변화:**\nIPv6는 IP 헤더에서 checksum을 완전히 제거했습니다. 상위 계층(TCP/UDP)과 하위 계층(이더넷)에서 이미 검증하므로 중복이라고 판단했습니다. 라우터 처리 성능이 향상되었습니다.\n\n**필수 여부:**\n- **IPv4 Checksum**: 필수입니다. 모든 IPv4 패킷은 올바른 checksum을 가져야 합니다\n- **TCP Checksum**: 필수입니다. TCP 세그먼트는 항상 checksum을 계산하고 검증합니다\n\n**계산 알고리즘:**\n둘 다 16비트 1의 보수 합을 사용하는 동일한 알고리즘입니다. 하지만 계산 대상 데이터가 다릅니다.\n\n**하드웨어 오프로딩:**\n현대 네트워크 카드는 TCP checksum을 하드웨어로 계산하여 CPU 부담을 줄입니다. IPv4 checksum은 라우터의 ASIC이나 NPU에서 처리합니다.\n\n**실무적 의미:**\nIPv4 checksum은 라우팅 무결성을, TCP checksum은 데이터 무결성을 보장합니다. 계층별로 적절한 검증을 수행하여 전체 통신의 신뢰성을 확보합니다.\n\n**다중 검증의 장점:**\n여러 계층에서 독립적으로 검증하므로 오류 감지율이 높아집니다. 한 계층에서 놓친 오류를 다른 계층에서 발견할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-4l5clbq6",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "TTL(Hop Limit)이란 무엇인가요?",
      "answer": "**TTL(Time To Live)**은 패킷이 네트워크에서 무한정 순환하는 것을 방지하기 위한 메커니즘입니다.\n\n**기본 개념:**\nTTL은 패킷이 거쳐갈 수 있는 최대 라우터(홉) 수를 나타냅니다. 송신자가 초기값을 설정하면, 패킷이 라우터를 통과할 때마다 1씩 감소합니다. TTL이 0이 되면 라우터는 패킷을 폐기하고 ICMP Time Exceeded 메시지를 송신자에게 보냅니다.\n\n**왜 필요한가:**\n라우팅 루프가 발생하면 패킷이 무한히 순환할 수 있습니다. 라우팅 테이블 오류, 네트워크 장애, 설정 실수 등으로 발생합니다. TTL이 없다면 이러한 패킷들이 네트워크 대역폭을 계속 소모하여 네트워크 마비를 일으킬 수 있습니다.\n\n**라우팅 루프의 예:**\n라우터 A가 목적지로 가려면 라우터 B를 거쳐야 하고, 라우터 B는 다시 라우터 A를 거쳐야 한다고 잘못 설정된 경우입니다. 패킷이 A와 B 사이를 무한히 왕복하게 됩니다.\n\n**초기 TTL 값:**\n운영체제마다 기본값이 다릅니다:\n- **Linux**: 64\n- **Windows**: 128\n- **Cisco 라우터**: 255\n- **일부 Unix**: 255\n\n**동작 과정:**\n1. 송신자가 TTL을 64로 설정하여 패킷을 보냅니다\n2. 첫 번째 라우터가 받아서 TTL을 63으로 감소시키고 전달합니다\n3. 각 라우터가 이를 반복합니다\n4. TTL이 1인 패킷을 받은 라우터는 0으로 감소시키고 폐기합니다\n5. 송신자에게 ICMP Time Exceeded를 보냅니다\n\n**IPv6의 Hop Limit:**\nIPv6에서는 TTL 대신 Hop Limit이라는 용어를 사용합니다. 기능은 동일하지만 이름이 더 정확합니다. \"시간\"이 아닌 \"홉 수\"를 제한하기 때문입니다.\n\n**TTL의 또 다른 용도 - Traceroute:**\ntraceroute 명령은 TTL을 활용합니다. TTL을 1, 2, 3... 순으로 증가시키며 패킷을 보냅니다. 각 라우터에서 Time Exceeded 메시지를 받아 경로를 파악합니다. 목적지까지의 모든 라우터를 순서대로 확인할 수 있습니다.\n\n**보안적 활용:**\nTTL 값으로 운영체제를 식별할 수 있습니다(OS Fingerprinting). 초기값이 64면 Linux, 128이면 Windows일 가능성이 높습니다. 현재 TTL로 거쳐온 홉 수를 추정할 수 있습니다.\n\n**적절한 TTL 선정:**\n너무 작으면 정상 패킷도 목적지에 도달하지 못합니다. 인터넷에서 가장 먼 거리도 30홉 이내이므로 64면 충분합니다. 너무 크면 루프 패킷이 오래 순환하여 자원을 낭비합니다.\n\n**TTL과 캐시:**\nDNS, CDN 등에서 TTL은 다른 의미로 사용됩니다. 캐시된 데이터가 유효한 시간(초 단위)을 나타냅니다. 같은 용어지만 문맥에 따라 의미가 다릅니다.\n\n**Checksum 재계산:**\nTTL이 변경되면 IPv4 헤더 checksum도 재계산해야 합니다. 모든 라우터가 매 홉마다 수행하므로 처리 오버헤드가 있습니다. IPv6가 checksum을 제거한 이유 중 하나입니다.\n\n**ICMP Time Exceeded 메시지:**\nTTL 만료 시 라우터는 송신자에게 알립니다. ICMP 타입 11, 코드 0(TTL exceeded in transit)입니다. 송신자는 이를 통해 라우팅 문제를 인식할 수 있습니다.\n\n**실무 사례:**\n네트워크 장애 시 라우팅 루프가 발생하면 대량의 ICMP Time Exceeded 메시지가 생성됩니다. 이를 모니터링하여 라우팅 문제를 조기에 발견할 수 있습니다.\n\n**제한값:**\nTTL은 8비트 필드이므로 최대값은 255입니다. 실제로 255홉을 거쳐야 하는 경우는 거의 없습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633066-r4tmqfo4",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.",
      "answer": "**IP 주소**와 **MAC 주소**는 서로 다른 계층에서 동작하는 주소 체계로, 역할과 특성이 다릅니다.\n\n**계층적 차이:**\n- **MAC 주소**: 데이터링크 계층(2계층)에서 사용하는 물리 주소입니다\n- **IP 주소**: 네트워크 계층(3계층)에서 사용하는 논리 주소입니다\n\n**주소 구조:**\n- **MAC 주소**: 48비트(6바이트)로 16진수 12자리입니다. 예: AA:BB:CC:DD:EE:FF 또는 AA-BB-CC-DD-EE-FF\n- **IP 주소**: IPv4는 32비트, IPv6는 128비트입니다. 예: 192.168.1.1 또는 2001:db8::1\n\n**고유성과 범위:**\n- **MAC 주소**: 전 세계적으로 고유합니다. 제조사가 하드웨어에 영구적으로 부여합니다(일부 예외 존재)\n- **IP 주소**: 네트워크 내에서 고유하지만, 사설 IP는 여러 네트워크에서 중복 사용됩니다\n\n**변경 가능성:**\n- **MAC 주소**: 하드웨어에 고정되어 있습니다(물리적 주소). 소프트웨어로 변경 가능하지만 일반적이지 않습니다\n- **IP 주소**: 쉽게 변경 가능합니다(논리적 주소). DHCP로 자동 할당받거나 수동 설정합니다\n\n**용도:**\n- **MAC 주소**: 같은 네트워크(브로드캐스트 도메인) 내에서 프레임을 전달하는 데 사용합니다\n- **IP 주소**: 서로 다른 네트워크 간에 패킷을 라우팅하는 데 사용합니다\n\n**작동 범위:**\n- **MAC 주소**: 로컬 네트워크 세그먼트 내에서만 유효합니다. 라우터를 넘어가면 MAC 주소가 변경됩니다\n- **IP 주소**: 엔드투엔드로 변경되지 않고 유지됩니다. 송신지에서 목적지까지 동일합니다\n\n**주소 지정 방식:**\n- **MAC 주소**: 플랫(Flat) 주소 체계로 계층 구조가 없습니다. 앞 24비트는 제조사 식별(OUI), 뒤 24비트는 일련번호입니다\n- **IP 주소**: 계층적(Hierarchical) 주소 체계로 네트워크 부분과 호스트 부분으로 나뉩니다\n\n**ARP의 역할:**\nIP 주소를 알고 있을 때 MAC 주소를 찾기 위해 ARP(Address Resolution Protocol)를 사용합니다. \"이 IP 주소를 가진 장치의 MAC 주소는 무엇인가\"라고 브로드캐스트로 질의합니다.\n\n**패킷 전달 과정:**\n1. 송신자는 목적지 IP 주소를 알고 있습니다\n2. 같은 네트워크면 ARP로 목적지 MAC 주소를 찾습니다\n3. 다른 네트워크면 게이트웨이의 MAC 주소를 찾습니다\n4. 이더넷 프레임에 목적지 MAC과 IP를 모두 포함하여 전송합니다\n5. 각 라우터는 IP 주소를 보고 라우팅하며, MAC 주소는 홉마다 변경합니다\n\n**비유:**\n- **IP 주소**: 우편 주소(예: 서울시 강남구 테헤란로 123)로, 어디로 가야 하는지를 나타냅니다\n- **MAC 주소**: 주민등록번호로, 사람(장치)을 고유하게 식별합니다\n- **패킷 전달**: 우편배달부가 주소를 보고 배달하지만, 각 우체국마다 다음 우체국 주소로 바꿔 씁니다\n\n**보안 측면:**\n- **MAC 주소**: MAC 필터링으로 네트워크 접근을 제어할 수 있지만, 스푸핑이 가능합니다\n- **IP 주소**: 방화벽, ACL로 트래픽을 제어합니다. IP 스푸핑도 가능하지만 응답을 받기 어렵습니다\n\n**유니캐스트, 브로드캐스트, 멀티캐스트:**\n두 주소 체계 모두 이러한 통신 방식을 지원하지만 표현 방법이 다릅니다.\n\n**실무적 중요성:**\n네트워크 문제 해결 시 두 주소의 관계를 이해해야 합니다. ARP 테이블, 라우팅 테이블, MAC 주소 테이블(스위치) 등을 확인하여 진단합니다.\n\n**결론:**\nIP 주소는 \"어디로\"를, MAC 주소는 \"누구에게\"를 나타냅니다. 두 주소가 협력하여 완전한 통신을 가능하게 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633066-yu9agn68",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "OSI 7계층에 대해 설명해 주세요.",
      "answer": "**OSI 7계층 모델(Open Systems Interconnection Model)**은 네트워크 통신을 7개의 추상 계층으로 나눈 표준 모델입니다.\n\n**1계층 - 물리 계층(Physical Layer):**\n비트 스트림을 전기 신호, 광 신호, 전파로 변환하여 물리적 매체를 통해 전송합니다. 케이블, 허브, 리피터, 네트워크 카드의 물리적 특성을 다룹니다. 전압 레벨, 타이밍, 물리적 커넥터 등을 정의합니다. 오류 감지나 수정 기능은 없으며 단순히 신호만 전달합니다.\n\n**2계층 - 데이터링크 계층(Data Link Layer):**\n같은 네트워크 내에서 노드 간 신뢰성 있는 프레임 전송을 담당합니다. MAC 주소를 사용하여 장치를 식별합니다. 오류 검출과 수정, 흐름 제어를 수행합니다. 이더넷, Wi-Fi, PPP 프로토콜이 동작하는 계층입니다. 스위치와 브리지가 이 계층에서 동작합니다.\n\n**3계층 - 네트워크 계층(Network Layer):**\n서로 다른 네트워크 간 패킷을 라우팅합니다. IP 주소를 사용하여 논리적 주소 지정을 합니다. 최적의 경로를 선택하고 패킷을 전달합니다. IP, ICMP, 라우팅 프로토콜(OSPF, BGP)이 동작합니다. 라우터가 이 계층에서 동작합니다.\n\n**4계층 - 전송 계층(Transport Layer):**\n엔드투엔드 통신을 제공하고 데이터 전송의 신뢰성을 보장합니다. 포트 번호로 애플리케이션을 식별합니다. 세그먼트 단위로 데이터를 나누고 재조립합니다. TCP(신뢰성)와 UDP(빠른 전송) 프로토콜이 있습니다. 흐름 제어, 혼잡 제어, 오류 복구를 수행합니다.\n\n**5계층 - 세션 계층(Session Layer):**\n통신 세션을 설정, 유지, 종료합니다. 대화 제어(Dialog Control)와 동기화를 관리합니다. 체크포인트와 복구 메커니즘을 제공합니다. 실무에서는 애플리케이션 계층에 통합되는 경우가 많습니다. RPC, NetBIOS 등이 이 계층에 해당합니다.\n\n**6계층 - 표현 계층(Presentation Layer):**\n데이터의 형식을 변환하고 암호화/복호화를 수행합니다. 서로 다른 시스템 간 데이터 표현 방식을 통일합니다. 문자 인코딩(ASCII, UTF-8), 압축, 암호화(SSL/TLS)를 담당합니다. JPEG, MPEG, ASCII 등의 형식을 다룹니다.\n\n**7계층 - 애플리케이션 계층(Application Layer):**\n사용자와 가장 가까운 계층으로 실제 애플리케이션 서비스를 제공합니다. HTTP, FTP, SMTP, DNS, SSH 등의 프로토콜이 동작합니다. 사용자 인터페이스와 직접 상호작용합니다. 웹 브라우저, 이메일 클라이언트 등이 이 계층에서 동작합니다.\n\n**캡슐화(Encapsulation):**\n데이터가 하위 계층으로 내려갈 때마다 해당 계층의 헤더가 추가됩니다. 각 계층은 자신의 헤더만 처리하고 나머지는 페이로드로 간주합니다. 수신 측에서는 역순으로 헤더를 제거하며 올라갑니다(역캡슐화).\n\n**계층별 데이터 단위:**\n- **물리 계층**: 비트(Bit)\n- **데이터링크 계층**: 프레임(Frame)\n- **네트워크 계층**: 패킷(Packet)\n- **전송 계층**: 세그먼트(Segment) 또는 데이터그램(Datagram)\n- **세션/표현/애플리케이션**: 데이터(Data) 또는 메시지(Message)\n\n**OSI 모델의 장점:**\n계층별로 독립적인 개발이 가능합니다. 특정 계층의 변경이 다른 계층에 영향을 주지 않습니다. 표준화된 인터페이스로 상호운용성이 향상됩니다. 네트워크 문제 해결 시 계층별로 분리하여 진단할 수 있습니다.\n\n**TCP/IP 모델과의 차이:**\n실무에서는 OSI 7계층보다 TCP/IP 4계층 모델을 더 많이 사용합니다. TCP/IP는 네트워크 인터페이스, 인터넷, 전송, 애플리케이션의 4계층으로 구성됩니다. OSI는 이론적 모델, TCP/IP는 실용적 모델입니다.\n\n**실무 활용:**\n네트워크 교육과 표준화에 OSI 모델을 사용합니다. 문제 해결 시 \"3계층 문제\"처럼 계층별로 분류합니다. 각 계층의 역할을 이해하면 복잡한 네트워크를 체계적으로 파악할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "캐시"
      ],
      "id": "1763437633066-d01j27gc",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.",
      "answer": "**전송 계층(Transport Layer)**과 **네트워크 계층(Network Layer)**은 OSI 모델에서 서로 다른 역할과 책임을 가진 계층입니다.\n\n**기본 역할:**\n- **네트워크 계층**: 서로 다른 네트워크 간 패킷을 라우팅하고 전달합니다\n- **전송 계층**: 엔드포인트 간 데이터 전송의 신뢰성과 순서를 보장합니다\n\n**주소 지정:**\n- **네트워크 계층**: IP 주소를 사용하여 호스트를 식별합니다\n- **전송 계층**: 포트 번호를 사용하여 호스트 내의 특정 프로세스나 서비스를 식별합니다\n\n**통신 범위:**\n- **네트워크 계층**: 호스트 대 호스트(Host-to-Host) 통신을 제공합니다\n- **전송 계층**: 프로세스 대 프로세스(Process-to-Process) 통신을 제공합니다\n\n**신뢰성:**\n- **네트워크 계층**: IP는 최선형 전달(Best Effort)로 신뢰성을 보장하지 않습니다\n- **전송 계층**: TCP는 신뢰성 있는 전송을, UDP는 빠른 전송을 제공합니다\n\n**라우팅 vs 전송 제어:**\n- **네트워크 계층**: 패킷이 목적지까지 가는 경로를 결정합니다. 라우팅 테이블과 알고리즘을 사용합니다\n- **전송 계층**: 데이터가 올바르게 전달되도록 제어합니다. 재전송, 순서 보장, 흐름 제어를 수행합니다\n\n**처리 위치:**\n- **네트워크 계층**: 모든 라우터와 호스트에서 처리됩니다. 중간 노드가 패킷을 검사하고 전달합니다\n- **전송 계층**: 엔드포인트(송신자와 수신자)에서만 처리됩니다. 중간 라우터는 전송 계층을 보지 않습니다\n\n**프로토콜:**\n- **네트워크 계층**: IP, ICMP, IGMP, 라우팅 프로토콜(OSPF, BGP)\n- **전송 계층**: TCP, UDP, SCTP, DCCP\n\n**데이터 단위:**\n- **네트워크 계층**: 패킷(Packet) 또는 데이터그램(Datagram)\n- **전송 계층**: 세그먼트(Segment - TCP) 또는 데이터그램(Datagram - UDP)\n\n**흐름 제어와 혼잡 제어:**\n- **네트워크 계층**: 혼잡 제어를 직접 수행하지 않지만, ICMP로 혼잡을 알립니다\n- **전송 계층**: TCP가 흐름 제어와 혼잡 제어를 적극적으로 수행합니다\n\n**멀티플렉싱:**\n- **네트워크 계층**: 여러 상위 프로토콜(TCP, UDP, ICMP)의 패킷을 IP 패킷에 캡슐화합니다\n- **전송 계층**: 여러 애플리케이션의 데이터를 포트 번호로 구분하여 멀티플렉싱/디멀티플렉싱합니다\n\n**세그먼테이션:**\n- **네트워크 계층**: 큰 패킷을 MTU에 맞게 단편화(Fragmentation)합니다\n- **전송 계층**: 애플리케이션 데이터를 MSS에 맞게 세그먼트로 나눕니다\n\n**오류 처리:**\n- **네트워크 계층**: 오류를 감지하고 패킷을 폐기하지만 복구하지 않습니다\n- **전송 계층**: TCP는 오류를 감지하고 재전송으로 복구합니다\n\n**엔드투엔드 원칙:**\n- **네트워크 계층**: 홉바이홉(Hop-by-Hop) 처리로 각 라우터가 패킷을 개별적으로 처리합니다\n- **전송 계층**: 엔드투엔드(End-to-End) 원칙으로 송신자와 수신자 간 직접 제어합니다\n\n**실무 예시:**\n웹 페이지를 요청할 때, 네트워크 계층(IP)은 서버까지 패킷을 전달하고, 전송 계층(TCP)은 웹 서버의 80번 포트와 통신하여 완전한 HTML 파일을 신뢰성 있게 받습니다.\n\n**계층 간 협력:**\n두 계층은 독립적이지만 협력합니다. 전송 계층은 네트워크 계층의 서비스를 이용하고, 네트워크 계층은 전송 계층에게 기본 전달 서비스를 제공합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-dj5ndj45",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "L3 Switch와 Router의 차이에 대해 설명해 주세요.",
      "answer": "**L3 스위치(Layer 3 Switch)**와 **라우터(Router)**는 모두 네트워크 계층에서 동작하지만, 설계 목적과 특성에서 차이가 있습니다.\n\n**기본 정의:**\n- **라우터**: 서로 다른 네트워크 간 패킷을 라우팅하는 전용 장비입니다\n- **L3 스위치**: 스위칭 기능에 라우팅 기능을 추가한 하이브리드 장비입니다\n\n**주요 목적:**\n- **라우터**: WAN 연결, 인터넷 게이트웨이, 복잡한 라우팅 정책 구현\n- **L3 스위치**: LAN 내부의 고속 라우팅, VLAN 간 통신\n\n**처리 방식:**\n- **라우터**: 소프트웨어 기반 라우팅으로 유연하지만 상대적으로 느립니다\n- **L3 스위치**: ASIC(Application-Specific Integrated Circuit) 하드웨어로 고속 처리합니다\n\n**성능:**\n- **라우터**: 패킷당 처리(Packet-by-Packet), 상대적으로 낮은 처리량\n- **L3 스위치**: 와이어 스피드(Wire Speed) 처리, 매우 높은 처리량\n\n**포트 수와 밀도:**\n- **라우터**: 일반적으로 적은 수의 포트(수개~수십 개)\n- **L3 스위치**: 많은 수의 포트(24, 48, 수백 개)로 고밀도 연결\n\n**라우팅 프로토콜 지원:**\n- **라우터**: BGP, OSPF, EIGRP, RIP 등 모든 라우팅 프로토콜을 완벽하게 지원합니다\n- **L3 스위치**: 기본적인 라우팅 프로토콜은 지원하지만, 복잡한 기능은 제한적일 수 있습니다\n\n**WAN 인터페이스:**\n- **라우터**: 시리얼, T1/E1, DSL, 광 WAN 등 다양한 WAN 인터페이스 지원\n- **L3 스위치**: 주로 이더넷 인터페이스만 지원하며, WAN 기능은 제한적입니다\n\n**NAT와 방화벽:**\n- **라우터**: NAT, 방화벽, VPN, QoS 등 고급 기능을 풍부하게 제공합니다\n- **L3 스위치**: 기본적인 ACL은 지원하지만, 고급 보안 기능은 제한적입니다\n\n**QoS(Quality of Service):**\n- **라우터**: 복잡한 QoS 정책, 트래픽 쉐이핑, 대역폭 관리\n- **L3 스위치**: 기본적인 QoS(우선순위, VLAN 기반) 지원\n\n**VLAN 지원:**\n- **라우터**: VLAN 간 라우팅은 가능하지만 VLAN 생성과 관리는 제한적입니다\n- **L3 스위치**: VLAN 생성, 관리, VLAN 간 라우팅이 주요 기능입니다\n\n**가격:**\n- **라우터**: 기능과 성능에 따라 다양하지만, 동급 성능 대비 L3 스위치보다 비쌉니다\n- **L3 스위치**: 대량 생산으로 포트당 가격이 저렴합니다\n\n**라우팅 테이블 크기:**\n- **라우터**: 수백만 개의 라우팅 엔트리를 처리할 수 있습니다(인터넷 전체 라우팅 테이블)\n- **L3 스위치**: 일반적으로 수천~수만 개의 엔트리로 제한됩니다\n\n**사용 위치:**\n- **라우터**: 네트워크 경계(인터넷 연결), 지사 간 연결, ISP 백본\n- **L3 스위치**: 데이터센터, 기업 코어/분산 레이어, 캠퍼스 네트워크\n\n**멀티캐스트:**\n- **라우터**: PIM, IGMP 등 고급 멀티캐스트 라우팅 지원\n- **L3 스위치**: 기본적인 IGMP 스누핑, 제한적인 멀티캐스트 라우팅\n\n**관리와 설정:**\n- **라우터**: 복잡한 CLI, 다양한 설정 옵션, 세밀한 제어\n- **L3 스위치**: 상대적으로 단순한 설정, GUI 지원 많음\n\n**수렴 경향:**\n최신 장비들은 두 카테고리의 경계가 모호해지고 있습니다. 고급 L3 스위치는 라우터 기능을 많이 탑재하고, 라우터는 처리 성능이 향상되고 있습니다.\n\n**실무 선택 기준:**\n- **인터넷 연결, WAN 연결**: 라우터\n- **VLAN 간 라우팅, 데이터센터 내부**: L3 스위치\n- **복잡한 정책, 보안 기능**: 라우터\n- **고속, 대량 트래픽**: L3 스위치\n\n**하이브리드 접근:**\n대규모 네트워크에서는 경계에 라우터를, 내부에 L3 스위치를 배치하는 것이 일반적입니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "동기화",
        "HTTP"
      ],
      "id": "1763437633066-h73s5qxu",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.",
      "answer": "각 OSI 계층에서 **데이터 단위**는 서로 다른 이름으로 불리며, 이는 각 계층의 역할과 처리 방식을 반영합니다.\n\n**물리 계층(Physical Layer) - 비트(Bit):**\n가장 기본 단위인 0과 1의 비트 스트림입니다. 전기 신호, 광 신호, 전파 등 물리적 매체를 통해 전송됩니다. 프레임이나 패킷의 개념이 없이 단순히 비트만 존재합니다.\n\n**데이터링크 계층(Data Link Layer) - 프레임(Frame):**\n비트 스트림을 의미 있는 단위로 묶은 것입니다. MAC 주소 정보를 포함하는 헤더와 트레일러로 감쌉니다. 이더넷 프레임, Wi-Fi 프레임 등이 있습니다. 오류 검출을 위한 FCS(Frame Check Sequence)를 포함합니다.\n\n**네트워크 계층(Network Layer) - 패킷(Packet):**\n라우팅 가능한 데이터 단위입니다. IP 헤더를 포함하여 송신지와 목적지 IP 주소를 가집니다. 일반적으로 \"IP 패킷\" 또는 \"데이터그램(Datagram)\"이라고 부릅니다. 데이터그램은 특히 비연결형 전송을 강조할 때 사용합니다.\n\n**전송 계층(Transport Layer) - 세그먼트(Segment) / 데이터그램(Datagram):**\n- **TCP**: 세그먼트(Segment)라고 부릅니다. 연결 지향적이고 순서가 있는 데이터 단위입니다\n- **UDP**: 데이터그램(Datagram)이라고 부릅니다. 비연결형이고 독립적인 데이터 단위입니다\n\n포트 번호로 애플리케이션을 식별하며, TCP는 순서 번호와 확인 응답 정보를 포함합니다.\n\n**세션 계층(Session Layer) - 데이터(Data):**\n특별한 명칭이 없으며 일반적으로 데이터 또는 메시지라고 부릅니다. 세션 관리와 관련된 제어 정보를 포함할 수 있습니다.\n\n**표현 계층(Presentation Layer) - 데이터(Data):**\n변환되고 형식화된 데이터입니다. 암호화, 압축, 인코딩된 형태를 가질 수 있습니다. 특별한 명칭보다는 처리 방식에 따라 \"암호화된 데이터\", \"압축된 데이터\" 등으로 표현합니다.\n\n**애플리케이션 계층(Application Layer) - 메시지(Message) / 데이터(Data):**\n사용자 데이터 또는 애플리케이션 메시지입니다. 프로토콜에 따라 다양한 이름을 사용합니다:\n- **HTTP**: HTTP 메시지(요청/응답)\n- **SMTP**: 이메일 메시지\n- **DNS**: DNS 쿼리/응답\n- **FTP**: FTP 명령/데이터\n\n**캡슐화 과정에서의 명칭 변화:**\n애플리케이션 데이터가 하위 계층으로 내려가면서:\n1. 애플리케이션: 메시지\n2. 전송 계층: 세그먼트(TCP) 또는 데이터그램(UDP) - TCP/UDP 헤더 추가\n3. 네트워크 계층: 패킷 - IP 헤더 추가\n4. 데이터링크 계층: 프레임 - 이더넷 헤더와 트레일러 추가\n5. 물리 계층: 비트 - 물리적 신호로 변환\n\n**역캡슐화(Decapsulation):**\n수신 측에서는 역순으로 각 계층의 헤더를 제거하며:\n1. 물리: 비트를 프레임으로\n2. 데이터링크: 프레임을 패킷으로\n3. 네트워크: 패킷을 세그먼트로\n4. 전송: 세그먼트를 데이터로\n5. 애플리케이션: 최종 메시지 전달\n\n**PDU(Protocol Data Unit):**\n각 계층의 데이터 단위를 통칭하여 PDU라고 부릅니다. Layer N PDU는 해당 계층의 헤더와 상위 계층의 전체 데이터를 포함합니다.\n\n**실무에서의 사용:**\n- \"패킷을 캡처했다\"고 하면 일반적으로 네트워크 계층 이상의 데이터를 의미합니다\n- \"프레임을 분석한다\"고 하면 데이터링크 계층부터 전체를 보는 것입니다\n- \"세그먼트가 손실되었다\"고 하면 TCP 레벨의 문제를 의미합니다\n\n**TCP/IP 모델에서:**\nTCP/IP 4계층 모델에서는 용어가 약간 다릅니다:\n- 네트워크 인터페이스 계층: 프레임\n- 인터넷 계층: 패킷 또는 데이터그램\n- 전송 계층: 세그먼트(TCP) 또는 데이터그램(UDP)\n- 애플리케이션 계층: 메시지 또는 데이터\n\n**중요성:**\n정확한 용어 사용은 네트워크 문제를 소통하고 진단할 때 중요합니다. \"패킷 손실\"과 \"프레임 에러\"는 서로 다른 계층의 문제를 나타냅니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633066-l5hh6mcm",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "각각의 Header의 Packing Order에 대해 설명해 주세요.",
      "answer": "**헤더 패킹 순서(Packing Order)**는 데이터가 송신될 때 각 계층의 헤더가 추가되는 순서를 의미하며, **캡슐화(Encapsulation)** 과정을 통해 이루어집니다.\n\n**송신 측 캡슐화 순서:**\n\n**1단계 - 애플리케이션 계층:**\n사용자 데이터 또는 애플리케이션 메시지가 생성됩니다. 예를 들어 HTTP 요청, 이메일 본문, 파일 데이터 등이 있습니다. 애플리케이션 프로토콜의 헤더가 추가됩니다(HTTP 헤더, SMTP 명령 등).\n\n**2단계 - 전송 계층:**\n애플리케이션 데이터 앞에 전송 계층 헤더가 추가됩니다. TCP 헤더(20-60 바이트) 또는 UDP 헤더(8 바이트)가 붙습니다. 포함 정보: 송신/수신 포트 번호, 순서 번호(TCP), 체크섬 등. 이 시점에서 세그먼트(TCP) 또는 데이터그램(UDP)이 됩니다.\n\n**3단계 - 네트워크 계층:**\n전송 계층 세그먼트 앞에 IP 헤더가 추가됩니다. IPv4 헤더(20-60 바이트) 또는 IPv6 헤더(40 바이트)가 붙습니다. 포함 정보: 송신/수신 IP 주소, TTL, 프로토콜 타입, 체크섬(IPv4) 등. 이 시점에서 IP 패킷 또는 데이터그램이 됩니다.\n\n**4단계 - 데이터링크 계층:**\nIP 패킷 앞에 데이터링크 헤더가, 뒤에 트레일러가 추가됩니다. 이더넷 헤더(14 바이트): 송신/수신 MAC 주소, 이더타입. 이더넷 트레일러(4 바이트): FCS(Frame Check Sequence)로 오류 검출. 이 시점에서 프레임이 됩니다.\n\n**5단계 - 물리 계층:**\n프레임이 비트 스트림으로 변환되어 물리적 매체(케이블, 전파)를 통해 전송됩니다. 프리앰블과 SFD(Start Frame Delimiter)가 추가될 수 있습니다.\n\n**실제 패킷 구조 (안쪽에서 바깥쪽으로):**\n[이더넷 헤더 | IP 헤더 | TCP/UDP 헤더 | 애플리케이션 데이터 | 이더넷 트레일러]\n\n**구체적 예시 (HTTP 요청):**\n1. HTTP 요청 메시지: \"GET /index.html HTTP/1.1...\"\n2. + TCP 헤더: 포트 80, 순서 번호 등\n3. + IP 헤더: 송신/수신 IP 주소\n4. + 이더넷 헤더 + 트레일러: MAC 주소, FCS\n\n**수신 측 역캡슐화 순서:**\n\n**1단계 - 물리 계층:**\n비트 스트림을 받아 프레임으로 재구성합니다.\n\n**2단계 - 데이터링크 계층:**\n이더넷 헤더와 트레일러를 제거합니다. FCS로 오류를 검사하고, 목적지 MAC 주소가 자신인지 확인합니다. 이더타입 필드를 보고 상위 프로토콜(IP)을 식별합니다. IP 패킷을 네트워크 계층으로 전달합니다.\n\n**3단계 - 네트워크 계층:**\nIP 헤더를 제거하고 검증합니다. 목적지 IP 주소가 자신인지 확인합니다. 프로토콜 필드를 보고 상위 프로토콜(TCP/UDP)을 식별합니다. 세그먼트를 전송 계층으로 전달합니다.\n\n**4단계 - 전송 계층:**\nTCP/UDP 헤더를 제거하고 검증합니다. 포트 번호로 해당 애플리케이션을 찾습니다. TCP의 경우 순서 확인, 재조립, ACK 전송 등을 수행합니다. 데이터를 애플리케이션 계층으로 전달합니다.\n\n**5단계 - 애플리케이션 계층:**\n최종 애플리케이션 데이터를 받아 처리합니다. HTTP 응답 파싱, 이메일 표시, 파일 저장 등을 수행합니다.\n\n**헤더 크기 총합:**\n최소한의 헤더만 사용할 때:\n- 이더넷: 14 바이트 헤더 + 4 바이트 트레일러 = 18 바이트\n- IP(v4): 20 바이트\n- TCP: 20 바이트\n- 총 오버헤드: 58 바이트\n\n실제 데이터가 100 바이트라면 총 158 바이트가 전송되며, 약 37%가 오버헤드입니다.\n\n**MTU와의 관계:**\n이더넷의 MTU(Maximum Transmission Unit)는 일반적으로 1500 바이트입니다. IP 패킷(헤더 + 데이터)이 1500 바이트를 초과하면 단편화가 발생합니다. 효율적인 전송을 위해 TCP MSS(Maximum Segment Size)를 조정합니다.\n\n**VLAN 태그:**\nVLAN을 사용하는 경우 이더넷 헤더에 4 바이트 태그가 추가됩니다. 이 경우 이더넷 헤더는 18 바이트가 됩니다.\n\n**터널링의 경우:**\nVPN이나 터널링 사용 시 추가 헤더가 중첩됩니다. 예: [외부 이더넷 | 외부 IP | 터널 프로토콜 | 내부 IP | TCP | 데이터 | 외부 이더넷 트레일러]\n\n**실무적 중요성:**\n패킷 캡처 도구(Wireshark)로 분석 시 이 순서를 이해해야 정확한 진단이 가능합니다. 네트워크 성능 최적화를 위해 오버헤드를 계산하고 관리해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-wtwddl82",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "ARP에 대해 설명해 주세요.",
      "answer": "**ARP(Address Resolution Protocol)**는 IP 주소를 MAC 주소로 변환하는 프로토콜입니다.\n\n**필요성:**\n네트워크 통신을 위해서는 논리 주소(IP)와 물리 주소(MAC)가 모두 필요합니다. 상위 계층은 IP 주소만 알고 있지만, 실제 프레임 전송을 위해서는 목적지의 MAC 주소가 필요합니다. ARP는 이 두 주소를 연결하는 다리 역할을 합니다.\n\n**동작 과정:**\n\n**1. ARP Request (요청):**\n호스트 A가 호스트 B(IP: 192.168.1.100)와 통신하려 하지만 MAC 주소를 모릅니다. 호스트 A는 ARP Request를 브로드캐스트로 전송합니다. 메시지 내용: \"IP 주소 192.168.1.100을 가진 사람의 MAC 주소는 무엇인가?\" 목적지 MAC 주소는 FF:FF:FF:FF:FF:FF(브로드캐스트)입니다. 같은 네트워크의 모든 장치가 이 메시지를 받습니다.\n\n**2. ARP Reply (응답):**\n해당 IP를 가진 호스트 B만 응답합니다. 호스트 B는 자신의 MAC 주소를 포함한 ARP Reply를 유니캐스트로 보냅니다. 메시지 내용: \"192.168.1.100은 내 IP이고, 내 MAC 주소는 AA:BB:CC:DD:EE:FF입니다.\" 호스트 A는 이 정보를 받아 통신을 시작합니다.\n\n**ARP 캐시(ARP Table):**\n매번 ARP 요청을 보내면 비효율적이므로, 학습한 IP-MAC 매핑을 캐시에 저장합니다. 일정 시간(일반적으로 몇 분) 동안 유효하며, 타임아웃 후 삭제됩니다. 윈도우에서는 \"arp -a\" 명령으로, 리눅스에서는 \"ip neigh\" 명령으로 확인할 수 있습니다.\n\n**동적 ARP vs 정적 ARP:**\n- **동적 ARP**: 자동으로 학습하고 타임아웃 후 삭제됩니다\n- **정적 ARP**: 관리자가 수동으로 설정하며 영구적입니다. 보안이 중요한 장치에 사용됩니다\n\n**Gratuitous ARP:**\n자신의 IP에 대한 ARP를 보내는 특수한 경우입니다. 목적: IP 주소 충돌 감지, 네트워크의 다른 장치들이 ARP 캐시를 업데이트하도록 함, 장비가 부팅되거나 IP가 변경될 때 사용됩니다.\n\n**Proxy ARP:**\n라우터가 다른 네트워크의 호스트를 대신하여 ARP 응답을 보냅니다. 서브넷 마스크 설정이 잘못된 호스트들이 통신할 수 있게 합니다. 보안 문제가 있어 권장되지 않습니다.\n\n**Reverse ARP(RARP):**\nMAC 주소를 알고 있을 때 IP 주소를 찾는 역방향 프로토콜입니다. 디스크 없는 워크스테이션이 부팅 시 사용했습니다. 현재는 DHCP, BOOTP로 대체되었습니다.\n\n**ARP 스푸핑(ARP Spoofing):**\n공격자가 거짓 ARP 응답을 보내 피해자의 ARP 캐시를 오염시킵니다. 중간자 공격(MITM)을 가능하게 하여 트래픽을 가로챌 수 있습니다. 대응: 정적 ARP 엔트리, DAI(Dynamic ARP Inspection), 암호화된 통신 사용합니다.\n\n**IPv6의 경우:**\nIPv6에서는 ARP 대신 NDP(Neighbor Discovery Protocol)를 사용합니다. ICMPv6 기반으로 더 많은 기능을 제공합니다. Neighbor Solicitation과 Neighbor Advertisement 메시지로 주소를 해석합니다.\n\n**동작 범위:**\nARP는 브로드캐스트를 사용하므로 같은 네트워크(브로드캐스트 도메인) 내에서만 동작합니다. 라우터를 넘어가는 통신에서는 게이트웨이의 MAC 주소를 찾습니다.\n\n**게이트웨이 통신 시:**\n호스트 A가 다른 네트워크의 호스트 C와 통신할 때, 목적지 IP는 C의 IP이지만, 목적지 MAC은 게이트웨이(라우터)의 MAC입니다. 라우터는 패킷을 받아 다음 홉으로 전달하며, MAC 주소는 홉마다 변경됩니다.\n\n**ARP 패킷 구조:**\nHardware Type, Protocol Type, Hardware/Protocol Length, Operation(Request/Reply), Sender MAC/IP, Target MAC/IP 필드를 포함합니다.\n\n**실무적 중요성:**\n네트워크 연결 문제 시 ARP 캐시를 확인하고 정리하는 것이 기본 해결 방법입니다. \"arp -d\" 명령으로 캐시를 삭제할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-l4wnq42z",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "3-Way Handshake에 대해 설명해 주세요.",
      "answer": "**3-Way Handshake**는 TCP 연결을 수립하는 과정으로, 양쪽이 통신 준비가 되었음을 확인합니다.\n\n**목적:**\n신뢰성 있는 양방향 연결을 설정합니다. 초기 순서 번호(ISN, Initial Sequence Number)를 교환합니다. 양쪽의 수신 능력을 확인합니다. 윈도우 크기, MSS 등의 연결 파라미터를 협상합니다.\n\n**3단계 과정:**\n\n**1단계 - SYN (클라이언트 → 서버):**\n클라이언트가 서버에 연결을 요청합니다. SYN(Synchronize) 플래그를 1로 설정합니다. 클라이언트의 초기 순서 번호(ISN_C)를 포함합니다. 예: Seq = 1000, SYN = 1. 클라이언트는 SYN_SENT 상태가 됩니다.\n\n**2단계 - SYN-ACK (서버 → 클라이언트):**\n서버가 연결 요청을 수락합니다. SYN 플래그와 ACK(Acknowledgment) 플래그를 모두 1로 설정합니다. 서버의 초기 순서 번호(ISN_S)를 포함합니다. ACK 번호는 클라이언트 ISN + 1입니다. 예: Seq = 2000, Ack = 1001, SYN = 1, ACK = 1. 서버는 SYN_RECEIVED 상태가 됩니다.\n\n**3단계 - ACK (클라이언트 → 서버):**\n클라이언트가 서버의 응답을 확인합니다. ACK 플래그를 1로 설정합니다(SYN은 0). ACK 번호는 서버 ISN + 1입니다. 예: Seq = 1001, Ack = 2001, ACK = 1. 이 시점에서 데이터 전송이 가능합니다. 양쪽 모두 ESTABLISHED 상태가 됩니다.\n\n**초기 순서 번호(ISN):**\n무작위로 생성되어 보안을 강화합니다. 시간과 연결 정보를 기반으로 계산됩니다. 예측 가능한 ISN은 시퀀스 예측 공격에 취약합니다.\n\n**옵션 협상:**\n3-Way Handshake 중에 TCP 옵션을 교환합니다:\n- **MSS(Maximum Segment Size)**: 수신할 수 있는 최대 세그먼트 크기\n- **윈도우 스케일**: 큰 윈도우 크기 지원\n- **SACK 허용**: 선택적 확인 응답 사용 여부\n- **타임스탬프**: RTT 측정과 PAWS 지원\n\n**상태 전이:**\n- 클라이언트: CLOSED → SYN_SENT → ESTABLISHED\n- 서버: CLOSED → LISTEN → SYN_RECEIVED → ESTABLISHED\n\n**왜 3단계가 필요한가:**\n2단계만으로는 양방향 통신을 보장할 수 없습니다. 서버도 클라이언트에게 데이터를 보낼 수 있어야 하므로 서버의 ISN도 확인받아야 합니다. 3단계를 통해 양쪽 모두의 송신/수신 능력을 확인합니다.\n\n**오래된 연결 요청 문제:**\n네트워크 지연으로 오래된 SYN이 늦게 도착할 수 있습니다. 2-Way만 사용하면 잘못된 연결이 수립될 수 있습니다. 3-Way Handshake는 순서 번호 확인으로 이를 방지합니다.\n\n**타임아웃:**\n각 단계에서 응답을 받지 못하면 재전송합니다. 여러 번 시도 후 실패하면 연결 수립을 포기합니다. 일반적으로 SYN은 몇 번 재전송한 후(수십 초) 타임아웃됩니다.\n\n**SYN Flooding 공격:**\n공격자가 대량의 SYN 패킷을 보내 서버의 자원을 고갈시킵니다. 서버는 SYN_RECEIVED 상태의 연결을 대기하며 메모리를 소비합니다. 대응: SYN 쿠키, SYN 프록시, 백로그 큐 크기 조정합니다.\n\n**동시 개방(Simultaneous Open):**\n양쪽이 동시에 SYN을 보내는 경우도 가능합니다. 4-Way Handshake가 발생하지만 최종적으로 연결이 수립됩니다.\n\n**Fast Open (TCP Fast Open):**\nTFO는 3-Way Handshake를 최적화합니다. 첫 SYN에 데이터를 포함하여 전송할 수 있습니다. 재연결 시 1-RTT로 단축됩니다.\n\n**실무 예시:**\n웹 브라우저가 서버에 접속할 때, 눈에 보이지 않지만 3-Way Handshake가 먼저 수행됩니다. 이후 HTTP 요청이 전송됩니다. 패킷 캡처 시 항상 SYN, SYN-ACK, ACK 순서를 확인할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-mkqadf7g",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?",
      "answer": "**ACK, SYN 같은 제어 정보는 TCP 헤더의 플래그 비트(Control Flags)**를 통해 전달됩니다.\n\n**TCP 헤더 구조:**\nTCP 헤더는 최소 20 바이트이며, 여러 필드로 구성됩니다. 13-14번째 바이트에 제어 플래그가 위치합니다. 각 플래그는 1비트로 표현되어 0(비활성) 또는 1(활성) 값을 가집니다.\n\n**주요 제어 플래그:**\n\n**URG(Urgent):**\n긴급 데이터가 포함되어 있음을 나타냅니다. 긴급 포인터 필드와 함께 사용됩니다. 현재는 거의 사용되지 않습니다.\n\n**ACK(Acknowledgment):**\n확인 응답 번호 필드가 유효함을 나타냅니다. 연결 수립 후 전송되는 모든 세그먼트에 설정됩니다. 수신한 데이터를 확인하는 용도입니다.\n\n**PSH(Push):**\n수신 측에서 버퍼에 쌓지 말고 즉시 애플리케이션에 전달하라는 요청입니다. 대화형 애플리케이션(텔넷, SSH)에서 사용됩니다.\n\n**RST(Reset):**\n연결을 강제로 종료하거나 잘못된 연결을 거부합니다. 비정상 종료 시 사용됩니다. 존재하지 않는 포트로 연결 시도 시 서버가 RST를 보냅니다.\n\n**SYN(Synchronize):**\n연결 수립을 요청하고 초기 순서 번호를 동기화합니다. 3-Way Handshake의 첫 두 단계에서 사용됩니다.\n\n**FIN(Finish):**\n연결 종료를 요청합니다. 더 이상 보낼 데이터가 없음을 알립니다. 4-Way Handshake에서 사용됩니다.\n\n**플래그 조합:**\n여러 플래그를 동시에 설정할 수 있습니다:\n- **SYN**: 연결 요청 (3-Way 1단계)\n- **SYN + ACK**: 연결 수락 (3-Way 2단계)\n- **ACK**: 확인 응답 (3-Way 3단계 및 데이터 전송)\n- **FIN + ACK**: 연결 종료 요청과 데이터 확인\n- **RST + ACK**: 연결 리셋과 확인\n\n**실제 전송 과정:**\n1. 송신자가 세그먼트를 생성하며 적절한 플래그 비트를 설정합니다\n2. TCP 헤더가 완성되어 IP 패킷에 캡슐화됩니다\n3. 수신자가 TCP 헤더의 플래그 비트를 확인합니다\n4. 플래그에 따라 적절한 동작을 수행합니다(상태 변경, ACK 전송 등)\n\n**TCP 헤더의 다른 중요 필드:**\n\n**순서 번호(Sequence Number):**\n전송하는 데이터의 첫 바이트 번호입니다. 순서 보장과 재조립에 사용됩니다.\n\n**확인 응답 번호(Acknowledgment Number):**\n다음에 받기를 기대하는 바이트 번호입니다. ACK 플래그가 1일 때만 유효합니다.\n\n**데이터 오프셋(Header Length):**\nTCP 헤더의 길이를 나타냅니다(4비트, 32비트 워드 단위). 옵션 필드 때문에 가변 길이입니다.\n\n**윈도우 크기(Window Size):**\n수신 가능한 버퍼 크기를 알립니다. 흐름 제어에 사용됩니다.\n\n**체크섬(Checksum):**\n헤더와 데이터의 무결성을 검증합니다.\n\n**긴급 포인터(Urgent Pointer):**\nURG 플래그가 1일 때 긴급 데이터의 끝을 가리킵니다.\n\n**옵션(Options):**\nMSS, 윈도우 스케일, SACK, 타임스탬프 등 추가 정보를 전달합니다. 가변 길이로 0-40 바이트입니다.\n\n**비트 레벨 표현:**\n플래그는 실제로는 연속된 비트들입니다. 예: 00011000은 PSH와 ACK가 설정된 것입니다. 네트워크 도구는 이를 읽기 쉽게 표시합니다(예: Flags: [.A....], Flags: [S.], Flags: [S.A...]).\n\n**Wireshark에서의 표시:**\nWireshark는 플래그를 약어로 표시합니다:\n- [S] = SYN\n- [.] = ACK만 (다른 플래그 없음)\n- [S.] = SYN + ACK\n- [F.] = FIN + ACK\n- [P.] = PSH + ACK\n- [R.] = RST\n\n**프로그래밍 관점:**\n소켓 프로그래밍에서 개발자는 이러한 플래그를 직접 설정하지 않습니다. connect(), send(), close() 같은 함수를 호출하면 운영체제가 자동으로 적절한 플래그를 설정합니다. 하지만 로우 소켓(Raw Socket)을 사용하면 직접 제어할 수 있습니다.\n\n**보안 스캐닝:**\n포트 스캐닝 도구는 다양한 플래그 조합을 보내 서버의 응답을 분석합니다:\n- **SYN 스캔**: SYN만 보내고 SYN-ACK 응답 확인\n- **FIN 스캔**: FIN을 보내 RST 응답 확인\n- **NULL 스캔**: 모든 플래그 0으로 설정\n- **Xmas 스캔**: FIN, URG, PSH 동시 설정\n\n**실무적 중요성:**\n패킷 분석 시 플래그를 확인하면 연결 상태와 문제를 정확히 파악할 수 있습니다. 비정상적인 플래그 조합은 공격이나 오작동을 의미할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "캐시"
      ],
      "id": "1763437633066-kpsb6qvg",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.",
      "answer": "**2-Way Handshaking**만으로는 **양방향 통신의 신뢰성을 보장할 수 없기** 때문에 사용하지 않습니다.\n\n**양방향 연결의 필요성:**\nTCP는 전이중(Full-Duplex) 통신을 제공합니다. 클라이언트와 서버가 모두 데이터를 송신하고 수신할 수 있어야 합니다. 각 방향에 대해 독립적인 순서 번호와 확인 응답이 필요합니다.\n\n**2-Way의 문제점:**\n\n**문제 1 - 서버의 준비 상태 미확인:**\n2-Way(SYN → SYN-ACK)만으로는 서버가 보낸 SYN-ACK를 클라이언트가 받았는지 서버가 알 수 없습니다. 서버는 자신의 ISN이 확인되었는지 모른 채 데이터를 보낼 수 있습니다. 클라이언트가 SYN-ACK를 받지 못했다면 서버의 데이터는 모두 버려집니다.\n\n**문제 2 - 오래된 연결 요청:**\n네트워크 지연으로 이전 연결의 SYN 패킷이 늦게 도착할 수 있습니다. 2-Way만으로는 이 오래된 SYN을 구별할 수 없습니다. 서버가 SYN-ACK를 보내면 잘못된 연결이 수립될 수 있습니다. 클라이언트는 예상하지 못한 연결로 혼란스러워집니다.\n\n**문제 3 - 반쪽 열린 연결(Half-Open Connection):**\n클라이언트가 SYN을 보낸 후 크래시될 수 있습니다. 서버는 SYN-ACK를 보내고 연결이 수립되었다고 생각합니다. 하지만 클라이언트는 존재하지 않아 데이터를 받을 수 없습니다. 서버 자원이 불필요하게 낭비됩니다.\n\n**3-Way가 해결하는 방법:**\n\n**서버 확인:**\n클라이언트의 ACK(3단계)로 서버는 자신의 SYN-ACK가 도착했음을 확인합니다. 이제 양쪽 모두 상대방의 준비 상태를 확인했습니다. 안전하게 데이터 전송을 시작할 수 있습니다.\n\n**순서 번호 검증:**\n클라이언트는 3단계 ACK에서 서버의 ISN + 1을 확인합니다. 오래된 SYN에 대한 SYN-ACK라면 순서 번호가 맞지 않아 연결을 거부합니다. 클라이언트가 예상하는 ISN과 일치해야만 연결이 완성됩니다.\n\n**반쪽 열린 연결 방지:**\n클라이언트가 크래시되면 3단계 ACK를 보낼 수 없습니다. 서버는 타임아웃 후 SYN_RECEIVED 상태를 정리합니다. 완전히 열린 연결만 유지되어 자원 낭비를 방지합니다.\n\n**구체적 예시:**\n\n**오래된 연결 시나리오:**\n1. 클라이언트가 SYN(ISN=100)을 보내지만 네트워크 지연으로 늦게 도착\n2. 클라이언트가 타임아웃 후 새 연결을 시도(ISN=500)\n3. 새 연결이 정상 수립되고 종료됨\n4. 뒤늦게 첫 SYN(ISN=100)이 서버에 도착\n5. 2-Way라면: 서버가 SYN-ACK(ISN_S=200, ACK=101)를 보내고 연결 수립으로 착각\n6. 3-Way라면: 클라이언트가 예상하지 않은 SYN-ACK를 받고 RST로 거부\n\n**수학적 관점:**\n3-Way Handshake는 양쪽의 ISN을 각각 확인받는 최소 단계입니다:\n- 1단계: 클라이언트 ISN 전달\n- 2단계: 서버 ISN 전달 + 클라이언트 ISN 확인\n- 3단계: 서버 ISN 확인\n총 2개의 ISN × 각 1회 확인 = 최소 3단계\n\n**대안은 없는가:**\n4-Way도 가능하지만 불필요한 오버헤드입니다. 2단계에서 SYN과 ACK를 결합(SYN-ACK)하여 효율성을 높였습니다. 3-Way가 최소한의 단계로 양방향 확인을 달성하는 최적 설계입니다.\n\n**RFC 793의 설계:**\nTCP 표준(RFC 793)은 이러한 문제들을 고려하여 3-Way Handshake를 명시했습니다. 40년 이상 검증된 신뢰성 있는 방법입니다.\n\n**성능 영향:**\n3-Way Handshake는 1.5 RTT(Round Trip Time)가 소요됩니다. 이는 신뢰성을 위해 필요한 비용입니다. HTTP/3와 QUIC의 0-RTT는 이전 연결 정보를 활용하여 최적화합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633066-2qis5fru",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?",
      "answer": "네, **동시 개방(Simultaneous Open)**이 가능하며, TCP는 이를 지원합니다.\n\n**정상적인 시나리오:**\n일반적으로는 한쪽이 능동 개방(Active Open, connect()), 다른 쪽이 수동 개방(Passive Open, listen())을 수행합니다. 클라이언트-서버 모델에서 서버는 LISTEN 상태에서 대기합니다.\n\n**동시 개방 시나리오:**\n양쪽 호스트가 모두 능동적으로 연결을 시도합니다. 두 호스트가 거의 동시에 SYN을 서로에게 보냅니다. 양쪽 모두 클라이언트이자 서버가 되는 특수한 상황입니다.\n\n**동시 개방의 4-Way Handshake:**\n\n**1단계 - 양쪽에서 SYN 전송:**\n호스트 A가 호스트 B에게 SYN(ISN_A=100)을 보냅니다. 호스트 B가 호스트 A에게 SYN(ISN_B=200)을 보냅니다. 두 SYN이 네트워크 상에서 교차합니다. 양쪽 모두 SYN_SENT 상태가 됩니다.\n\n**2단계 - 상대방의 SYN 수신:**\n호스트 A가 B의 SYN을 받습니다. 호스트 B가 A의 SYN을 받습니다. 일반적인 3-Way라면 SYN_SENT에서 SYN을 받는 것은 예상 밖입니다. TCP는 이를 동시 개방으로 인식합니다.\n\n**3단계 - SYN-ACK 교환:**\n호스트 A가 B에게 SYN-ACK(ISN_A=100, ACK=201)를 보냅니다. 호스트 B가 A에게 SYN-ACK(ISN_B=200, ACK=101)를 보냅니다. 양쪽 모두 SYN_RECEIVED 상태가 됩니다.\n\n**4단계 - 최종 ACK:**\n호스트 A가 B의 SYN-ACK를 받고 ESTABLISHED 상태로 전환합니다. 호스트 B가 A의 SYN-ACK를 받고 ESTABLISHED 상태로 전환합니다. 연결이 완전히 수립됩니다.\n\n**상태 전이:**\n- **정상 3-Way**: CLOSED → SYN_SENT → ESTABLISHED (클라이언트)\n- **동시 개방**: CLOSED → SYN_SENT → SYN_RECEIVED → ESTABLISHED (양쪽)\n\n**왜 4단계가 필요한가:**\n정상 3-Way에서는 서버가 LISTEN 상태에서 대기하므로 SYN-ACK로 응답합니다. 동시 개방에서는 양쪽 모두 SYN_SENT 상태이므로 먼저 SYN을 수신합니다. 각자의 SYN을 확인받기 위해 SYN-ACK를 교환해야 합니다.\n\n**실제 발생 가능성:**\n실무에서는 매우 드뭅니다. 정확히 같은 시간에 연결을 시도해야 하기 때문입니다. P2P 애플리케이션이나 NAT 홀 펀칭에서 의도적으로 사용될 수 있습니다.\n\n**포트 번호:**\n동시 개방이 성공하려면 양쪽이 서로의 포트로 연결을 시도해야 합니다. 예: A(IP1:Port1)와 B(IP2:Port2)가 서로를 향해 연결합니다. 일반적인 클라이언트-서버에서는 클라이언트가 임의 포트를 사용하므로 이런 일치가 어렵습니다.\n\n**NAT 홀 펀칭(Hole Punching):**\nP2P 연결을 위해 동시 개방을 활용합니다. 양쪽이 NAT 뒤에 있을 때 중계 서버가 타이밍을 조정합니다. 양쪽이 동시에 SYN을 보내면 NAT가 포트를 열어줍니다. 이를 통해 직접 P2P 연결이 가능해집니다.\n\n**RFC 793 지원:**\nTCP 표준은 동시 개방을 명시적으로 지원합니다. 모든 TCP 구현은 이 시나리오를 올바르게 처리해야 합니다. 대칭적인 연결로, 클라이언트와 서버의 구분이 없습니다.\n\n**방화벽과 NAT:**\n동시 개방은 방화벽 규칙을 복잡하게 만듭니다. 양방향 연결을 모두 허용해야 합니다. 상태 추적(Stateful) 방화벽은 이를 올바르게 처리합니다.\n\n**실험 방법:**\n두 호스트에서 동시에 특정 포트로 서로 연결을 시도합니다. 타이밍이 정확하면 4-Way Handshake를 관찰할 수 있습니다. 패킷 캡처로 SYN → SYN, SYN-ACK → SYN-ACK 교환을 확인합니다.\n\n**응용 사례:**\n- **P2P 파일 공유**: 양쪽이 모두 NAT 뒤에 있을 때\n- **VoIP**: 직접 미디어 연결 설정\n- **온라인 게임**: P2P 멀티플레이어 연결\n\n**주의사항:**\n의도적인 동시 개방 구현 시 정확한 타이밍 조정이 필요합니다. 중계 서버나 STUN 서버가 도와줍니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "동기화",
        "TCP"
      ],
      "id": "1763437633066-y6pojwyz",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "SYN Flooding 에 대해 설명해 주세요.",
      "answer": "**SYN Flooding**은 TCP의 3-Way Handshake 메커니즘을 악용한 서비스 거부 공격(DoS)입니다.\n\n**공격 원리:**\n공격자가 대량의 SYN 패킷을 서버에 전송합니다. 송신 IP 주소를 위조(Spoofing)하여 실제로 존재하지 않는 주소를 사용합니다. 서버는 각 SYN에 대해 SYN-ACK를 보내고 연결을 대기합니다. 위조된 IP는 응답하지 않으므로 ACK가 오지 않습니다. 서버는 타임아웃까지 연결을 유지하며 자원을 소모합니다.\n\n**피해:**\n서버의 백로그 큐(Backlog Queue)가 가득 차서 정상적인 연결 요청을 받을 수 없습니다. SYN_RECEIVED 상태의 연결들이 메모리를 고갈시킵니다. CPU 자원도 재전송과 타임아웃 처리로 소모됩니다. 결과적으로 정상 사용자가 서비스를 이용할 수 없게 됩니다.\n\n**반쪽 열린 연결(Half-Open Connections):**\nSYN_RECEIVED 상태에서 대기하는 불완전한 연결들입니다. 각 연결은 메모리(TCB, Transmission Control Block)를 차지합니다. 타임아웃이 길면(수십 초) 공격 효과가 커집니다.\n\n**백로그 큐:**\n서버의 listen() 함수가 설정하는 대기 큐입니다. 일반적으로 수십에서 수백 개의 연결을 저장합니다. SYN Flooding으로 큐가 가득 차면 새로운 SYN을 거부합니다.\n\n**대응 방법:**\n\n**1. SYN 쿠키(SYN Cookies):**\n가장 효과적인 방어 기법입니다. 서버가 SYN을 받을 때 상태를 저장하지 않습니다. 대신 암호학적 해시로 쿠키를 생성하여 SYN-ACK에 포함합니다. 클라이언트의 ACK를 받을 때 쿠키를 검증하여 연결을 수립합니다. 메모리 소모 없이 공격을 방어하지만, 일부 TCP 옵션을 사용할 수 없는 단점이 있습니다.\n\n**2. 백로그 큐 크기 증가:**\n더 많은 연결을 대기할 수 있도록 큐 크기를 늘립니다. 완전한 해결책은 아니지만 공격 규모가 작을 때 효과적입니다.\n\n**3. 타임아웃 시간 단축:**\nSYN_RECEIVED 상태의 타임아웃을 줄여 빠르게 정리합니다. 정상 연결도 영향을 받을 수 있으므로 신중하게 조정합니다.\n\n**4. 방화벽과 라우터 필터링:**\n비정상적인 SYN 비율을 감지하고 제한합니다. 특정 IP나 네트워크의 SYN을 차단합니다. Rate Limiting으로 초당 SYN 수를 제한합니다.\n\n**5. SYN 프록시:**\n전용 장비나 소프트웨어가 SYN을 대신 처리합니다. 3-Way Handshake를 완료한 후에만 실제 서버로 연결을 전달합니다. 서버를 공격으로부터 격리시킵니다.\n\n**6. Reverse Path Forwarding(RPF) 확인:**\n라우터가 송신 IP의 유효성을 확인합니다. 해당 IP로의 응답 경로가 없으면 패킷을 폐기합니다. IP 스푸핑을 어렵게 만듭니다.\n\n**7. 클라우드 DDoS 보호:**\nCloudflare, AWS Shield 같은 서비스를 사용합니다. 대규모 인프라로 공격 트래픽을 분산시킵니다.\n\n**운영체제 설정:**\n리눅스에서는 sysctl로 설정을 조정합니다:\n- tcp_max_syn_backlog: 백로그 큐 크기\n- tcp_synack_retries: SYN-ACK 재전송 횟수\n- tcp_syncookies: SYN 쿠키 활성화\n\n**공격 감지:**\nnetstat으로 SYN_RECEIVED 상태가 비정상적으로 많은지 확인합니다. 서버 로그에서 연결 시도 실패율을 모니터링합니다. IDS/IPS 시스템으로 패턴을 탐지합니다.\n\n**분산 SYN Flooding (DDoS):**\n여러 봇넷이 동시에 공격하면 더 강력합니다. IP 차단이 어려워지고 트래픽 양이 압도적입니다. 전문적인 DDoS 방어 서비스가 필요합니다.\n\n**역사적 배경:**\n1990년대 중반부터 알려진 고전적인 공격입니다. SYN 쿠키(1996년 발명)로 근본적 해결책이 마련되었습니다. 현대 서버는 기본적으로 SYN 쿠키를 지원합니다.\n\n**실무 권장:**\nSYN 쿠키를 활성화하고 모니터링 시스템을 구축합니다. 방화벽 규칙과 Rate Limiting을 설정합니다. 정기적인 보안 점검과 업데이트를 수행합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-kqaeyx53",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?",
      "answer": "**0-RTT(Zero Round Trip Time)**는 이전 연결의 정보를 재사용하여 즉시 데이터를 전송하는 최적화 기법입니다.\n\n**기존 핸드셰이크의 오버헤드:**\n일반 TCP 3-Way Handshake는 1.5 RTT가 소요됩니다. TLS를 추가하면 총 2-3 RTT가 필요합니다. 지연 시간이 큰 환경(모바일, 장거리)에서는 수백 ms가 걸립니다. 사용자 경험에 직접적인 영향을 줍니다.\n\n**TCP Fast Open (TFO):**\n\n**원리:**\n클라이언트와 서버가 이전에 연결한 적이 있을 때 쿠키를 교환합니다. 이 쿠키는 클라이언트를 인증하는 토큰입니다.\n\n**첫 연결:**\n일반 3-Way Handshake를 수행합니다. 서버가 SYN-ACK에 TFO 쿠키를 포함하여 보냅니다. 클라이언트가 이 쿠키를 저장합니다.\n\n**재연결 시:**\n클라이언트가 SYN 패킷에 TFO 쿠키와 함께 실제 데이터를 포함합니다. 서버가 쿠키를 검증하고 데이터를 즉시 처리합니다. 동시에 SYN-ACK를 보내 핸드셰이크를 완료합니다. 데이터 전송에 0-RTT가 소요됩니다(핸드셰이크와 동시).\n\n**TLS 1.3의 0-RTT:**\n\n**세션 재개:**\n이전 TLS 세션의 암호화 키를 재사용합니다. 클라이언트가 PSK(Pre-Shared Key) 또는 세션 티켓을 저장합니다.\n\n**Early Data:**\nClientHello와 함께 암호화된 애플리케이션 데이터를 보냅니다. 서버가 세션 정보를 확인하고 즉시 데이터를 처리합니다. 핸드셰이크 완료를 기다리지 않습니다.\n\n**QUIC (HTTP/3):**\n\n**연결 ID 사용:**\n이전 연결의 Connection ID와 암호화 정보를 저장합니다.\n\n**0-RTT 재개:**\n첫 패킷에 Connection ID, 암호화된 데이터, 연결 재개 토큰을 포함합니다. 서버가 검증 후 즉시 응답하며 데이터를 처리합니다.\n\n**1-RTT 초기 연결:**\n처음 연결할 때도 TLS 핸드셰이크를 QUIC 핸드셰이크와 통합하여 1-RTT로 단축합니다.\n\n**0-RTT의 보안 고려사항:**\n\n**재생 공격(Replay Attack):**\n0-RTT 데이터는 공격자가 캡처하여 재전송할 수 있습니다. 서버는 같은 요청이 여러 번 처리될 수 있음을 인지해야 합니다.\n\n**멱등성(Idempotency) 요구:**\n0-RTT로 전송되는 요청은 멱등성을 가져야 합니다. GET 요청은 안전하지만 POST, DELETE 등은 위험합니다. 중요한 상태 변경 작업은 1-RTT 이후에 수행해야 합니다.\n\n**서버 측 방어:**\n단일 사용 토큰, 타임스탬프 검증, 중복 요청 감지 메커니즘을 구현합니다. 일부 서버는 0-RTT를 특정 작업으로만 제한합니다.\n\n**적용 범위:**\n모든 연결이 0-RTT를 사용할 수 없습니다. 첫 연결은 항상 전체 핸드셰이크가 필요합니다. 쿠키나 세션이 만료되면 다시 전체 핸드셰이크를 수행합니다.\n\n**실무 활용:**\n웹 브라우저와 CDN이 0-RTT를 적극 활용합니다. 정적 콘텐츠 요청(이미지, CSS, JS)에 적합합니다. API 중에서도 읽기 전용 작업에 사용합니다.\n\n**성능 개선:**\n0-RTT는 페이지 로딩 시간을 20-30% 단축할 수 있습니다. 특히 모바일이나 고지연 네트워크에서 효과가 큽니다. 사용자 경험이 크게 향상됩니다.\n\n**프로토콜별 지원:**\n- **TCP Fast Open**: RFC 7413, 리눅스/윈도우 지원\n- **TLS 1.3 0-RTT**: RFC 8446, 주요 브라우저 지원\n- **QUIC 0-RTT**: HTTP/3의 핵심 기능\n\n**활성화 방법:**\n서버 설정에서 TCP Fast Open, TLS 1.3, QUIC을 활성화합니다. 클라이언트(브라우저)도 지원해야 합니다. 보안 정책에 따라 0-RTT 허용 범위를 조정합니다.\n\n**미래 전망:**\n0-RTT는 점점 더 표준이 되고 있습니다. 5G, 위성 인터넷 등 고지연 환경에서 특히 중요합니다. 보안과 성능의 균형을 맞추는 발전이 계속되고 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP"
      ],
      "id": "1763437633066-6y1sxwq4",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "4-Way Handshake에 대해 설명해 주세요.",
      "answer": "**4-Way Handshake**는 TCP 연결을 안전하게 종료하는 과정입니다.\n\n**필요성:**\nTCP는 전이중(Full-Duplex) 통신이므로 양방향을 독립적으로 종료해야 합니다. 한쪽이 데이터 전송을 끝내도 상대방은 계속 보낼 수 있습니다. 양쪽 모두 종료에 동의하고 모든 데이터가 전달되었음을 확인해야 합니다.\n\n**4단계 과정:**\n\n**1단계 - FIN (클라이언트 → 서버):**\n클라이언트가 연결 종료를 시작합니다. FIN(Finish) 플래그를 1로 설정한 세그먼트를 보냅니다. \"더 이상 보낼 데이터가 없습니다\"라는 의미입니다. 클라이언트는 FIN_WAIT_1 상태가 됩니다. 하지만 서버로부터 데이터는 계속 받을 수 있습니다.\n\n**2단계 - ACK (서버 → 클라이언트):**\n서버가 FIN을 확인합니다. ACK 플래그를 1로 설정하고 ACK 번호는 FIN의 순서 번호 + 1입니다. 서버는 CLOSE_WAIT 상태가 됩니다. 클라이언트는 FIN_WAIT_2 상태가 됩니다. 서버는 아직 보낼 데이터가 있을 수 있습니다.\n\n**3단계 - FIN (서버 → 클라이언트):**\n서버가 남은 데이터를 모두 전송한 후 연결 종료를 요청합니다. FIN 플래그를 1로 설정합니다. 서버는 LAST_ACK 상태가 됩니다. \"이제 나도 보낼 데이터가 없습니다\"라는 의미입니다.\n\n**4단계 - ACK (클라이언트 → 서버):**\n클라이언트가 서버의 FIN을 확인합니다. ACK 플래그를 1로 설정하고 ACK 번호는 FIN의 순서 번호 + 1입니다. 클라이언트는 TIME_WAIT 상태로 전환됩니다. 서버는 ACK를 받고 CLOSED 상태가 됩니다. 클라이언트는 일정 시간(2MSL) 대기 후 CLOSED가 됩니다.\n\n**상태 전이:**\n- **클라이언트(능동 종료)**: ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED\n- **서버(수동 종료)**: ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED\n\n**반쪽 종료(Half-Close):**\n1단계와 3단계 사이에 서버는 데이터를 계속 보낼 수 있습니다. 이를 half-close 상태라고 합니다. 클라이언트는 더 이상 보내지 않지만 받을 수는 있습니다. 대용량 파일 다운로드 후 연결 종료 시 유용합니다.\n\n**TIME_WAIT 상태:**\n클라이언트가 마지막 ACK를 보낸 후 2MSL(Maximum Segment Lifetime, 일반적으로 2-4분) 동안 대기합니다.\n\n**TIME_WAIT의 이유:**\n1. 마지막 ACK가 손실될 경우를 대비합니다. 서버가 FIN을 재전송하면 클라이언트가 ACK를 다시 보낼 수 있습니다\n2. 이전 연결의 지연된 패킷이 새 연결에 영향을 주는 것을 방지합니다\n\n**동시 종료(Simultaneous Close):**\n양쪽이 동시에 FIN을 보낼 수 있습니다. 각자 상대방의 FIN에 ACK로 응답합니다. 총 4개의 세그먼트가 교환되지만 순서가 다릅니다. 최종적으로는 정상 종료됩니다.\n\n**3-Way 종료가 아닌 이유:**\n2단계 ACK와 3단계 FIN을 결합하면 3-Way가 가능합니다. 하지만 서버가 즉시 종료할 준비가 안 될 수 있습니다. Half-close 기능이 필요하므로 4-Way를 사용합니다.\n\n**RST로 종료:**\n비정상 종료 시에는 4-Way Handshake 없이 RST(Reset)로 즉시 종료합니다. 애플리케이션 크래시, 프로그래밍 오류, 강제 종료 시 발생합니다. RST는 확인 응답이 없으며 즉시 연결을 끊습니다.\n\n**SO_LINGER 옵션:**\n소켓 옵션으로 종료 동작을 제어할 수 있습니다. 기본값: close() 시 4-Way Handshake 수행하고 즉시 반환합니다. linger=0: 버퍼 데이터를 버리고 RST로 강제 종료합니다. linger=N: N초 동안 대기하며 데이터 전송을 시도합니다.\n\n**FIN_WAIT_2 타임아웃:**\n클라이언트가 FIN_WAIT_2 상태에서 서버의 FIN을 무한정 기다리지 않습니다. 타임아웃 후(일반적으로 수 분) 연결을 강제 종료합니다.\n\n**실무 고려사항:**\n서버 재시작 시 TIME_WAIT 상태의 소켓들이 포트를 점유할 수 있습니다. SO_REUSEADDR 옵션으로 포트를 즉시 재사용할 수 있습니다. 하지만 보안과 안정성을 위해 TIME_WAIT는 중요합니다.\n\n**패킷 캡처 예시:**\nWireshark에서 정상 종료 시 [F.], [.], [F.], [.] 플래그 순서를 볼 수 있습니다. 비정상 종료 시 [R.] 플래그를 볼 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "TCP"
      ],
      "id": "1763437633066-005i7fad",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?",
      "answer": "패킷이 4-Way Handshake인지는 **TCP 헤더의 플래그 비트와 연결 상태**를 확인하여 파악합니다.\n\n**FIN 플래그 확인:**\n4-Way Handshake의 핵심은 FIN 플래그입니다. TCP 헤더의 제어 플래그에서 FIN 비트가 1인지 확인합니다. FIN이 설정된 패킷은 연결 종료 관련 패킷입니다.\n\n**플래그 조합으로 단계 구분:**\n\n**1단계 - 첫 FIN:**\nFIN 플래그만 설정되어 있습니다(일반적으로 ACK도 함께). 플래그: [F.] 또는 [FA] (FIN + ACK). 이전 데이터에 대한 ACK와 함께 FIN이 올 수 있습니다.\n\n**2단계 - FIN에 대한 ACK:**\nACK 플래그만 설정됩니다. 플래그: [.] 또는 [A]. ACK 번호가 받은 FIN의 순서 번호 + 1입니다. 이 시점에서는 일반 데이터 ACK와 구별하기 어려울 수 있습니다.\n\n**3단계 - 두 번째 FIN:**\n반대 방향에서 FIN 플래그가 설정됩니다. 플래그: [F.] 또는 [FA]. 서버가 클라이언트에게 종료를 알립니다.\n\n**4단계 - 두 번째 FIN에 대한 ACK:**\nACK 플래그가 설정됩니다. 플래그: [.] 또는 [A]. 이것이 연결 종료의 마지막 패킷입니다.\n\n**순서 번호와 ACK 번호 추적:**\nFIN도 순서 번호를 소비합니다(1 바이트처럼 계산). FIN의 Seq=X를 받으면 ACK=X+1로 응답합니다. 순서 번호의 흐름을 추적하면 종료 과정을 명확히 파악할 수 있습니다.\n\n**연결 상태 추적:**\n상태 기반 방화벽이나 모니터링 도구는 각 연결의 상태를 추적합니다. ESTABLISHED 상태에서 FIN을 받으면 종료 과정 시작으로 인식합니다. FIN_WAIT, CLOSE_WAIT 등의 상태로 전환됩니다.\n\n**방향성 확인:**\n누가 먼저 종료를 시작했는지 확인합니다. 첫 FIN의 송신자가 능동 종료(Active Close)를 수행합니다. 반대쪽은 수동 종료(Passive Close)를 수행합니다.\n\n**타이밍 분석:**\nFIN 패킷들 사이의 시간 간격을 확인합니다. 정상적인 종료는 일정한 패턴을 보입니다. 비정상적으로 긴 간격은 문제를 나타낼 수 있습니다.\n\n**Wireshark에서 파악:**\n\n**Info 컬럼:**\nWireshark는 패킷의 의미를 해석하여 표시합니다. \"[FIN, ACK]\"로 표시되어 종료 패킷임을 알 수 있습니다.\n\n**Stream 추적:**\n\"Follow TCP Stream\"으로 특정 연결의 전체 흐름을 볼 수 있습니다. 연결 수립(SYN), 데이터 전송, 연결 종료(FIN) 과정을 시간순으로 확인합니다.\n\n**필터 사용:**\n\"tcp.flags.fin == 1\"로 FIN 패킷만 필터링합니다. 특정 연결의 종료 과정만 집중해서 볼 수 있습니다.\n\n**프로그래밍적 파악:**\n패킷 캡처 라이브러리(libpcap, Scapy)를 사용할 때 TCP 헤더를 파싱합니다. 플래그 필드의 FIN 비트(0x01)를 확인합니다.\n\n**운영체제 레벨:**\nnetstat 명령으로 현재 연결 상태를 확인합니다. FIN_WAIT, TIME_WAIT, CLOSE_WAIT 상태는 종료 중임을 나타냅니다.\n\n**비정상 종료 구별:**\nRST 플래그가 설정된 패킷은 4-Way Handshake가 아닌 강제 종료입니다. 플래그: [R.] 또는 [RA]. RST는 즉시 연결을 끊으며 확인 응답이 없습니다.\n\n**동시 종료:**\n양쪽에서 거의 동시에 FIN이 전송되는 경우도 있습니다. 두 개의 FIN과 두 개의 ACK가 다른 순서로 나타날 수 있습니다. 최종적으로는 양쪽 모두 종료됩니다.\n\n**실무 활용:**\n네트워크 문제 진단 시 연결이 정상 종료되는지 확인합니다. FIN을 보냈지만 ACK를 받지 못하면 네트워크 문제나 상대방 크래시를 의심합니다. TIME_WAIT 상태가 과도하게 많으면 서버 설정을 조정합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-hz5ksah8",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?",
      "answer": "빠르게 연결을 종료해야 할 때는 **RST(Reset) 패킷**을 사용합니다.\n\n**RST의 역할:**\nRST는 TCP 연결을 즉시 강제 종료합니다. 4-Way Handshake 없이 일방적으로 연결을 끊습니다. 확인 응답을 기다리지 않으며, 상대방도 응답하지 않습니다.\n\n**RST 전송 상황:**\n\n**1. 애플리케이션의 명시적 요청:**\nSO_LINGER 소켓 옵션을 linger=0으로 설정하고 close()를 호출합니다. 버퍼에 남은 데이터를 버리고 즉시 RST를 보냅니다. 강제 종료가 필요한 특수한 경우에 사용합니다.\n\n**2. 존재하지 않는 포트 접근:**\n서버에서 리스닝하지 않는 포트로 SYN이 도착하면 RST로 응답합니다. \"해당 포트는 열려있지 않습니다\"라는 의미입니다. 포트 스캐닝에서 닫힌 포트를 감지하는 방법입니다.\n\n**3. 반쪽 열린 연결(Half-Open Connection):**\n한쪽이 크래시된 후 재부팅했을 때 상대방이 데이터를 보내면 RST로 응답합니다. \"이 연결을 모르겠습니다\"라는 의미입니다.\n\n**4. 잘못된 세그먼트:**\n예상하지 못한 순서 번호나 잘못된 ACK를 받으면 RST를 보낼 수 있습니다. 연결 상태가 맞지 않는 패킷을 거부합니다.\n\n**5. 타임아웃:**\n일부 구현은 연결이 오래 유휴 상태일 때 FIN 대신 RST로 종료합니다.\n\n**6. 보안 정책:**\n방화벽이나 IDS가 악의적인 연결을 차단할 때 RST를 보냅니다.\n\n**RST의 동작:**\nRST 플래그가 1로 설정된 세그먼트를 전송합니다. 플래그 표시: [R] 또는 [R.] 또는 [RA]. 송신 버퍼와 수신 버퍼의 데이터를 모두 버립니다. 양쪽 모두 즉시 CLOSED 상태로 전환합니다. TIME_WAIT 상태가 없습니다.\n\n**RST의 장점:**\n즉각적인 연결 종료로 자원을 빠르게 회수합니다. 비정상 상태의 연결을 정리할 수 있습니다. 오버헤드가 최소화됩니다(1개 패킷).\n\n**RST의 단점:**\n버퍼에 남은 데이터가 손실됩니다. 상대방이 이미 보낸 데이터도 받지 못할 수 있습니다. 비정상 종료로 간주되어 애플리케이션이 오류를 인식합니다. TIME_WAIT 없이 즉시 포트를 재사용하면 이전 연결의 지연 패킷 문제가 발생할 수 있습니다.\n\n**정상 종료와의 비교:**\n- **4-Way Handshake**: 모든 데이터 전송 보장, 우아한 종료(Graceful Shutdown), 양쪽 합의\n- **RST**: 즉시 종료, 데이터 손실 가능, 일방적 종료\n\n**프로그래밍 예시:**\n일반적인 close()는 4-Way Handshake를 수행합니다. SO_LINGER를 사용하여 RST 강제 종료를 선택할 수 있습니다. shutdown() 함수로 half-close를 수행한 후 close()를 호출할 수도 있습니다.\n\n**실무 권장:**\n가능하면 정상적인 4-Way Handshake를 사용해야 합니다. RST는 예외적인 상황이나 보안 목적으로만 사용합니다. 데이터 무결성이 중요한 애플리케이션은 반드시 정상 종료를 해야 합니다.\n\n**클라이언트 측 경험:**\nRST를 받은 애플리케이션은 \"Connection reset by peer\" 오류를 받습니다. 이는 상대방이 강제로 연결을 끊었다는 의미입니다. 애플리케이션은 이를 적절히 처리해야 합니다(재시도, 오류 표시 등).\n\n**서버 측 고려사항:**\n서버가 과부하 상태에서 새 연결을 RST로 거부할 수 있습니다. 백로그 큐가 가득 찬 경우 SYN에 RST로 응답합니다. 클라이언트는 \"Connection refused\" 오류를 받습니다.\n\n**보안 측면:**\nRST는 공격에도 사용될 수 있습니다. TCP RST 공격: 위조된 RST 패킷으로 정상 연결을 끊습니다. 방어: 순서 번호 검증을 강화합니다.\n\n**실무 진단:**\n패킷 캡처에서 예상치 못한 RST가 나타나면 문제를 조사해야 합니다. 방화벽 정책, 서버 크래시, 애플리케이션 버그 등을 확인합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP"
      ],
      "id": "1763437633066-t8v5bk7v",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?",
      "answer": "한쪽이 강제로 종료되면 반대쪽은 **타임아웃과 재전송 메커니즘, 킵얼라이브**를 통해 인식합니다.\n\n**시나리오별 분석:**\n\n**시나리오 1 - FIN 전송 후 크래시:**\n클라이언트가 FIN을 보낸 후 크래시됩니다. 서버가 ACK를 보내도 응답이 없습니다. 서버가 자신의 FIN을 보내도 ACK를 받지 못합니다.\n\n**서버의 인식 과정:**\n서버는 FIN에 대한 ACK를 받지 못해 재전송을 시도합니다. 일정 횟수(일반적으로 5-8회) 재전송 후 타임아웃됩니다. 타임아웃 시간은 지수 백오프로 증가합니다(1초, 2초, 4초, 8초...). 최종적으로 연결이 비정상 종료되었다고 판단하고 정리합니다.\n\n**시나리오 2 - ACK 전송 후 크래시:**\n클라이언트가 서버의 FIN에 ACK를 보낸 직후 크래시됩니다. 서버는 ACK를 받아 정상 종료합니다. 클라이언트만 비정상 상태로 남습니다.\n\n**이 경우 문제:**\n서버는 정상 종료로 인식하지만 클라이언트는 TIME_WAIT 없이 사라집니다. 이전 연결의 지연 패킷이 새 연결에 영향을 줄 위험이 있습니다. 하지만 클라이언트 재시작 시 새로운 포트를 사용하므로 실질적 문제는 적습니다.\n\n**시나리오 3 - ESTABLISHED 상태에서 크래시:**\n정상 통신 중에 한쪽이 갑자기 크래시됩니다. 운영체제가 종료되거나 네트워크 케이블이 뽑힙니다. 어떤 종료 패킷(FIN, RST)도 보내지 못합니다.\n\n**반대쪽의 인식:**\n\n**데이터 전송 시도 시:**\n크래시를 모르고 데이터를 계속 보냅니다. ACK를 받지 못해 재전송을 시도합니다. 재전송 타임아웃(RTO)이 지수적으로 증가합니다. 일정 시간(몇 분에서 십수 분) 후 최종 타임아웃됩니다. \"Connection timed out\" 오류가 발생합니다.\n\n**데이터 전송이 없을 때:**\n아무것도 보낼 데이터가 없으면 상대방의 크래시를 모릅니다. 연결이 ESTABLISHED 상태로 남아있습니다. 이를 \"Dead Connection\" 또는 \"Zombie Connection\"이라고 합니다.\n\n**TCP Keep-Alive 메커니즘:**\n\n**목적:**\n오랫동안 유휴 상태인 연결이 여전히 유효한지 확인합니다. Dead Connection을 감지하고 정리합니다.\n\n**동작 방식:**\n일정 시간(기본 2시간) 동안 데이터 전송이 없으면 Keep-Alive 프로브를 보냅니다. 작은 패킷(1 바이트)을 전송하여 상대방의 응답을 확인합니다. 응답이 오면 연결이 살아있다고 판단합니다.\n\n**응답 없을 때:**\n일정 간격(기본 75초)으로 여러 번(기본 9회) 재시도합니다. 모두 실패하면 연결을 종료합니다. 애플리케이션에 \"Connection timed out\" 오류를 알립니다.\n\n**Keep-Alive 설정:**\nSO_KEEPALIVE 소켓 옵션으로 활성화합니다. 시스템 설정으로 간격과 횟수를 조정할 수 있습니다. 리눅스: tcp_keepalive_time, tcp_keepalive_intvl, tcp_keepalive_probes.\n\n**한계:**\n기본 설정으로는 2시간 이상 걸려 느립니다. 모든 애플리케이션이 활성화하지 않습니다.\n\n**애플리케이션 레벨 Heartbeat:**\nTCP Keep-Alive 대신 애플리케이션이 직접 heartbeat 메시지를 교환합니다. 주기적으로(예: 30초마다) ping/pong 메시지를 보냅니다. 응답이 없으면 빠르게 연결을 끊고 재연결합니다. 웹소켓, MQTT, gRPC 등에서 사용합니다.\n\n**ICMP 오류:**\n경우에 따라 ICMP 메시지로 인식할 수 있습니다. 상대방 호스트가 다운되면 라우터가 \"Destination Unreachable\"을 보낼 수 있습니다. TCP는 이를 받아 연결 종료를 판단합니다.\n\n**RST 수신:**\n상대방이 재부팅 후 데이터를 받으면 \"알 수 없는 연결\"로 판단하고 RST를 보냅니다. 이를 받으면 즉시 연결이 끊어졌음을 인식합니다.\n\n**실무 권장사항:**\n중요한 연결은 애플리케이션 레벨 heartbeat를 구현합니다. Keep-Alive를 활성화하되 간격을 짧게 조정합니다(예: 60초). 재연결 로직을 구현하여 연결 끊김에 자동 대응합니다. 타임아웃 설정을 적절히 조정합니다.\n\n**로드밸런서와 프록시:**\n중간 장비들도 유휴 연결을 타임아웃시킬 수 있습니다. 로드밸런서의 idle timeout보다 짧은 주기로 heartbeat를 보내야 합니다.\n\n**클라우드 환경:**\nAWS ELB, Azure Load Balancer 등은 기본 idle timeout(보통 60초)이 있습니다. 이를 고려하여 애플리케이션 설계를 해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP"
      ],
      "id": "1763437633066-4s1hwl00",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?",
      "answer": "**TIME_WAIT 상태**는 TCP 연결 종료 후 일정 시간(2MSL) 동안 대기하는 것으로, 두 가지 중요한 목적이 있습니다.\n\n**목적 1 - 마지막 ACK의 재전송 대비:**\n\n**문제 상황:**\n클라이언트가 서버의 FIN에 대해 마지막 ACK를 보냅니다. 이 ACK가 네트워크에서 손실될 수 있습니다. 서버는 ACK를 받지 못하면 FIN을 재전송합니다. 클라이언트가 이미 CLOSED 상태라면 재전송된 FIN을 처리할 수 없습니다.\n\n**TIME_WAIT의 해결:**\n클라이언트가 TIME_WAIT 상태로 연결 정보를 유지합니다. 서버의 FIN 재전송을 받으면 ACK를 다시 보냅니다. 서버가 최종적으로 정상 종료할 수 있도록 보장합니다. 우아한 종료(Graceful Shutdown)를 완성합니다.\n\n**목적 2 - 지연된 패킷으로부터 보호:**\n\n**문제 상황:**\n이전 연결의 패킷이 네트워크에서 지연되어 나중에 도착할 수 있습니다. 같은 포트 조합으로 새 연결이 즉시 수립되면 문제가 발생합니다. 지연된 패킷이 새 연결의 데이터로 오인되어 데이터 손상이 일어날 수 있습니다.\n\n**TIME_WAIT의 해결:**\n2MSL(Maximum Segment Lifetime의 2배) 동안 대기합니다. MSL은 패킷이 네트워크에 존재할 수 있는 최대 시간입니다. 2MSL이 지나면 이전 연결의 모든 패킷이 소멸됩니다. 이후 같은 포트 조합을 안전하게 재사용할 수 있습니다.\n\n**MSL 시간:**\nRFC에서는 2분을 권장하지만 구현에 따라 다릅니다. 리눅스: 일반적으로 60초(2MSL = 120초)입니다. 윈도우: 일반적으로 120초(2MSL = 240초)입니다. 실제 네트워크에서 패킷이 2분 이상 살아있는 경우는 거의 없습니다.\n\n**누가 TIME_WAIT에 들어가나:**\n능동 종료(Active Close)를 수행한 쪽이 TIME_WAIT에 들어갑니다. 일반적으로 클라이언트가 먼저 close()를 호출하므로 클라이언트가 TIME_WAIT 상태가 됩니다. 서버는 CLOSED 상태로 즉시 전환되어 새 연결을 받을 수 있습니다.\n\n**서버가 TIME_WAIT에 들어가는 경우:**\n서버가 먼저 연결을 끊으면(예: 타임아웃) 서버가 TIME_WAIT 상태가 됩니다. 이 경우 같은 포트를 2MSL 동안 재사용할 수 없어 문제가 될 수 있습니다. 웹 서버, API 서버는 일반적으로 수동 종료하여 이를 피합니다.\n\n**TIME_WAIT 과다 문제:**\n\n**서버 측 문제:**\n서버가 많은 연결을 처리하다가 능동 종료하면 대량의 TIME_WAIT이 생성됩니다. 파일 디스크립터와 메모리를 소비합니다. 극단적인 경우 새 연결을 받을 수 없게 됩니다.\n\n**해결 방법:**\n서버가 수동 종료하도록 설계합니다(클라이언트가 먼저 FIN 보내도록). SO_REUSEADDR 소켓 옵션을 사용하여 TIME_WAIT 상태의 주소를 재사용합니다. 커널 파라미터 조정: tcp_tw_reuse, tcp_tw_recycle(주의: 일부는 deprecated).\n\n**클라이언트 측:**\n클라이언트는 매번 새로운 임시 포트를 사용하므로 TIME_WAIT이 큰 문제가 되지 않습니다. 하지만 고성능 클라이언트(로드 테스트 도구 등)는 포트 고갈 문제가 발생할 수 있습니다.\n\n**SO_REUSEADDR vs SO_REUSEPORT:**\n\n**SO_REUSEADDR:**\nTIME_WAIT 상태의 소켓 주소를 bind()할 수 있게 합니다. 서버 재시작 시 즉시 포트를 재사용할 수 있습니다. 일반적으로 서버 소켓에 설정합니다.\n\n**SO_REUSEPORT:**\n여러 소켓이 같은 주소를 bind()할 수 있게 합니다. 멀티프로세스 서버에서 로드 밸런싱에 사용됩니다.\n\n**TIME_WAIT Assassination:**\n일부 구현은 타임아웃을 조작하여 TIME_WAIT를 강제로 종료합니다. 위험한 방법이며 권장되지 않습니다. 데이터 무결성 문제를 일으킬 수 있습니다.\n\n**HTTP Keep-Alive와의 관계:**\nHTTP/1.1의 persistent connection은 연결을 재사용하여 TIME_WAIT을 줄입니다. 여러 요청을 하나의 TCP 연결로 처리하므로 종료 횟수가 감소합니다. 서버가 타임아웃으로 종료하면 서버가 TIME_WAIT에 들어가는 문제가 있습니다.\n\n**모니터링:**\nnetstat이나 ss 명령으로 TIME_WAIT 상태의 연결 수를 확인합니다. 비정상적으로 많으면 애플리케이션 설계를 검토해야 합니다.\n\n**실무 권장:**\nTIME_WAIT은 TCP의 중요한 안전장치입니다. 가능하면 자연스럽게 만료되도록 두는 것이 좋습니다. 성능 문제가 있을 때만 신중하게 조정합니다. 서버는 수동 종료, 클라이언트는 능동 종료 패턴을 따릅니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP"
      ],
      "id": "1763437633066-tw2ndu4t",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.",
      "answer": "브라우저에 URL을 입력하고 엔터를 치면 매우 복잡하고 다층적인 **네트워크 통신 과정**이 진행됩니다.\n\n**1단계 - URL 파싱:**\n브라우저가 입력된 문자열을 분석합니다. 프로토콜(https://), 도메인(www.github.com), 포트(생략 시 443), 경로(/)를 식별합니다. 유효하지 않은 URL이면 검색 엔진으로 리다이렉트합니다.\n\n**2단계 - HSTS 확인:**\n브라우저가 HSTS(HTTP Strict Transport Security) 목록을 확인합니다. github.com이 HSTS에 등록되어 있으면 자동으로 HTTPS를 사용합니다. HTTP로 접속 시도를 방지하여 보안을 강화합니다.\n\n**3단계 - DNS 조회:**\n\n**브라우저 캐시 확인:**\n브라우저가 자체 DNS 캐시를 먼저 확인합니다. 최근에 방문했다면 캐시된 IP 주소를 사용합니다.\n\n**운영체제 캐시 확인:**\n브라우저 캐시에 없으면 OS의 DNS 캐시를 확인합니다. hosts 파일도 확인합니다(/etc/hosts 또는 C:\\Windows\\System32\\drivers\\etc\\hosts).\n\n**DNS 리졸버에 쿼리:**\n캐시에 없으면 설정된 DNS 리졸버(보통 ISP 또는 8.8.8.8)에 쿼리를 보냅니다. UDP 53번 포트로 DNS 쿼리 패킷을 전송합니다.\n\n**재귀적 DNS 조회:**\nDNS 리졸버가 루트 DNS 서버에 문의합니다. 루트 서버가 .com TLD 서버 주소를 알려줍니다. TLD 서버가 github.com의 네임서버 주소를 알려줍니다. github.com 네임서버가 www.github.com의 실제 IP 주소를 반환합니다(예: 140.82.121.4).\n\n**응답 캐싱:**\n받은 IP 주소를 TTL 동안 캐시합니다. 다음 접속 시 빠르게 사용할 수 있습니다.\n\n**4단계 - TCP 연결 수립(3-Way Handshake):**\n\n**라우팅 결정:**\n클라이언트가 목적지 IP(140.82.121.4)가 같은 네트워크인지 확인합니다. 다른 네트워크이므로 기본 게이트웨이(공유기)로 전송합니다.\n\n**ARP 조회:**\n게이트웨이의 IP는 알지만 MAC 주소를 모르면 ARP 요청을 브로드캐스트합니다. 게이트웨이가 자신의 MAC 주소를 응답합니다.\n\n**SYN 전송:**\n클라이언트가 임시 포트(예: 54321)를 선택하고 SYN 패킷을 보냅니다. 목적지: 140.82.121.4:443, 송신: 클라이언트IP:54321. 패킷이 게이트웨이, ISP, 인터넷 백본을 거쳐 GitHub 서버로 전달됩니다.\n\n**SYN-ACK 수신:**\nGitHub 서버가 SYN-ACK를 응답합니다. 클라이언트가 받습니다.\n\n**ACK 전송:**\n클라이언트가 ACK를 보내 연결을 완료합니다. TCP 연결이 ESTABLISHED 상태가 됩니다.\n\n**5단계 - TLS/SSL Handshake:**\n\n**ClientHello:**\n클라이언트가 지원하는 TLS 버전, 암호화 스위트, 난수를 보냅니다.\n\n**ServerHello:**\n서버가 선택한 TLS 버전, 암호화 스위트, 난수, 인증서를 보냅니다. 인증서에는 서버의 공개키와 CA 서명이 포함됩니다.\n\n**인증서 검증:**\n브라우저가 인증서 체인을 검증합니다. CA의 공개키(브라우저에 내장)로 서명을 확인합니다. 도메인 이름, 유효 기간, 폐기 여부(OCSP)를 확인합니다.\n\n**키 교환:**\n클라이언트가 Pre-Master Secret을 서버 공개키로 암호화하여 전송합니다. 양쪽이 이를 기반으로 세션 키를 생성합니다.\n\n**Finished 메시지:**\n암호화된 연결이 수립되었음을 확인합니다. 이제 모든 데이터가 암호화됩니다.\n\n**6단계 - HTTP 요청:**\n\n**HTTP/2 협상:**\nALPN(Application-Layer Protocol Negotiation)으로 HTTP/2 사용을 협상합니다.\n\n**GET 요청 전송:**\n클라이언트가 암호화된 HTTP GET 요청을 보냅니다. 헤더: Host, User-Agent, Accept, Cookie 등.\n\n**7단계 - 서버 처리:**\nGitHub 서버(실제로는 로드 밸런서)가 요청을 받습니다. 적절한 백엔드 서버로 라우팅합니다. 애플리케이션이 요청을 처리하고 HTML을 생성합니다.\n\n**8단계 - HTTP 응답:**\n서버가 HTTP 응답을 보냅니다. 상태 코드 200, 헤더(Content-Type, Content-Length, Set-Cookie 등), HTML 본문. 암호화되어 전송됩니다.\n\n**9단계 - 추가 리소스 요청:**\n\n**HTML 파싱:**\n브라우저가 HTML을 파싱하며 추가 리소스를 발견합니다(CSS, JavaScript, 이미지 등).\n\n**병렬 요청:**\nHTTP/2의 멀티플렉싱으로 여러 리소스를 동시에 요청합니다. 같은 TCP 연결을 재사용합니다.\n\n**10단계 - 렌더링:**\n브라우저가 DOM 트리와 CSSOM 트리를 구축합니다. 렌더 트리를 생성하고 레이아웃을 계산합니다. 화면에 픽셀을 그립니다(Painting). JavaScript를 실행하여 동적 콘텐츠를 처리합니다.\n\n**중간 장비들:**\n\n**NAT:**\n공유기가 사설 IP를 공인 IP로 변환합니다. 포트 번호로 여러 기기를 구별합니다.\n\n**방화벽:**\n패킷을 검사하고 정책에 따라 허용/차단합니다.\n\n**라우터:**\n최적 경로를 계산하고 패킷을 다음 홉으로 전달합니다. 수십 개의 라우터를 거칠 수 있습니다.\n\n**로드 밸런서:**\nGitHub의 엣지 서버가 요청을 여러 백엔드에 분산합니다.\n\n**CDN:**\n정적 리소스는 CDN에서 제공될 수 있습니다. 지리적으로 가까운 서버에서 받아 속도를 향상시킵니다.\n\n**소요 시간:**\n전체 과정은 일반적으로 수백 ms에서 1-2초 정도 걸립니다. DNS: 20-120ms, TCP+TLS: 100-300ms, HTTP: 50-500ms, 렌더링: 100-1000ms.\n\n**실제로는 더 복잡:**\nHTTP/3 사용 시 QUIC 프로토콜이 추가됩니다. 서비스 워커, 캐시, 프리페칭 등이 개입할 수 있습니다. 광고, 분석 스크립트 등 서드파티 리소스도 로드됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP"
      ],
      "id": "1763437633066-finiz86v",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?",
      "answer": "DNS 쿼리로 얻은 IP 주소는 일반적으로 **실제 웹 서버가 아닌 여러 중간 인프라**를 가리킵니다.\n\n**소규모 웹사이트:**\n개인 블로그나 작은 서비스는 실제 웹 서버의 IP를 직접 가리킬 수 있습니다. 단일 서버에서 웹 서버 소프트웨어(Apache, Nginx)가 직접 동작합니다. 이 경우 DNS IP = 실제 서버 IP입니다.\n\n**대규모 서비스(GitHub, Google 등):**\n\n**로드 밸런서:**\nDNS가 반환하는 IP는 일반적으로 로드 밸런서의 IP입니다. 로드 밸런서가 사용자 요청을 받아 여러 백엔드 서버 중 하나로 분배합니다. L4(TCP 레벨) 또는 L7(HTTP 레벨) 로드 밸런서가 사용됩니다. AWS ELB, Google Cloud Load Balancer, Nginx Plus 등이 있습니다.\n\n**리버스 프록시:**\n로드 밸런서 뒤에 리버스 프록시(Nginx, HAProxy, Varnish)가 있을 수 있습니다. 캐싱, SSL/TLS 종료, 요청 라우팅 등을 수행합니다. 실제 애플리케이션 서버는 그 뒤에 숨어 있습니다.\n\n**CDN(Content Delivery Network):**\n정적 콘텐츠를 제공하는 사이트는 CDN의 엣지 서버 IP를 반환할 수 있습니다. Cloudflare, Akamai, Fastly, AWS CloudFront 등이 있습니다. 사용자와 지리적으로 가까운 엣지 서버의 IP를 받습니다. 실제 원본(Origin) 서버는 CDN 뒤에 숨어 있습니다.\n\n**Anycast IP:**\n하나의 IP 주소를 전 세계 여러 위치에서 동시에 사용합니다. 라우팅 프로토콜(BGP)이 가장 가까운 서버로 트래픽을 전달합니다. DNS 서비스(8.8.8.8), CDN, DDoS 방어 서비스에 사용됩니다. 같은 IP라도 접속 위치에 따라 다른 물리 서버로 연결됩니다.\n\n**지리적 DNS(GeoDNS):**\n사용자의 위치에 따라 다른 IP를 반환합니다. 서울에서 쿼리하면 한국 데이터센터 IP를, 뉴욕에서 쿼리하면 미국 데이터센터 IP를 받습니다. 지연 시간을 최소화하고 사용자 경험을 향상시킵니다.\n\n**멀티 IP 응답:**\n하나의 도메인에 여러 IP 주소를 설정할 수 있습니다. DNS Round Robin으로 간단한 로드 밸런싱을 구현합니다. 브라우저는 여러 IP 중 하나를 선택하거나 순서대로 시도합니다.\n\n**클라우드 환경:**\n\n**AWS:**\nELB의 IP 주소를 받습니다. ELB는 여러 가용 영역(AZ)의 EC2 인스턴스로 분배합니다.\n\n**Google Cloud:**\nCloud Load Balancer의 글로벌 Anycast IP를 받습니다. 가장 가까운 리전의 백엔드로 연결됩니다.\n\n**Azure:**\nTraffic Manager 또는 Application Gateway의 IP를 받습니다.\n\n**실제 예시 - github.com:**\nDNS 쿼리 시 140.82.121.4 같은 IP를 받습니다. 이는 GitHub의 로드 밸런서 또는 CDN 엣지 서버입니다. 실제 애플리케이션 서버는 내부 네트워크에 있으며 외부에서 직접 접근할 수 없습니다.\n\n**보안 목적:**\n실제 서버를 숨김으로써 DDoS 공격으로부터 보호합니다. 로드 밸런서나 CDN이 공격 트래픽을 필터링합니다. 실제 서버의 IP는 비공개로 유지됩니다.\n\n**동적 변경:**\nDNS TTL이 짧으면 IP를 자주 변경할 수 있습니다. 트래픽 분산, 장애 대응, 유지보수를 위해 IP를 바꿉니다. 사용자는 이를 인식하지 못합니다.\n\n**CNAME 레코드:**\n일부 도메인은 CNAME으로 다른 도메인을 가리킵니다. 예: www.example.com → example.cdn.cloudflare.net → 실제 IP. 여러 단계의 리다이렉션이 있을 수 있습니다.\n\n**확인 방법:**\nnslookup, dig, host 명령으로 DNS 조회 결과를 확인합니다. traceroute로 실제 네트워크 경로를 추적합니다. HTTP 응답 헤더(Server, X-Served-By)로 어떤 인프라가 사용되는지 힌트를 얻습니다.\n\n**결론:**\nDNS IP는 대부분 프론트엔드 인프라(로드 밸런서, CDN, 프록시)를 가리키며, 실제 애플리케이션 서버는 그 뒤에 보호되어 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633066-q8rnq7mx",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "Web Server와 Web Application Server의 차이에 대해 설명해 주세요.",
      "answer": "**웹 서버(Web Server)**와 **웹 애플리케이션 서버(WAS, Web Application Server)**는 서로 다른 역할과 기능을 가진 서버 소프트웨어입니다.\n\n**웹 서버(Web Server):**\n\n**정의:**\nHTTP 프로토콜을 사용하여 클라이언트 요청을 처리하고 정적 콘텐츠를 제공하는 서버입니다.\n\n**주요 기능:**\n정적 파일(HTML, CSS, JavaScript, 이미지, 비디오) 제공합니다. HTTP 요청/응답 처리를 담당합니다. 리버스 프록시로 요청을 다른 서버로 전달합니다. SSL/TLS 종료, 캐싱, 로드 밸런싱을 수행합니다.\n\n**대표 소프트웨어:**\nApache HTTP Server, Nginx, Microsoft IIS, LiteSpeed.\n\n**처리 방식:**\n클라이언트가 /index.html을 요청하면 파일 시스템에서 파일을 읽어 그대로 전송합니다. 동적 처리 없이 저장된 내용을 빠르게 제공합니다.\n\n**웹 애플리케이션 서버(WAS):**\n\n**정의:**\n비즈니스 로직을 실행하고 동적 콘텐츠를 생성하는 서버입니다. 일반적으로 웹 서버 기능도 포함합니다.\n\n**주요 기능:**\n동적 콘텐츠 생성(DB 조회, 계산, 데이터 처리)을 수행합니다. 비즈니스 로직 실행(결제, 인증, 데이터 검증 등)을 담당합니다. 트랜잭션 관리, 세션 관리를 수행합니다. 데이터베이스 연결 풀 관리를 합니다. 여러 프로토콜 지원(HTTP, RMI, CORBA 등)을 제공합니다.\n\n**대표 소프트웨어:**\nJava: Tomcat, JBoss, WebLogic, WebSphere. .NET: IIS + ASP.NET. Python: Gunicorn, uWSGI. Node.js: Express, Koa. PHP: PHP-FPM.\n\n**처리 방식:**\n클라이언트가 /users/123을 요청하면 애플리케이션 코드가 실행됩니다. 데이터베이스에서 사용자 정보를 조회합니다. 템플릿을 사용하여 HTML을 동적으로 생성합니다. 생성된 HTML을 응답으로 보냅니다.\n\n**주요 차이점:**\n\n**콘텐츠 타입:**\n- **웹 서버**: 정적 콘텐츠 중심\n- **WAS**: 동적 콘텐츠 중심\n\n**비즈니스 로직:**\n- **웹 서버**: 비즈니스 로직 실행 불가\n- **WAS**: 복잡한 비즈니스 로직 실행 가능\n\n**리소스 사용:**\n- **웹 서버**: 가볍고 빠름, 메모리/CPU 사용량 적음\n- **WAS**: 무겁고 복잡함, 더 많은 리소스 필요\n\n**확장성:**\n- **웹 서버**: 수평 확장 용이, 상태 비저장\n- **WAS**: 세션 관리 등으로 확장이 더 복잡함\n\n**전형적인 아키텍처:**\n\n**2-Tier 구조:**\n클라이언트 → WAS (WAS가 웹 서버 역할 포함). 소규모 애플리케이션에 적합합니다.\n\n**3-Tier 구조:**\n클라이언트 → 웹 서버 → WAS → 데이터베이스. 대규모 애플리케이션의 표준 구조입니다.\n\n**역할 분담:**\n웹 서버(Nginx)가 정적 파일을 직접 제공합니다. 동적 요청만 WAS(Tomcat)로 프록시합니다. WAS는 비즈니스 로직에만 집중합니다.\n\n**3-Tier의 장점:**\n\n**성능 향상:**\n정적 파일은 빠른 웹 서버가 처리하여 WAS 부하를 줄입니다. WAS는 동적 처리에만 리소스를 사용합니다.\n\n**보안 강화:**\n웹 서버가 외부에 노출되고 WAS는 내부 네트워크에 위치합니다. 웹 서버에서 기본적인 공격을 필터링합니다.\n\n**확장성:**\n웹 서버와 WAS를 독립적으로 스케일링할 수 있습니다. 로드 밸런서로 여러 WAS 인스턴스에 분산합니다.\n\n**유지보수:**\nWAS 재시작 시 웹 서버가 정적 콘텐츠를 계속 제공합니다. 무중단 배포가 용이합니다.\n\n**실무 예시:**\n\n**Nginx + Tomcat:**\nNginx가 80/443 포트로 요청을 받습니다. *.jsp, /api/* 요청은 Tomcat(8080)으로 프록시합니다. *.html, *.css, *.js, 이미지는 Nginx가 직접 제공합니다.\n\n**Apache + PHP-FPM:**\nApache가 프론트엔드로 동작합니다. PHP 요청은 FastCGI로 PHP-FPM에 전달합니다.\n\n**최신 트렌드:**\n\n**서버리스:**\nAWS Lambda, Google Cloud Functions 등은 WAS를 추상화합니다. 개발자는 비즈니스 로직만 작성합니다.\n\n**컨테이너:**\nDocker로 웹 서버와 WAS를 컨테이너화합니다. Kubernetes로 오케스트레이션합니다.\n\n**마이크로서비스:**\n모놀리식 WAS 대신 작은 서비스들로 분리합니다. API 게이트웨이가 웹 서버 역할을 합니다.\n\n**선택 기준:**\n정적 사이트만 필요하면 웹 서버만 사용합니다. 동적 기능이 필요하면 WAS를 추가합니다. 트래픽이 많으면 웹 서버 + WAS 분리 구조를 사용합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-ooebgapx",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "URL, URI, URN은 어떤 차이가 있나요?",
      "answer": "**URI(Uniform Resource Identifier)**, **URL(Uniform Resource Locator)**, **URN(Uniform Resource Name)**은 리소스를 식별하는 서로 다른 방식입니다.\n\n**URI (Uniform Resource Identifier):**\n\n**정의:**\n리소스를 고유하게 식별하는 문자열의 총칭입니다. URL과 URN을 모두 포함하는 상위 개념입니다.\n\n**구성:**\nScheme + Authority + Path + Query + Fragment로 이루어집니다. 리소스를 \"무엇\"으로 식별하는지에 관계없이 모든 식별자를 포함합니다.\n\n**예시:**\n- https://www.example.com/path/to/resource\n- mailto:user@example.com\n- urn:isbn:0-486-27557-4\n- tel:+1-816-555-1212\n\n**URL (Uniform Resource Locator):**\n\n**정의:**\n리소스의 **위치**를 나타내는 URI의 한 종류입니다. 리소스를 \"어디서\" 찾을 수 있는지 명시합니다.\n\n**구성 요소:**\n- **Scheme(Protocol)**: http, https, ftp, mailto 등\n- **Authority**: 사용자 정보(선택), 호스트(도메인 또는 IP), 포트(선택)\n- **Path**: 리소스의 경로\n- **Query**: 쿼리 파라미터(선택)\n- **Fragment**: 문서 내 특정 부분(선택)\n\n**예시:**\n- https://www.example.com:443/path/to/resource?key=value#section\n- ftp://ftp.example.com/file.zip\n- file:///C:/Users/Documents/file.txt\n\n**특징:**\n위치 기반이므로 리소스가 이동하면 URL이 변경됩니다. 네트워크에서 리소스에 접근하는 방법을 제공합니다.\n\n**URN (Uniform Resource Name):**\n\n**정의:**\n리소스의 **이름**으로 식별하는 URI의 한 종류입니다. 위치와 무관하게 리소스를 고유하게 식별합니다.\n\n**구성:**\nurn:namespace:specific-string 형식을 사용합니다.\n\n**예시:**\n- urn:isbn:0451450523 (책의 ISBN)\n- urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66\n- urn:ietf:rfc:3986 (RFC 문서)\n\n**특징:**\n리소스의 위치가 변경되어도 URN은 동일합니다. 영구적이고 위치 독립적인 식별자입니다. 하지만 URN만으로는 리소스에 접근할 수 없고, 별도의 해석 메커니즘이 필요합니다.\n\n**관계:**\n\n**포함 관계:**\nURI는 최상위 개념입니다. URI는 URL과 URN을 포함합니다. 모든 URL은 URI이지만, 모든 URI가 URL은 아닙니다. 모든 URN은 URI이지만, 모든 URI가 URN은 아닙니다.\n\n**벤 다이어그램:**\n```\n         URI\n    ┌───────────┐\n    │  ┌─URL─┐  │\n    │  │     │  │\n    │  └─────┘  │\n    │  ┌─URN─┐  │\n    │  │     │  │\n    │  └─────┘  │\n    └───────────┘\n```\n\n**실제 예시 비교:**\n\n**URL이면서 URI:**\nhttps://www.example.com/users/123 - 위치를 나타내므로 URL이고, 식별자이므로 URI입니다.\n\n**URN이면서 URI:**\nurn:isbn:0-486-27557-4 - 이름으로 식별하므로 URN이고, 식별자이므로 URI입니다.\n\n**URI이지만 명확히 URL/URN이 아닌 경우:**\n현대적으로는 거의 모든 URI가 URL 또는 URN으로 분류되지만, 이론적으로는 중간 영역도 존재합니다.\n\n**실무에서의 사용:**\n\n**용어 선택:**\n대부분의 경우 \"URL\"이라고 부릅니다. 웹 개발에서는 URL이 압도적으로 많이 사용됩니다. 정확하게는 \"URI\"라고 해야 하지만 관습적으로 \"URL\"을 사용합니다.\n\n**REST API:**\nRESTful API의 엔드포인트는 정확히는 URI입니다. 하지만 \"API URL\"이라고 부르는 것이 일반적입니다.\n\n**URN의 사용:**\n실무에서 URN은 드물게 사용됩니다. ISBN, UUID, ISSN 등 표준 식별자 체계에서 주로 사용합니다. 도서관, 출판, 학술 분야에서 활용됩니다.\n\n**URI 구문 상세:**\n\n**일반 형식:**\nscheme:[//authority]path[?query][#fragment]\n\n**Authority 구성:**\n[userinfo@]host[:port]\n\n**실제 예시 분해:**\nhttps://user:pass@www.example.com:8080/path/to/resource?key1=value1&key2=value2#section1\n- Scheme: https\n- Userinfo: user:pass\n- Host: www.example.com\n- Port: 8080\n- Path: /path/to/resource\n- Query: key1=value1&key2=value2\n- Fragment: section1\n\n**인코딩:**\nURI에는 특수 문자가 포함될 수 있습니다. 퍼센트 인코딩(Percent Encoding)으로 변환합니다. 예: 공백 → %20, 한글 → UTF-8 인코딩 후 %로 표현합니다.\n\n**절대 URI vs 상대 URI:**\n- **절대 URI**: 완전한 정보 포함 (https://example.com/path)\n- **상대 URI**: 기준 URI를 기반으로 해석 (/path, ../other)\n\n**보안 고려사항:**\nURI에 민감한 정보(비밀번호, 토큰)를 포함하면 로그에 남을 수 있습니다. 쿼리 파라미터는 리퍼러 헤더에 노출될 수 있습니다. POST 바디나 헤더를 사용하는 것이 안전합니다.\n\n**SEO 관점:**\n의미 있는 URI 구조는 검색 엔진 최적화에 유리합니다. /users/123보다 /users/john-doe가 더 친화적입니다.\n\n**결론:**\n일상적으로는 URL이라는 용어를 사용하지만, 엄밀하게는 URI가 정확한 표현인 경우가 많습니다. URN은 특수한 식별 체계에서 사용됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-b7ssvq4x",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DNS에 대해 설명해 주세요.",
      "answer": "**DNS(Domain Name System)**는 사람이 읽을 수 있는 도메인 이름을 컴퓨터가 사용하는 IP 주소로 변환하는 시스템입니다.\n\n**필요성:**\nIP 주소(예: 192.0.2.1)는 기억하기 어렵습니다. 도메인 이름(예: www.example.com)은 직관적이고 기억하기 쉽습니다. IP 주소는 변경될 수 있지만 도메인 이름은 유지할 수 있습니다. DNS는 이 두 가지를 연결하는 인터넷의 전화번호부 역할을 합니다.\n\n**계층적 구조:**\n\n**루트 도메인(Root Domain):**\n최상위 계층으로 \".\"로 표현됩니다(일반적으로 생략). 전 세계에 13개의 루트 DNS 서버가 있습니다(논리적으로는 13개, 물리적으로는 수백 개가 분산). a.root-servers.net부터 m.root-servers.net까지 있습니다.\n\n**최상위 도메인(TLD, Top-Level Domain):**\n.com, .org, .net 같은 일반 TLD(gTLD)가 있습니다. .kr, .jp, .uk 같은 국가 코드 TLD(ccTLD)가 있습니다. .google, .samsung 같은 브랜드 TLD도 있습니다.\n\n**2차 도메인(Second-Level Domain):**\nexample.com에서 \"example\" 부분입니다. 조직이나 개인이 등록하는 도메인입니다.\n\n**서브도메인(Subdomain):**\nwww.example.com에서 \"www\" 부분입니다. 도메인 소유자가 자유롭게 생성할 수 있습니다.\n\n**FQDN(Fully Qualified Domain Name):**\n완전한 도메인 이름으로 www.example.com.(루트 포함)입니다.\n\n**DNS 레코드 타입:**\n\n**A 레코드:**\n도메인을 IPv4 주소로 매핑합니다. 예: example.com → 192.0.2.1\n\n**AAAA 레코드:**\n도메인을 IPv6 주소로 매핑합니다. 예: example.com → 2001:db8::1\n\n**CNAME 레코드:**\n도메인을 다른 도메인으로 매핑(별칭)합니다. 예: www.example.com → example.com\n\n**MX 레코드:**\n메일 서버를 지정합니다. 우선순위 값을 포함합니다.\n\n**TXT 레코드:**\n임의의 텍스트 정보를 저장합니다. SPF, DKIM, 도메인 검증 등에 사용합니다.\n\n**NS 레코드:**\n도메인의 권한 있는 네임서버를 지정합니다.\n\n**SOA 레코드:**\n도메인 영역의 시작을 나타내며, 관리 정보를 포함합니다.\n\n**PTR 레코드:**\n역방향 DNS로 IP를 도메인으로 변환합니다.\n\n**DNS 조회 과정:**\n\n**1. 브라우저 캐시:**\n최근에 방문한 사이트의 IP는 브라우저에 캐시됩니다.\n\n**2. OS 캐시:**\n운영체제의 DNS 캐시를 확인합니다.\n\n**3. 리졸버(Resolver):**\nISP 또는 설정된 DNS 리졸버(8.8.8.8, 1.1.1.1)에 쿼리합니다.\n\n**4. 재귀적 조회:**\n리졸버가 루트 서버에 문의하여 TLD 서버 주소를 받습니다. TLD 서버에 문의하여 권한 있는 네임서버 주소를 받습니다. 권한 있는 네임서버에서 최종 IP 주소를 받습니다.\n\n**5. 응답 반환:**\n리졸버가 받은 IP를 클라이언트에 반환하고 캐시합니다.\n\n**재귀 쿼리 vs 반복 쿼리:**\n\n**재귀 쿼리(Recursive Query):**\n클라이언트가 리졸버에 \"최종 답을 찾아주세요\"라고 요청합니다. 리졸버가 모든 과정을 처리하여 최종 IP를 반환합니다.\n\n**반복 쿼리(Iterative Query):**\n리졸버가 루트, TLD, 권한 서버에 차례로 질의합니다. 각 서버는 \"다음 단계는 여기에 물어보세요\"라고 응답합니다.\n\n**DNS 캐싱:**\n\n**TTL(Time To Live):**\nDNS 레코드마다 유효 시간이 지정됩니다. TTL 동안은 캐시된 값을 사용합니다. 만료 후 다시 조회합니다.\n\n**캐시 위치:**\n브라우저, OS, 리졸버, ISP 서버 등 여러 단계에서 캐싱합니다. 이를 통해 DNS 조회 속도가 크게 향상됩니다.\n\n**DNS 서버 종류:**\n\n**권한 있는 네임서버(Authoritative Name Server):**\n특정 도메인의 공식 DNS 레코드를 보유합니다. 도메인 소유자가 관리합니다.\n\n**재귀 리졸버(Recursive Resolver):**\n클라이언트를 대신하여 DNS 조회를 수행합니다. ISP 또는 공개 DNS 서비스(Google, Cloudflare)가 운영합니다.\n\n**공개 DNS 서비스:**\n- **Google Public DNS**: 8.8.8.8, 8.8.4.4\n- **Cloudflare DNS**: 1.1.1.1, 1.0.0.1\n- **Quad9**: 9.9.9.9\n\n**DNS 보안:**\n\n**DNS 스푸핑/캐시 포이즈닝:**\n공격자가 거짓 DNS 응답을 주입하여 사용자를 악의적인 사이트로 리다이렉트합니다.\n\n**DNSSEC:**\nDNS 응답에 디지털 서명을 추가하여 무결성을 검증합니다. 위변조를 방지하지만 아직 완전히 보편화되지 않았습니다.\n\n**DNS over HTTPS(DoH):**\nDNS 쿼리를 HTTPS로 암호화하여 프라이버시를 보호합니다.\n\n**DNS over TLS(DoT):**\nTLS로 DNS 통신을 암호화합니다.\n\n**성능 최적화:**\nDNS 프리페칭으로 미리 조회를 수행합니다. 낮은 TTL로 빠른 전환을, 높은 TTL로 안정성을 추구합니다. GeoDNS로 지역별 최적 서버를 제공합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633066-i7dmwxrf",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DNS는 몇 계층 프로토콜인가요?",
      "answer": "DNS는 **애플리케이션 계층(7계층) 프로토콜**입니다.\n\n**OSI 모델에서의 위치:**\nDNS는 최상위 계층인 애플리케이션 계층에서 동작합니다. 사용자나 애플리케이션에게 도메인 이름 해석 서비스를 제공합니다. HTTP, FTP, SMTP 등과 같은 계층에 위치합니다.\n\n**이유:**\nDNS는 특정 애플리케이션 기능(이름 해석)을 제공합니다. 하위 계층(전송, 네트워크)의 서비스를 이용하는 상위 프로토콜입니다. 네트워크 인프라가 아닌 애플리케이션 지원 서비스입니다.\n\n**전송 계층 프로토콜:**\nDNS는 주로 **UDP 포트 53번**을 사용합니다. 작은 쿼리/응답은 UDP로 빠르게 처리합니다. 응답이 512 바이트를 초과하면 TCP를 사용합니다. DNSSEC 등으로 응답이 커지면서 TCP 사용이 증가하고 있습니다. 존 전송(Zone Transfer)은 항상 TCP를 사용합니다.\n\n**왜 UDP를 주로 사용하나:**\n\n**낮은 오버헤드:**\nDNS 쿼리는 단순한 요청-응답 구조입니다. TCP의 3-way handshake는 불필요한 오버헤드입니다. UDP로 빠르게 처리하는 것이 효율적입니다.\n\n**상태 비저장:**\n각 쿼리가 독립적이므로 연결 상태를 유지할 필요가 없습니다. UDP의 비연결 특성이 적합합니다.\n\n**재전송 메커니즘:**\nDNS 클라이언트가 애플리케이션 레벨에서 재전송을 구현합니다. 응답이 없으면 다른 DNS 서버로 재시도합니다. TCP의 신뢰성 보장이 필수적이지 않습니다.\n\n**성능:**\nDNS는 인터넷 사용의 첫 단계이므로 속도가 중요합니다. UDP의 낮은 지연 시간이 사용자 경험을 개선합니다.\n\n**TCP를 사용하는 경우:**\n\n**응답 크기 초과:**\n전통적으로 UDP DNS 응답은 512 바이트 제한이 있었습니다. EDNS0으로 확장되었지만 여전히 크기 제한이 있습니다. 초과 시 TC(Truncated) 플래그를 설정하고 클라이언트가 TCP로 재시도합니다.\n\n**존 전송(Zone Transfer):**\n권한 서버 간 DNS 레코드를 동기화할 때 사용합니다. 대량의 데이터를 전송하므로 TCP의 신뢰성이 필요합니다. AXFR(전체 전송), IXFR(증분 전송) 모두 TCP를 사용합니다.\n\n**보안 프로토콜:**\nDNS over TLS(DoT, 포트 853)는 TCP 기반입니다. DNS over HTTPS(DoH, 포트 443)도 TCP 기반입니다.\n\n**포트 번호:**\n표준 DNS 쿼리: UDP/TCP 53번. DNS over TLS: TCP 853번. DNS over HTTPS: TCP 443번.\n\n**다른 계층 프로토콜과의 협력:**\n\n**애플리케이션 계층:**\nDNS는 다른 애플리케이션(웹 브라우저, 이메일 클라이언트)에게 서비스를 제공합니다.\n\n**전송 계층:**\nUDP 또는 TCP를 사용하여 데이터를 전송합니다.\n\n**네트워크 계층:**\nIP 프로토콜로 DNS 패킷을 라우팅합니다. DNS 서버의 IP 주소는 미리 설정되어 있어야 합니다(부트스트랩 문제).\n\n**부트스트랩 문제:**\nDNS를 사용하려면 DNS 서버의 IP 주소를 알아야 합니다. 이 IP는 DHCP로 자동 설정되거나 수동으로 입력됩니다. 루트 DNS 서버의 IP는 모든 리졸버에 하드코딩되어 있습니다.\n\n**DNS 메시지 구조:**\n\n**헤더:**\n쿼리 ID, 플래그(쿼리/응답, 재귀, 권한 등), 섹션 카운트를 포함합니다.\n\n**질문 섹션:**\n조회할 도메인 이름과 레코드 타입을 명시합니다.\n\n**응답 섹션:**\n요청한 레코드의 답변을 포함합니다.\n\n**권한 섹션:**\n권한 있는 네임서버 정보를 제공합니다.\n\n**추가 정보 섹션:**\n관련된 추가 레코드를 포함합니다.\n\n**실무적 의미:**\nDNS를 애플리케이션 계층으로 이해하면 네트워크 문제 진단 시 적절한 레벨에서 접근할 수 있습니다. DNS 문제는 애플리케이션/서비스 설정을 확인해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633066-8kdhp3uk",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "UDP와 TCP 중 어떤 것을 사용하나요?",
      "answer": "DNS는 **주로 UDP를 사용하지만, 상황에 따라 TCP도 사용**합니다.\n\n**기본 선택 - UDP:**\n\n**일반 쿼리:**\n대부분의 DNS 쿼리/응답은 UDP를 사용합니다. 클라이언트가 UDP 53번 포트로 쿼리를 보냅니다. 서버가 UDP로 응답을 반환합니다. 전체 DNS 트래픽의 약 95% 이상이 UDP입니다.\n\n**UDP를 선택한 이유:**\n\n**빠른 응답 시간:**\nTCP는 3-way handshake에 1.5 RTT가 필요합니다. UDP는 즉시 데이터를 전송하여 0.5 RTT만 필요합니다. DNS는 웹 브라우징의 첫 단계이므로 지연이 치명적입니다.\n\n**낮은 서버 부하:**\nDNS 서버는 초당 수만~수십만 건의 쿼리를 처리합니다. TCP 연결 관리는 엄청난 오버헤드를 발생시킵니다. UDP의 상태 비저장 특성으로 서버 부하를 최소화합니다.\n\n**단순한 요청-응답:**\n대부분의 DNS 쿼리는 하나의 요청과 하나의 응답으로 완료됩니다. 복잡한 세션 관리가 필요 없습니다.\n\n**자체 재전송 메커니즘:**\nDNS 클라이언트는 타임아웃 시 재전송을 직접 구현합니다. 다른 DNS 서버로 폴오버할 수 있습니다. TCP의 재전송 메커니즘이 불필요합니다.\n\n**TCP를 사용하는 경우:**\n\n**1. 응답 크기 초과:**\n\n**512 바이트 제한:**\n전통적으로 UDP DNS 응답은 512 바이트로 제한되었습니다. 이더넷 MTU와 IPv4 단편화를 고려한 안전한 크기입니다.\n\n**TC(Truncated) 플래그:**\n응답이 512 바이트를 초과하면 서버는 잘린 응답을 보내고 TC 플래그를 설정합니다. 클라이언트는 이를 감지하고 TCP로 재시도합니다.\n\n**EDNS0 확장:**\nExtension Mechanisms for DNS로 UDP 페이로드 크기를 확장합니다. 일반적으로 4096 바이트까지 지원합니다. 하지만 네트워크에서 단편화 문제가 발생할 수 있습니다.\n\n**2. 존 전송(Zone Transfer):**\n\n**AXFR(Full Zone Transfer):**\n전체 DNS 존 데이터를 전송합니다. 수백 MB에 달할 수 있어 TCP가 필수입니다. 마스터-슬레이브 서버 간 동기화에 사용합니다.\n\n**IXFR(Incremental Zone Transfer):**\n변경된 레코드만 전송합니다. 여전히 TCP를 사용하여 신뢰성을 보장합니다.\n\n**3. DNS over TLS (DoT):**\n포트 853번에서 TLS로 암호화된 DNS 통신을 제공합니다. TCP 기반으로 동작합니다. 프라이버시 보호가 목적입니다.\n\n**4. DNS over HTTPS (DoH):**\n포트 443번에서 HTTPS로 DNS 쿼리를 전송합니다. 일반 웹 트래픽으로 위장되어 검열 우회에 유리합니다. TCP 기반입니다.\n\n**5. 대용량 DNSSEC 응답:**\nDNSSEC은 암호화 서명을 추가하여 응답 크기를 크게 증가시킵니다. 512 바이트를 초과하는 경우가 많아 TCP 사용이 증가합니다.\n\n**실제 동작 흐름:**\n\n**일반적인 경우:**\n1. 클라이언트가 UDP로 쿼리를 보냅니다\n2. 서버가 UDP로 응답합니다\n3. 완료\n\n**응답이 큰 경우:**\n1. 클라이언트가 UDP로 쿼리를 보냅니다\n2. 서버가 잘린 UDP 응답을 보냅니다 (TC=1)\n3. 클라이언트가 TCP로 재시도합니다\n4. 서버가 TCP로 완전한 응답을 보냅니다\n\n**최신 트렌드:**\n\n**TCP 사용 증가:**\nDNSSEC, IPv6, CDN 등으로 응답 크기가 커지고 있습니다. TCP 사용 비율이 점점 증가하는 추세입니다. 일부 환경에서는 TCP를 기본으로 사용하기도 합니다.\n\n**Fast Open:**\nTCP Fast Open으로 TCP의 지연을 줄일 수 있습니다. TLS 1.3의 0-RTT로 DoT 성능을 개선합니다.\n\n**QUIC 기반 DNS:**\nDNS over QUIC(DoQ)가 제안되었습니다. UDP 기반이지만 TCP의 신뢰성을 제공합니다.\n\n**듀얼 스택 지원:**\n현대 DNS 서버는 UDP와 TCP를 모두 지원합니다. 클라이언트가 필요에 따라 선택할 수 있습니다.\n\n**방화벽 고려사항:**\nDNS는 UDP 53번과 TCP 53번을 모두 허용해야 합니다. TCP를 차단하면 큰 응답을 받을 수 없습니다. DoT(853), DoH(443)도 고려해야 합니다.\n\n**성능 비교:**\nUDP DNS: 평균 20-50ms. TCP DNS: 평균 50-150ms (핸드셰이크 포함). DoH: 평균 100-200ms (HTTPS 오버헤드).\n\n**결론:**\nDNS는 기본적으로 빠른 UDP를 사용하지만, 신뢰성과 보안이 필요한 경우 TCP를 사용합니다. 두 프로토콜이 상호보완적으로 동작합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633066-22l3woc8",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DNS Recursive Query, Iterative Query가 무엇인가요?",
      "answer": "**Recursive Query(재귀 쿼리)**와 **Iterative Query(반복 쿼리)**는 DNS 조회를 수행하는 서로 다른 방식입니다.\n\n**Recursive Query (재귀 쿼리):**\n\n**정의:**\n클라이언트가 DNS 리졸버에게 \"최종 답을 찾아서 알려달라\"고 요청하는 방식입니다.\n\n**동작 방식:**\n클라이언트가 리졸버에게 한 번만 쿼리를 보냅니다. 리졸버가 모든 조회 과정을 대신 수행합니다. 리졸버가 최종 IP 주소를 찾을 때까지 여러 DNS 서버에 질의합니다. 최종 결과(IP 주소 또는 오류)만 클라이언트에게 반환합니다.\n\n**책임:**\n리졸버가 답을 찾을 책임을 집니다. 클라이언트는 단순히 결과만 받습니다.\n\n**장점:**\n클라이언트 입장에서 간단하고 편리합니다. 네트워크 트래픽이 클라이언트에서 발생하지 않습니다. 리졸버의 캐시를 활용할 수 있습니다.\n\n**단점:**\n리졸버에 부하가 집중됩니다. 리졸버가 다운되면 DNS 조회가 불가능합니다.\n\n**Iterative Query (반복 쿼리):**\n\n**정의:**\nDNS 서버가 \"전체 답은 모르지만, 다음에 물어볼 곳은 여기야\"라고 응답하는 방식입니다.\n\n**동작 방식:**\n리졸버가 루트 DNS 서버에 질의합니다. 루트 서버가 \"TLD 서버 주소는 이거야\"라고 응답합니다(참조 응답). 리졸버가 TLD 서버에 질의합니다. TLD 서버가 \"권한 서버 주소는 이거야\"라고 응답합니다. 리졸버가 권한 서버에 질의합니다. 권한 서버가 최종 IP 주소를 응답합니다.\n\n**책임:**\n각 DNS 서버는 자신이 아는 정보만 제공합니다. 리졸버가 단계별로 조회를 진행합니다.\n\n**장점:**\nDNS 서버의 부하가 분산됩니다. 각 서버는 자신의 영역만 관리하면 됩니다. 확장성이 좋습니다.\n\n**단점:**\n여러 번의 왕복이 필요하여 시간이 오래 걸립니다.\n\n**실제 DNS 조회 과정:**\n\n**클라이언트 ↔ 리졸버: Recursive Query**\n사용자 컴퓨터가 ISP 리졸버(또는 8.8.8.8)에 재귀 쿼리를 보냅니다. \"www.example.com의 IP 주소를 찾아주세요.\" 리졸버가 모든 조회를 대신 수행합니다.\n\n**리졸버 ↔ DNS 서버들: Iterative Query**\n리졸버가 루트 서버에 반복 쿼리를 보냅니다. 루트 서버: \".com TLD 서버는 이 주소로 물어보세요\" 리졸버가 TLD 서버에 반복 쿼리를 보냅니다. TLD 서버: \"example.com 네임서버는 이 주소로 물어보세요\" 리졸버가 권한 서버에 쿼리를 보냅니다. 권한 서버: \"www.example.com의 IP는 192.0.2.1입니다\"\n\n**혼합 사용:**\n실무에서는 두 방식이 혼합되어 사용됩니다. 클라이언트 → 리졸버는 재귀 쿼리. 리졸버 → 다른 DNS 서버들은 반복 쿼리.\n\n**상세한 예시:**\n\n**www.example.com 조회:**\n\n**1단계 - 재귀 쿼리:**\n사용자 PC → 리졸버(8.8.8.8): \"www.example.com의 IP를 알려주세요\" (RD=1, Recursion Desired 플래그 설정)\n\n**2단계 - 반복 쿼리 시작:**\n리졸버 → 루트 서버: \"www.example.com의 IP는?\" 루트 서버 → 리졸버: \"모르겠지만, .com은 이 TLD 서버에 물어보세요\"\n\n**3단계:**\n리졸버 → .com TLD 서버: \"www.example.com의 IP는?\" TLD 서버 → 리졸버: \"모르겠지만, example.com은 이 네임서버에 물어보세요\"\n\n**4단계:**\n리졸버 → example.com 네임서버: \"www.example.com의 IP는?\" 네임서버 → 리졸버: \"192.0.2.1입니다\" (최종 응답)\n\n**5단계 - 재귀 응답:**\n리졸버 → 사용자 PC: \"192.0.2.1입니다\"\n\n**DNS 메시지 플래그:**\n\n**RD (Recursion Desired):**\n클라이언트가 재귀 쿼리를 요청할 때 설정합니다. \"재귀적으로 조회해주세요\"\n\n**RA (Recursion Available):**\n서버가 재귀 쿼리를 지원하는지 나타냅니다. 리졸버는 RA=1, 권한 서버는 RA=0\n\n**캐싱의 역할:**\n리졸버가 이전에 .com TLD 서버 주소를 캐시했다면 루트 서버 조회를 생략합니다. 권한 서버 주소를 캐시했다면 TLD 서버 조회도 생략합니다. 최종 IP를 캐시했다면 모든 조회를 생략하고 즉시 응답합니다.\n\n**비재귀 리졸버:**\n일부 DNS 서버는 재귀 쿼리를 지원하지 않습니다. 권한 서버는 일반적으로 반복 쿼리만 응답합니다. 재귀 쿼리는 리졸버의 역할입니다.\n\n**보안 고려사항:**\n개방형 재귀 리졸버는 DNS 증폭 공격에 악용될 수 있습니다. 재귀 쿼리는 신뢰할 수 있는 네트워크에서만 허용해야 합니다.\n\n**성능 영향:**\n재귀 쿼리는 클라이언트 관점에서 빠릅니다(한 번의 왕복). 반복 쿼리는 여러 번의 왕복이 필요하지만 캐싱으로 완화됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "동기화",
        "HTTP"
      ],
      "id": "1763437633066-iayqq9d0",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?",
      "answer": "DNS는 주로 UDP를 사용하므로 자체적으로 **재전송 메커니즘**을 구현하여 손실을 처리합니다.\n\n**UDP의 비신뢰성:**\nUDP는 패킷 손실, 순서 변경, 중복을 보장하지 않습니다. DNS 쿼리나 응답이 네트워크에서 손실될 수 있습니다. 애플리케이션 레벨에서 손실을 감지하고 복구해야 합니다.\n\n**타임아웃 메커니즘:**\n\n**초기 타임아웃:**\n클라이언트 또는 리졸버가 쿼리를 보낸 후 일정 시간(일반적으로 2-5초) 대기합니다. 응답을 받지 못하면 타임아웃으로 판단합니다.\n\n**타임아웃 값 설정:**\n너무 짧으면 정상 응답을 기다리지 못하고 재전송합니다. 너무 길면 사용자 경험이 나빠집니다. 네트워크 상태에 따라 동적으로 조정하는 구현도 있습니다.\n\n**재전송 전략:**\n\n**1. 같은 서버로 재전송:**\n첫 번째 시도가 실패하면 같은 DNS 서버로 쿼리를 다시 보냅니다. 일시적인 네트워크 문제나 서버 부하를 고려합니다.\n\n**2. 다른 서버로 폴오버:**\n재전송도 실패하면 대체 DNS 서버로 시도합니다. 대부분의 시스템은 primary와 secondary DNS 서버를 설정합니다. 예: 8.8.8.8 → 8.8.4.4 또는 ISP의 보조 DNS\n\n**3. 지수 백오프(Exponential Backoff):**\n재시도 간격을 점진적으로 늘립니다. 첫 시도: 즉시, 첫 재전송: 2초 후, 두 번째 재전송: 4초 후, 세 번째 재전송: 8초 후. 네트워크 혼잡을 악화시키지 않습니다.\n\n**재시도 횟수 제한:**\n무한정 재시도하지 않고 일정 횟수(일반적으로 2-3회) 후 포기합니다. 총 대기 시간이 너무 길어지는 것을 방지합니다.\n\n**클라이언트 측 처리:**\n\n**시스템 리졸버:**\n운영체제의 DNS 클라이언트가 재전송을 자동으로 처리합니다. resolv.conf(Linux) 또는 레지스트리(Windows)에서 설정을 조정할 수 있습니다.\n\n**애플리케이션:**\n브라우저나 애플리케이션은 시스템 리졸버에 의존합니다. 일부는 자체 DNS 캐시와 재시도 로직을 구현합니다.\n\n**DNS 리졸버 측 처리:**\n\n**병렬 쿼리:**\n일부 리졸버는 여러 권한 서버에 동시에 쿼리를 보냅니다. 가장 빠른 응답을 사용합니다. 신뢰성과 성능을 동시에 개선합니다.\n\n**캐시 활용:**\n이전에 받은 응답을 캐시하여 재쿼리를 피합니다. TTL 내에서는 캐시된 값을 즉시 반환합니다.\n\n**손실 유형별 처리:**\n\n**쿼리 패킷 손실:**\n서버가 쿼리를 받지 못하므로 응답하지 않습니다. 클라이언트가 타임아웃 후 재전송합니다.\n\n**응답 패킷 손실:**\n서버는 응답을 보냈지만 클라이언트가 받지 못합니다. 클라이언트가 타임아웃 후 쿼리를 재전송합니다. 서버는 같은 쿼리를 다시 받고 응답합니다(멱등성).\n\n**부분 응답 손실:**\nUDP는 패킷 전체가 손실되거나 전체가 도착합니다. 부분 손실은 발생하지 않습니다.\n\n**중복 쿼리 처리:**\nDNS는 멱등성이 있어 같은 쿼리를 여러 번 처리해도 문제없습니다. 서버는 각 쿼리를 독립적으로 처리합니다.\n\n**쿼리 ID:**\n각 DNS 쿼리에는 고유한 ID가 있습니다. 응답의 ID를 확인하여 어떤 쿼리에 대한 응답인지 매칭합니다. 늦게 도착한 응답을 구별할 수 있습니다.\n\n**TCP 폴백:**\nUDP로 여러 번 시도해도 실패하면 TCP로 전환합니다. TCP는 신뢰성을 보장하여 손실 문제를 해결합니다.\n\n**DNSSEC와 손실:**\nDNSSEC 응답은 크기가 커서 UDP 손실 가능성이 높습니다. TCP 사용 비율이 증가하는 이유 중 하나입니다.\n\n**네트워크 레벨 대응:**\n라우터와 방화벽은 DNS 트래픽에 우선순위를 부여할 수 있습니다. QoS 정책으로 DNS 패킷 손실을 최소화합니다.\n\n**실무 권장사항:**\n최소 2개의 DNS 서버를 설정합니다. 신뢰할 수 있는 공개 DNS(8.8.8.8, 1.1.1.1)를 백업으로 사용합니다. 로컬 DNS 캐시를 활용하여 재쿼리를 줄입니다.\n\n**모니터링:**\nDNS 쿼리 실패율을 모니터링합니다. 비정상적으로 높으면 네트워크나 DNS 서버 문제를 조사합니다.\n\n**최종 실패 처리:**\n모든 재시도가 실패하면 애플리케이션에 오류를 반환합니다. 브라우저는 \"서버를 찾을 수 없음\" 오류를 표시합니다. 애플리케이션은 적절한 에러 처리를 구현해야 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "동기화",
        "HTTP"
      ],
      "id": "1763437633066-cw2hspw8",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?",
      "answer": "캐싱된 DNS가 잘못되는 경우와 이를 **보정하는 방법**은 다양합니다.\n\n**잘못된 캐시 발생 원인:**\n\n**1. DNS 레코드 변경:**\n서버 IP 주소가 변경되었지만 캐시가 아직 만료되지 않았습니다. 마이그레이션, 로드 밸런서 변경, 장애 복구 시 발생합니다.\n\n**2. DNS 캐시 포이즈닝:**\n공격자가 거짓 DNS 응답을 주입하여 캐시를 오염시킵니다. 사용자가 악의적인 사이트로 리다이렉트됩니다.\n\n**3. 설정 오류:**\nDNS 관리자가 잘못된 레코드를 등록했습니다. 오타, 설정 실수, 테스트 데이터를 운영에 적용한 경우입니다.\n\n**4. 오래된 캐시:**\nTTL이 너무 길게 설정되어 오래된 정보가 유지됩니다.\n\n**TTL(Time To Live) 기반 자동 보정:**\n\n**TTL의 역할:**\n모든 DNS 레코드에는 유효 시간(TTL)이 설정됩니다. TTL이 만료되면 캐시가 자동으로 삭제됩니다. 다음 조회 시 권한 서버에서 최신 정보를 받습니다.\n\n**TTL 설정 전략:**\n자주 변경되는 레코드: 짧은 TTL (60초 - 5분). 안정적인 레코드: 긴 TTL (1시간 - 24시간). 변경 예정 시: 사전에 TTL을 짧게 조정합니다.\n\n**수동 캐시 삭제:**\n\n**클라이언트 측:**\nWindows: ipconfig /flushdns. Linux: sudo systemd-resolve --flush-caches 또는 sudo service nscd restart. macOS: sudo dscacheutil -flushcache. 브라우저 캐시도 별도로 삭제해야 할 수 있습니다.\n\n**리졸버 측:**\n관리자가 DNS 서버의 캐시를 삭제할 수 있습니다. 하지만 모든 사용자의 리졸버를 제어할 수는 없습니다.\n\n**서버 변경 시 Best Practice:**\n\n**1. TTL 사전 단축:**\n변경 1-2일 전에 TTL을 짧게 조정합니다(예: 5분). 기존 캐시가 빠르게 만료되도록 합니다.\n\n**2. IP 변경:**\n계획된 시간에 DNS 레코드를 변경합니다.\n\n**3. 양쪽 서버 유지:**\nTTL 기간 동안 새 서버와 구 서버를 모두 운영합니다. 오래된 캐시로 접속하는 사용자도 서비스를 받을 수 있습니다.\n\n**4. 모니터링:**\n새 서버와 구 서버의 트래픽을 모니터링합니다. 구 서버 트래픽이 0에 가까워지면 안전하게 종료합니다.\n\n**5. TTL 복원:**\n변경 완료 후 TTL을 원래 값으로 되돌립니다.\n\n**DNS 레코드 다중화:**\n\n**Round Robin DNS:**\n여러 IP 주소를 등록하여 부하를 분산합니다. 하나의 서버에 문제가 있어도 다른 서버로 접속할 수 있습니다.\n\n**Health Check:**\nGeoDNS나 동적 DNS 서비스는 서버 상태를 확인합니다. 문제가 있는 서버의 IP를 자동으로 제외합니다.\n\n**DNSSEC으로 캐시 포이즈닝 방지:**\n\n**디지털 서명:**\nDNSSEC은 DNS 응답에 암호화 서명을 추가합니다. 클라이언트가 서명을 검증하여 위변조를 감지합니다.\n\n**신뢰 체인:**\n루트부터 TLD, 권한 서버까지 서명 체인을 검증합니다. 공격자가 거짓 응답을 주입해도 서명이 맞지 않아 거부됩니다.\n\n**애플리케이션 레벨 검증:**\n\n**연결 테스트:**\nDNS로 받은 IP에 실제 연결을 시도합니다. 연결 실패, 잘못된 응답, 인증서 불일치를 감지합니다.\n\n**폴백 메커니즘:**\n주 서버 연결 실패 시 대체 서버나 IP로 시도합니다. 하드코딩된 IP를 백업으로 사용할 수 있습니다.\n\n**HTTPS 인증서 검증:**\nHTTPS 접속 시 서버 인증서의 도메인 이름을 확인합니다. 잘못된 IP로 리다이렉트되면 인증서 오류가 발생합니다.\n\n**사용자 교육:**\n브라우저의 보안 경고를 무시하지 않도록 합니다. 민감한 정보 입력 전 URL을 재확인합니다.\n\n**모니터링과 알림:**\n\n**DNS 모니터링:**\n정기적으로 외부에서 DNS 조회를 수행합니다. 예상과 다른 응답을 받으면 알림을 보냅니다.\n\n**변경 감지:**\nDNS 레코드 변경을 추적하고 승인되지 않은 변경을 감지합니다.\n\n**Anycast DNS:**\n여러 위치에서 같은 IP로 DNS 서비스를 제공합니다. 한 지역의 문제가 전체 서비스에 영향을 주지 않습니다.\n\n**캐시 예열(Cache Warming):**\n변경 직후 주요 리졸버에 쿼리를 보내 캐시를 업데이트합니다. 대부분의 사용자가 빠르게 새 정보를 받을 수 있습니다.\n\n**실무 권장사항:**\n중요한 변경은 점진적으로 수행합니다. 롤백 계획을 준비합니다. TTL을 적절하게 설정합니다(너무 짧으면 부하, 너무 길면 유연성 저하). DNSSEC, DoH, DoT 같은 보안 기술을 도입합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "캐시"
      ],
      "id": "1763437633067-r1fbpsrf",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.",
      "answer": "**A**, **AAAA**, **CNAME** 레코드는 DNS에서 가장 기본적이고 중요한 레코드 타입들입니다.\n\n**A 레코드 (Address Record):**\n\n**정의:**\n도메인 이름을 **IPv4 주소**로 매핑하는 레코드입니다.\n\n**형식:**\n도메인 → IPv4 주소 (예: example.com → 192.0.2.1)\n\n**예시:**\n```\nexample.com.        IN  A  192.0.2.1\nwww.example.com.    IN  A  192.0.2.1\nmail.example.com.   IN  A  192.0.2.5\n```\n\n**특징:**\n가장 기본적이고 널리 사용되는 레코드입니다. 하나의 도메인에 여러 A 레코드를 설정할 수 있습니다(Round Robin). 직접 IP 주소를 반환하므로 추가 조회가 필요 없습니다.\n\n**용도:**\n웹 서버, 메일 서버, API 서버 등의 IP 주소를 지정합니다. 서브도메인별로 다른 서버를 가리킬 수 있습니다.\n\n**AAAA 레코드 (IPv6 Address Record):**\n\n**정의:**\n도메인 이름을 **IPv6 주소**로 매핑하는 레코드입니다. \"Quad-A\"로 읽습니다.\n\n**형식:**\n도메인 → IPv6 주소 (예: example.com → 2001:db8::1)\n\n**예시:**\n```\nexample.com.        IN  AAAA  2001:db8::1\nwww.example.com.    IN  AAAA  2001:db8::2\n```\n\n**특징:**\nIPv6가 128비트이므로 A 레코드(32비트)보다 4배 크다는 의미로 AAAA입니다. IPv4 A 레코드와 함께 설정할 수 있습니다(듀얼 스택). 클라이언트가 IPv6를 지원하면 AAAA를 우선 사용합니다.\n\n**용도:**\nIPv6 네트워크를 지원하는 서버의 주소를 지정합니다. 미래 대비와 IPv4 고갈 문제 해결을 위해 점점 더 중요해지고 있습니다.\n\n**듀얼 스택 구성:**\n```\nexample.com.        IN  A     192.0.2.1\nexample.com.        IN  AAAA  2001:db8::1\n```\n클라이언트가 양쪽을 모두 받아 지원 가능한 프로토콜을 선택합니다.\n\n**CNAME 레코드 (Canonical Name Record):**\n\n**정의:**\n도메인 이름을 **다른 도메인 이름**으로 매핑하는 별칭(alias) 레코드입니다.\n\n**형식:**\n별칭 도메인 → 정식 도메인 (예: www.example.com → example.com)\n\n**예시:**\n```\nwww.example.com.    IN  CNAME  example.com.\nblog.example.com.   IN  CNAME  hosting.provider.com.\ncdn.example.com.    IN  CNAME  cdn-network.cloudfront.net.\n```\n\n**특징:**\nIP 주소가 아닌 다른 도메인을 가리킵니다. 최종적으로 A 또는 AAAA 레코드로 해석됩니다. 여러 단계의 CNAME을 따라갈 수 있습니다(체인).\n\n**장점:**\nIP 변경 시 원본 도메인의 A 레코드만 수정하면 됩니다. 여러 도메인이 같은 서버를 가리킬 때 관리가 편리합니다. CDN이나 호스팅 서비스에서 동적으로 최적 서버를 제공할 수 있습니다.\n\n**제약사항:**\n루트 도메인(example.com)은 CNAME을 가질 수 없습니다(RFC 제한). CNAME과 다른 레코드(A, MX, TXT)를 동시에 설정할 수 없습니다. 추가 DNS 조회가 필요하여 약간의 지연이 발생합니다.\n\n**주요 차이점:**\n\n**반환 값:**\n- **A**: IPv4 주소 (32비트)\n- **AAAA**: IPv6 주소 (128비트)\n- **CNAME**: 다른 도메인 이름\n\n**용도:**\n- **A/AAAA**: 실제 서버의 IP 주소를 지정\n- **CNAME**: 도메인 별칭, 서비스 위임, 유연한 관리\n\n**조회 과정:**\n- **A/AAAA**: 한 번의 조회로 IP를 얻음\n- **CNAME**: CNAME → A/AAAA 두 단계 조회 필요\n\n**사용 예시 비교:**\n\n**Case 1 - A 레코드 사용:**\n```\nexample.com.        IN  A  192.0.2.1\nwww.example.com.    IN  A  192.0.2.1\n```\n장점: 빠른 조회. 단점: IP 변경 시 두 곳 수정 필요.\n\n**Case 2 - CNAME 사용:**\n```\nexample.com.        IN  A      192.0.2.1\nwww.example.com.    IN  CNAME  example.com.\n```\n장점: IP 변경 시 한 곳만 수정. 단점: 약간의 추가 지연.\n\n**CDN 사용 시:**\n```\ncdn.example.com.    IN  CNAME  example-com.cdn.provider.net.\n```\nCDN 제공자가 동적으로 최적 서버를 선택합니다. GeoDNS로 사용자 위치에 따라 다른 IP를 반환합니다.\n\n**실제 조회 예시:**\n\n**A 레코드 조회:**\n```\n클라이언트 → DNS: \"example.com의 A 레코드는?\"\nDNS → 클라이언트: \"192.0.2.1\"\n```\n\n**CNAME 조회:**\n```\n클라이언트 → DNS: \"www.example.com의 A 레코드는?\"\nDNS → 클라이언트: \"www.example.com은 example.com의 CNAME입니다. example.com의 A는 192.0.2.1입니다\"\n```\n\n**루트 도메인 CNAME 제약:**\nexample.com에는 CNAME을 설정할 수 없습니다. MX, SOA, NS 레코드와 충돌하기 때문입니다. 대안으로 ALIAS 레코드(일부 DNS 제공자)나 A/AAAA 레코드를 사용합니다.\n\n**성능 고려:**\nA/AAAA 레코드는 직접 IP를 반환하여 가장 빠릅니다. CNAME은 추가 조회로 10-50ms 지연이 발생할 수 있습니다. 하지만 캐싱으로 이후 조회는 빠릅니다.\n\n**선택 기준:**\n고정 IP를 가리킬 때: A/AAAA 레코드. 외부 서비스를 가리킬 때: CNAME(CDN, 클라우드 서비스). 여러 별칭이 필요할 때: CNAME. IPv6 지원: AAAA 추가.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633067-wv6b9rp5",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?",
      "answer": "**hosts 파일**은 로컬 시스템에서 도메인 이름을 IP 주소로 매핑하는 텍스트 파일입니다.\n\n**hosts 파일의 위치:**\n- **Windows**: C:\\Windows\\System32\\drivers\\etc\\hosts\n- **Linux/macOS**: /etc/hosts\n\n**형식:**\n각 줄에 IP 주소와 도메인 이름을 공백으로 구분하여 작성합니다.\n```\n192.0.2.1    example.com www.example.com\n127.0.0.1    localhost\n::1          localhost\n```\n\n**역할:**\n\n**도메인 이름 해석:**\nhosts 파일에 등록된 도메인은 DNS 조회 없이 즉시 IP로 변환됩니다. 로컬 시스템에서만 유효한 매핑입니다.\n\n**개발 및 테스트:**\n운영 서버에 영향 없이 로컬에서 도메인을 테스트할 수 있습니다. 예: 새 서버의 IP를 미리 hosts에 등록하여 테스트합니다.\n\n**광고 차단:**\n광고 도메인을 127.0.0.1로 매핑하여 차단합니다. 악성 사이트 접근을 방지합니다.\n\n**우회 접근:**\nDNS 문제 발생 시 임시로 IP를 직접 지정합니다.\n\n**우선순위:**\n\n**hosts 파일이 DNS보다 우선합니다.**\n\n**조회 순서:**\n1. 애플리케이션이 도메인 이름 해석을 요청합니다\n2. 운영체제가 hosts 파일을 먼저 확인합니다\n3. hosts 파일에 매핑이 있으면 즉시 해당 IP를 반환합니다\n4. hosts 파일에 없으면 DNS 조회를 수행합니다\n5. DNS 캐시 확인 후 DNS 서버에 쿼리합니다\n\n**전체 이름 해석 순서:**\nhosts 파일 → DNS 캐시 → DNS 리졸버 → 권한 DNS 서버\n\n**장점:**\n\n**빠른 해석:**\nDNS 네트워크 조회 없이 즉시 IP를 얻습니다. 지연 시간이 거의 없습니다.\n\n**완전한 제어:**\n로컬 시스템에서 어떤 도메인도 원하는 IP로 매핑할 수 있습니다.\n\n**DNS 독립성:**\nDNS 서버 장애 시에도 hosts 파일의 매핑은 동작합니다.\n\n**단점:**\n\n**수동 관리:**\n모든 컴퓨터에서 개별적으로 편집해야 합니다. 중앙 집중 관리가 불가능합니다.\n\n**확장성 부족:**\n대량의 도메인을 관리하기 어렵습니다.\n\n**동기화 문제:**\nIP 주소가 변경되면 모든 시스템의 hosts 파일을 수동으로 업데이트해야 합니다.\n\n**캐시 없음:**\nhosts 파일은 매번 읽히므로 TTL 개념이 없습니다.\n\n**실무 활용:**\n\n**개발 환경:**\n```\n127.0.0.1    dev.example.com\n192.168.1.100    staging.example.com\n```\n로컬 개발 서버나 스테이징 서버를 편리하게 접근합니다.\n\n**테스트:**\n운영 DNS를 변경하기 전에 hosts 파일로 새 서버를 테스트합니다.\n\n**보안:**\n```\n0.0.0.0    ads.example.com\n0.0.0.0    malware.example.com\n```\n악성 사이트나 광고 서버를 차단합니다.\n\n**주의사항:**\n\n**권한 필요:**\nhosts 파일 수정은 관리자 권한이 필요합니다. 보안상 중요한 파일이기 때문입니다.\n\n**오타 위험:**\n잘못된 IP를 입력하면 사이트 접속이 불가능해집니다. 정상 동작하지 않을 때 hosts 파일을 확인해야 합니다.\n\n**보안 위협:**\n악성 소프트웨어가 hosts 파일을 변조하여 피싱 사이트로 리다이렉트할 수 있습니다. 정기적으로 hosts 파일을 점검해야 합니다.\n\n**캐시 이슈:**\nhosts 파일 변경 후 DNS 캐시를 삭제해야 즉시 적용됩니다. Windows: ipconfig /flushdns. Linux: sudo systemd-resolve --flush-caches.\n\n**IPv6 지원:**\nIPv4와 IPv6 매핑을 모두 지정할 수 있습니다.\n```\n192.0.2.1       example.com\n2001:db8::1     example.com\n```\n\n**무시되는 경우:**\n일부 브라우저(Chrome 등)는 자체 DNS 캐시를 사용하여 hosts 파일을 우회할 수 있습니다. DoH(DNS over HTTPS)를 사용하면 hosts 파일이 무시될 수 있습니다.\n\n**대안:**\n대규모 환경에서는 내부 DNS 서버를 구축하는 것이 더 효율적입니다. 컨테이너 환경에서는 Docker의 DNS 또는 쿠버네티스의 CoreDNS를 사용합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "캐시"
      ],
      "id": "1763437633067-a7q2kimt",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "SOP 정책에 대해 설명해 주세요.",
      "answer": "**SOP(Same-Origin Policy, 동일 출처 정책)**는 웹 브라우저의 핵심 보안 메커니즘으로, 한 출처의 스크립트가 다른 출처의 리소스에 접근하는 것을 제한합니다.\n\n**출처(Origin)의 정의:**\n출처는 **프로토콜(Scheme) + 호스트(Host) + 포트(Port)**의 조합입니다. 세 가지가 모두 동일해야 같은 출처로 간주됩니다.\n\n**예시 - https://www.example.com:443/page 기준:**\n- https://www.example.com:443/other → 같은 출처 (O)\n- https://www.example.com/page → 같은 출처 (O, 포트 443 기본값)\n- http://www.example.com → 다른 출처 (X, 프로토콜 다름)\n- https://example.com → 다른 출처 (X, 호스트 다름)\n- https://www.example.com:8080 → 다른 출처 (X, 포트 다름)\n- https://api.example.com → 다른 출처 (X, 서브도메인 다름)\n\n**SOP가 제한하는 것:**\n\n**XMLHttpRequest와 Fetch API:**\n다른 출처로 AJAX 요청을 보낼 수 없습니다. JavaScript로 응답을 읽을 수 없습니다.\n\n**DOM 접근:**\n다른 출처의 iframe 내부 DOM에 접근할 수 없습니다. window.opener로 부모 창에 접근하는 것도 제한됩니다.\n\n**쿠키와 스토리지:**\n다른 출처의 Cookie, LocalStorage, SessionStorage에 접근할 수 없습니다.\n\n**SOP가 허용하는 것:**\n\n**리소스 임베딩:**\n다른 출처의 이미지, CSS, JavaScript를 로드할 수 있습니다. script, img, link, iframe 태그는 허용됩니다. 하지만 읽기는 제한될 수 있습니다.\n\n**폼 전송:**\n다른 출처로 form을 제출할 수 있습니다.\n\n**리다이렉션:**\n다른 출처로 이동할 수 있습니다.\n\n**SOP의 필요성:**\n\n**보안 위협 방지:**\n악의적인 사이트가 사용자의 은행 사이트 데이터를 읽는 것을 방지합니다. 세션 하이재킹, CSRF 공격을 완화합니다.\n\n**사용자 정보 보호:**\n한 탭의 민감한 정보가 다른 탭의 스크립트에 노출되지 않습니다.\n\n**실제 공격 시나리오 (SOP가 없다면):**\n\n**1. 악의적 사이트 방문:**\n사용자가 evil.com을 방문합니다. evil.com의 JavaScript가 실행됩니다.\n\n**2. 은행 사이트 공격:**\nJavaScript가 숨겨진 iframe으로 bank.com을 로드합니다. 사용자가 이미 bank.com에 로그인되어 있습니다. SOP 없이는 evil.com의 스크립트가 bank.com의 계좌 정보를 읽을 수 있습니다.\n\n**3. 정보 탈취:**\n은행 계좌 잔액, 거래 내역 등을 evil.com 서버로 전송합니다.\n\n**SOP의 한계:**\n\n**같은 출처의 공격:**\nXSS(Cross-Site Scripting)처럼 같은 출처에서 악성 스크립트가 실행되면 SOP는 무력합니다.\n\n**개발 불편:**\n마이크로서비스, API 서버 등 정당한 교차 출처 통신도 막힙니다. 이를 해결하기 위해 CORS가 도입되었습니다.\n\n**우회 기법:**\n\n**JSONP:**\nscript 태그는 SOP 제한을 받지 않는 점을 이용합니다. 콜백 함수로 데이터를 전달합니다. 보안 문제로 더 이상 권장되지 않습니다.\n\n**프록시 서버:**\n같은 출처의 서버가 다른 출처 API를 대신 호출합니다. 브라우저 입장에서는 같은 출처 통신입니다.\n\n**CORS:**\n서버가 명시적으로 다른 출처의 접근을 허용합니다. Access-Control-Allow-Origin 헤더를 사용합니다.\n\n**postMessage:**\n다른 출처의 window 간 안전한 메시지 전달을 위한 API입니다.\n\n**브라우저별 차이:**\n대부분의 현대 브라우저는 SOP를 엄격하게 적용합니다. 일부 구형 브라우저는 느슨한 정책을 가질 수 있습니다.\n\n**개발 시 주의사항:**\nSOP 오류는 콘솔에 명확히 표시됩니다. 정당한 교차 출처 통신은 CORS를 구현해야 합니다. 로컬 개발 시 프록시나 CORS 플러그인을 사용할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633067-w83kqxnh",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "CORS 정책이 무엇인가요?",
      "answer": "**CORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)**는 SOP의 제약을 완화하여 **다른 출처 간 안전한 리소스 공유**를 가능하게 하는 메커니즘입니다.\n\n**필요성:**\nSOP는 보안을 위해 필수적이지만, 정당한 교차 출처 통신도 막습니다. 프론트엔드(www.example.com)와 API 서버(api.example.com)가 다른 도메인일 때 통신이 필요합니다. CORS는 서버가 명시적으로 허용한 출처에만 접근을 허용합니다.\n\n**동작 원리:**\n\n**서버의 허가 헤더:**\n서버가 HTTP 응답에 특별한 헤더를 포함하여 어떤 출처를 허용하는지 명시합니다. 브라우저가 이 헤더를 확인하고 접근을 허용하거나 차단합니다.\n\n**주요 CORS 헤더:**\n\n**Access-Control-Allow-Origin:**\n어떤 출처를 허용할지 지정합니다.\n```\nAccess-Control-Allow-Origin: https://www.example.com\nAccess-Control-Allow-Origin: *  (모든 출처 허용, 보안 위험)\n```\n\n**Access-Control-Allow-Methods:**\n허용되는 HTTP 메서드를 지정합니다.\n```\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\n```\n\n**Access-Control-Allow-Headers:**\n허용되는 요청 헤더를 지정합니다.\n```\nAccess-Control-Allow-Headers: Content-Type, Authorization\n```\n\n**Access-Control-Allow-Credentials:**\n쿠키나 인증 정보를 포함한 요청을 허용할지 지정합니다.\n```\nAccess-Control-Allow-Credentials: true\n```\n\n**Access-Control-Max-Age:**\nPreflight 응답을 캐시할 시간(초)을 지정합니다.\n```\nAccess-Control-Max-Age: 86400\n```\n\n**단순 요청(Simple Request):**\n\n**조건:**\n- 메서드: GET, HEAD, POST 중 하나\n- 헤더: Accept, Accept-Language, Content-Language, Content-Type만 사용\n- Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나\n\n**동작:**\n1. 브라우저가 바로 실제 요청을 보냅니다\n2. 요청에 Origin 헤더를 자동으로 추가합니다\n3. 서버가 Access-Control-Allow-Origin 헤더와 함께 응답합니다\n4. 브라우저가 헤더를 확인하고 응답을 JavaScript에 전달하거나 차단합니다\n\n**Preflight 요청:**\n\n**조건:**\n단순 요청 조건을 만족하지 않는 경우. 사용자 정의 헤더를 사용하거나, PUT, DELETE 등의 메서드를 사용하거나, application/json Content-Type을 사용하는 경우.\n\n**동작:**\n1. 브라우저가 먼저 OPTIONS 메서드로 Preflight 요청을 보냅니다\n2. 서버가 허용 정책을 헤더로 응답합니다\n3. 브라우저가 허용 여부를 확인합니다\n4. 허용되면 실제 요청(POST, PUT 등)을 보냅니다\n5. 서버가 실제 응답을 반환합니다\n\n**Preflight 예시:**\n\n**Preflight 요청:**\n```\nOPTIONS /api/users HTTP/1.1\nOrigin: https://www.example.com\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type\n```\n\n**Preflight 응답:**\n```\nHTTP/1.1 200 OK\nAccess-Control-Allow-Origin: https://www.example.com\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: Content-Type\nAccess-Control-Max-Age: 86400\n```\n\n**실제 요청:**\n브라우저가 확인 후 실제 POST 요청을 보냅니다.\n\n**인증 정보 포함:**\n\n**Credentials 모드:**\nJavaScript에서 fetch나 XMLHttpRequest 시 credentials 옵션을 설정합니다.\n```\nfetch(url, { credentials: 'include' })\n```\n\n**서버 응답:**\n```\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Origin: https://www.example.com  (와일드카드 불가)\n```\n\n**와일드카드 제한:**\ncredentials: true일 때 Allow-Origin에 *를 사용할 수 없습니다. 보안상 정확한 출처를 명시해야 합니다.\n\n**서버 구현 예시:**\n\n**Node.js (Express):**\n```\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', 'https://www.example.com');\n  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE');\n  res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');\n  if (req.method === 'OPTIONS') {\n    return res.sendStatus(200);\n  }\n  next();\n});\n```\n\n**Spring Boot:**\n```\n@CrossOrigin(origins = \"https://www.example.com\")\n```\n\n**보안 고려사항:**\n\n**와일드카드 위험:**\nAccess-Control-Allow-Origin: *는 모든 출처를 허용하여 위험합니다. 공개 API가 아니면 사용하지 않아야 합니다.\n\n**동적 출처 검증:**\n요청의 Origin 헤더를 확인하고 허용 목록에 있을 때만 반영합니다.\n\n**민감한 데이터:**\n인증이 필요한 API는 credentials와 정확한 출처 지정을 함께 사용합니다.\n\n**개발 환경:**\n로컬 개발 시 프록시를 사용하거나 개발 서버에서 CORS를 느슨하게 설정합니다. 운영 환경에서는 엄격하게 제한합니다.\n\n**문제 해결:**\nCORS 오류는 브라우저 콘솔에 명확히 표시됩니다. 서버 응답 헤더를 확인하고 누락된 헤더를 추가합니다. Preflight 요청을 올바르게 처리하는지 확인합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "동기화",
        "HTTP"
      ],
      "id": "1763437633067-xbhj9xev",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "Preflight에 대해 설명해 주세요.",
      "answer": "**Preflight 요청**은 CORS에서 실제 요청 전에 서버의 허가를 확인하는 **사전 검증 요청**입니다.\n\n**목적:**\n서버가 실제 요청을 처리하기 전에 해당 요청을 허용하는지 확인합니다. 서버에 부담을 주는 요청(POST, PUT, DELETE)을 사전 차단합니다. 보안과 성능을 동시에 고려한 메커니즘입니다.\n\n**발생 조건:**\n\n**1. 비표준 HTTP 메서드:**\nGET, HEAD, POST 외의 메서드(PUT, DELETE, PATCH 등)를 사용할 때.\n\n**2. 사용자 정의 헤더:**\nAuthorization, X-Custom-Header 같은 표준 외 헤더를 포함할 때.\n\n**3. Content-Type:**\napplication/json, application/xml 등 특정 Content-Type을 사용할 때. application/x-www-form-urlencoded, multipart/form-data, text/plain은 단순 요청으로 분류됩니다.\n\n**Preflight 요청 형식:**\n\n**메서드:**\n항상 OPTIONS 메서드를 사용합니다.\n\n**헤더:**\n```\nOPTIONS /api/users HTTP/1.1\nHost: api.example.com\nOrigin: https://www.example.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: Content-Type, Authorization\n```\n\n**Access-Control-Request-Method:**\n실제 요청에서 사용할 메서드를 알립니다.\n\n**Access-Control-Request-Headers:**\n실제 요청에서 사용할 헤더 목록을 알립니다.\n\n**Preflight 응답 형식:**\n\n**성공 응답:**\n```\nHTTP/1.1 200 OK\nAccess-Control-Allow-Origin: https://www.example.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS\nAccess-Control-Allow-Headers: Content-Type, Authorization\nAccess-Control-Max-Age: 86400\n```\n\n**거부 응답:**\nCORS 헤더가 없거나 Origin을 허용하지 않으면 브라우저가 실제 요청을 차단합니다.\n\n**전체 흐름:**\n\n**1단계 - Preflight 요청:**\n브라우저가 자동으로 OPTIONS 요청을 보냅니다. 개발자가 명시적으로 보내지 않아도 됩니다.\n\n**2단계 - 서버 검증:**\n서버가 요청된 메서드와 헤더를 허용하는지 확인합니다. 허용 정책을 응답 헤더에 포함합니다.\n\n**3단계 - 브라우저 확인:**\n브라우저가 서버 응답을 검토합니다. 허용되지 않으면 실제 요청을 보내지 않고 오류를 발생시킵니다.\n\n**4단계 - 실제 요청:**\nPreflight가 성공하면 원래 의도한 요청(DELETE, PUT 등)을 보냅니다.\n\n**5단계 - 실제 응답:**\n서버가 비즈니스 로직을 처리하고 결과를 반환합니다.\n\n**캐싱:**\n\n**Access-Control-Max-Age:**\nPreflight 응답을 캐시할 시간(초)을 지정합니다.\n```\nAccess-Control-Max-Age: 86400  (24시간)\n```\n\n**효과:**\n같은 조건의 요청은 캐시 기간 동안 Preflight를 다시 보내지 않습니다. 네트워크 트래픽과 지연을 감소시킵니다.\n\n**브라우저별 차이:**\nChrome: 2시간 기본 캐시, 최대 24시간. Firefox: 24시간 최대. Safari: 5분 기본.\n\n**서버 구현:**\n\n**OPTIONS 요청 처리:**\n서버는 OPTIONS 메서드를 명시적으로 처리해야 합니다. 실제 비즈니스 로직을 실행하지 않고 CORS 헤더만 반환합니다.\n\n**모든 라우트 대응:**\nOPTIONS 요청은 모든 엔드포인트에 도착할 수 있으므로 공통 미들웨어에서 처리합니다.\n\n**예시 - Express.js:**\n```\napp.options('*', (req, res) => {\n  res.header('Access-Control-Allow-Origin', 'https://www.example.com');\n  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');\n  res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');\n  res.header('Access-Control-Max-Age', '86400');\n  res.sendStatus(200);\n});\n```\n\n**성능 최적화:**\n\n**Max-Age 활용:**\n긴 캐시 시간을 설정하여 Preflight 횟수를 줄입니다.\n\n**단순 요청 사용:**\n가능하면 단순 요청 조건을 만족하도록 설계합니다. Content-Type을 text/plain으로 보내고 서버에서 JSON으로 파싱하는 트릭도 있습니다.\n\n**필요한 헤더만:**\n불필요한 사용자 정의 헤더를 피합니다.\n\n**문제 해결:**\n\n**Preflight 실패:**\n브라우저 콘솔에 명확한 오류 메시지가 표시됩니다. 서버가 OPTIONS 요청을 올바르게 처리하는지 확인합니다. 허용 헤더에 요청한 모든 헤더가 포함되어 있는지 확인합니다.\n\n**네트워크 도구:**\nChrome DevTools의 Network 탭에서 OPTIONS 요청을 확인할 수 있습니다. Preflight와 실제 요청이 순차적으로 나타납니다.\n\n**보안 의미:**\nPreflight는 서버를 보호하는 메커니즘입니다. 악의적인 교차 출처 요청이 실제 데이터를 변경하기 전에 차단합니다. 하지만 서버가 허용하면 통과하므로, 서버 측 검증이 필수입니다.\n\n**실무 권장:**\nCORS를 올바르게 설정하여 Preflight를 통과시킵니다. Max-Age를 적절히 설정하여 성능을 최적화합니다. 서버 로그에서 OPTIONS 요청을 모니터링합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "세션",
        "쿠키"
      ],
      "id": "1763437633067-cnthjjn9",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "Stateless와 Connectionless에 대해 설명해 주세요.",
      "answer": "**Stateless(무상태)**와 **Connectionless(비연결)**는 HTTP 프로토콜의 핵심 특성입니다.\n\n**Stateless (무상태성):**\n\n**정의:**\n서버가 클라이언트의 이전 요청 정보를 저장하지 않는 특성입니다. 각 요청은 완전히 독립적이며 이전 요청과 무관합니다.\n\n**특징:**\n서버는 클라이언트의 상태, 세션, 컨텍스트를 유지하지 않습니다. 매 요청마다 필요한 모든 정보를 포함해야 합니다. 요청 간에 어떤 관계도 존재하지 않습니다.\n\n**예시:**\n사용자가 로그인 후 상품 목록을 조회하고, 장바구니에 추가하는 과정에서 각 요청은 독립적입니다. 서버는 \"이 사용자가 방금 로그인했다\"는 정보를 자동으로 기억하지 않습니다.\n\n**장점:**\n\n**확장성:**\n서버가 상태를 저장하지 않으므로 어떤 서버든 요청을 처리할 수 있습니다. 로드 밸런서가 요청을 자유롭게 분산할 수 있습니다. 서버 추가/제거가 쉽습니다.\n\n**단순성:**\n서버 구현이 단순해집니다. 메모리 관리 부담이 줄어듭니다. 세션 동기화 문제가 없습니다.\n\n**안정성:**\n서버 크래시 시에도 다른 서버가 즉시 대체할 수 있습니다. 상태 손실 위험이 없습니다.\n\n**단점:**\n\n**반복 전송:**\n매 요청마다 인증 정보 등을 다시 보내야 합니다. 네트워크 트래픽이 증가합니다.\n\n**사용자 경험:**\n로그인 상태, 장바구니 등을 유지하기 어렵습니다. 쿠키, 세션, 토큰 등 별도 메커니즘이 필요합니다.\n\n**해결 방법:**\n\n**쿠키(Cookie):**\n클라이언트가 상태 정보를 저장하고 매 요청마다 전송합니다.\n\n**세션(Session):**\n서버가 세션 ID만 발급하고 실제 데이터는 서버에 저장합니다. 엄밀히는 Stateful이지만 HTTP는 여전히 Stateless입니다.\n\n**토큰(JWT):**\n클라이언트가 암호화된 토큰을 보관하고 매 요청에 포함합니다. 서버는 토큰을 검증만 하고 저장하지 않습니다.\n\n**Connectionless (비연결성):**\n\n**정의:**\n서버와 클라이언트가 연결을 지속적으로 유지하지 않는 특성입니다. 요청과 응답이 완료되면 TCP 연결을 끊습니다.\n\n**HTTP/1.0의 동작:**\n클라이언트가 요청마다 새로운 TCP 연결을 생성합니다. 서버가 응답하면 즉시 연결을 종료합니다. 하나의 HTML 페이지에 10개의 이미지가 있다면 11번의 연결이 필요합니다.\n\n**장점:**\n\n**서버 리소스 절약:**\n불필요한 연결을 유지하지 않아 메모리와 포트를 절약합니다. 동시 사용자 수가 많아도 부담이 적습니다.\n\n**단순성:**\n연결 관리의 복잡성이 줄어듭니다.\n\n**단점:**\n\n**성능 저하:**\n매번 TCP 3-way handshake를 수행해야 합니다. 연결 수립에 시간이 소요됩니다(1.5 RTT). 리소스가 많은 페이지는 매우 느립니다.\n\n**오버헤드:**\n반복적인 연결/종료로 CPU와 네트워크 자원을 낭비합니다.\n\n**HTTP/1.1의 개선 - Keep-Alive:**\n\n**Persistent Connection:**\nHTTP/1.1부터 기본적으로 연결을 유지합니다. Connection: keep-alive 헤더를 사용합니다. 한 연결로 여러 요청/응답을 처리합니다.\n\n**타임아웃:**\n일정 시간(예: 5초) 동안 요청이 없으면 연결을 종료합니다. 서버 리소스를 절약하면서도 성능을 개선합니다.\n\n**HTTP/2의 개선:**\n\n**멀티플렉싱:**\n하나의 연결에서 여러 요청/응답을 동시에 처리합니다. 연결 비용을 최소화하면서 성능을 극대화합니다.\n\n**비교:**\n\n**Stateless vs Stateful:**\n- Stateless: HTTP, DNS, UDP\n- Stateful: TCP, FTP 제어 연결, WebSocket\n\n**Connectionless vs Connection-Oriented:**\n- Connectionless: HTTP/1.0, UDP\n- Connection-Oriented: TCP, WebSocket\n\n**실무적 의미:**\n\n**RESTful API 설계:**\nStateless 원칙을 따라 각 요청이 자체 완결적이어야 합니다. 인증 토큰, 필요한 파라미터를 모두 포함합니다.\n\n**확장성:**\nStateless 특성 덕분에 수평 확장이 용이합니다. 클라우드 환경에서 오토스케일링이 가능합니다.\n\n**캐싱:**\nStateless 요청은 캐싱하기 쉽습니다. 같은 요청은 같은 응답을 반환하므로 CDN, 프록시 캐시를 활용할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "쿠키"
      ],
      "id": "1763437633067-2p177sel",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "왜 HTTP는 Stateless 구조를 채택하고 있을까요?",
      "answer": "HTTP가 Stateless 구조를 채택한 이유는 **확장성, 단순성, 안정성**을 위해서입니다.\n\n**역사적 배경:**\n\n**웹의 초기 목적:**\n1990년대 초 웹은 단순한 문서 공유 시스템으로 설계되었습니다. 정적 HTML 페이지를 요청하고 받는 것이 주요 용도였습니다. 복잡한 상태 관리가 필요 없었습니다.\n\n**단순성 우선:**\n팀 버너스리는 단순하고 확장 가능한 시스템을 원했습니다. Stateless는 가장 단순한 설계였습니다.\n\n**확장성(Scalability):**\n\n**서버 독립성:**\n서버가 상태를 저장하지 않으므로 요청이 어느 서버로 가도 상관없습니다. 로드 밸런서가 자유롭게 트래픽을 분산할 수 있습니다.\n\n**수평 확장:**\n서버를 추가하거나 제거하는 것이 간단합니다. 세션 동기화나 상태 복제가 필요 없습니다. 트래픽 증가 시 서버만 추가하면 됩니다.\n\n**무한 확장 가능:**\n상태 정보를 공유할 필요가 없어 이론적으로 무한대로 확장할 수 있습니다. 대규모 웹 서비스(Google, Facebook)가 가능한 이유입니다.\n\n**단순성(Simplicity):**\n\n**구현 간소화:**\n서버가 클라이언트 상태를 추적하지 않아 코드가 단순합니다. 메모리 관리, 세션 타임아웃, 동기화 등의 복잡성이 없습니다.\n\n**디버깅 용이:**\n각 요청이 독립적이므로 문제를 격리하기 쉽습니다. 특정 요청만 재현하면 버그를 찾을 수 있습니다.\n\n**프로토콜 진화:**\nStateless 설계로 HTTP 프로토콜을 점진적으로 발전시킬 수 있었습니다.\n\n**안정성(Reliability):**\n\n**장애 격리:**\n한 서버가 크래시해도 다른 서버가 즉시 대체할 수 있습니다. 클라이언트는 단순히 다시 요청하면 됩니다.\n\n**상태 손실 없음:**\n서버에 저장된 상태가 없으므로 손실될 것도 없습니다. 롤링 재시작이 안전합니다.\n\n**캐싱 가능성:**\n\n**프록시 캐시:**\nStateless 요청은 캐싱하기 쉽습니다. 같은 URL에 같은 요청은 같은 결과를 반환합니다.\n\n**CDN 활용:**\n정적 콘텐츠를 전 세계 CDN에 캐싱할 수 있습니다. 서버 부하를 크게 줄입니다.\n\n**네트워크 효율:**\n\n**중간 장비:**\n프록시, 게이트웨이, 캐시 서버 등이 요청을 독립적으로 처리할 수 있습니다. 복잡한 상태 동기화가 필요 없습니다.\n\n**RESTful 아키텍처:**\n\n**REST 원칙:**\nRoy Fielding의 REST 아키텍처는 Stateless를 핵심 제약 조건으로 정의합니다. Stateless 덕분에 REST API의 장점이 실현됩니다.\n\n**트레이드오프:**\n\n**상태 유지의 필요성:**\n실제 웹 애플리케이션은 상태가 필요합니다(로그인, 장바구니 등). Stateless HTTP 위에 상태 관리 레이어를 추가합니다(쿠키, 세션, 토큰).\n\n**복잡성 이동:**\n서버의 복잡성이 클라이언트나 별도 저장소(Redis, DB)로 이동합니다. 하지만 HTTP 자체는 단순하게 유지됩니다.\n\n**실무적 해결:**\n\n**클라이언트 측 저장:**\n쿠키, LocalStorage, SessionStorage에 상태를 저장합니다.\n\n**토큰 기반 인증:**\nJWT 같은 자체 포함 토큰을 사용합니다. 서버는 토큰을 검증만 하고 저장하지 않습니다.\n\n**외부 세션 저장소:**\nRedis, Memcached에 세션을 저장합니다. 여러 서버가 공유할 수 있습니다.\n\n**대안 프로토콜:**\n\n**WebSocket:**\nStateful한 양방향 연결이 필요한 경우 사용합니다. 실시간 채팅, 게임, 협업 도구 등에 적합합니다.\n\n**HTTP/2 Server Push:**\n일부 상태를 유지하는 것처럼 동작할 수 있습니다.\n\n**결론:**\nHTTP의 Stateless 설계는 웹이 글로벌 규모로 확장될 수 있었던 핵심 요소입니다. 단순성과 확장성의 이점이 상태 관리의 불편함을 상회합니다. 필요한 경우 애플리케이션 레벨에서 상태를 추가하면 됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "캐시"
      ],
      "id": "1763437633067-zzb79cys",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?",
      "answer": "Connectionless의 성능 문제는 여러 **최적화 기법**으로 해결되었습니다.\n\n**문제점:**\n\n**반복적인 연결 수립:**\n매 요청마다 TCP 3-way handshake가 필요합니다(1.5 RTT). 수십 개의 리소스가 있는 웹 페이지는 매우 느립니다.\n\n**느린 시작(Slow Start):**\n새 TCP 연결은 혼잡 제어의 Slow Start 단계를 거칩니다. 초기 전송 속도가 제한됩니다.\n\n**자원 낭비:**\n연결/종료에 CPU와 메모리가 소모됩니다.\n\n**해결 방법:**\n\n**1. HTTP/1.1 Keep-Alive (Persistent Connection):**\n\n**원리:**\n한 번 수립한 TCP 연결을 재사용합니다. Connection: keep-alive 헤더로 연결 유지를 요청합니다. 서버가 일정 시간 동안 연결을 열어둡니다.\n\n**효과:**\n여러 요청이 하나의 연결로 처리됩니다. 핸드셰이크 오버헤드가 대폭 감소합니다. 페이지 로딩 속도가 2-3배 향상됩니다.\n\n**타임아웃:**\n일정 시간(예: 5초) 동안 요청이 없으면 연결을 종료합니다. 서버 리소스를 절약하면서도 성능을 유지합니다.\n\n**2. HTTP Pipelining:**\n\n**원리:**\n첫 번째 응답을 기다리지 않고 여러 요청을 연속으로 보냅니다. 네트워크를 더 효율적으로 사용합니다.\n\n**한계:**\n응답은 요청 순서대로 받아야 합니다(HOL Blocking). 프록시 서버와의 호환성 문제. 실무에서 거의 사용되지 않습니다.\n\n**3. HTTP/2 Multiplexing:**\n\n**원리:**\n하나의 TCP 연결에서 여러 요청/응답을 동시에 처리합니다. 스트림 단위로 독립적으로 전송됩니다. 순서 제약 없이 병렬 처리가 가능합니다.\n\n**효과:**\n연결 수를 1개로 줄여도 성능이 우수합니다. HOL Blocking을 애플리케이션 레벨에서 해결했습니다. 헤더 압축(HPACK)으로 추가 최적화됩니다.\n\n**4. HTTP/3 (QUIC):**\n\n**원리:**\nUDP 기반 QUIC 프로토콜을 사용합니다. 0-RTT 연결 재개가 가능합니다. 스트림별 독립적인 전송으로 TCP HOL Blocking도 해결합니다.\n\n**효과:**\n첫 연결은 1-RTT, 재연결은 0-RTT로 매우 빠릅니다. 모바일 환경에서 성능이 크게 향상됩니다.\n\n**5. 도메인 샤딩(Domain Sharding):**\n\n**원리:**\n리소스를 여러 도메인(cdn1, cdn2, cdn3)에 분산합니다. 브라우저가 도메인당 6-8개의 병렬 연결을 생성합니다. 총 병렬 다운로드 수가 증가합니다.\n\n**적용:**\nHTTP/1.1 환경에서 유용합니다. HTTP/2에서는 오히려 역효과입니다(연결이 분산되어 멀티플렉싱 이점 감소).\n\n**6. 리소스 최적화:**\n\n**번들링:**\n여러 JS/CSS 파일을 하나로 합칩니다. 요청 수를 줄입니다.\n\n**스프라이트:**\n여러 이미지를 하나의 파일로 결합합니다.\n\n**인라이닝:**\n작은 리소스를 HTML에 직접 포함합니다(Base64 인코딩).\n\n**7. 캐싱:**\n\n**브라우저 캐시:**\nCache-Control, Expires 헤더로 리소스를 캐시합니다. 재방문 시 요청 자체를 하지 않습니다.\n\n**CDN:**\n정적 리소스를 전 세계에 배포합니다. 사용자와 가까운 서버에서 제공합니다.\n\n**8. 프리커넥트(Preconnect):**\n\n**원리:**\n필요한 도메인에 미리 연결합니다.\n```\n<link rel=\"preconnect\" href=\"https://api.example.com\">\n```\nDNS 조회, TCP 핸드셰이크, TLS 핸드셰이크를 사전에 수행합니다.\n\n**9. DNS 프리페치:**\n\n**원리:**\n필요한 도메인의 DNS를 미리 조회합니다.\n```\n<link rel=\"dns-prefetch\" href=\"//cdn.example.com\">\n```\n\n**10. TCP Fast Open:**\n\n**원리:**\n첫 SYN 패킷에 데이터를 포함합니다. 재연결 시 핸드셰이크 없이 즉시 데이터 전송합니다.\n\n**효과:**\n연결 수립 시간을 1 RTT 절약합니다.\n\n**11. Early Hints (HTTP 103):**\n\n**원리:**\n서버가 최종 응답 전에 힌트를 먼저 보냅니다. 브라우저가 CSS, JS를 미리 로드할 수 있습니다.\n\n**실무 적용:**\n\n**HTTP/1.1:**\nKeep-Alive + 도메인 샤딩 + 캐싱 + 번들링\n\n**HTTP/2:**\n단일 연결 + 멀티플렉싱 + 서버 푸시 + 캐싱\n\n**HTTP/3:**\nQUIC + 0-RTT + 연결 마이그레이션 + 캐싱\n\n**성능 비교:**\n\n**HTTP/1.0 (Connectionless):**\n10개 리소스 = 10번 연결 = 15 RTT\n\n**HTTP/1.1 (Keep-Alive):**\n10개 리소스 = 1번 연결 + 10번 순차 요청 = 1.5 RTT + 지연\n\n**HTTP/2:**\n10개 리소스 = 1번 연결 + 병렬 전송 = 1.5 RTT + 최소 지연\n\n**HTTP/3:**\n10개 리소스 = 0-1 RTT + 병렬 전송 = 최소 지연\n\n**결론:**\n초기 HTTP의 Connectionless 문제는 Keep-Alive, 멀티플렉싱, QUIC 등으로 해결되었습니다. 현대 웹은 연결을 효율적으로 재사용하여 뛰어난 성능을 제공합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "동기화"
      ],
      "id": "1763437633067-jfrkp1gp",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?",
      "answer": "**TCP Keep-Alive**와 **HTTP Keep-Alive**는 이름은 비슷하지만 **목적과 동작 방식이 다릅니다**.\n\n**TCP Keep-Alive:**\n\n**목적:**\n유휴 상태의 TCP 연결이 여전히 살아있는지 확인합니다. Dead Connection을 감지하고 정리합니다.\n\n**동작 방식:**\n일정 시간(기본 2시간) 동안 데이터 전송이 없으면 Keep-Alive 프로브를 보냅니다. 작은 패킷(일반적으로 1바이트)을 전송합니다. 상대방이 ACK로 응답하면 연결이 살아있다고 판단합니다. 응답이 없으면 일정 간격(기본 75초)으로 재시도합니다(기본 9회). 모두 실패하면 연결을 종료합니다.\n\n**레벨:**\n전송 계층(Layer 4) 메커니즘입니다. 운영체제 커널에서 처리됩니다. 애플리케이션과 무관하게 동작합니다.\n\n**설정:**\n소켓 옵션 SO_KEEPALIVE로 활성화합니다. sysctl로 시스템 전역 설정을 조정합니다. Linux: tcp_keepalive_time, tcp_keepalive_intvl, tcp_keepalive_probes.\n\n**사용 사례:**\n방화벽이나 NAT가 유휴 연결을 끊는 것을 방지합니다. 서버/클라이언트 크래시를 감지합니다. 장시간 유지되는 연결(DB, SSH)에서 유용합니다.\n\n**문제점:**\n기본 타임아웃(2시간)이 너무 깁니다. 빠른 감지가 필요한 경우 부적합합니다. 네트워크 트래픽을 약간 증가시킵니다.\n\n**HTTP Keep-Alive:**\n\n**목적:**\nTCP 연결을 재사용하여 여러 HTTP 요청/응답을 처리합니다. 연결 수립 오버헤드를 줄입니다.\n\n**동작 방식:**\nHTTP/1.1에서 기본적으로 활성화됩니다. Connection: keep-alive 헤더로 명시할 수 있습니다. 한 요청/응답이 끝나도 TCP 연결을 즉시 끊지 않습니다. 다음 요청이 올 때까지 대기합니다(일반적으로 5-120초). 타임아웃 내에 요청이 없으면 연결을 종료합니다.\n\n**레벨:**\n애플리케이션 계층(Layer 7) 메커니즘입니다. 웹 서버와 클라이언트가 처리합니다.\n\n**헤더:**\n```\n요청:\nConnection: keep-alive\n\n응답:\nConnection: keep-alive\nKeep-Alive: timeout=5, max=100\n```\n\n**timeout:**\n연결을 유지할 최대 시간(초)입니다.\n\n**max:**\n이 연결로 처리할 최대 요청 수입니다.\n\n**사용 사례:**\n웹 페이지의 여러 리소스(HTML, CSS, JS, 이미지)를 하나의 연결로 다운로드합니다. API 클라이언트가 여러 요청을 연속으로 보냅니다. 페이지 로딩 속도를 크게 향상시킵니다.\n\n**HTTP/1.0 vs HTTP/1.1:**\nHTTP/1.0: 기본적으로 비활성화, 명시적으로 요청해야 함. HTTP/1.1: 기본적으로 활성화, Connection: close로 비활성화 가능.\n\n**주요 차이점:**\n\n**계층:**\n- TCP Keep-Alive: 전송 계층(OS 커널)\n- HTTP Keep-Alive: 애플리케이션 계층(웹 서버/클라이언트)\n\n**목적:**\n- TCP: 연결 상태 확인, Dead Connection 감지\n- HTTP: 연결 재사용, 성능 최적화\n\n**타임아웃:**\n- TCP: 매우 김(2시간 기본)\n- HTTP: 짧음(5-120초)\n\n**프로브:**\n- TCP: Keep-Alive 프로브 패킷 전송\n- HTTP: 프로브 없음, 단순히 연결 유지\n\n**설정 위치:**\n- TCP: 운영체제 설정, 소켓 옵션\n- HTTP: 웹 서버 설정, HTTP 헤더\n\n**대상:**\n- TCP: 모든 TCP 연결(HTTP, FTP, SSH 등)\n- HTTP: HTTP 연결만\n\n**함께 사용:**\n두 메커니즘은 독립적으로 동작하며 동시에 활성화될 수 있습니다. HTTP Keep-Alive로 연결을 재사용하고, TCP Keep-Alive로 연결 상태를 확인합니다.\n\n**실무 예시:**\n\n**웹 브라우징:**\nHTTP Keep-Alive가 활성화되어 여러 리소스를 빠르게 다운로드합니다. TCP Keep-Alive는 대부분 비활성화되어 있습니다(필요없음).\n\n**WebSocket:**\n장시간 연결 유지를 위해 TCP Keep-Alive를 활성화하는 경우가 많습니다. 애플리케이션 레벨 Ping/Pong도 함께 사용합니다.\n\n**데이터베이스 연결:**\nConnection Pool이 TCP Keep-Alive를 활성화하여 유휴 연결을 유지합니다.\n\n**선택 기준:**\n단기 연결(웹): HTTP Keep-Alive만으로 충분. 장기 연결(DB, SSH): TCP Keep-Alive 활성화 권장. 방화벽/NAT 뒤: 두 메커니즘 모두 고려.\n\n**HTTP/2와 HTTP/3:**\nHTTP/2: Keep-Alive 개념이 없음, 멀티플렉싱으로 하나의 연결 사용. HTTP/3: QUIC의 Connection ID로 연결 유지, 별도 Keep-Alive 불필요.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "동기화"
      ],
      "id": "1763437633067-g2kmevj0",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "라우터 내의 포워딩 과정에 대해 설명해 주세요.",
      "answer": "**포워딩(Forwarding)**은 라우터가 도착한 패킷을 적절한 출력 인터페이스로 전달하는 과정입니다.\n\n**포워딩의 단계:**\n\n**1단계 - 패킷 수신:**\n패킷이 라우터의 입력 인터페이스에 도착합니다. 물리 계층에서 전기/광 신호를 비트로 변환합니다. 데이터링크 계층에서 프레임을 역캡슐화하여 IP 패킷을 추출합니다.\n\n**2단계 - 헤더 검증:**\nIP 헤더의 체크섬을 검증합니다. 버전, 헤더 길이, 패킷 크기를 확인합니다. 손상된 패킷은 폐기합니다.\n\n**3단계 - TTL 처리:**\nTTL(Time To Live) 값을 1 감소시킵니다. TTL이 0이 되면 패킷을 폐기하고 ICMP Time Exceeded 메시지를 송신자에게 보냅니다. 라우팅 루프를 방지하는 메커니즘입니다.\n\n**4단계 - 목적지 주소 추출:**\nIP 헤더에서 목적지 IP 주소를 읽습니다. 이 주소가 포워딩 결정의 핵심입니다.\n\n**5단계 - 포워딩 테이블 조회:**\n목적지 IP 주소로 포워딩 테이블(Forwarding Table)을 검색합니다. **최장 접두사 매칭(Longest Prefix Match)**을 사용합니다. 가장 구체적인(긴 접두사) 경로를 선택합니다.\n\n**최장 접두사 매칭 예시:**\n목적지: 192.168.1.100\n포워딩 테이블:\n- 192.168.0.0/16 → 인터페이스 1\n- 192.168.1.0/24 → 인터페이스 2\n- 0.0.0.0/0 (기본 경로) → 인터페이스 3\n\n결과: /24가 가장 길므로 인터페이스 2를 선택합니다.\n\n**6단계 - 출력 인터페이스 결정:**\n포워딩 테이블의 결과로 출력 포트를 결정합니다. 다음 홉(Next Hop) 라우터의 IP 주소도 함께 제공됩니다.\n\n**7단계 - 체크섬 재계산:**\nTTL이 변경되었으므로 IP 헤더 체크섬을 다시 계산합니다. 이는 IPv4에만 해당됩니다(IPv6는 체크섬 없음).\n\n**8단계 - ARP 조회:**\n다음 홉의 IP 주소를 MAC 주소로 변환합니다. ARP 캐시를 먼저 확인합니다. 캐시에 없으면 ARP 요청을 보냅니다.\n\n**9단계 - 프레임 생성:**\nIP 패킷을 데이터링크 프레임으로 캡슐화합니다. 이더넷 헤더에 목적지 MAC 주소(다음 홉), 송신 MAC 주소(라우터 인터페이스)를 설정합니다.\n\n**10단계 - 패킷 전송:**\n프레임을 출력 인터페이스의 큐에 넣습니다. 물리 계층이 비트를 신호로 변환하여 전송합니다.\n\n**빠른 경로 vs 느린 경로:**\n\n**빠른 경로(Fast Path):**\n대부분의 일반 패킷은 하드웨어(ASIC)에서 처리됩니다. 와이어 스피드로 포워딩됩니다. 소프트웨어 개입이 최소화됩니다.\n\n**느린 경로(Slow Path):**\n특수한 경우(ICMP, 옵션 패킷, 첫 패킷)는 CPU로 올라갑니다. 소프트웨어가 처리합니다. 상대적으로 느립니다.\n\n**QoS와 우선순위:**\nIP 헤더의 DSCP(Differentiated Services Code Point) 필드를 확인합니다. 우선순위가 높은 패킷(VoIP, 영상 등)을 먼저 전송합니다. 큐 관리로 혼잡을 제어합니다.\n\n**단편화(Fragmentation):**\n패킷 크기가 출력 인터페이스의 MTU를 초과하면 단편화합니다. IPv4는 라우터가 단편화할 수 있습니다. IPv6는 송신자만 단편화하며, 라우터는 Packet Too Big ICMP를 보냅니다.\n\n**멀티캐스트:**\n목적지가 멀티캐스트 주소면 특별한 처리를 합니다. 여러 출력 인터페이스로 복사하여 전송합니다.\n\n**필터링:**\nACL(Access Control List)을 확인하여 패킷을 허용/차단합니다. 방화벽 규칙을 적용합니다.\n\n**포워딩 테이블 구조:**\n일반적으로 트라이(Trie) 구조로 구현됩니다. TCAM(Ternary Content-Addressable Memory)을 사용하여 고속 조회를 수행합니다.\n\n**성능 최적화:**\n캐싱: 최근 조회 결과를 캐시합니다. 파이프라이닝: 여러 단계를 병렬 처리합니다. 하드웨어 가속: ASIC, FPGA로 포워딩 로직을 구현합니다.\n\n**라우팅 vs 포워딩:**\n라우팅: 경로를 계산하고 테이블을 구축하는 제어 평면. 포워딩: 패킷을 실제로 전달하는 데이터 평면. 포워딩은 라우팅 결과를 사용합니다.\n\n**오류 처리:**\n포워딩 테이블에 경로가 없으면 기본 경로(0.0.0.0/0)를 사용합니다. 그것도 없으면 ICMP Destination Unreachable을 송신자에게 보냅니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633067-ibsv9ssi",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "라우팅과 포워딩의 차이는 무엇인가요?",
      "answer": "**라우팅(Routing)**과 **포워딩(Forwarding)**은 네트워크 계층의 서로 다른 기능입니다.\n\n**라우팅(Routing):**\n\n**정의:**\n네트워크 토폴로지를 학습하고 최적의 경로를 계산하는 과정입니다.\n\n**역할:**\n라우팅 테이블(Routing Table)을 생성하고 유지합니다. 네트워크 변화를 감지하고 업데이트합니다. 여러 경로 중 최선의 경로를 선택합니다.\n\n**주기:**\n지속적으로 동작하지만 상대적으로 느린 프로세스입니다. 네트워크 변화가 있을 때 업데이트됩니다. 초 단위에서 분 단위로 동작합니다.\n\n**처리 위치:**\n라우터의 CPU(제어 평면)에서 처리됩니다. 소프트웨어로 구현됩니다.\n\n**프로토콜:**\nOSPF, BGP, RIP, EIGRP 등의 라우팅 프로토콜을 사용합니다. 정적 라우팅은 관리자가 수동으로 설정합니다.\n\n**목적:**\n네트워크 토폴로지를 이해하고 최적 경로를 찾습니다. 라우팅 테이블을 구축합니다.\n\n**포워딩(Forwarding):**\n\n**정의:**\n도착한 패킷을 적절한 출력 포트로 전달하는 과정입니다.\n\n**역할:**\n포워딩 테이블(Forwarding Table)을 참조합니다. 패킷의 목적지 주소를 보고 출력 인터페이스를 결정합니다. 실제로 패킷을 전송합니다.\n\n**주기:**\n패킷이 도착할 때마다 실행됩니다. 마이크로초 단위로 동작합니다. 매우 빠른 처리가 필요합니다.\n\n**처리 위치:**\n라우터의 전용 하드웨어(데이터 평면)에서 처리됩니다. ASIC, NPU 등으로 구현됩니다.\n\n**참조:**\n포워딩 테이블(라우팅 테이블에서 파생)을 사용합니다. 최장 접두사 매칭(Longest Prefix Match)을 수행합니다.\n\n**목적:**\n개별 패킷을 빠르게 전달합니다.\n\n**관계:**\n\n**종속 관계:**\n라우팅이 포워딩을 위한 정보를 제공합니다. 라우팅 테이블 → 포워딩 테이블 변환.\n\n**제어 평면 vs 데이터 평면:**\n- 라우팅: 제어 평면(Control Plane), 경로 결정\n- 포워딩: 데이터 평면(Data Plane), 패킷 전달\n\n**라우팅 테이블 vs 포워딩 테이블:**\n\n**라우팅 테이블:**\n라우팅 프로토콜이 학습한 모든 경로를 포함합니다. 여러 경로 중 최선의 경로를 선택하는 정보가 있습니다. 메트릭, 관리 거리, 다음 홉 등 상세 정보를 포함합니다.\n\n**포워딩 테이블:**\n라우팅 테이블에서 최선의 경로만 추출한 간소화된 테이블입니다. 빠른 조회를 위해 최적화되어 있습니다. 목적지 네트워크 → 출력 인터페이스 매핑만 포함합니다.\n\n**비유:**\n\n**라우팅:**\n지도를 연구하고 모든 가능한 경로를 분석하는 과정입니다. 교통 상황, 거리, 시간을 고려하여 최적 경로를 결정합니다. 한 번 계획하면 여러 번 사용합니다.\n\n**포워딩:**\n내비게이션의 음성 안내를 따라 실제로 운전하는 과정입니다. 각 교차로에서 즉시 어느 방향으로 갈지 결정합니다. 빠른 판단이 필요합니다.\n\n**구체적 예시:**\n\n**라우팅 프로세스:**\n1. OSPF가 네트워크 토폴로지를 학습합니다\n2. 다익스트라 알고리즘으로 최단 경로를 계산합니다\n3. 라우팅 테이블에 여러 경로를 저장합니다\n4. 최선의 경로를 선택하여 포워딩 테이블을 생성합니다\n\n**포워딩 프로세스:**\n1. 패킷이 도착합니다\n2. 목적지 IP(192.168.1.100)를 추출합니다\n3. 포워딩 테이블에서 조회합니다\n4. 매칭되는 경로(192.168.1.0/24 → eth1)를 찾습니다\n5. eth1 인터페이스로 패킷을 전송합니다\n\n**SDN(Software-Defined Networking):**\n\n**전통적 라우터:**\n라우팅과 포워딩이 같은 장비에 통합되어 있습니다.\n\n**SDN:**\n제어 평면(라우팅)과 데이터 평면(포워딩)을 분리합니다. 중앙 컨트롤러가 라우팅을 담당합니다. 스위치는 포워딩만 수행합니다.\n\n**성능 차이:**\n- 라우팅: 초당 수천 개의 경로 계산\n- 포워딩: 초당 수백만~수십억 개의 패킷 처리\n\n**오류 처리:**\n\n**라우팅 오류:**\n경로를 찾지 못하면 기본 경로를 사용합니다. 라우팅 프로토콜 장애 시 이전 정보를 유지합니다.\n\n**포워딩 오류:**\n매칭되는 경로가 없으면 ICMP Unreachable을 보냅니다. 인터페이스 다운 시 패킷을 폐기합니다.\n\n**실무 관점:**\n\n**라우터 설정:**\n라우팅 프로토콜을 설정하고 관리합니다(show ip route). 경로를 확인하고 문제를 진단합니다.\n\n**성능 모니터링:**\n포워딩 성능(pps, throughput)을 측정합니다. 포워딩 테이블 크기와 조회 속도를 최적화합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633067-mejw4obk",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "라우팅 알고리즘에 대해 설명해 주세요.",
      "answer": "**라우팅 알고리즘**은 네트워크에서 최적의 경로를 찾는 방법입니다.\n\n**분류:**\n\n**1. 정적 vs 동적:**\n\n**정적 라우팅(Static Routing):**\n관리자가 수동으로 경로를 설정합니다. 네트워크 변화에 자동으로 대응하지 못합니다. 소규모 네트워크나 특정 경로에 사용합니다.\n\n**동적 라우팅(Dynamic Routing):**\n라우팅 프로토콜이 자동으로 경로를 학습하고 업데이트합니다. 네트워크 변화에 적응합니다. 대규모 네트워크에 필수적입니다.\n\n**2. 전역 vs 분산:**\n\n**전역 정보(Global/Link-State):**\n모든 라우터가 전체 네트워크 토폴로지를 알고 있습니다. 각 라우터가 독립적으로 최단 경로를 계산합니다. OSPF, IS-IS가 대표적입니다.\n\n**분산 정보(Decentralized/Distance-Vector):**\n라우터가 인접 라우터로부터 정보를 받습니다. 전체 토폴로지를 모르고 거리 정보만 교환합니다. RIP, EIGRP가 대표적입니다.\n\n**주요 라우팅 알고리즘:**\n\n**1. 다익스트라 알고리즘(Dijkstra's Algorithm):**\n\n**특징:**\n링크 상태(Link-State) 알고리즘입니다. 전체 네트워크 토폴로지를 알고 있어야 합니다. 최단 경로 트리(Shortest Path Tree)를 구축합니다.\n\n**동작:**\n1. 출발 노드를 초기화합니다\n2. 출발 노드로부터 각 노드까지의 최단 거리를 계산합니다\n3. 방문하지 않은 노드 중 최단 거리 노드를 선택합니다\n4. 선택한 노드를 통한 경로가 더 짧으면 업데이트합니다\n5. 모든 노드를 방문할 때까지 반복합니다\n\n**장점:**\n최적 경로를 보장합니다. 루프가 발생하지 않습니다. 빠른 수렴(Convergence)이 가능합니다.\n\n**단점:**\n모든 노드의 정보가 필요합니다. 계산 복잡도가 O(N²) 또는 O(N log N)입니다. 메모리를 많이 사용합니다.\n\n**사용:**\nOSPF, IS-IS 프로토콜이 사용합니다.\n\n**2. 벨만-포드 알고리즘(Bellman-Ford Algorithm):**\n\n**특징:**\n거리 벡터(Distance-Vector) 알고리즘입니다. 분산 방식으로 동작합니다. 인접 라우터와 정보를 교환합니다.\n\n**동작:**\n1. 각 라우터가 자신의 거리 벡터를 초기화합니다\n2. 인접 라우터에게 거리 벡터를 전송합니다\n3. 받은 정보로 자신의 테이블을 업데이트합니다\n4. 변화가 없을 때까지 반복합니다\n\n**업데이트 공식:**\nD(x,y) = min{c(x,v) + D(v,y)} for all neighbors v\n\n**장점:**\n구현이 간단합니다. 전체 토폴로지 정보가 불필요합니다. 분산 처리가 가능합니다.\n\n**단점:**\n수렴 속도가 느립니다. 카운트 투 인피니티(Count to Infinity) 문제가 있습니다. 라우팅 루프가 발생할 수 있습니다.\n\n**해결책:**\nSplit Horizon: 받은 방향으로 정보를 되돌려 보내지 않습니다. Poison Reverse: 무한대 거리로 광고합니다. Hold-down Timer: 경로 변경 시 일정 시간 대기합니다.\n\n**사용:**\nRIP 프로토콜이 사용합니다.\n\n**3. 경로 벡터(Path Vector):**\n\n**특징:**\n전체 경로 정보를 포함합니다. 자율 시스템(AS) 간 라우팅에 사용합니다.\n\n**동작:**\n거리뿐 아니라 전체 경로(AS 경로)를 광고합니다. 루프를 쉽게 감지할 수 있습니다(자신이 경로에 있으면 거부).\n\n**사용:**\nBGP(Border Gateway Protocol)가 대표적입니다.\n\n**메트릭(Metric):**\n\n**홉 카운트(Hop Count):**\n경유하는 라우터 수입니다. RIP가 사용합니다. 단순하지만 대역폭을 고려하지 않습니다.\n\n**대역폭(Bandwidth):**\n링크의 전송 속도입니다. 빠른 링크를 선호합니다.\n\n**지연(Delay):**\n패킷 전송 시간입니다. 실시간 애플리케이션에 중요합니다.\n\n**비용(Cost):**\n관리자가 정의한 값입니다. OSPF가 대역폭 기반 비용을 사용합니다.\n\n**복합 메트릭:**\nEIGRP는 대역폭, 지연, 신뢰성, 부하를 종합합니다.\n\n**수렴(Convergence):**\n\n**정의:**\n모든 라우터가 일관된 라우팅 정보를 가지는 상태입니다.\n\n**중요성:**\n수렴 중에는 라우팅 루프나 블랙홀이 발생할 수 있습니다. 빠른 수렴이 네트워크 안정성에 중요합니다.\n\n**비교:**\n- Link-State: 매우 빠름(수초)\n- Distance-Vector: 느림(수십 초 ~ 수 분)\n\n**계층적 라우팅:**\n\n**필요성:**\n대규모 네트워크에서 모든 경로를 저장하는 것은 불가능합니다.\n\n**영역(Area) 분할:**\n네트워크를 영역으로 나눕니다. 영역 내부는 상세 정보, 영역 간은 요약 정보를 사용합니다. OSPF의 Area 개념이 대표적입니다.\n\n**자율 시스템(AS):**\n인터넷은 AS 단위로 분할됩니다. AS 내부는 IGP(OSPF, EIGRP), AS 간은 BGP를 사용합니다.\n\n**실무 선택:**\n\n**소규모 네트워크:**\n정적 라우팅 또는 간단한 RIP.\n\n**기업 네트워크:**\nOSPF 또는 EIGRP(Cisco).\n\n**인터넷 백본:**\nBGP로 AS 간 라우팅.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "캐시"
      ],
      "id": "1763437633067-otio1hal",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "포워딩 테이블의 구조에 대해 설명해 주세요.",
      "answer": "**포워딩 테이블(Forwarding Table)**은 라우터가 패킷을 전달하기 위해 참조하는 자료구조입니다.\n\n**기본 구조:**\n\n**엔트리 구성:**\n각 행(엔트리)은 하나의 경로를 나타냅니다. 주요 필드:\n- **목적지 네트워크(Destination Network)**: IP 주소와 서브넷 마스크\n- **넥스트 홉(Next Hop)**: 다음 라우터의 IP 주소\n- **출력 인터페이스(Output Interface)**: 패킷을 보낼 물리 포트\n- **메트릭(Metric)**: 경로의 비용\n- **플래그(Flags)**: 경로의 속성(직접 연결, 정적, 동적 등)\n\n**예시:**\n```\n목적지          넷마스크        넥스트홉      인터페이스   메트릭\n192.168.1.0    255.255.255.0   직접연결      eth0        0\n10.0.0.0       255.0.0.0       192.168.1.1   eth0        10\n0.0.0.0        0.0.0.0         192.168.1.254 eth0        1\n```\n\n**CIDR 표기:**\n```\n목적지              넥스트홉      인터페이스\n192.168.1.0/24      직접연결      eth0\n10.0.0.0/8          192.168.1.1   eth0\n0.0.0.0/0           192.168.1.254 eth0\n```\n\n**최장 접두사 매칭(Longest Prefix Match):**\n\n**원리:**\n패킷의 목적지 IP와 매칭되는 엔트리 중 가장 구체적인(긴 접두사) 것을 선택합니다.\n\n**예시:**\n목적지 IP: 192.168.1.100\n포워딩 테이블:\n- 192.168.0.0/16 → 인터페이스 1\n- 192.168.1.0/24 → 인터페이스 2\n- 192.168.1.64/26 → 인터페이스 3\n- 0.0.0.0/0 → 기본 게이트웨이\n\n결과: /26 (가장 긴 접두사) → 인터페이스 3\n\n**기본 경로(Default Route):**\n0.0.0.0/0 또는 ::/0은 모든 주소와 매칭됩니다. 다른 경로가 없을 때 사용됩니다. 일반적으로 인터넷 게이트웨이를 가리킵니다.\n\n**직접 연결 네트워크:**\n라우터 인터페이스에 직접 연결된 네트워크입니다. 넥스트 홉 없이 바로 전송할 수 있습니다.\n\n**자료구조 구현:**\n\n**1. 선형 탐색:**\n단순한 배열 또는 리스트입니다. 모든 엔트리를 순차적으로 검사합니다. 엔트리 수가 적을 때 간단하지만, 대규모 테이블에서는 느립니다.\n\n**2. 트라이(Trie):**\n비트별로 트리를 구성합니다. 빠른 조회(O(W), W는 주소 길이)가 가능합니다. 메모리 효율적입니다.\n\n**3. 패트리시아 트라이(Patricia Trie):**\n압축된 트라이로 메모리를 절약합니다. 최장 접두사 매칭에 최적화되어 있습니다.\n\n**4. TCAM(Ternary Content-Addressable Memory):**\n하드웨어 기반 병렬 검색입니다. 0, 1, X(don't care) 세 가지 상태를 지원합니다. 모든 엔트리를 동시에 검색하여 매우 빠릅니다(나노초 단위). 고성능 라우터에서 사용합니다.\n\n**5. 해시 테이블:**\n고정 길이 주소(/32)에 효과적입니다. 호스트 경로에 사용할 수 있습니다.\n\n**크기:**\n\n**엔터프라이즈 라우터:**\n수천 ~ 수만 개 엔트리.\n\n**ISP 라우터:**\n수십만 ~ 백만 개 엔트리. 전체 인터넷 라우팅 테이블은 약 90만 개 이상입니다(2024년 기준).\n\n**임베디드/홈 라우터:**\n수십 ~ 수백 개 엔트리.\n\n**캐싱:**\n\n**라우트 캐시:**\n최근 조회한 결과를 캐시합니다. 동일한 목적지로 향하는 패킷이 많을 때 효과적입니다.\n\n**플로우 캐시:**\n5-tuple(프로토콜, 송신 IP, 송신 포트, 수신 IP, 수신 포트)을 키로 캐싱합니다.\n\n**업데이트:**\n\n**라우팅 프로토콜 변경:**\n라우팅 테이블이 업데이트되면 포워딩 테이블도 갱신됩니다. 일관성을 유지하기 위해 원자적(atomic) 업데이트를 수행합니다.\n\n**소프트웨어 vs 하드웨어:**\n제어 평면(CPU)에서 포워딩 테이블을 구축합니다. 데이터 평면(ASIC)으로 복사하여 실제 포워딩에 사용합니다.\n\n**IPv6:**\nIPv6 포워딩 테이블은 별도로 유지됩니다. 128비트 주소로 인해 더 큰 메모리가 필요합니다.\n\n**특수 엔트리:**\n\n**로컬 주소:**\n라우터 자신의 IP 주소는 로컬 처리로 표시됩니다.\n\n**브로드캐스트:**\n255.255.255.255와 네트워크 브로드캐스트 주소.\n\n**멀티캐스트:**\n224.0.0.0/4 범위의 주소는 멀티캐스트 포워딩 테이블을 참조합니다.\n\n**최적화 기법:**\n\n**테이블 압축:**\n인접한 네트워크를 집계(Aggregation)하여 엔트리 수를 줄입니다.\n\n**빠른 조회:**\n이진 검색, 해시, TCAM 등으로 조회 속도를 최적화합니다.\n\n**병렬 처리:**\n여러 포워딩 엔진이 동시에 패킷을 처리합니다.\n\n**모니터링:**\nshow ip route 명령으로 라우팅 테이블을 확인합니다. show ip cef 명령으로 CEF(Cisco Express Forwarding) 테이블을 확인합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "프로세스"
      ],
      "id": "1763437633067-jj94v6m8",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "로드밸런서가 무엇인가요?",
      "answer": "**로드밸런서(Load Balancer)**는 들어오는 네트워크 트래픽을 여러 서버에 분산하는 장치 또는 소프트웨어입니다.\n\n**목적:**\n\n**트래픽 분산:**\n한 서버에 부하가 집중되는 것을 방지합니다. 여러 서버에 고르게 요청을 분배합니다.\n\n**고가용성(High Availability):**\n한 서버가 다운되어도 다른 서버가 계속 서비스를 제공합니다. 단일 장애점(Single Point of Failure)을 제거합니다.\n\n**확장성(Scalability):**\n서버를 추가하여 처리 용량을 쉽게 늘릴 수 있습니다. 수평 확장(Scale-Out)이 가능합니다.\n\n**성능 향상:**\n서버 간 부하를 균등하게 분배하여 응답 시간을 줄입니다.\n\n**동작 원리:**\n\n**1. 요청 수신:**\n클라이언트가 로드밸런서의 가상 IP(VIP)로 요청을 보냅니다. 사용자는 로드밸런서와 통신한다고 인식합니다.\n\n**2. 서버 선택:**\n로드밸런싱 알고리즘에 따라 백엔드 서버 중 하나를 선택합니다.\n\n**3. 요청 전달:**\n선택된 서버로 요청을 포워딩합니다. 필요시 IP 주소나 포트를 변경(NAT)합니다.\n\n**4. 응답 반환:**\n서버의 응답을 클라이언트에게 전달합니다.\n\n**유형:**\n\n**하드웨어 로드밸런서:**\n전용 장비(F5, Citrix NetScaler, Radware)입니다. 고성능이지만 비용이 높습니다. 대규모 엔터프라이즈 환경에서 사용합니다.\n\n**소프트웨어 로드밸런서:**\n범용 서버에 설치하는 소프트웨어(HAProxy, Nginx, Apache)입니다. 유연하고 비용이 저렴합니다. 클라우드 환경에 적합합니다.\n\n**클라우드 로드밸런서:**\n클라우드 제공자의 관리형 서비스(AWS ELB, Google Cloud Load Balancer, Azure Load Balancer)입니다. 설정과 관리가 간편합니다. 자동 스케일링을 지원합니다.\n\n**헬스 체크(Health Check):**\n\n**목적:**\n백엔드 서버의 상태를 지속적으로 확인합니다. 장애가 발생한 서버를 자동으로 제외합니다.\n\n**방법:**\n- **TCP 연결**: 특정 포트에 연결을 시도합니다\n- **HTTP 요청**: 특정 경로에 GET 요청을 보내고 응답 코드를 확인합니다\n- **커스텀 스크립트**: 복잡한 상태 검증을 수행합니다\n\n**간격:**\n일반적으로 5-30초마다 확인합니다. 연속 실패 횟수로 서버를 제외합니다(예: 3회 연속 실패).\n\n**세션 유지(Session Persistence):**\n\n**문제:**\nStateful 애플리케이션에서 사용자 요청이 서로 다른 서버로 가면 세션이 끊어집니다.\n\n**해결:**\n\n**Sticky Session(고정 세션):**\n같은 클라이언트의 요청을 항상 같은 서버로 보냅니다. 쿠키나 IP 주소로 클라이언트를 식별합니다.\n\n**Session Clustering:**\n서버 간 세션을 공유합니다. Redis, Memcached 등 외부 저장소를 사용합니다.\n\n**Stateless 설계:**\nJWT 같은 토큰 기반 인증을 사용하여 세션 의존성을 제거합니다.\n\n**SSL/TLS 종료:**\n\n**SSL Termination:**\n로드밸런서에서 HTTPS를 복호화합니다. 백엔드 서버는 HTTP로 통신하여 부담을 줄입니다. 인증서 관리가 중앙화됩니다.\n\n**SSL Passthrough:**\n암호화된 트래픽을 그대로 백엔드로 전달합니다. 엔드투엔드 암호화를 유지합니다.\n\n**장점:**\n\n**안정성:**\n서버 장애 시 자동으로 다른 서버로 전환합니다.\n\n**유연성:**\n서버를 추가/제거하여 용량을 조절할 수 있습니다. 무중단 배포가 가능합니다.\n\n**보안:**\n백엔드 서버를 외부에 직접 노출하지 않습니다. DDoS 공격 완화에 도움이 됩니다.\n\n**단점:**\n\n**단일 장애점:**\n로드밸런서 자체가 고장나면 전체 서비스가 중단됩니다. 로드밸런서도 이중화해야 합니다.\n\n**비용:**\n추가 하드웨어/소프트웨어 비용이 발생합니다.\n\n**복잡성:**\n설정과 관리가 복잡해질 수 있습니다.\n\n**실무 활용:**\n\n**웹 서비스:**\n여러 웹 서버 앞에 로드밸런서를 배치합니다. 트래픽 증가 시 서버를 추가합니다.\n\n**마이크로서비스:**\n각 서비스마다 로드밸런서를 두어 독립적으로 확장합니다. 서비스 메시(Istio, Linkerd)가 이를 자동화합니다.\n\n**데이터베이스:**\n읽기 전용 복제본에 대한 쿼리를 분산합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633067-u9wcq26g",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.",
      "answer": "**L4 로드밸런서**와 **L7 로드밸런서**는 OSI 모델의 서로 다른 계층에서 동작하는 로드밸런서입니다.\n\n**L4 로드밸런서 (전송 계층):**\n\n**동작 계층:**\nOSI 모델의 4계층(전송 계층)에서 동작합니다. TCP/UDP 수준에서 트래픽을 처리합니다.\n\n**판단 기준:**\n- **IP 주소**: 송신/수신 IP\n- **포트 번호**: 송신/수신 포트\n- **프로토콜**: TCP, UDP\n\n**처리 방식:**\n패킷의 IP 헤더와 TCP/UDP 헤더만 확인합니다. 애플리케이션 데이터(페이로드)를 보지 않습니다. 빠른 패킷 전달에 집중합니다.\n\n**예시:**\n모든 80번 포트 트래픽을 서버 풀에 분산합니다. IP 주소 기반으로 라운드 로빈을 수행합니다.\n\n**장점:**\n- **속도**: 패킷 처리가 매우 빠릅니다\n- **효율**: 적은 리소스로 높은 처리량을 제공합니다\n- **프로토콜 독립성**: HTTP 외 다양한 프로토콜을 지원합니다(FTP, SMTP, DB 등)\n- **보안**: 애플리케이션 데이터를 복호화하지 않아도 됩니다\n\n**단점:**\n- **제한된 분산**: URL, 헤더, 쿠키 등을 고려할 수 없습니다\n- **세션 유지 한계**: IP 기반 고정만 가능합니다\n- **캐싱 불가**: 콘텐츠를 이해하지 못해 캐싱할 수 없습니다\n\n**사용 사례:**\n단순한 트래픽 분산, 높은 처리량이 필요한 경우, 프로토콜 다양성이 필요한 경우.\n\n**L7 로드밸런서 (애플리케이션 계층):**\n\n**동작 계층:**\nOSI 모델의 7계층(애플리케이션 계층)에서 동작합니다. HTTP/HTTPS 같은 애플리케이션 프로토콜을 이해합니다.\n\n**판단 기준:**\n- **URL 경로**: /api, /images, /admin\n- **HTTP 헤더**: Host, User-Agent, Content-Type\n- **쿠키**: 세션 ID, 사용자 정보\n- **HTTP 메서드**: GET, POST, PUT, DELETE\n- **요청 내용**: JSON 데이터, 쿼리 파라미터\n\n**처리 방식:**\n패킷의 애플리케이션 데이터를 파싱하고 분석합니다. HTTP 요청을 완전히 이해하고 처리합니다. 필요시 콘텐츠를 수정하거나 캐싱합니다.\n\n**예시:**\n- /api/* 요청은 API 서버로\n- /images/* 요청은 이미지 서버로\n- 모바일 User-Agent는 모바일 최적화 서버로\n\n**장점:**\n- **정교한 분산**: URL, 헤더 등 다양한 조건으로 라우팅합니다\n- **콘텐츠 기반 라우팅**: 요청 내용을 분석하여 최적 서버를 선택합니다\n- **SSL 종료**: HTTPS 복호화/암호화를 담당합니다\n- **캐싱**: 정적 콘텐츠를 캐싱하여 서버 부하를 줄입니다\n- **압축**: Gzip 압축으로 대역폭을 절약합니다\n- **보안**: WAF(Web Application Firewall) 기능을 통합할 수 있습니다\n\n**단점:**\n- **느린 속도**: 애플리케이션 데이터 파싱으로 지연이 증가합니다\n- **높은 리소스**: CPU와 메모리를 더 많이 사용합니다\n- **프로토콜 제한**: 주로 HTTP/HTTPS만 지원합니다\n\n**사용 사례:**\n마이크로서비스 아키텍처, API 게이트웨이, 복잡한 라우팅 규칙이 필요한 경우.\n\n**비교 표:**\n\n**처리 속도:**\n- L4: 매우 빠름 (수백만 pps)\n- L7: 상대적으로 느림\n\n**판단 정보:**\n- L4: IP, 포트\n- L7: URL, 헤더, 쿠키, 콘텐츠\n\n**프로토콜:**\n- L4: 모든 TCP/UDP\n- L7: 주로 HTTP/HTTPS\n\n**세션 유지:**\n- L4: IP 기반\n- L7: 쿠키 기반\n\n**캐싱:**\n- L4: 불가\n- L7: 가능\n\n**SSL 처리:**\n- L4: Passthrough\n- L7: Termination 가능\n\n**실제 예시:**\n\n**L4 라우팅:**\n```\n클라이언트:50123 → 로드밸런서:80 → 서버1:8080\n클라이언트:50124 → 로드밸런서:80 → 서버2:8080\n```\n포트 정보만으로 단순 분산합니다.\n\n**L7 라우팅:**\n```\nGET /api/users → API 서버\nGET /images/logo.png → 이미지 서버\nPOST /admin/login → 관리 서버\n```\nURL 경로로 서비스별 라우팅합니다.\n\n**하이브리드 구성:**\n\n**L4 + L7 조합:**\nL4 로드밸런서를 앞단에 두어 트래픽을 먼저 분산합니다. 각 L4 뒤에 L7 로드밸런서를 배치하여 세밀한 라우팅을 수행합니다. 성능과 유연성을 동시에 확보합니다.\n\n**대표 제품:**\n\n**L4:**\nAWS NLB(Network Load Balancer), IPVS, LVS.\n\n**L7:**\nAWS ALB(Application Load Balancer), Nginx, HAProxy, Envoy.\n\n**선택 기준:**\n단순한 트래픽 분산, 높은 성능 필요 → L4. 복잡한 라우팅, HTTP 기능 필요 → L7. 초고성능 + 세밀한 제어 → L4와 L7 조합.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "캐시"
      ],
      "id": "1763437633067-46tezuc0",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "로드밸런서 알고리즘에 대해 설명해 주세요.",
      "answer": "**로드밸런서 알고리즘**은 들어오는 요청을 어느 서버로 보낼지 결정하는 방법입니다.\n\n**1. 라운드 로빈(Round Robin):**\n\n**원리:**\n요청을 서버 목록 순서대로 순환하며 분배합니다. 서버 A → B → C → A → B → C...\n\n**장점:**\n구현이 간단합니다. 서버 간 균등하게 분산됩니다.\n\n**단점:**\n서버 성능 차이를 고려하지 않습니다. 요청 처리 시간이 다를 때 불균형이 발생합니다.\n\n**적합한 경우:**\n모든 서버가 동일한 성능을 가질 때. 요청 처리 시간이 비슷할 때.\n\n**2. 가중 라운드 로빈(Weighted Round Robin):**\n\n**원리:**\n각 서버에 가중치를 부여합니다. 가중치가 높은 서버에 더 많은 요청을 보냅니다. 예: A(가중치 3), B(가중치 2), C(가중치 1) → A, A, A, B, B, C 순서로 분배.\n\n**장점:**\n서버 성능 차이를 반영할 수 있습니다. 점진적인 배포(Canary Deployment)에 유용합니다.\n\n**단점:**\n가중치를 수동으로 설정해야 합니다.\n\n**적합한 경우:**\n서버 성능이 다를 때. 일부 서버에 더 많은 트래픽을 보내고 싶을 때.\n\n**3. 최소 연결(Least Connections):**\n\n**원리:**\n현재 활성 연결 수가 가장 적은 서버를 선택합니다. 동적으로 서버 부하를 고려합니다.\n\n**장점:**\n장시간 연결이나 처리 시간이 다를 때 효과적입니다. 실시간으로 부하를 반영합니다.\n\n**단점:**\n연결 수를 추적해야 하므로 오버헤드가 있습니다.\n\n**적합한 경우:**\nWebSocket, 스트리밍 등 장시간 연결. 요청 처리 시간이 크게 다를 때.\n\n**4. 가중 최소 연결(Weighted Least Connections):**\n\n**원리:**\n최소 연결 방식에 서버 가중치를 추가합니다. 연결 수를 가중치로 나눈 값이 가장 작은 서버를 선택합니다.\n\n**장점:**\n서버 성능과 현재 부하를 모두 고려합니다.\n\n**적합한 경우:**\n성능이 다른 서버를 효율적으로 활용할 때.\n\n**5. IP 해시(IP Hash):**\n\n**원리:**\n클라이언트 IP 주소를 해시하여 서버를 결정합니다. 같은 IP는 항상 같은 서버로 연결됩니다.\n\n**장점:**\n세션 고정(Sticky Session)이 자동으로 이루어집니다. 추가 쿠키나 설정이 필요 없습니다.\n\n**단점:**\nIP 주소가 변경되면 다른 서버로 연결됩니다. NAT 뒤의 여러 사용자가 같은 IP로 보일 수 있습니다. 서버 추가/제거 시 많은 세션이 재분배됩니다.\n\n**적합한 경우:**\nStateful 애플리케이션. 세션 유지가 중요한 경우.\n\n**6. URL 해시(URL Hash):**\n\n**원리:**\n요청 URL을 해시하여 서버를 결정합니다. 같은 URL은 항상 같은 서버로 연결됩니다.\n\n**장점:**\n캐싱 효율이 높아집니다. 같은 콘텐츠는 항상 같은 서버에서 제공됩니다.\n\n**단점:**\nURL 분포가 고르지 않으면 불균형이 발생합니다.\n\n**적합한 경우:**\nCDN, 프록시 캐시. 정적 콘텐츠 서빙.\n\n**7. 최소 응답 시간(Least Response Time):**\n\n**원리:**\n응답 시간이 가장 짧은 서버를 선택합니다. 헬스 체크로 응답 시간을 측정합니다.\n\n**장점:**\n사용자가 가장 빠른 서비스를 받습니다.\n\n**단점:**\n지속적인 측정이 필요하여 오버헤드가 큽니다.\n\n**적합한 경우:**\n지연 시간이 중요한 애플리케이션. 지리적으로 분산된 서버.\n\n**8. 랜덤(Random):**\n\n**원리:**\n서버를 무작위로 선택합니다.\n\n**장점:**\n구현이 간단합니다. 서버 수가 많을 때 통계적으로 균등해집니다.\n\n**단점:**\n단기적으로 불균형이 발생할 수 있습니다.\n\n**적합한 경우:**\n간단한 테스트 환경. 서버 수가 매우 많을 때.\n\n**9. 리소스 기반(Resource-Based):**\n\n**원리:**\n서버의 CPU, 메모리, 디스크 사용률을 실시간 모니터링합니다. 리소스가 가장 여유로운 서버를 선택합니다.\n\n**장점:**\n서버 상태를 정확히 반영합니다.\n\n**단점:**\n모니터링 오버헤드가 큽니다. 네트워크 지연이 추가될 수 있습니다.\n\n**적합한 경우:**\n서버 부하가 매우 다양할 때. 동적 워크로드.\n\n**10. 일관성 해싱(Consistent Hashing):**\n\n**원리:**\n해시 링을 사용하여 서버를 배치합니다. 서버 추가/제거 시 최소한의 키만 재분배됩니다.\n\n**장점:**\n서버 변경 시 영향을 최소화합니다. 캐시 무효화를 줄입니다.\n\n**단점:**\n구현이 복잡합니다.\n\n**적합한 경우:**\n분산 캐시. 동적으로 서버가 추가/제거되는 환경.\n\n**선택 기준:**\n\n**동일 성능, 단순 환경:**\n라운드 로빈.\n\n**성능 차이, 정적 환경:**\n가중 라운드 로빈.\n\n**동적 부하, 장시간 연결:**\n최소 연결.\n\n**세션 유지 필요:**\nIP 해시.\n\n**캐싱 최적화:**\nURL 해시 또는 일관성 해싱.\n\n**실무 권장:**\n대부분의 경우 라운드 로빈이나 최소 연결로 시작합니다. 필요에 따라 가중치를 추가하거나 해시 기반으로 전환합니다. 모니터링하여 알고리즘 효과를 검증합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633067-pqdvew85",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?",
      "answer": "로드밸런서는 **헬스 체크(Health Check)** 메커니즘으로 장애 서버를 자동으로 감지하고 제외합니다.\n\n**헬스 체크 메커니즘:**\n\n**1. 주기적 검사:**\n로드밸런서가 일정 간격으로 백엔드 서버의 상태를 확인합니다. 일반적으로 5-30초마다 검사합니다.\n\n**2. 검사 방법:**\n\n**TCP 연결 확인:**\n특정 포트에 TCP 연결을 시도합니다. 연결 성공하면 서버가 살아있다고 판단합니다. 빠르고 간단하지만 애플리케이션 상태를 확인하지 못합니다.\n\n**HTTP/HTTPS 요청:**\n특정 경로(예: /health, /ping)에 GET 요청을 보냅니다. 응답 코드를 확인합니다(일반적으로 200 OK 기대). 응답 본문을 검증할 수도 있습니다.\n\n**커스텀 스크립트:**\n복잡한 검증 로직을 실행합니다. 데이터베이스 연결, 의존 서비스 확인 등을 수행합니다.\n\n**3. 실패 판정:**\n\n**연속 실패 횟수:**\n일시적인 오류를 무시하기 위해 여러 번 실패해야 제외합니다. 일반적으로 2-3회 연속 실패 시 제외합니다.\n\n**타임아웃:**\n응답이 일정 시간(예: 3초) 내에 오지 않으면 실패로 간주합니다.\n\n**4. 서버 제외:**\n실패 조건을 만족하면 해당 서버를 서버 풀에서 제외합니다. 새로운 요청을 해당 서버로 보내지 않습니다.\n\n**5. 복구 감지:**\n\n**계속 검사:**\n제외된 서버도 계속 헬스 체크를 수행합니다.\n\n**복구 확인:**\n연속적으로 성공하면(예: 2-3회) 서버 풀에 다시 추가합니다.\n\n**점진적 복구:**\n즉시 전체 트래픽을 보내지 않고 점진적으로 증가시킵니다.\n\n**헬스 체크 예시:**\n\n**AWS ELB:**\n```\nTarget: /health\nInterval: 30초\nTimeout: 5초\nHealthy threshold: 2회 연속 성공\nUnhealthy threshold: 3회 연속 실패\n```\n\n**Nginx:**\n```\nupstream backend {\n    server backend1.example.com;\n    server backend2.example.com;\n\n    health_check interval=5s\n                 fails=3\n                 passes=2\n                 uri=/health\n                 match=server_ok;\n}\n\nmatch server_ok {\n    status 200;\n    body ~ \"OK\";\n}\n```\n\n**고급 헬스 체크:**\n\n**애플리케이션 레벨 체크:**\n단순히 서버가 실행 중인지가 아니라 정상 동작하는지 확인합니다. 데이터베이스 연결, 캐시 접근, 의존 서비스 확인 등을 포함합니다.\n\n**엔드포인트 구현:**\n백엔드 서버에 /health 엔드포인트를 구현합니다. 자체 진단 로직을 실행하고 상태를 반환합니다.\n```\nGET /health\n200 OK\n{ \"status\": \"healthy\", \"database\": \"ok\", \"cache\": \"ok\" }\n```\n\n**Graceful Shutdown:**\n\n**문제:**\n서버 종료 중에도 로드밸런서가 요청을 보낼 수 있습니다.\n\n**해결:**\n\n**1. 헬스 체크 실패 반환:**\n서버가 종료를 시작하면 헬스 체크에 실패 응답을 반환합니다.\n\n**2. 대기:**\n로드밸런서가 서버를 제외할 때까지 기다립니다(헬스 체크 간격 + 실패 횟수).\n\n**3. 기존 요청 완료:**\n진행 중인 요청을 모두 처리합니다.\n\n**4. 종료:**\n안전하게 서버를 종료합니다.\n\n**드레이닝(Draining):**\n\n**원리:**\n서버를 서버 풀에서 제외하되 기존 연결은 유지합니다. 새 요청은 받지 않고 기존 요청만 완료합니다.\n\n**사용:**\n배포, 유지보수, 서버 교체 시 사용합니다.\n\n**자동 복구:**\n\n**Auto Healing:**\n클라우드 환경에서 헬스 체크 실패 시 자동으로 인스턴스를 교체합니다. AWS Auto Scaling, Kubernetes Liveness Probe 등이 해당합니다.\n\n**Self-Healing:**\n서버 자체가 문제를 감지하고 재시작을 시도합니다.\n\n**모니터링과 알림:**\n\n**서버 제외 알림:**\n서버가 서버 풀에서 제외되면 관리자에게 알립니다.\n\n**헬스 체크 실패 로그:**\n실패 원인을 분석할 수 있도록 로깅합니다.\n\n**대시보드:**\n실시간으로 서버 풀 상태를 시각화합니다.\n\n**실무 권장사항:**\n\n**적절한 간격:**\n너무 짧으면 서버 부하, 너무 길면 장애 감지 지연. 일반적으로 10-30초가 적절합니다.\n\n**타임아웃 설정:**\n네트워크 지연을 고려하여 여유 있게 설정합니다.\n\n**점진적 제외:**\n연속 실패로 일시적 문제를 무시합니다.\n\n**테스트:**\n헬스 체크 엔드포인트를 정기적으로 테스트합니다. 장애 시나리오를 시뮬레이션합니다.\n\n**백업:**\n최소 2대 이상의 서버를 유지하여 모든 서버가 동시에 제외되지 않도록 합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "HTTP"
      ],
      "id": "1763437633067-r3uj76zs",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.",
      "answer": "**DNS 기반 로드밸런싱**은 DNS 응답에 여러 IP 주소를 포함하거나 조건에 따라 다른 IP를 반환하여 트래픽을 분산하는 방법입니다.\n\n**DNS Round Robin:**\n\n**원리:**\n하나의 도메인에 여러 A 레코드(IP 주소)를 등록합니다. DNS 서버가 쿼리마다 IP 주소 순서를 순환하여 응답합니다.\n\n**설정 예시:**\n```\nexample.com.    IN  A   192.0.2.1\nexample.com.    IN  A   192.0.2.2\nexample.com.    IN  A   192.0.2.3\n```\n\n**동작:**\n- 첫 번째 클라이언트: 192.0.2.1, 192.0.2.2, 192.0.2.3 받음\n- 두 번째 클라이언트: 192.0.2.2, 192.0.2.3, 192.0.2.1 받음\n- 세 번째 클라이언트: 192.0.2.3, 192.0.2.1, 192.0.2.2 받음\n\n클라이언트는 일반적으로 첫 번째 IP를 사용하므로 분산 효과가 있습니다.\n\n**장점:**\n설정이 간단하고 추가 장비가 필요 없습니다. 비용이 들지 않습니다. DNS 인프라만 있으면 됩니다.\n\n**단점:**\n\n**캐싱 문제:**\nDNS 응답이 캐싱되어 실시간 분산이 어렵습니다. TTL 동안 같은 IP를 계속 사용할 수 있습니다.\n\n**헬스 체크 없음:**\n서버 장애를 자동으로 감지하지 못합니다. 다운된 서버의 IP도 계속 응답에 포함됩니다.\n\n**불균등 분산:**\n클라이언트가 항상 첫 번째 IP를 선택하지 않을 수 있습니다. 캐시, 네트워크 조건에 따라 불균등해집니다.\n\n**세션 유지 어려움:**\n사용자가 재접속 시 다른 서버로 연결될 수 있습니다.\n\n**GeoDNS (지리적 DNS):**\n\n**원리:**\n클라이언트의 지리적 위치에 따라 다른 IP 주소를 반환합니다. 가까운 데이터센터로 연결하여 지연을 최소화합니다.\n\n**동작:**\n- 한국 클라이언트 → 한국 데이터센터 IP\n- 미국 클라이언트 → 미국 데이터센터 IP\n- 유럽 클라이언트 → 유럽 데이터센터 IP\n\n**장점:**\n지연 시간을 크게 줄입니다. 지역별 규정 준수(데이터 주권)에 유리합니다.\n\n**제공자:**\nAWS Route 53, Cloudflare, Google Cloud DNS, Akamai.\n\n**가중 Round Robin:**\n\n**원리:**\n각 서버에 가중치를 부여합니다. 가중치에 비례하여 IP를 응답합니다.\n\n**예시:**\n- Server A (가중치 3): 60% 트래픽\n- Server B (가중치 2): 40% 트래픽\n\n**사용:**\n점진적 배포(Canary), 서버 성능 차이 반영.\n\n**헬스 체크 통합:**\n\n**DNS 헬스 체크:**\n일부 DNS 서비스는 서버 상태를 모니터링합니다. 다운된 서버의 IP를 응답에서 자동 제외합니다. 복구되면 다시 포함합니다.\n\n**예시:**\nAWS Route 53, Google Cloud DNS는 헬스 체크를 지원합니다. 엔드포인트에 주기적으로 요청을 보내 상태를 확인합니다.\n\n**장애 조치(Failover):**\n\n**Primary-Secondary 구조:**\n정상 시에는 Primary 서버 IP를 반환합니다. Primary 다운 시 자동으로 Secondary IP로 전환합니다.\n\n**설정:**\n헬스 체크를 Primary에 설정합니다. 실패 시 DNS가 자동으로 Secondary를 반환합니다.\n\n**Latency-Based Routing:**\n\n**원리:**\n클라이언트에게 가장 낮은 지연 시간을 제공하는 서버를 선택합니다. 실제 네트워크 지연을 측정하여 결정합니다.\n\n**장점:**\n지리적 위치보다 실제 성능을 반영합니다.\n\n**TTL 관리:**\n\n**짧은 TTL:**\n빠른 변경 적용을 위해 TTL을 짧게(60초~5분) 설정합니다. 서버 추가/제거, 장애 조치가 빠릅니다.\n\n**단점:**\nDNS 쿼리가 증가하여 DNS 서버 부하가 커집니다.\n\n**긴 TTL:**\nDNS 쿼리를 줄여 성능을 향상시킵니다. 하지만 변경 적용이 느립니다.\n\n**권장:**\n일반적으로 5분~1시간이 적절합니다.\n\n**DNS 로드밸런싱 vs 전용 로드밸런서:**\n\n**DNS의 장점:**\n비용이 저렴하거나 무료입니다. 설정이 간단합니다. 추가 인프라가 필요 없습니다. 지리적 분산에 효과적입니다.\n\n**DNS의 단점:**\n실시간 헬스 체크가 제한적입니다. 세션 유지가 어렵습니다. 세밀한 제어가 불가능합니다. 캐싱으로 인한 지연이 있습니다.\n\n**전용 로드밸런서의 장점:**\n실시간 헬스 체크와 자동 제외를 수행합니다. 정교한 알고리즘을 사용합니다. 세션 유지, SSL 종료 등 고급 기능을 제공합니다.\n\n**하이브리드 접근:**\n\n**DNS + 로드밸런서:**\nDNS로 지역별 로드밸런서를 선택합니다. 각 로드밸런서가 해당 지역 서버를 관리합니다. 글로벌 분산과 로컬 최적화를 동시에 달성합니다.\n\n**실무 사용:**\n\n**소규모:**\n비용 절감을 위해 DNS Round Robin 사용.\n\n**중규모:**\nGeoDNS + 헬스 체크로 기본 고가용성 확보.\n\n**대규모:**\nDNS(글로벌 분산) + 로드밸런서(로컬 분산) 조합.\n\n**주의사항:**\nDNS 캐싱을 고려한 설계가 필요합니다. 백업 계획이 필수적입니다. 모니터링으로 분산 효과를 검증합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "메모리",
        "세션"
      ],
      "id": "1763437633067-r0wb6dsp",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.",
      "answer": "**서브넷 마스크(Subnet Mask)**와 **게이트웨이(Gateway)**는 IP 네트워킹의 핵심 개념입니다.\n\n**서브넷 마스크:**\n\n**정의:**\nIP 주소에서 네트워크 부분과 호스트 부분을 구분하는 32비트 값입니다.\n\n**역할:**\n같은 네트워크에 있는지 판단합니다. 네트워크 크기를 정의합니다. 효율적인 IP 주소 관리를 가능하게 합니다.\n\n**형식:**\n\n**점 십진 표기:**\n255.255.255.0 형태로 표현합니다.\n\n**CIDR 표기:**\n/24 형태로 표현합니다(1비트 개수).\n\n**비트 패턴:**\n네트워크 부분은 1, 호스트 부분은 0으로 표시합니다.\n\n**예시:**\n\n**255.255.255.0 (/24):**\n이진: 11111111.11111111.11111111.00000000\n네트워크 비트: 24개, 호스트 비트: 8개\n가능한 호스트: 256개 (사용 가능: 254개)\n\n**IP 주소 192.168.1.100/24:**\n- IP: 192.168.1.100\n- 서브넷 마스크: 255.255.255.0\n- 네트워크 주소: 192.168.1.0\n- 브로드캐스트 주소: 192.168.1.255\n- 사용 가능한 호스트: 192.168.1.1 ~ 192.168.1.254\n\n**계산 방법:**\n\n**네트워크 주소:**\nIP AND 서브넷 마스크 = 네트워크 주소\n192.168.1.100 AND 255.255.255.0 = 192.168.1.0\n\n**브로드캐스트 주소:**\n네트워크 주소 OR (NOT 서브넷 마스크)\n\n**같은 네트워크 판단:**\n두 IP의 네트워크 주소가 같으면 같은 네트워크입니다.\n\n**예시:**\n- 192.168.1.100/24와 192.168.1.200/24: 같은 네트워크\n- 192.168.1.100/24와 192.168.2.100/24: 다른 네트워크\n\n**서브넷팅:**\n\n**목적:**\n큰 네트워크를 작은 서브넷으로 분할합니다. IP 주소를 효율적으로 사용합니다. 보안과 관리를 개선합니다.\n\n**예시:**\n192.168.1.0/24를 4개 서브넷으로 분할:\n- 192.168.1.0/26 (192.168.1.0 ~ 192.168.1.63)\n- 192.168.1.64/26 (192.168.1.64 ~ 192.168.1.127)\n- 192.168.1.128/26 (192.168.1.128 ~ 192.168.1.191)\n- 192.168.1.192/26 (192.168.1.192 ~ 192.168.1.255)\n\n**게이트웨이(Gateway):**\n\n**정의:**\n서로 다른 네트워크를 연결하는 장치(일반적으로 라우터)의 IP 주소입니다.\n\n**역할:**\n다른 네트워크로 패킷을 전달합니다. 기본 게이트웨이는 알 수 없는 목적지로 가는 패킷의 출구입니다.\n\n**동작:**\n\n**같은 네트워크:**\n목적지가 같은 네트워크에 있으면 직접 전송합니다. ARP로 목적지 MAC 주소를 찾아 전송합니다.\n\n**다른 네트워크:**\n목적지가 다른 네트워크에 있으면 게이트웨이로 전송합니다. 게이트웨이가 패킷을 라우팅합니다.\n\n**기본 게이트웨이(Default Gateway):**\n\n**정의:**\n특정 경로가 없는 모든 트래픽을 보낼 라우터입니다. 일반적으로 인터넷으로 나가는 출구입니다.\n\n**예시:**\n홈 네트워크에서 공유기가 기본 게이트웨이입니다. 공유기 IP: 192.168.1.1 (일반적).\n\n**설정:**\n수동: 관리자가 직접 입력합니다. DHCP: 자동으로 할당받습니다.\n\n**패킷 전송 예시:**\n\n**시나리오:**\nPC: 192.168.1.100/24, 게이트웨이: 192.168.1.1\n목적지: www.google.com (142.250.185.46)\n\n**과정:**\n1. PC가 목적지 IP와 자신의 네트워크를 비교합니다\n2. 다른 네트워크이므로 게이트웨이로 전송 결정합니다\n3. ARP로 게이트웨이(192.168.1.1)의 MAC 주소를 찾습니다\n4. 패킷의 목적지 IP는 142.250.185.46이지만, 이더넷 프레임의 목적지 MAC은 게이트웨이의 MAC입니다\n5. 게이트웨이가 패킷을 받아 라우팅합니다\n\n**여러 게이트웨이:**\n\n**복수 인터페이스:**\n여러 네트워크 인터페이스가 있을 때 각각 다른 게이트웨이를 가질 수 있습니다.\n\n**정적 라우트:**\n특정 목적지로 가는 패킷은 특정 게이트웨이를 사용하도록 설정합니다.\n\n**메트릭:**\n여러 게이트웨이가 있을 때 메트릭으로 우선순위를 결정합니다.\n\n**라우팅 테이블:**\n\n**예시:**\n```\n목적지          서브넷마스크    게이트웨이      인터페이스\n192.168.1.0    255.255.255.0   직접연결        eth0\n10.0.0.0       255.0.0.0       192.168.1.1     eth0\n0.0.0.0        0.0.0.0         192.168.1.1     eth0\n```\n\n**0.0.0.0/0:**\n기본 게이트웨이를 나타냅니다. 모든 알 수 없는 목적지에 매칭됩니다.\n\n**문제 해결:**\n\n**ping 테스트:**\n같은 네트워크 호스트에 ping: 네트워크 연결 확인. 게이트웨이에 ping: 게이트웨이 연결 확인. 외부 IP에 ping: 인터넷 연결 확인.\n\n**traceroute:**\n패킷이 거치는 게이트웨이 목록을 확인합니다.\n\n**잘못된 설정:**\n서브넷 마스크나 게이트웨이가 잘못되면 통신이 불가능합니다. 게이트웨이가 같은 네트워크에 없으면 도달할 수 없습니다.\n\n**실무 예시:**\n\n**가정 네트워크:**\nIP: 192.168.0.100\n서브넷 마스크: 255.255.255.0\n게이트웨이: 192.168.0.1 (공유기)\n\n**기업 네트워크:**\nIP: 10.1.2.100\n서브넷 마스크: 255.255.255.0 (/24)\n게이트웨이: 10.1.2.1 (라우터)",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633067-r08smh3y",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "NAT에 대해 설명해 주세요.",
      "answer": "**NAT(Network Address Translation)**는 IP 주소를 변환하는 기술로, 주로 사설 IP를 공인 IP로 변환하는 데 사용됩니다.\n\n**필요성:**\n\n**IPv4 주소 고갈:**\n공인 IP 주소가 부족합니다. 모든 장치에 공인 IP를 할당할 수 없습니다. NAT로 여러 장치가 하나의 공인 IP를 공유합니다.\n\n**보안:**\n내부 네트워크 구조를 외부에서 숨깁니다. 직접적인 외부 접근을 차단합니다.\n\n**동작 원리:**\n\n**기본 NAT:**\n1. 내부 호스트(192.168.1.100)가 외부(8.8.8.8)로 패킷을 보냅니다\n2. NAT 라우터가 송신 IP를 공인 IP(203.0.113.1)로 변환합니다\n3. 외부 서버는 203.0.113.1로부터 패킷을 받은 것으로 인식합니다\n4. 응답 패킷이 203.0.113.1로 돌아옵니다\n5. NAT 라우터가 목적지 IP를 192.168.1.100으로 변환합니다\n6. 내부 호스트가 응답을 받습니다\n\n**NAT 테이블:**\nNAT 라우터는 변환 정보를 테이블에 저장합니다.\n```\n내부 IP:포트        외부 IP:포트        목적지 IP:포트\n192.168.1.100:50123 203.0.113.1:50123  8.8.8.8:53\n192.168.1.101:50124 203.0.113.1:50124  1.1.1.1:443\n```\n\n**NAT 유형:**\n\n**1. SNAT (Source NAT):**\n송신자 IP 주소를 변환합니다. 내부에서 외부로 나가는 트래픽에 사용합니다. 일반적인 홈 네트워크 NAT입니다.\n\n**2. DNAT (Destination NAT):**\n목적지 IP 주소를 변환합니다. 외부에서 내부로 들어오는 트래픽에 사용합니다. 포트 포워딩이 대표적입니다.\n\n**3. PAT (Port Address Translation, NAPT):**\nIP 주소와 포트를 모두 변환합니다. 여러 내부 호스트가 하나의 공인 IP를 공유합니다. 가장 일반적인 NAT 방식입니다.\n\n**4. Static NAT:**\n내부 IP와 공인 IP를 1:1로 고정 매핑합니다. 서버 등에 사용합니다.\n\n**5. Dynamic NAT:**\n공인 IP 풀에서 동적으로 할당합니다. 동시 접속자 수만큼 공인 IP가 필요합니다.\n\n**포트 포워딩(Port Forwarding):**\n\n**목적:**\n외부에서 내부 서버로 접근을 허용합니다.\n\n**설정:**\n공인 IP의 특정 포트를 내부 IP의 특정 포트로 매핑합니다. 예: 203.0.113.1:80 → 192.168.1.10:80 (웹 서버)\n\n**예시:**\n외부 사용자가 공유기 IP:80으로 접속하면 내부 웹 서버(192.168.1.10:80)로 연결됩니다.\n\n**장점:**\n\n**IP 절약:**\n수백 대의 장치가 하나의 공인 IP를 사용합니다. IPv4 고갈 문제를 완화합니다.\n\n**보안:**\n내부 IP가 외부에 노출되지 않습니다. 외부에서 내부로의 직접 접근이 차단됩니다(포트 포워딩 제외).\n\n**유연성:**\n내부 네트워크를 자유롭게 설계할 수 있습니다.\n\n**단점:**\n\n**엔드투엔드 연결 방해:**\n진정한 엔드투엔드 통신이 불가능합니다. 일부 프로토콜(FTP, VoIP)에서 문제가 발생할 수 있습니다.\n\n**성능:**\nNAT 처리로 인한 지연이 발생합니다. 라우터 부하가 증가합니다.\n\n**복잡성:**\n포트 포워딩, 알리지 등 추가 설정이 필요합니다.\n\n**P2P 통신 어려움:**\n양쪽이 모두 NAT 뒤에 있으면 직접 연결이 어렵습니다. NAT 트래버설(STUN, TURN) 기술이 필요합니다.\n\n**NAT 트래버설:**\n\n**STUN (Session Traversal Utilities for NAT):**\nNAT의 외부 IP와 포트를 확인합니다. 이를 상대방에게 알려 P2P 연결을 시도합니다.\n\n**TURN (Traversal Using Relays around NAT):**\n직접 연결이 불가능하면 중계 서버를 통해 통신합니다.\n\n**ICE (Interactive Connectivity Establishment):**\nSTUN과 TURN을 결합한 프레임워크입니다. WebRTC에서 사용합니다.\n\n**Carrier-Grade NAT (CGN):**\n\n**정의:**\nISP 레벨에서 대규모 NAT를 수행합니다. 여러 가정이 하나의 공인 IP를 공유합니다(이중 NAT).\n\n**문제:**\n포트 포워딩이 불가능하거나 매우 복잡합니다. 일부 애플리케이션이 동작하지 않을 수 있습니다.\n\n**IPv6와 NAT:**\n\n**IPv6의 충분한 주소:**\nNAT의 주요 이유(주소 부족)가 사라집니다. 모든 장치가 공인 IP를 가질 수 있습니다.\n\n**NAT의 미래:**\nIPv6 환경에서도 보안을 위해 NAT를 사용할 수 있습니다. 하지만 엔드투엔드 연결이 IPv6의 철학입니다.\n\n**실무 예시:**\n\n**홈 네트워크:**\n공유기가 NAT를 수행합니다. 내부: 192.168.x.x, 외부: ISP가 할당한 공인 IP.\n\n**기업 네트워크:**\n방화벽이나 라우터가 NAT를 수행합니다. 다수의 공인 IP 풀을 사용할 수 있습니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "세션",
        "캐시"
      ],
      "id": "1763437633067-cmiow9o5",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "서브넷 마스크의 표현 방식에 대해 설명해 주세요.",
      "answer": "**서브넷 마스크**는 네트워크와 호스트 부분을 구분하며, 여러 방식으로 표현할 수 있습니다.\n\n**1. 점 십진 표기(Dotted Decimal Notation):**\n\n**형식:**\n4개의 십진수를 점으로 구분합니다. 예: 255.255.255.0\n\n**일반적인 값:**\n- 255.255.255.0 (클래스 C 기본)\n- 255.255.0.0 (클래스 B 기본)\n- 255.0.0.0 (클래스 A 기본)\n- 255.255.255.128 (/25)\n- 255.255.255.192 (/26)\n\n**이진수 변환:**\n255 = 11111111 (모두 1)\n0 = 00000000 (모두 0)\n\n**2. CIDR 표기(Classless Inter-Domain Routing):**\n\n**형식:**\n슬래시 뒤에 네트워크 비트 수를 표시합니다. 예: /24\n\n**의미:**\n/24 = 앞의 24비트가 네트워크 부분입니다.\n\n**변환:**\n- /24 = 255.255.255.0\n- /16 = 255.255.0.0\n- /8 = 255.0.0.0\n\n**장점:**\n간결하고 명확합니다. 가변 길이 서브넷 마스크(VLSM)를 표현하기 쉽습니다. 현대 네트워킹에서 표준입니다.\n\n**3. 이진 표기:**\n\n**형식:**\n32비트 이진수로 표현합니다. 네트워크 부분은 1, 호스트 부분은 0입니다.\n\n**예시:**\n255.255.255.0 = 11111111.11111111.11111111.00000000\n\n**직관성:**\n네트워크와 호스트 경계가 명확합니다.\n\n**4. 16진수 표기:**\n\n**형식:**\n0x로 시작하는 16진수입니다.\n\n**예시:**\n255.255.255.0 = 0xFFFFFF00\n\n**사용:**\n프로그래밍, 저수준 네트워크 설정에서 사용합니다.\n\n**변환 예시:**\n\n**255.255.255.0:**\n- 점 십진: 255.255.255.0\n- CIDR: /24\n- 이진: 11111111.11111111.11111111.00000000\n- 16진: 0xFFFFFF00\n- 네트워크 비트: 24개\n- 호스트 비트: 8개\n\n**255.255.255.128:**\n- 점 십진: 255.255.255.128\n- CIDR: /25\n- 이진: 11111111.11111111.11111111.10000000\n- 네트워크 비트: 25개\n- 호스트 비트: 7개\n\n**유효한 서브넷 마스크:**\n\n**규칙:**\n왼쪽부터 연속된 1, 오른쪽부터 연속된 0이어야 합니다. 1과 0이 섞일 수 없습니다.\n\n**유효:**\n- 11111111.11111111.11111111.00000000 (O)\n- 11111111.11111111.11110000.00000000 (O)\n\n**무효:**\n- 11111111.11111111.00000000.11111111 (X) - 1과 0이 섞임\n- 11111111.11111111.11111111.01010101 (X) - 1과 0이 교차\n\n**가능한 서브넷 마스크 값:**\n\n**/8부터 /30까지:**\n- /8: 255.0.0.0 (1,677만 호스트)\n- /16: 255.255.0.0 (6.5만 호스트)\n- /24: 255.255.255.0 (254 호스트)\n- /25: 255.255.255.128 (126 호스트)\n- /26: 255.255.255.192 (62 호스트)\n- /27: 255.255.255.224 (30 호스트)\n- /28: 255.255.255.240 (14 호스트)\n- /29: 255.255.255.248 (6 호스트)\n- /30: 255.255.255.252 (2 호스트, P2P 링크용)\n- /31: 255.255.255.254 (RFC 3021, P2P 전용)\n- /32: 255.255.255.255 (호스트 라우트, 단일 IP)\n\n**호스트 수 계산:**\n2^(32-prefix) - 2 = 사용 가능한 호스트 수\n(네트워크 주소와 브로드캐스트 주소 제외)\n\n**예시:**\n/24: 2^(32-24) - 2 = 2^8 - 2 = 256 - 2 = 254 호스트\n\n**VLSM (Variable Length Subnet Mask):**\n\n**정의:**\n하나의 네트워크를 다양한 크기의 서브넷으로 나눕니다. 필요에 따라 다른 서브넷 마스크를 사용합니다.\n\n**예시:**\n192.168.1.0/24를 분할:\n- 192.168.1.0/26 (62 호스트) - 서버용\n- 192.168.1.64/27 (30 호스트) - 사무실 A\n- 192.168.1.96/27 (30 호스트) - 사무실 B\n- 192.168.1.128/25 (126 호스트) - 직원용\n\n**장점:**\nIP 주소를 효율적으로 사용합니다. 네트워크를 유연하게 설계할 수 있습니다.\n\n**표기 방법 선택:**\n\n**설정 파일:**\n일반적으로 점 십진 표기를 사용합니다.\n\n**라우팅 테이블:**\nCIDR 표기가 간결하고 명확합니다.\n\n**문서화:**\nCIDR 표기가 현대적이고 표준적입니다.\n\n**프로그래밍:**\n이진수나 16진수로 비트 연산을 수행합니다.\n\n**실무 권장:**\nCIDR 표기(/24 형식)를 기본으로 사용하고, 필요시 점 십진 표기를 병기합니다. 예: 192.168.1.0/24 (255.255.255.0)",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633067-7gmpsom1",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?",
      "answer": "**결론**\n255.0.255.0과 같은 불연속적인 서브넷 마스크는 이론적으로는 가능하지만, 실무에서는 사용하지 않으며 대부분의 네트워크 장비에서 지원하지 않습니다.\n\n**연속된 1의 비트 원칙**\n- 서브넷 마스크는 왼쪽부터 연속된 1의 비트로 구성되어야 합니다\n- 1의 비트가 끝나면 나머지는 모두 0이어야 합니다\n- 255.255.255.0 (11111111.11111111.11111111.00000000)은 올바른 형태\n- 255.0.255.0 (11111111.00000000.11111111.00000000)은 불연속적인 형태\n\n**불연속 서브넷 마스크의 문제점**\n- 네트워크 주소와 호스트 주소의 구분이 모호해집니다\n- 라우팅 테이블 계산이 복잡하고 비효율적입니다\n- CIDR 표기법으로 표현할 수 없습니다\n- 네트워크 장비의 라우팅 알고리즘과 호환되지 않습니다\n- 서브넷 계산 및 관리가 매우 어려워집니다\n\n**RFC 표준과 실무**\n- RFC 950과 RFC 1812에서 연속된 비트 패턴을 권장합니다\n- 대부분의 라우터와 네트워크 장비는 불연속 마스크를 거부합니다\n- 일부 장비는 설정은 허용하지만 예상치 못한 동작을 할 수 있습니다\n- 표준 네트워크 관리 도구들이 지원하지 않습니다\n\n**올바른 서브넷 마스크 예시**\n- 255.0.0.0 (/8) - 연속된 8비트\n- 255.255.0.0 (/16) - 연속된 16비트\n- 255.255.255.0 (/24) - 연속된 24비트\n- 255.255.255.128 (/25) - 연속된 25비트\n- 255.255.255.252 (/30) - 연속된 30비트\n\n**실무 권장사항**\n- 항상 연속된 1의 비트로 구성된 표준 서브넷 마스크를 사용해야 합니다\n- CIDR 표기법을 사용하여 명확하게 표현합니다\n- 네트워크 설계 시 RFC 표준을 준수합니다\n- 특수한 목적이 있더라도 비표준 마스크 사용을 피해야 합니다",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "세션"
      ],
      "id": "1763437633067-cx6w1wig",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.",
      "answer": "**멀티플렉싱 (Multiplexing) 정의**\n멀티플렉싱은 전송 계층에서 여러 응용 프로세스의 데이터를 하나의 전송 채널로 합쳐서 전송하는 기술입니다. 송신 측에서 여러 소켓으로부터 데이터를 수집하여 세그먼트를 생성하고 네트워크 계층으로 전달하는 과정입니다.\n\n**디멀티플렉싱 (Demultiplexing) 정의**\n디멀티플렉싱은 수신 측에서 하나의 전송 채널로 들어온 데이터를 올바른 응용 프로세스의 소켓으로 분배하는 기술입니다. 전송 계층에서 세그먼트를 받아 헤더 정보를 기반으로 적절한 소켓으로 전달하는 과정입니다.\n\n**멀티플렉싱의 필요성**\n- 하나의 네트워크 인터페이스로 여러 애플리케이션이 동시에 통신할 수 있습니다\n- 시스템 자원을 효율적으로 활용할 수 있습니다\n- 다중 프로세스 환경에서 각 프로세스가 독립적으로 네트워크 통신이 가능합니다\n- 포트 번호를 통해 프로세스를 식별하고 구분합니다\n\n**동작 메커니즘**\n- 송신 측: 소켓 → 전송 계층 헤더 추가 (포트 번호 포함) → 세그먼트 생성 → 네트워크 계층으로 전달\n- 수신 측: 네트워크 계층 → 전송 계층 → 헤더 정보 확인 → 목적지 포트로 데이터 전달 → 해당 소켓\n- 포트 번호가 핵심 식별자 역할을 수행합니다\n\n**UDP의 멀티플렉싱/디멀티플렉싱**\n- 목적지 IP 주소와 목적지 포트 번호만으로 소켓을 식별합니다\n- 출발지 정보는 소켓 식별에 사용되지 않습니다\n- 같은 목적지 포트로 오는 모든 데이터는 같은 소켓으로 전달됩니다\n- 단순하고 빠른 처리가 가능합니다\n\n**TCP의 멀티플렉싱/디멀티플렉싱**\n- 4개의 정보로 소켓을 식별합니다: 출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트\n- 각 연결마다 고유한 소켓이 생성됩니다\n- 같은 서버 포트로 여러 클라이언트가 동시에 연결 가능합니다\n- 연결 지향적이고 정확한 데이터 전달이 보장됩니다\n\n**실무 활용**\n- 웹 서버가 80번 포트로 여러 클라이언트의 HTTP 요청을 동시에 처리합니다\n- 하나의 컴퓨터에서 브라우저, 메일 클라이언트, 파일 전송 등 여러 네트워크 애플리케이션이 동시에 작동합니다\n- 서버는 수천 개의 클라이언트 연결을 하나의 포트로 관리합니다\n- 포트 번호를 통해 각 애플리케이션을 독립적으로 관리할 수 있습니다",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633067-nzqlamge",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "디멀티플렉싱의 과정에 대해 설명해 주세요.",
      "answer": "**디멀티플렉싱 개요**\n디멀티플렉싱은 네트워크 계층으로부터 받은 세그먼트를 헤더 정보를 분석하여 올바른 애플리케이션의 소켓으로 전달하는 과정입니다.\n\n**1단계: 세그먼트 수신**\n- 네트워크 계층(IP 계층)에서 데이터그램을 전송 계층으로 전달합니다\n- 데이터그램에는 IP 헤더와 전송 계층 세그먼트가 포함되어 있습니다\n- IP 계층은 IP 헤더를 제거하고 세그먼트를 전송 계층으로 전달합니다\n\n**2단계: 헤더 정보 추출**\n- 전송 계층에서 세그먼트의 헤더를 읽습니다\n- TCP 또는 UDP 헤더에서 필요한 정보를 추출합니다\n- 목적지 포트 번호를 확인합니다\n- 출발지 IP 주소와 포트 번호도 함께 확인합니다 (TCP의 경우)\n\n**3단계: UDP 디멀티플렉싱**\n- UDP는 2-tuple 방식을 사용합니다\n- 목적지 IP 주소와 목적지 포트 번호만으로 소켓을 식별합니다\n- 해당 포트 번호로 바인딩된 소켓을 찾습니다\n- 출발지 정보와 관계없이 같은 목적지 포트로 오는 모든 데이터는 동일한 소켓으로 전달됩니다\n\n**4단계: TCP 디멀티플렉싱**\n- TCP는 4-tuple 방식을 사용합니다\n- 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호를 모두 확인합니다\n- 이 4개 정보의 조합으로 고유한 소켓을 식별합니다\n- 같은 서버 포트라도 클라이언트가 다르면 다른 소켓으로 전달됩니다\n\n**5단계: 소켓 테이블 조회**\n- 운영체제는 소켓 테이블을 유지합니다\n- 포트 번호와 연결 정보를 기반으로 소켓 테이블을 검색합니다\n- 매칭되는 소켓 디스크립터를 찾습니다\n- 해당 소켓과 연결된 프로세스를 식별합니다\n\n**6단계: 데이터 전달**\n- 찾아진 소켓의 수신 버퍼에 데이터를 저장합니다\n- 애플리케이션이 read/recv 시스템 콜을 호출하면 버퍼의 데이터를 전달합니다\n- 프로세스는 자신의 소켓으로 온 데이터만 받게 됩니다\n\n**7단계: 오류 처리**\n- 매칭되는 소켓이 없는 경우 처리합니다\n- UDP는 ICMP Port Unreachable 메시지를 보냅니다\n- TCP는 RST 세그먼트를 보내 연결을 거부합니다\n- 방화벽 규칙에 따라 패킷을 드롭할 수도 있습니다\n\n**실무 예시**\n- 웹 서버 80번 포트로 여러 클라이언트 연결이 들어옵니다\n- 각 연결은 (클라이언트IP:클라이언트포트, 서버IP:80) 조합으로 식별됩니다\n- 예: (192.168.1.100:52000, 10.0.0.1:80)과 (192.168.1.101:52000, 10.0.0.1:80)은 서로 다른 소켓입니다\n- 전송 계층은 이 정보를 기반으로 각 데이터를 올바른 연결의 소켓으로 전달합니다\n- 애플리케이션은 각 클라이언트의 요청을 독립적으로 처리할 수 있습니다\n\n**성능 최적화**\n- 소켓 테이블은 해시 테이블로 구현되어 빠른 검색이 가능합니다\n- 연결이 많을수록 효율적인 자료구조가 중요합니다\n- 커널 레벨에서 최적화되어 있어 오버헤드가 최소화됩니다",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접"
      ],
      "id": "1763437633067-c763uy96",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "XSS에 대해서 설명해 주세요.",
      "answer": "**XSS (Cross-Site Scripting) 정의**\nXSS는 공격자가 웹 애플리케이션에 악의적인 스크립트를 삽입하여 다른 사용자의 브라우저에서 실행되도록 하는 보안 취약점입니다. 사용자 입력을 적절히 검증하거나 이스케이프하지 않을 때 발생합니다.\n\n**XSS의 동작 원리**\n- 공격자가 악성 스크립트가 포함된 데이터를 웹 애플리케이션에 입력합니다\n- 서버가 이를 검증 없이 저장하거나 반환합니다\n- 다른 사용자가 해당 페이지를 방문하면 악성 스크립트가 실행됩니다\n- 스크립트는 피해자의 브라우저 권한으로 실행되어 민감한 정보에 접근할 수 있습니다\n\n**Stored XSS (저장형 XSS)**\n- 악성 스크립트가 서버의 데이터베이스에 영구적으로 저장됩니다\n- 게시판, 댓글, 사용자 프로필 등에 스크립트를 삽입합니다\n- 해당 페이지를 방문하는 모든 사용자가 피해를 입습니다\n- 가장 위험한 형태의 XSS 공격입니다\n- 예: 게시글에 악성 스크립트를 작성하여 저장하면, 이를 읽는 모든 사용자가 공격당합니다\n\n**Reflected XSS (반사형 XSS)**\n- 악성 스크립트가 URL 파라미터나 폼 입력을 통해 전달됩니다\n- 서버가 입력값을 그대로 응답 페이지에 포함시킵니다\n- 공격자가 악의적인 링크를 피해자에게 전송해야 합니다\n- 일회성 공격이지만 피싱과 결합하면 위험합니다\n- 예: 검색어를 URL에 포함시키는 검색 결과 페이지에서 스크립트를 URL에 포함시켜 전달합니다\n\n**DOM-based XSS (DOM 기반 XSS)**\n- 서버가 관여하지 않고 클라이언트 측 JavaScript에서 발생합니다\n- 브라우저의 DOM 환경에서 악성 스크립트가 실행됩니다\n- JavaScript가 사용자 입력을 안전하게 처리하지 않을 때 발생합니다\n- 서버 로그에 남지 않아 탐지가 어렵습니다\n- 예: location.hash나 document.URL을 그대로 innerHTML에 삽입하는 경우\n\n**XSS 공격의 피해**\n- 세션 쿠키 탈취로 계정 하이재킹이 가능합니다\n- 사용자의 개인정보를 공격자 서버로 전송할 수 있습니다\n- 피해자 권한으로 악의적인 행동을 수행할 수 있습니다\n- 가짜 로그인 폼을 띄워 비밀번호를 탈취할 수 있습니다\n- 웹사이트의 내용을 변조하여 피싱 공격을 수행할 수 있습니다\n- 악성 코드 다운로드를 유도할 수 있습니다\n\n**XSS 방어 기법**\n\n**입력 검증 및 필터링**\n- 모든 사용자 입력을 신뢰하지 않고 검증합니다\n- 화이트리스트 방식으로 허용된 문자만 받습니다\n- 특수 문자와 스크립트 태그를 필터링합니다\n\n**출력 인코딩 및 이스케이핑**\n- HTML 컨텍스트에 출력할 때 특수 문자를 HTML 엔티티로 변환합니다\n- JavaScript 컨텍스트에서는 JavaScript 인코딩을 사용합니다\n- URL 컨텍스트에서는 URL 인코딩을 적용합니다\n- 예: `<`를 `&lt;`로, `>`를 `&gt;`로 변환합니다\n\n**CSP (Content Security Policy)**\n- HTTP 헤더로 허용되는 스크립트 소스를 제한합니다\n- 인라인 스크립트 실행을 차단할 수 있습니다\n- 외부 도메인으로의 데이터 전송을 제한합니다\n- eval 같은 위험한 기능을 비활성화합니다\n\n**HttpOnly 쿠키**\n- 세션 쿠키에 HttpOnly 플래그를 설정합니다\n- JavaScript에서 쿠키에 접근할 수 없게 합니다\n- XSS 공격으로 세션 하이재킹을 방지합니다\n\n**보안 라이브러리 사용**\n- DOMPurify 같은 검증된 라이브러리를 사용합니다\n- React, Vue 같은 프레임워크는 기본적으로 XSS 보호 기능을 제공합니다\n- 템플릿 엔진의 자동 이스케이핑 기능을 활용합니다\n\n**실무 권장사항**\n- 절대 사용자 입력을 innerHTML, eval, document.write에 직접 사용하지 않습니다\n- 프레임워크의 안전한 API를 사용합니다 (React의 JSX, Vue의 템플릿)\n- 정기적인 보안 감사와 취약점 스캔을 실시합니다\n- 개발자 보안 교육을 통해 XSS 위험성을 인식시킵니다\n- 방어를 여러 계층에서 적용합니다 (입력 검증 + 출력 인코딩 + CSP)",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "TCP"
      ],
      "id": "1763437633067-5cwwpx3h",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "CSRF랑 XSS는 어떤 차이가 있나요?",
      "answer": "Stateless는 HTTP 프로토콜의 핵심 특성으로, 서버가 클라이언트의 이전 요청에 대한 상태나 정보를 유지하지 않는다는 것을 의미합니다.\n\n각 HTTP 요청은 완전히 독립적으로 처리됩니다. 서버는 요청을 받으면 그 요청에 필요한 모든 정보를 요청 자체에서 얻어야 하며, 이전에 같은 클라이언트로부터 어떤 요청을 받았는지 기억하지 않습니다. 클라이언트가 첫 번째 요청을 보내든 백 번째 요청을 보내든, 서버는 각 요청을 처음 보는 것처럼 처리합니다.\n\n**Stateless의 장점:**\n\n확장성이 뛰어납니다. 서버가 클라이언트 상태를 저장하지 않기 때문에, 요청을 어떤 서버로 보내도 동일하게 처리할 수 있습니다. 로드밸런서를 통해 여러 서버로 트래픽을 분산할 때 특정 클라이언트를 특정 서버로 고정할 필요가 없습니다.\n\n서버의 메모리 부담이 줄어듭니다. 수많은 클라이언트의 상태 정보를 저장하고 관리할 필요가 없어 서버 리소스를 효율적으로 사용할 수 있습니다.\n\n장애 복구가 간단합니다. 서버가 다운되어도 클라이언트는 다른 서버로 요청을 보내면 됩니다. 잃어버린 상태 정보가 없기 때문입니다.\n\n**Stateless의 단점:**\n\n매 요청마다 인증 정보 등 필요한 모든 정보를 전송해야 합니다. 이는 네트워크 오버헤드를 증가시킬 수 있습니다.\n\n연속적인 사용자 경험을 제공하기 어렵습니다. 로그인 상태 유지, 장바구니 관리 등 상태가 필요한 기능을 구현하려면 별도의 메커니즘이 필요합니다.\n\n**실무에서의 대응:**\n\n실제로는 쿠키, 세션, 토큰 등을 사용하여 상태를 관리합니다. 하지만 이는 HTTP 프로토콜 자체가 아닌 애플리케이션 레벨에서 구현되는 것입니다. 쿠키나 JWT 토큰을 매 요청에 포함시켜 서버가 사용자를 식별할 수 있게 합니다.\n\nStateless는 웹의 성장과 확장에 필수적인 특성이었으며, 분산 시스템과 마이크로서비스 아키텍처의 기반이 됩니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "TCP",
        "UDP"
      ],
      "id": "1763437633067-wxeymcva",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    },
    {
      "question": "XSS는 프론트엔드에서만 막을 수 있나요?",
      "answer": "맞습니다. 세션 기반 인증은 엄격한 의미에서 HTTP의 Stateless 원칙에 위배됩니다.\n\n세션 방식은 서버가 사용자의 로그인 상태를 메모리나 데이터베이스에 저장합니다. 클라이언트는 세션 ID만 쿠키로 가지고 있고, 실제 사용자 정보는 서버에 저장됩니다. 이는 서버가 클라이언트의 상태를 유지한다는 점에서 Stateful한 방식입니다.\n\n**세션 방식의 문제점:**\n\n서버 확장이 복잡합니다. 여러 서버가 있을 때 세션 정보를 공유해야 하는데, 이를 위해 세션 클러스터링이나 중앙 세션 저장소(Redis 등)가 필요합니다. 특정 사용자를 항상 같은 서버로 라우팅하는 Sticky Session을 사용할 수도 있지만, 이는 로드밸런싱의 효율성을 떨어뜨립니다.\n\n메모리 부담이 있습니다. 동시 접속자가 많아지면 모든 세션 정보를 저장하기 위한 메모리가 상당히 필요합니다.\n\n서버 재시작 시 세션이 유실될 수 있습니다. 별도의 영속성 메커니즘 없이는 서버가 재시작되면 모든 사용자가 로그아웃됩니다.\n\n**그럼에도 세션이 사용되는 이유:**\n\n보안성이 높습니다. 중요한 정보가 클라이언트에 노출되지 않고 서버에만 저장됩니다. 클라이언트는 의미 없는 세션 ID만 가지고 있어 탈취되어도 서버에서 해당 세션을 무효화할 수 있습니다.\n\n세션 관리가 용이합니다. 서버에서 언제든 세션을 무효화하거나 수정할 수 있어 강제 로그아웃이나 권한 변경이 즉시 반영됩니다.\n\n구현이 간단하고 검증되었습니다. 대부분의 웹 프레임워크가 세션 관리 기능을 기본 제공하며, 오랜 기간 사용되어 안정성이 입증되었습니다.\n\n**현대적 대안:**\n\nJWT(JSON Web Token) 같은 토큰 기반 인증은 더 Stateless에 가깝습니다. 토큰 자체에 사용자 정보가 포함되어 있어 서버가 상태를 저장할 필요가 없습니다. 하지만 토큰 무효화가 어렵고 토큰 크기가 크다는 단점이 있습니다.\n\n실무에서는 서비스의 요구사항에 따라 세션, 토큰, 또는 하이브리드 방식을 선택합니다. 완벽한 Stateless보다는 실용성과 보안성, 확장성 사이의 균형을 찾는 것이 중요합니다.",
      "type": "essay",
      "tags": [
        "네트워크",
        "CS",
        "면접",
        "HTTP",
        "세션"
      ],
      "id": "1763437633067-reg4mldt",
      "createdAt": "2025-11-18T03:47:13.065623",
      "studyCount": 0
    }
  ]
}