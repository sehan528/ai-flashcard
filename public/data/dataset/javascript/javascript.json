{
  "name": "자바스크립트",
  "description": "JavaScript 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "JavaScript의 데이터 타입에는 어떤 것들이 있나요?",
      "answer": "**정의:**\nJavaScript의 데이터 타입은 크게 원시 타입과 참조 타입으로 구분됩니다. 원시 타입은 변경 불가능한 값이며, 참조 타입은 객체를 참조하는 타입입니다.\n\n**원시 타입의 종류:**\n- Number: 정수와 실수를 포함한 모든 숫자를 표현합니다. 특수한 값으로 Infinity, NaN이 있습니다.\n- String: 텍스트 데이터를 표현하며 따옴표로 감싸서 사용합니다. 불변 값입니다.\n- Boolean: 참과 거짓을 나타내는 true와 false 값만 가집니다.\n- Undefined: 변수가 선언되었지만 값이 할당되지 않은 상태를 나타냅니다.\n- Null: 의도적으로 값이 없음을 명시적으로 나타냅니다.\n- Symbol: ES6에서 추가된 타입으로 고유하고 변경 불가능한 값을 생성합니다.\n- BigInt: ES2020에서 추가된 타입으로 아주 큰 정수를 안전하게 표현합니다.\n\n**참조 타입의 특징:**\n- Object: 키와 값의 쌍으로 이루어진 데이터 구조입니다. Array, Function, Date, RegExp 등이 모두 Object의 하위 타입입니다.\n- Array: 순서가 있는 값의 집합으로 인덱스로 접근합니다.\n- Function: 실행 가능한 코드 블록으로 일급 객체입니다.\n\n**원시 타입과 참조 타입의 차이:**\n- 저장 방식: 원시 타입은 값 자체가 저장되고, 참조 타입은 메모리 주소가 저장됩니다.\n- 불변성: 원시 타입은 불변하지만 참조 타입은 가변적입니다.\n- 복사 방식: 원시 타입은 값이 복사되고, 참조 타입은 참조가 복사됩니다.\n\n**실무 활용:**\n- 타입에 따라 비교 연산과 복사 방식이 달라지므로 이를 이해하고 사용해야 합니다.\n- 원시 타입은 스택에 저장되어 빠르지만, 참조 타입은 힙에 저장되어 메모리 관리가 필요합니다.\n- typeof 연산자로 타입을 확인할 수 있지만 null은 object로 표시되는 등 주의가 필요합니다.\n- 적절한 타입 선택은 메모리 효율성과 코드 안정성에 영향을 미칩니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-w9mmy6fdz",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "var, let, const의 차이점과 호이스팅에 대해 설명해주세요.",
      "answer": "**정의:**\nvar, let, const는 JavaScript에서 변수를 선언하는 키워드입니다. 각각 스코프, 재선언, 재할당, 호이스팅 동작이 다릅니다.\n\n**var의 특징:**\n- 함수 스코프를 가집니다. 블록 스코프를 무시하고 함수 내에서만 유효합니다.\n- 재선언이 가능합니다. 같은 이름의 변수를 여러 번 선언할 수 있어 실수를 유발할 수 있습니다.\n- 재할당이 가능합니다. 선언 후 값을 변경할 수 있습니다.\n- 호이스팅 시 undefined로 초기화됩니다. 선언 전에 접근하면 undefined를 반환합니다.\n\n**let의 특징:**\n- 블록 스코프를 가집니다. 중괄호로 감싼 블록 내에서만 유효합니다.\n- 재선언이 불가능합니다. 같은 스코프에서 중복 선언 시 에러가 발생합니다.\n- 재할당이 가능합니다. 값을 변경할 수 있습니다.\n- TDZ가 존재합니다. 선언 전에 접근하면 ReferenceError가 발생합니다.\n\n**const의 특징:**\n- 블록 스코프를 가집니다. let과 동일하게 블록 내에서만 유효합니다.\n- 재선언이 불가능합니다. 중복 선언 시 에러가 발생합니다.\n- 재할당이 불가능합니다. 선언 시 반드시 초기화해야 하며 이후 변경할 수 없습니다.\n- 객체나 배열의 경우 참조는 변경할 수 없지만 내부 프로퍼티는 변경 가능합니다.\n\n**호이스팅의 동작:**\n- 모든 선언은 해당 스코프의 최상단으로 끌어올려집니다.\n- var는 선언과 동시에 undefined로 초기화되어 접근 가능합니다.\n- let과 const는 선언만 호이스팅되고 초기화는 실제 선언문에서 이루어져 TDZ가 발생합니다.\n- 함수 선언문은 전체가 호이스팅되어 선언 전에도 호출 가능합니다.\n\n**실무 활용:**\n- 기본적으로 const를 사용하고 재할당이 필요한 경우에만 let을 사용합니다.\n- var는 사용하지 않는 것이 권장됩니다. 예측 불가능한 동작을 방지할 수 있습니다.\n- 블록 스코프를 활용하여 변수의 유효 범위를 최소화하면 코드 안정성이 높아집니다.\n- 호이스팅을 이해하면 예상치 못한 버그를 방지할 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "hoisting"
      ],
      "id": "1763441901792-zxattz3uc",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "실행 컨텍스트(Execution Context)란 무엇인가요?",
      "answer": "**정의:**\n실행 컨텍스트는 JavaScript 코드가 실행되는 환경을 의미합니다. 코드 실행에 필요한 모든 정보를 담고 있으며, 변수, 함수, this 등이 어떻게 결정되는지를 정의합니다.\n\n**실행 컨텍스트의 구성 요소:**\n- Variable Environment: 변수와 함수 선언을 저장합니다. 초기 상태의 Lexical Environment를 스냅샷으로 가집니다.\n- Lexical Environment: 식별자와 참조를 기록합니다. Environment Record와 외부 렉시컬 환경 참조를 포함합니다.\n- This Binding: this 값이 결정됩니다. 함수 호출 방식에 따라 달라집니다.\n\n**실행 컨텍스트의 종류:**\n- Global Execution Context: 가장 기본이 되는 컨텍스트로 전역 객체와 연결됩니다. 브라우저에서는 window 객체가 됩니다.\n- Function Execution Context: 함수가 호출될 때마다 생성됩니다. 각 함수는 자신만의 실행 컨텍스트를 가집니다.\n- Eval Execution Context: eval 함수 내부의 코드를 위한 컨텍스트입니다. 보안상 사용이 권장되지 않습니다.\n\n**실행 컨텍스트의 생성 과정:**\n- Creation Phase: 컨텍스트를 생성하고 초기화합니다. 변수와 함수 선언이 메모리에 저장되며 호이스팅이 발생합니다. this 바인딩이 결정됩니다.\n- Execution Phase: 코드를 한 줄씩 실행합니다. 변수에 실제 값이 할당되고 함수가 호출됩니다.\n\n**실행 컨텍스트 스택:**\n- Call Stack에 쌓이며 LIFO 방식으로 관리됩니다.\n- 함수 호출 시 새 컨텍스트가 스택에 push되고, 함수 종료 시 pop됩니다.\n- 스택의 최상단에 있는 컨텍스트가 현재 실행 중인 컨텍스트입니다.\n\n**실무 활용:**\n- 실행 컨텍스트를 이해하면 스코프와 클로저의 동작 원리를 파악할 수 있습니다.\n- 디버깅 시 Call Stack을 분석하여 함수 호출 흐름을 추적할 수 있습니다.\n- 변수 접근과 this 바인딩 문제를 해결하는 데 도움이 됩니다.\n- 메모리 누수를 방지하고 성능을 최적화하는 데 활용됩니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-1li1de6p0",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "스코프(Scope)와 스코프 체인에 대해 설명해주세요.",
      "answer": "**정의:**\n스코프는 변수에 접근할 수 있는 유효한 범위를 의미합니다. JavaScript는 렉시컬 스코프를 따르며, 함수가 선언된 위치에 따라 스코프가 결정됩니다. 스코프 체인은 내부 스코프에서 외부 스코프로 변수를 찾아가는 연결 구조입니다.\n\n**스코프의 종류:**\n- Global Scope: 코드 전체에서 접근 가능한 최상위 스코프입니다. 전역 변수는 어디서든 참조할 수 있습니다.\n- Function Scope: 함수 내부에서만 접근 가능한 스코프입니다. var 키워드가 함수 스코프를 따릅니다.\n- Block Scope: 블록 내부에서만 접근 가능한 스코프입니다. let과 const가 블록 스코프를 따릅니다.\n\n**스코프 체인의 동작 원리:**\n- 변수를 참조할 때 현재 스코프에서 먼저 찾습니다.\n- 현재 스코프에 없으면 외부 스코프로 이동하여 찾습니다.\n- 전역 스코프까지 찾아도 없으면 ReferenceError가 발생합니다.\n- 이 과정은 외부 렉시컬 환경 참조를 통해 이루어집니다.\n\n**렉시컬 스코프의 특징:**\n- 함수가 호출된 위치가 아닌 선언된 위치에 따라 스코프가 결정됩니다.\n- 정적 스코프라고도 하며 코드 작성 시점에 스코프가 확정됩니다.\n- 클로저의 기반이 되는 중요한 개념입니다.\n\n**스코프와 관련된 개념:**\n- Shadowing: 내부 스코프의 변수가 외부 스코프의 같은 이름 변수를 가리는 현상입니다.\n- Closure: 함수가 선언될 때의 렉시컬 환경을 기억하여 외부 변수에 접근할 수 있는 현상입니다.\n- Hoisting: 선언이 스코프 최상단으로 끌어올려지는 동작입니다.\n\n**실무 활용:**\n- 변수의 스코프를 최소화하여 네임스페이스 충돌을 방지합니다.\n- 전역 변수 사용을 줄이고 모듈 패턴이나 IIFE로 스코프를 격리합니다.\n- 블록 스코프를 활용하여 변수의 생명주기를 명확히 관리합니다.\n- 스코프 체인을 이해하면 변수 접근 성능을 최적화할 수 있습니다. 지역 변수 사용이 전역 변수보다 빠릅니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "scope"
      ],
      "id": "1763441901792-1puela0vr",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "렉시컬 스코프(Lexical Scope)란 무엇인가요?",
      "answer": "**정의:**\n렉시컬 스코프는 함수가 선언된 위치에 따라 상위 스코프가 결정되는 스코프 방식입니다. 정적 스코프라고도 하며, 함수를 어디서 호출하는지가 아니라 어디에 선언했는지에 따라 스코프가 정해집니다.\n\n**렉시컬 스코프의 핵심 원리:**\n- 함수 선언 시점에 스코프가 확정됩니다. 코드를 작성하는 시점에 스코프 체인이 결정됩니다.\n- 실행 시점이 아닌 작성 시점이 중요합니다. 함수를 어디서 호출하든 선언된 위치의 스코프를 참조합니다.\n- 외부 렉시컬 환경 참조를 통해 구현됩니다. 함수 객체는 내부 슬롯에 자신이 정의된 환경을 기억합니다.\n\n**동적 스코프와의 차이점:**\n- 렉시컬 스코프: 함수 선언 위치에 따라 스코프가 결정됩니다. JavaScript, Python, Java 등 대부분의 언어가 채택합니다.\n- 동적 스코프: 함수 호출 위치에 따라 스코프가 결정됩니다. Bash, Perl 일부 등에서 사용됩니다.\n- 렉시컬 스코프는 예측 가능하고 안정적입니다. 코드만 보고도 변수 참조를 파악할 수 있습니다.\n\n**클로저와의 관계:**\n- 렉시컬 스코프가 클로저의 기반입니다. 함수가 선언될 때의 환경을 기억하기 때문에 클로저가 가능합니다.\n- 중첩 함수는 외부 함수의 변수에 접근할 수 있습니다. 외부 함수가 종료되어도 렉시컬 환경을 참조합니다.\n- 이를 통해 데이터 은닉과 캡슐화를 구현할 수 있습니다.\n\n**렉시컬 환경의 구성:**\n- Environment Record: 현재 스코프의 식별자와 값을 저장합니다.\n- Outer Lexical Environment Reference: 외부 렉시컬 환경을 참조합니다. 스코프 체인을 형성합니다.\n\n**실무 활용:**\n- 모듈 패턴 구현 시 렉시컬 스코프를 활용하여 private 변수를 만듭니다.\n- 콜백 함수나 이벤트 핸들러에서 외부 변수를 안전하게 참조할 수 있습니다.\n- 함수형 프로그래밍에서 고차 함수를 구현할 때 필수적입니다.\n- 코드의 예측 가능성이 높아져 디버깅과 유지보수가 쉬워집니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "scope"
      ],
      "id": "1763441901792-y9e33nd8o",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "클로저(Closure)란 무엇이고 어떻게 활용할 수 있나요?",
      "answer": "**정의:**\n클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. 함수가 생성될 때의 외부 변수를 기억하고 접근할 수 있는 특성을 말합니다. 외부 함수가 종료된 후에도 외부 함수의 변수에 접근할 수 있습니다.\n\n**클로저의 동작 원리:**\n- 내부 함수가 외부 함수의 변수를 참조합니다. 외부 함수의 실행 컨텍스트가 종료되어도 렉시컬 환경은 유지됩니다.\n- 가비지 컬렉션에서 제외됩니다. 내부 함수가 참조하는 변수는 메모리에서 해제되지 않습니다.\n- 외부 함수를 반환하거나 콜백으로 전달할 때 클로저가 생성됩니다.\n\n**클로저가 생성되는 조건:**\n- 중첩된 함수 구조를 가져야 합니다. 외부 함수와 내부 함수가 필요합니다.\n- 내부 함수가 외부 함수의 변수를 참조해야 합니다. 단순히 중첩되기만 해서는 클로저가 아닙니다.\n- 내부 함수가 외부로 전달되어야 합니다. 반환되거나 다른 곳에 저장되어야 합니다.\n\n**클로저의 장점:**\n- 데이터 은닉과 캡슐화가 가능합니다. private 변수를 구현할 수 있습니다.\n- 상태를 안전하게 유지할 수 있습니다. 외부에서 직접 접근하지 못하도록 보호합니다.\n- 함수 팩토리 패턴을 구현할 수 있습니다. 설정을 기억하는 함수를 생성합니다.\n\n**클로저의 단점과 주의사항:**\n- 메모리 누수가 발생할 수 있습니다. 필요 없는 클로저는 명시적으로 해제해야 합니다.\n- 과도한 사용은 메모리 사용량을 증가시킵니다. 성능에 영향을 줄 수 있습니다.\n- 반복문에서 클로저 사용 시 주의가 필요합니다. 변수가 의도치 않게 공유될 수 있습니다.\n\n**실무 활용 사례:**\n- 모듈 패턴으로 private 메서드와 변수를 구현합니다. API를 제한적으로 노출할 수 있습니다.\n- 커링과 부분 적용 함수를 만듭니다. 함수의 인자를 미리 설정할 수 있습니다.\n- 이벤트 핸들러와 콜백 함수에서 컨텍스트를 유지합니다. 비동기 작업에서 상태를 기억합니다.\n- React Hooks의 내부 구현에서 사용됩니다. useState 등이 클로저를 활용합니다.\n- 디바운스와 스로틀 함수 구현에 활용됩니다. 타이머 ID를 클로저로 관리합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "closure"
      ],
      "id": "1763441901792-mfpn7p1pr",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "호이스팅(Hoisting)은 어떻게 동작하나요?",
      "answer": "**정의:**\n호이스팅은 변수와 함수 선언이 해당 스코프의 최상단으로 끌어올려지는 JavaScript의 특성입니다. 실제로 코드가 이동하는 것이 아니라 실행 컨텍스트 생성 단계에서 선언이 먼저 처리되는 것입니다.\n\n**호이스팅의 동작 원리:**\n- 실행 컨텍스트 생성 단계에서 발생합니다. 코드 실행 전에 선언을 메모리에 저장합니다.\n- 선언과 초기화가 분리됩니다. var는 undefined로 초기화되지만 let과 const는 초기화되지 않습니다.\n- 스코프 단위로 동작합니다. 전역 스코프나 함수 스코프 내에서 최상단으로 올라갑니다.\n\n**변수 호이스팅의 종류:**\n- var 호이스팅: 선언과 동시에 undefined로 초기화됩니다. 선언 전에 접근하면 undefined를 반환합니다. 에러가 발생하지 않아 버그의 원인이 될 수 있습니다.\n- let과 const 호이스팅: 선언은 호이스팅되지만 초기화는 되지 않습니다. TDZ에 들어가며 접근 시 ReferenceError가 발생합니다. 더 안전한 코드를 작성할 수 있습니다.\n\n**함수 호이스팅:**\n- 함수 선언문: 함수 전체가 호이스팅됩니다. 선언 전에도 호출할 수 있습니다. 함수 이름과 본문 모두 메모리에 저장됩니다.\n- 함수 표현식: 변수 선언만 호이스팅됩니다. var로 선언 시 undefined로 초기화되어 호출하면 TypeError가 발생합니다. let이나 const로 선언 시 ReferenceError가 발생합니다.\n\n**호이스팅 우선순위:**\n- 변수와 함수 선언이 모두 호이스팅될 때 함수가 우선입니다.\n- 같은 이름의 변수와 함수가 있으면 함수 선언이 먼저 처리됩니다.\n- 이후 변수 할당은 함수를 덮어씁니다.\n\n**실무에서의 주의사항:**\n- var 사용을 피하고 let과 const를 사용합니다. 호이스팅으로 인한 혼란을 줄일 수 있습니다.\n- 변수와 함수는 사용 전에 선언합니다. 코드 가독성과 유지보수성이 향상됩니다.\n- 함수 선언문보다 함수 표현식 사용을 고려합니다. 호이스팅 동작을 명확히 파악할 수 있습니다.\n- 호이스팅을 이해하면 예상치 못한 버그를 방지할 수 있습니다. 특히 반복문이나 조건문 내 선언에 주의합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "hoisting"
      ],
      "id": "1763441901792-kyzihwef1",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "TDZ(Temporal Dead Zone)에 대해 설명해주세요.",
      "answer": "**정의:**\nTDZ는 let과 const로 선언된 변수가 선언되기 전까지 접근할 수 없는 구간을 의미합니다. 스코프의 시작 지점부터 변수 선언문까지의 영역이며, 이 구간에서 변수에 접근하면 ReferenceError가 발생합니다.\n\n**TDZ가 존재하는 이유:**\n- 변수 사용 전 초기화를 강제합니다. 의도하지 않은 undefined 사용을 방지합니다.\n- 코드의 안전성을 높입니다. 선언되지 않은 변수 접근을 컴파일 타임이 아닌 런타임에 감지합니다.\n- const의 불변성을 보장합니다. 초기화 없이 선언만 하는 것을 방지합니다.\n\n**TDZ의 동작 방식:**\n- 스코프에 진입하면 변수가 생성됩니다. 하지만 초기화는 되지 않습니다.\n- 선언문을 만나기 전까지 TDZ에 머뭅니다. 이 시점까지는 변수를 사용할 수 없습니다.\n- 선언문을 만나면 TDZ에서 벗어납니다. let은 undefined로, const는 할당된 값으로 초기화됩니다.\n- 초기화 이후에는 정상적으로 접근할 수 있습니다.\n\n**TDZ와 호이스팅:**\n- let과 const도 호이스팅됩니다. 선언 자체는 스코프 최상단으로 끌어올려집니다.\n- var와의 차이는 초기화 시점입니다. var는 선언과 동시에 undefined로 초기화되지만 let과 const는 선언문에서 초기화됩니다.\n- 호이스팅되지 않는 것처럼 보이지만 실제로는 호이스팅됩니다. 섀도잉을 통해 확인할 수 있습니다.\n\n**TDZ가 적용되는 경우:**\n- let과 const 변수 선언 시 항상 적용됩니다.\n- 클래스 선언도 TDZ를 따릅니다. 선언 전 사용 시 에러가 발생합니다.\n- 함수의 기본 매개변수에서도 발생합니다. 매개변수는 왼쪽에서 오른쪽 순서로 초기화됩니다.\n\n**실무 활용:**\n- 변수는 사용하기 직전에 선언하는 것이 좋습니다. 스코프 최상단에 모든 선언을 모으는 것보다 명확합니다.\n- TDZ 에러를 통해 잘못된 변수 참조를 조기에 발견합니다. var의 undefined 반환보다 디버깅이 쉽습니다.\n- const를 우선 사용하고 재할당이 필요할 때만 let을 사용합니다. TDZ를 통해 초기화를 강제할 수 있습니다.\n- 순환 참조나 의존성 문제를 파악할 수 있습니다. 변수 선언 순서를 명확히 관리합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-fsg07uwvb",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "일반 함수와 화살표 함수의 차이점은 무엇인가요?",
      "answer": "**정의:**\n일반 함수는 function 키워드로 선언하는 전통적인 함수이고, 화살표 함수는 ES6에서 도입된 간결한 함수 표현식입니다. 두 함수는 문법뿐만 아니라 this 바인딩, arguments 객체, 생성자 사용 등에서 근본적인 차이가 있습니다.\n\n**this 바인딩의 차이:**\n- 일반 함수: 호출 방식에 따라 this가 동적으로 결정됩니다. 메서드로 호출되면 호출한 객체가 this가 됩니다. 일반 함수로 호출되면 전역 객체 또는 undefined가 됩니다.\n- 화살표 함수: 자신만의 this를 가지지 않습니다. 상위 스코프의 this를 렉시컬하게 캡처합니다. 선언될 때의 this가 영구적으로 고정됩니다. call, apply, bind로도 this를 변경할 수 없습니다.\n\n**arguments 객체:**\n- 일반 함수: arguments 객체를 가집니다. 전달된 모든 인수에 접근할 수 있습니다. 유사 배열 객체로 배열 메서드를 직접 사용할 수 없습니다.\n- 화살표 함수: arguments 객체를 가지지 않습니다. 상위 스코프의 arguments를 참조합니다. 나머지 매개변수를 사용하여 인수를 받아야 합니다.\n\n**생성자 함수로서의 사용:**\n- 일반 함수: new 키워드로 생성자 함수로 사용할 수 있습니다. prototype 프로퍼티를 가지며 인스턴스를 생성할 수 있습니다.\n- 화살표 함수: 생성자 함수로 사용할 수 없습니다. new와 함께 호출하면 TypeError가 발생합니다. prototype 프로퍼티가 없습니다.\n\n**메서드 정의:**\n- 일반 함수: 객체의 메서드로 적합합니다. this가 메서드를 호출한 객체를 가리킵니다.\n- 화살표 함수: 메서드로는 부적합합니다. this가 상위 스코프를 가리켜 의도와 다르게 동작합니다. 콜백 함수로 사용하기에 적합합니다.\n\n**실무 활용:**\n- 콜백 함수에서는 화살표 함수가 유용합니다. this 바인딩 문제를 해결할 수 있습니다.\n- 이벤트 핸들러에서는 상황에 따라 선택합니다. DOM 요소를 참조해야 하면 일반 함수를 사용합니다.\n- 메서드 정의 시에는 일반 함수나 메서드 축약 표현을 사용합니다.\n- React의 클래스 컴포넌트에서 이벤트 핸들러는 화살표 함수로 정의하면 바인딩이 필요 없습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "function"
      ],
      "id": "1763441901792-bax5irx7d",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "this 바인딩의 종류와 동작 원리를 설명해주세요.",
      "answer": "**정의:**\nthis는 함수 호출 시 동적으로 결정되는 특수한 객체 참조입니다. 함수가 어떻게 호출되었는지에 따라 this가 가리키는 대상이 달라지며, 이를 this 바인딩이라고 합니다.\n\n**기본 바인딩:**\n- 일반 함수 호출 시 적용됩니다. 엄격 모드가 아니면 전역 객체를 가리킵니다. 브라우저에서는 window, Node.js에서는 global입니다.\n- 엄격 모드에서는 undefined가 됩니다. 의도치 않은 전역 객체 참조를 방지합니다.\n\n**암시적 바인딩:**\n- 메서드로 호출될 때 적용됩니다. 메서드를 호출한 객체가 this가 됩니다.\n- 점 표기법이나 대괄호 표기법으로 호출된 경우입니다.\n- 주의할 점은 메서드를 변수에 할당하면 암시적 바인딩이 사라집니다. 일반 함수 호출이 되어 this가 변경됩니다.\n\n**명시적 바인딩:**\n- call, apply, bind 메서드를 사용하여 this를 명시적으로 지정합니다.\n- call과 apply는 즉시 함수를 실행하며 this를 지정합니다. 차이는 인수 전달 방식입니다.\n- bind는 this가 고정된 새로운 함수를 반환합니다. 나중에 호출할 수 있습니다.\n\n**new 바인딩:**\n- 생성자 함수를 new 키워드로 호출할 때 적용됩니다.\n- 새로운 빈 객체가 생성되고 이 객체가 this가 됩니다.\n- 함수 내부에서 this에 프로퍼티를 추가하면 새 객체에 추가됩니다.\n- 명시적으로 객체를 반환하지 않으면 this가 자동으로 반환됩니다.\n\n**화살표 함수의 this:**\n- 렉시컬 this를 사용합니다. 상위 스코프의 this를 그대로 사용합니다.\n- 선언될 때 this가 결정되어 변경할 수 없습니다.\n- 바인딩 규칙을 따르지 않습니다.\n\n**바인딩 우선순위:**\n- new 바인딩이 가장 높습니다. 생성자 함수의 this는 항상 새 객체입니다.\n- 명시적 바인딩이 다음입니다. call, apply, bind가 우선됩니다.\n- 암시적 바인딩이 그다음입니다. 메서드 호출 시 적용됩니다.\n- 기본 바인딩이 가장 낮습니다. 다른 규칙이 없을 때 적용됩니다.\n\n**실무 활용:**\n- 콜백 함수에서 this 문제를 해결할 때 화살표 함수나 bind를 사용합니다.\n- React 클래스 컴포넌트에서 이벤트 핸들러를 바인딩합니다.\n- 프로토타입 메서드에서 this는 인스턴스를 가리키도록 설계합니다.\n- 디버깅 시 this가 무엇인지 파악하면 문제 해결이 쉬워집니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "this"
      ],
      "id": "1763441901792-dljzbal8o",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "call, apply, bind 메서드의 차이점과 사용법은 무엇인가요?",
      "answer": "**정의:**\ncall, apply, bind는 함수의 this를 명시적으로 지정하는 메서드입니다. 모두 Function 프로토타입의 메서드로, 함수 호출 시 this 바인딩을 제어할 수 있습니다.\n\n**call 메서드:**\n- 함수를 즉시 호출하며 this를 지정합니다. 첫 번째 인수로 this가 될 객체를 전달합니다.\n- 이후 인수들은 호출할 함수의 인수로 개별적으로 전달됩니다.\n- 인수를 쉼표로 구분하여 나열합니다.\n- 인수 개수를 알고 있을 때 사용하기 편리합니다.\n\n**apply 메서드:**\n- call과 동일하게 함수를 즉시 호출하며 this를 지정합니다.\n- 첫 번째 인수로 this가 될 객체를 전달합니다.\n- 두 번째 인수로 배열 또는 유사 배열 객체를 전달합니다. 배열의 요소들이 함수의 인수로 전달됩니다.\n- 인수가 배열 형태로 있을 때 유용합니다.\n- 가변 인수 함수를 호출할 때 편리합니다.\n\n**bind 메서드:**\n- 함수를 즉시 호출하지 않고 새로운 함수를 반환합니다.\n- this가 영구적으로 고정된 함수를 생성합니다.\n- 첫 번째 인수로 this가 될 객체를 전달합니다.\n- 이후 인수들은 부분 적용됩니다. 반환된 함수 호출 시 미리 전달한 인수들이 앞에 고정됩니다.\n- 이벤트 핸들러나 콜백 함수로 전달할 때 유용합니다.\n\n**call과 apply의 사용 사례:**\n- 유사 배열 객체에 배열 메서드를 사용할 때 활용합니다. arguments 객체를 배열로 변환하지 않고 배열 메서드를 적용할 수 있습니다.\n- 최댓값이나 최솟값을 구할 때 apply를 사용합니다. Math.max와 Math.min에 배열을 전달할 수 있습니다.\n- 생성자 빌려쓰기 패턴에서 사용합니다. 다른 생성자의 초기화 로직을 재사용할 수 있습니다.\n\n**bind의 사용 사례:**\n- 이벤트 핸들러에서 this를 유지할 때 사용합니다. DOM 이벤트 핸들러의 this는 이벤트 타겟이 되므로 bind로 고정합니다.\n- React 클래스 컴포넌트의 메서드를 바인딩합니다. constructor에서 bind하거나 화살표 함수를 사용합니다.\n- 부분 적용 함수를 만들 때 활용합니다. 일부 인수를 미리 고정한 함수를 생성합니다.\n- 타이머 함수의 콜백에서 this를 보존합니다.\n\n**실무 활용:**\n- ES6 이후에는 화살표 함수나 스프레드 연산자로 대체할 수 있는 경우가 많습니다.\n- call과 apply는 스프레드 연산자로 대체 가능합니다. 하지만 this 바인딩이 필요하면 여전히 유용합니다.\n- bind는 this 고정이 필요한 상황에서 여전히 중요합니다.\n- 성능상으로는 call이 apply보다 약간 빠릅니다. 인수가 적을 때는 call을 사용하는 것이 좋습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-s16xqi8p0",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "고차 함수(Higher-Order Function)란 무엇인가요?",
      "answer": "**정의:**\n고차 함수는 함수를 인수로 받거나 함수를 반환하는 함수입니다. JavaScript에서 함수는 일급 객체이므로 변수에 할당하거나 다른 함수의 인수로 전달하거나 반환값으로 사용할 수 있습니다.\n\n**일급 객체로서의 함수:**\n- 변수에 할당할 수 있습니다. 함수를 값처럼 다룰 수 있습니다.\n- 함수의 인수로 전달할 수 있습니다. 콜백 패턴의 기초가 됩니다.\n- 함수의 반환값으로 사용할 수 있습니다. 클로저와 함께 강력한 패턴을 만듭니다.\n- 객체의 프로퍼티나 배열의 요소가 될 수 있습니다.\n\n**함수를 인수로 받는 고차 함수:**\n- map, filter, reduce 등 배열 메서드가 대표적입니다. 콜백 함수를 받아 각 요소에 적용합니다.\n- forEach, some, every 등도 고차 함수입니다.\n- addEventListener도 고차 함수입니다. 이벤트 핸들러 함수를 인수로 받습니다.\n- setTimeout, setInterval도 콜백 함수를 받는 고차 함수입니다.\n\n**함수를 반환하는 고차 함수:**\n- 클로저를 활용하여 상태를 유지하는 함수를 만듭니다.\n- 함수 팩토리 패턴으로 설정을 기억하는 함수를 생성합니다.\n- 커링과 부분 적용을 구현할 수 있습니다.\n- 데코레이터 패턴을 구현하여 기존 함수에 기능을 추가합니다.\n\n**고차 함수의 장점:**\n- 코드 재사용성이 높아집니다. 공통 로직을 고차 함수로 추출할 수 있습니다.\n- 추상화 수준이 높아집니다. 구체적인 구현보다 의도를 명확히 표현합니다.\n- 함수 조합이 가능합니다. 작은 함수들을 조합하여 복잡한 기능을 만듭니다.\n- 선언적 프로그래밍이 가능합니다. 무엇을 할지 명시하여 가독성이 향상됩니다.\n\n**실무 활용 사례:**\n- 배열 변환과 필터링에 map, filter를 사용합니다. 반복문보다 의도가 명확합니다.\n- 이벤트 핸들러를 고차 함수로 감싸 공통 로직을 처리합니다. 로깅이나 권한 검사를 추가할 수 있습니다.\n- 미들웨어 패턴을 구현합니다. Express나 Redux에서 고차 함수로 미들웨어를 연결합니다.\n- React의 고차 컴포넌트는 컴포넌트를 받아 새 컴포넌트를 반환하는 고차 함수입니다.\n- 유틸리티 함수를 만들어 코드 중복을 줄입니다. 디바운스, 스로틀, 메모이제이션 등을 구현합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "function"
      ],
      "id": "1763441901792-ujx7ot3sn",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "커링(Currying)과 부분 적용(Partial Application)에 대해 설명해주세요.",
      "answer": "**정의:**\n커링은 여러 개의 인수를 받는 함수를 인수 하나씩 받는 함수들의 체인으로 변환하는 기법입니다. 부분 적용은 함수의 일부 인수를 미리 고정하여 새로운 함수를 만드는 기법입니다. 둘 다 함수형 프로그래밍에서 중요한 개념입니다.\n\n**커링의 특징:**\n- n개의 인수를 받는 함수를 1개의 인수를 받는 n개의 함수로 변환합니다.\n- 각 함수는 하나의 인수만 받고 다음 함수를 반환합니다.\n- 모든 인수가 제공될 때까지 함수를 반환합니다.\n- 마지막 인수가 제공되면 최종 결과를 계산합니다.\n\n**부분 적용의 특징:**\n- 일부 인수를 미리 고정한 새로운 함수를 생성합니다.\n- 나머지 인수는 나중에 제공됩니다.\n- bind 메서드나 클로저로 구현할 수 있습니다.\n- 커링과 달리 여러 인수를 한 번에 고정할 수 있습니다.\n\n**커링과 부분 적용의 차이:**\n- 커링: 항상 단일 인수 함수의 연속입니다. 모든 인수를 하나씩 받습니다.\n- 부분 적용: 여러 인수를 한 번에 고정할 수 있습니다. 남은 인수를 한 번에 받을 수 있습니다.\n- 커링은 더 순수한 함수형 기법이고, 부분 적용은 더 실용적입니다.\n\n**커링의 장점:**\n- 함수 재사용성이 높아집니다. 공통 인수를 가진 함수를 쉽게 만들 수 있습니다.\n- 함수 조합이 용이합니다. 작은 함수들을 조합하여 복잡한 로직을 구성합니다.\n- 지연 실행이 가능합니다. 필요한 시점까지 실행을 미룰 수 있습니다.\n- 코드 가독성이 향상됩니다. 각 인수의 의미가 명확해집니다.\n\n**실무 활용 사례:**\n- 설정 함수를 만들 때 유용합니다. 공통 설정을 먼저 제공하고 나중에 구체적인 값을 전달합니다.\n- 이벤트 핸들러를 생성할 때 사용합니다. 공통 로직을 커링으로 분리합니다.\n- 유효성 검사 함수를 만들 때 활용합니다. 검사 규칙을 먼저 설정하고 값은 나중에 전달합니다.\n- Lodash나 Ramda 같은 함수형 라이브러리에서 널리 사용됩니다.\n- React에서 HOC를 만들 때 커링 패턴을 활용합니다.\n- Redux의 액션 크리에이터나 미들웨어에서 부분 적용을 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-a4xhff8h0",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "IIFE(즉시 실행 함수)는 왜 사용하나요?",
      "answer": "**정의:**\nIIFE는 Immediately Invoked Function Expression의 약자로, 정의되자마자 즉시 실행되는 함수 표현식입니다. 함수를 괄호로 감싸고 바로 호출 연산자를 붙여 실행합니다.\n\n**IIFE의 문법:**\n- 함수 표현식을 괄호로 감쌉니다. 함수 선언문이 아닌 표현식으로 만듭니다.\n- 즉시 호출 연산자를 붙입니다. 마지막에 괄호를 추가하여 바로 실행합니다.\n- 화살표 함수로도 만들 수 있습니다.\n- 인수를 전달할 수도 있습니다.\n\n**IIFE의 주요 목적:**\n- 전역 스코프 오염을 방지합니다. 변수와 함수를 지역 스코프에 격리합니다.\n- 전역 네임스페이스를 보호합니다. 다른 라이브러리와의 충돌을 막습니다.\n- 클로저를 활용한 데이터 은닉이 가능합니다. private 변수를 만들 수 있습니다.\n- 초기화 코드를 실행합니다. 설정이나 초기 설정을 한 번만 실행합니다.\n\n**IIFE의 장점:**\n- 변수 충돌을 방지합니다. 같은 이름의 전역 변수가 있어도 영향을 받지 않습니다.\n- 메모리 관리가 효율적입니다. 실행 후 내부 변수는 가비지 컬렉션 대상이 됩니다.\n- 모듈 패턴의 기초가 됩니다. public API만 노출하고 내부 구현을 숨길 수 있습니다.\n- 초기화 로직을 명확히 분리합니다. 일회성 코드를 구조화합니다.\n\n**실무 활용 사례:**\n- 라이브러리나 플러그인 개발 시 사용합니다. 내부 변수가 외부로 노출되지 않도록 합니다.\n- 모듈 패턴을 구현합니다. 공개할 메서드만 반환하고 나머지는 private으로 유지합니다.\n- 반복문에서 클로저 문제를 해결합니다. 각 반복마다 독립적인 스코프를 만듭니다.\n- 초기 설정이나 환경 감지를 수행합니다. 페이지 로드 시 한 번만 실행되는 코드를 작성합니다.\n- ES6 모듈이 없던 시절 모듈화를 구현했습니다. 현재는 import/export를 사용하지만 레거시 코드에서 볼 수 있습니다.\n\n**현대적인 대안:**\n- ES6 모듈 시스템이 도입되면서 IIFE의 필요성이 줄었습니다.\n- let과 const의 블록 스코프로 변수 격리가 가능합니다.\n- 하지만 여전히 즉시 실행이 필요한 초기화 코드에서는 유용합니다.\n- 번들러나 트랜스파일러가 자동으로 IIFE로 감싸주기도 합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "function"
      ],
      "id": "1763441901792-c9nk0m17n",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "프로토타입(Prototype)과 프로토타입 체인에 대해 설명해주세요.",
      "answer": "**정의:**\n프로토타입은 JavaScript 객체가 다른 객체로부터 속성과 메서드를 상속받을 수 있게 하는 메커니즘입니다. 프로토타입 체인은 객체에서 프로퍼티를 찾을 때 상위 프로토타입을 따라 올라가며 검색하는 구조입니다.\n\n**프로토타입의 핵심 개념:**\n- 모든 객체는 내부적으로 프로토타입을 참조합니다. 이를 통해 다른 객체의 속성을 사용할 수 있습니다.\n- 함수는 prototype 프로퍼티를 가집니다. 생성자 함수로 만든 인스턴스의 프로토타입이 됩니다.\n- 객체는 프로토타입으로부터 속성을 상속받습니다. 직접 가지지 않은 속성도 접근할 수 있습니다.\n\n**프로토타입 체인의 동작:**\n- 객체의 프로퍼티에 접근하면 먼저 객체 자신에게서 찾습니다.\n- 없으면 프로토타입 객체에서 찾습니다. 내부 슬롯을 통해 프로토타입을 참조합니다.\n- 프로토타입에도 없으면 프로토타입의 프로토타입에서 찾습니다. 체인을 따라 올라갑니다.\n- Object.prototype까지 올라가도 없으면 undefined를 반환합니다.\n- Object.prototype이 체인의 최상위입니다. 그 위의 프로토타입은 null입니다.\n\n**프로토타입 상속의 특징:**\n- 동적 상속입니다. 프로토타입이 변경되면 모든 인스턴스에 즉시 반영됩니다.\n- 메모리 효율적입니다. 공통 메서드를 프로토타입에 한 번만 정의하면 모든 인스턴스가 공유합니다.\n- 인스턴스마다 메서드를 복사하지 않아도 됩니다.\n- 하지만 프로토타입 변경은 위험할 수 있습니다. 기존 인스턴스에 영향을 미칩니다.\n\n**프로토타입 기반 상속의 구현:**\n- 생성자 함수의 prototype에 메서드를 추가합니다. 모든 인스턴스가 공유합니다.\n- Object.create로 프로토타입을 지정한 객체를 만듭니다.\n- ES6 클래스 문법은 내부적으로 프로토타입을 사용합니다. 문법적 설탕일 뿐입니다.\n\n**프로토타입 관련 메서드:**\n- Object.getPrototypeOf는 객체의 프로토타입을 가져옵니다.\n- Object.setPrototypeOf는 프로토타입을 변경합니다. 성능상 권장되지 않습니다.\n- hasOwnProperty는 객체 자신의 프로퍼티인지 확인합니다. 프로토타입 체인을 검색하지 않습니다.\n- instanceof는 프로토타입 체인에 생성자의 prototype이 있는지 확인합니다.\n\n**실무 활용:**\n- 공통 메서드는 프로토타입에 정의하여 메모리를 절약합니다.\n- 프로토타입 체인을 이해하면 상속 구조를 설계할 수 있습니다.\n- 네이티브 객체의 프로토타입 확장은 피해야 합니다. 다른 코드와 충돌할 수 있습니다.\n- 프레임워크나 라이브러리의 상속 패턴을 이해하는 데 필수적입니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "prototype"
      ],
      "id": "1763441901792-53xv9txzu",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "__proto__와 prototype의 차이점은 무엇인가요?",
      "answer": "**정의:**\n__proto__는 모든 객체가 가지는 접근자 프로퍼티로 자신의 프로토타입을 가리킵니다. prototype은 함수 객체만 가지는 프로퍼티로, 생성자 함수로 생성될 인스턴스의 프로토타입을 가리킵니다.\n\n**__proto__의 특징:**\n- 모든 객체가 가집니다. 일반 객체, 배열, 함수 모두 가지고 있습니다.\n- 객체의 프로토타입을 참조합니다. 상속받은 프로퍼티를 찾을 때 사용됩니다.\n- 접근자 프로퍼티입니다. getter와 setter로 구현되어 있습니다.\n- 비표준이었다가 ES6에서 표준화되었습니다. 하지만 직접 사용은 권장되지 않습니다.\n- Object.getPrototypeOf와 Object.setPrototypeOf 사용이 권장됩니다.\n\n**prototype의 특징:**\n- 함수 객체만 가집니다. 일반 객체는 가지지 않습니다.\n- 생성자 함수로 만들 인스턴스의 프로토타입을 가리킵니다.\n- new 키워드로 객체를 생성하면 prototype이 인스턴스의 프로토타입이 됩니다.\n- constructor 프로퍼티를 통해 생성자 함수를 역참조합니다.\n- 화살표 함수는 prototype을 가지지 않습니다. 생성자로 사용할 수 없기 때문입니다.\n\n**관계와 연결:**\n- 생성자 함수의 prototype과 인스턴스의 __proto__는 같은 객체를 가리킵니다.\n- 인스턴스에서 __proto__로 접근하는 것과 생성자.prototype은 동일합니다.\n- prototype.constructor는 생성자 함수 자신을 가리킵니다. 순환 참조 구조입니다.\n\n**사용 시 주의사항:**\n- __proto__는 직접 사용하지 않는 것이 좋습니다. 성능 문제가 있고 모든 환경에서 지원되지 않습니다.\n- Object.getPrototypeOf를 사용하여 프로토타입을 가져옵니다.\n- Object.create를 사용하여 프로토타입을 지정한 객체를 생성합니다.\n- Object.setPrototypeOf는 성능에 매우 부정적입니다. 가능하면 객체 생성 시 프로토타입을 지정합니다.\n\n**프로토타입 체인에서의 역할:**\n- __proto__가 체인을 형성합니다. 각 객체의 __proto__가 다음 프로토타입을 가리킵니다.\n- prototype은 생성자 함수가 만들 객체의 프로토타입을 미리 정의합니다.\n- 인스턴스 생성 시 인스턴스.__proto__에 생성자.prototype이 연결됩니다.\n\n**실무 활용:**\n- 클래스 문법을 사용하면 prototype을 직접 다룰 일이 적습니다. 내부적으로 처리됩니다.\n- 하지만 프로토타입 기반 상속을 이해해야 합니다. 클래스도 프로토타입을 사용합니다.\n- 객체의 프로토타입을 확인할 때는 Object.getPrototypeOf를 사용합니다.\n- 디버깅 시 __proto__를 콘솔에서 확인할 수 있지만 코드에서는 사용하지 않습니다.\n- instanceof 연산자는 프로토타입 체인을 검색하여 타입을 확인합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "prototype"
      ],
      "id": "1763441901792-83qo0ucok",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "프로토타입 기반 상속은 어떻게 구현하나요?",
      "answer": "**정의:**\n프로토타입 기반 상속은 객체가 다른 객체의 속성과 메서드를 프로토타입 체인을 통해 물려받는 JavaScript의 상속 메커니즘입니다. 클래스 기반 상속과 달리 객체가 직접 다른 객체를 상속받습니다.\n\n**생성자 함수를 이용한 상속:**\n- 부모 생성자를 자식 생성자 내에서 호출합니다. call이나 apply를 사용하여 this를 전달합니다.\n- 자식 생성자의 prototype을 부모 생성자의 인스턴스로 설정합니다. 프로토타입 체인이 연결됩니다.\n- constructor 프로퍼티를 다시 자식 생성자로 설정합니다. 덮어쓴 constructor를 복원합니다.\n- 이 방법은 프로토타입 체인과 인스턴스 속성을 모두 상속받습니다.\n\n**Object.create를 이용한 상속:**\n- Object.create로 프로토타입을 지정한 객체를 생성합니다. 더 직접적이고 명확한 방법입니다.\n- 부모 prototype을 자식 prototype의 프로토타입으로 설정합니다.\n- 불필요한 인스턴스 생성 없이 프로토타입만 연결합니다.\n- 생성자 함수 방식보다 깔끔하고 이해하기 쉽습니다.\n\n**ES6 Class 문법:**\n- extends 키워드로 상속을 선언합니다. 문법이 간결하고 직관적입니다.\n- super 키워드로 부모 생성자와 메서드를 호출합니다.\n- 내부적으로는 프로토타입 기반 상속을 사용합니다. 문법적 설탕에 불과합니다.\n- constructor에서 반드시 super를 먼저 호출해야 합니다.\n\n**상속 구현 시 주의사항:**\n- prototype을 직접 할당하면 constructor가 사라집니다. 반드시 복원해야 합니다.\n- 부모 생성자를 호출하지 않으면 인스턴스 속성이 상속되지 않습니다.\n- 프로토타입 체인이 올바르게 연결되었는지 확인해야 합니다.\n- Object.create(null)로 만든 객체는 프로토타입이 없습니다.\n\n**다중 상속과 믹스인:**\n- JavaScript는 단일 상속만 지원합니다. 프로토타입 체인은 하나만 가질 수 있습니다.\n- 다중 상속이 필요하면 믹스인 패턴을 사용합니다. Object.assign으로 여러 객체의 속성을 복사합니다.\n- 하지만 믹스인은 진정한 상속이 아닙니다. 프로토타입 체인에 연결되지 않습니다.\n\n**실무 활용:**\n- 공통 기능을 부모 클래스에 정의하고 자식 클래스에서 확장합니다.\n- 프레임워크나 라이브러리의 기본 클래스를 상속받아 커스터마이징합니다.\n- 프로토타입 체인을 이해하면 instanceof와 타입 체크를 올바르게 사용할 수 있습니다.\n- 현대적인 코드에서는 ES6 클래스 문법을 주로 사용하지만 내부 동작 원리를 이해해야 합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "prototype"
      ],
      "id": "1763441901792-kvojaopbz",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Object.create()의 동작 원리와 사용 사례는 무엇인가요?",
      "answer": "**정의:**\nObject.create는 지정된 프로토타입 객체와 속성을 가지는 새 객체를 생성하는 메서드입니다. 프로토타입을 명시적으로 지정할 수 있어 상속 구조를 명확하게 만들 수 있습니다.\n\n**동작 원리:**\n- 첫 번째 인수로 프로토타입이 될 객체를 받습니다. 새 객체의 내부 프로토타입 참조가 이 객체를 가리킵니다.\n- 두 번째 인수로 속성 디스크립터 객체를 받습니다. Object.defineProperties와 같은 형식입니다.\n- 빈 객체를 생성하고 프로토타입을 연결합니다.\n- 프로토타입 없는 객체도 만들 수 있습니다. null을 전달하면 됩니다.\n\n**프로토타입 없는 객체 생성:**\n- Object.create(null)로 완전히 빈 객체를 만듭니다.\n- Object.prototype의 메서드도 가지지 않습니다. toString, hasOwnProperty 등이 없습니다.\n- 순수한 데이터 저장소로 사용하기 좋습니다.\n- 프로토타입 오염 공격을 방지할 수 있습니다.\n- Map처럼 키-값 저장에 안전합니다.\n\n**상속 구현에서의 활용:**\n- 생성자 함수의 prototype을 설정할 때 사용합니다.\n- 부모의 인스턴스를 만들지 않고 프로토타입만 연결합니다.\n- 불필요한 속성 초기화를 피할 수 있습니다.\n- 더 효율적이고 명확한 상속 구조를 만듭니다.\n\n**객체 복제와 확장:**\n- 기존 객체를 프로토타입으로 하는 새 객체를 만듭니다.\n- 원본 객체를 변경하지 않고 확장할 수 있습니다.\n- 프로토타입 체인을 통한 위임 패턴을 구현합니다.\n\n**Object.create vs 생성자 함수:**\n- Object.create는 프로토타입을 직접 지정합니다. 더 명시적입니다.\n- 생성자 함수는 초기화 로직을 실행합니다. 속성 설정이 자동화됩니다.\n- Object.create는 간단한 상속에 적합합니다.\n- 생성자 함수는 복잡한 초기화가 필요할 때 적합합니다.\n\n**실무 활용 사례:**\n- 프로토타입 체인을 명확히 제어해야 할 때 사용합니다.\n- 설정 객체나 옵션 객체의 기본값을 프로토타입으로 설정합니다. 사용자 설정으로 오버라이드할 수 있습니다.\n- 순수 사전 객체가 필요할 때 Object.create(null)을 사용합니다.\n- 팩토리 패턴 구현 시 활용합니다. 동일한 프로토타입을 가진 객체를 대량 생성합니다.\n- Polyfill이나 레거시 브라우저 지원에서 중요합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "object"
      ],
      "id": "1763441901792-y1nyvqyk8",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Object.assign()과 얕은 복사에 대해 설명해주세요.",
      "answer": "**정의:**\nObject.assign은 하나 이상의 소스 객체로부터 대상 객체로 속성을 복사하는 메서드입니다. 얕은 복사를 수행하므로 중첩된 객체는 참조가 복사됩니다.\n\n**Object.assign의 동작:**\n- 첫 번째 인수가 대상 객체입니다. 이 객체에 속성이 추가되고 변경됩니다.\n- 두 번째 이후 인수들이 소스 객체들입니다. 이들의 속성이 대상 객체로 복사됩니다.\n- 열거 가능한 속성만 복사됩니다. enumerable이 true인 속성만 해당됩니다.\n- 같은 키가 있으면 나중 소스의 값으로 덮어씁니다. 뒤쪽 인수가 우선순위가 높습니다.\n- 대상 객체를 반환합니다. 원본 대상 객체가 변경됩니다.\n\n**얕은 복사의 의미:**\n- 최상위 레벨의 속성만 복사됩니다. 원시값은 값이 복사되고 객체는 참조가 복사됩니다.\n- 중첩된 객체는 같은 참조를 공유합니다. 원본과 복사본이 같은 내부 객체를 가리킵니다.\n- 내부 객체를 수정하면 원본도 영향을 받습니다.\n- 완전한 복사가 아닌 부분적인 복사입니다.\n\n**깊은 복사와의 차이:**\n- 얕은 복사: 한 단계만 복사하고 내부 객체는 참조를 공유합니다.\n- 깊은 복사: 모든 중첩 객체를 재귀적으로 복사합니다. 완전히 독립적인 복사본을 만듭니다.\n- JSON.stringify와 JSON.parse로 간단히 깊은 복사를 할 수 있습니다. 하지만 함수, undefined, Symbol은 복사되지 않습니다.\n- structuredClone을 사용하면 더 완전한 깊은 복사가 가능합니다.\n\n**Object.assign의 활용:**\n- 객체 병합에 사용합니다. 여러 설정 객체를 하나로 합칠 수 있습니다.\n- 객체 복제에 사용합니다. 빈 객체를 대상으로 하여 복사본을 만듭니다.\n- 기본값 설정에 활용합니다. 기본 옵션과 사용자 옵션을 병합합니다.\n- 불변성 유지에 사용합니다. 원본을 변경하지 않고 새 객체를 만듭니다.\n\n**주의사항:**\n- 대상 객체가 변경됩니다. 불변성을 유지하려면 빈 객체를 대상으로 사용합니다.\n- 심볼 속성도 복사됩니다. 하지만 프로토타입 체인의 속성은 복사되지 않습니다.\n- getter는 실행되고 그 결과가 복사됩니다. setter는 대상 객체에서 호출됩니다.\n- 순환 참조가 있으면 무한 루프가 발생하지 않습니다. 얕은 복사이기 때문입니다.\n\n**실무 활용:**\n- React나 Redux에서 상태를 불변하게 업데이트할 때 사용합니다.\n- 스프레드 문법으로 대체할 수 있습니다. 더 간결하고 가독성이 좋습니다.\n- 설정 객체나 옵션 객체를 병합할 때 유용합니다.\n- 얕은 복사의 한계를 이해하고 필요 시 깊은 복사를 구현해야 합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "object"
      ],
      "id": "1763441901792-62amva2si",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Object.freeze()와 Object.seal()의 차이점은 무엇인가요?",
      "answer": "**정의:**\nObject.freeze와 Object.seal은 객체의 변경을 제한하는 메서드입니다. 둘 다 객체를 불변하게 만들지만 제한의 정도가 다릅니다.\n\n**Object.freeze의 특징:**\n- 객체를 완전히 동결합니다. 가장 강력한 불변성을 제공합니다.\n- 속성 추가가 불가능합니다. 새로운 속성을 추가할 수 없습니다.\n- 속성 삭제가 불가능합니다. 기존 속성을 제거할 수 없습니다.\n- 속성 값 변경이 불가능합니다. 기존 속성의 값을 수정할 수 없습니다.\n- 속성 설명자 변경이 불가능합니다. writable, enumerable, configurable을 변경할 수 없습니다.\n- 읽기 전용 객체가 됩니다. 모든 쓰기 작업이 차단됩니다.\n\n**Object.seal의 특징:**\n- 객체를 봉인합니다. freeze보다는 약한 제한입니다.\n- 속성 추가가 불가능합니다. 새로운 속성을 추가할 수 없습니다.\n- 속성 삭제가 불가능합니다. 기존 속성을 제거할 수 없습니다.\n- 속성 값 변경은 가능합니다. 기존 속성의 값은 수정할 수 있습니다.\n- 속성 설명자 변경이 부분적으로 불가능합니다. configurable이 false가 되지만 writable은 변경 가능합니다.\n\n**Object.preventExtensions:**\n- 가장 약한 제한입니다. 확장만 방지합니다.\n- 속성 추가만 불가능합니다. 새로운 속성을 추가할 수 없습니다.\n- 속성 삭제는 가능합니다. 기존 속성을 제거할 수 있습니다.\n- 속성 값 변경은 가능합니다. 기존 속성의 값을 수정할 수 있습니다.\n\n**제한 수준 비교:**\n- preventExtensions: 확장 방지만. 삭제와 변경은 가능합니다.\n- seal: 확장과 삭제 방지. 값 변경은 가능합니다.\n- freeze: 모든 변경 방지. 완전한 불변입니다.\n\n**얕은 동결의 한계:**\n- 중첩된 객체는 동결되지 않습니다. 내부 객체는 여전히 변경 가능합니다.\n- 깊은 동결이 필요하면 재귀적으로 freeze를 적용해야 합니다.\n- 배열의 요소가 객체라면 해당 객체는 변경 가능합니다.\n\n**확인 메서드:**\n- Object.isFrozen으로 동결 상태를 확인합니다.\n- Object.isSealed로 봉인 상태를 확인합니다.\n- Object.isExtensible로 확장 가능 여부를 확인합니다.\n\n**엄격 모드와의 관계:**\n- 비엄격 모드에서는 변경이 조용히 실패합니다. 에러가 발생하지 않고 무시됩니다.\n- 엄격 모드에서는 TypeError가 발생합니다. 문제를 조기에 발견할 수 있습니다.\n\n**실무 활용:**\n- 상수 객체나 설정 객체를 보호할 때 사용합니다. 실수로 변경되는 것을 방지합니다.\n- 불변 데이터 구조를 구현할 때 활용합니다. 함수형 프로그래밍에서 유용합니다.\n- API 응답이나 설정을 동결하여 안정성을 높입니다.\n- 성능에 영향을 줄 수 있으므로 꼭 필요한 경우에만 사용합니다.\n- TypeScript의 readonly나 Immutable.js 같은 라이브러리도 대안이 될 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "object"
      ],
      "id": "1763441901792-23qgbjrzl",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?",
      "answer": "**정의:**\n동기는 코드가 순차적으로 실행되어 이전 작업이 완료될 때까지 다음 작업이 대기하는 방식입니다. 비동기는 작업이 완료되기를 기다리지 않고 다음 코드를 실행하며, 작업 완료 시 콜백이나 프로미스로 결과를 처리하는 방식입니다.\n\n**동기 처리의 특징:**\n- 코드가 작성된 순서대로 실행됩니다. 한 줄씩 차례로 처리됩니다.\n- 이전 작업이 완료될 때까지 블로킹됩니다. 다음 코드는 대기 상태가 됩니다.\n- 실행 흐름을 예측하기 쉽습니다. 코드를 읽는 순서대로 동작합니다.\n- 간단하고 이해하기 쉽습니다. 디버깅이 직관적입니다.\n\n**비동기 처리의 특징:**\n- 작업을 시작하고 완료를 기다리지 않습니다. 논블로킹 방식입니다.\n- 백그라운드에서 작업이 실행됩니다. 메인 스레드는 다른 작업을 계속합니다.\n- 작업 완료 시 콜백, Promise, async/await로 결과를 받습니다.\n- 동시에 여러 작업을 처리할 수 있습니다. 효율성이 높습니다.\n\n**JavaScript에서 비동기가 필요한 이유:**\n- 단일 스레드 언어입니다. 동기 작업만 사용하면 UI가 멈춥니다.\n- I/O 작업이 오래 걸립니다. 네트워크 요청, 파일 읽기 등을 기다리면 비효율적입니다.\n- 사용자 경험을 해치지 않습니다. 응답성을 유지할 수 있습니다.\n\n**비동기 처리 방식:**\n- 콜백 함수: 가장 기본적인 방식입니다. 중첩되면 콜백 지옥이 발생합니다.\n- Promise: 체이닝으로 가독성을 높입니다. 에러 처리가 명확합니다.\n- async/await: 동기 코드처럼 작성할 수 있습니다. 가장 현대적이고 직관적입니다.\n\n**실무 활용:**\n- API 호출은 항상 비동기로 처리합니다. 서버 응답을 기다리는 동안 UI를 유지합니다.\n- 파일 처리와 데이터베이스 쿼리는 비동기가 적합합니다.\n- 타이머 함수는 비동기입니다. setTimeout, setInterval을 사용합니다.\n- 이벤트 리스너도 비동기적으로 동작합니다.\n- 적절한 비동기 처리로 애플리케이션 성능을 크게 향상시킬 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "async"
      ],
      "id": "1763441901792-3mlgk61d5",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "콜백 함수(Callback)와 콜백 지옥(Callback Hell)에 대해 설명해주세요.",
      "answer": "**정의:**\n콜백 함수는 다른 함수의 인수로 전달되어 나중에 실행되는 함수입니다. 콜백 지옥은 콜백 함수가 중첩되어 코드의 가독성과 유지보수성이 떨어지는 현상입니다.\n\n**콜백 함수의 특징:**\n- 비동기 작업의 결과를 처리하는 데 사용됩니다. 작업 완료 시 호출됩니다.\n- 고차 함수의 인수로 전달됩니다. 함수를 값처럼 다룰 수 있습니다.\n- 이벤트 핸들러로도 사용됩니다. 사용자 액션에 반응합니다.\n- 동기와 비동기 모두에서 사용됩니다. map, filter 같은 배열 메서드도 콜백을 받습니다.\n\n**콜백 지옥의 문제점:**\n- 가독성이 크게 떨어집니다. 코드가 오른쪽으로 계속 들여쓰기됩니다.\n- 유지보수가 어렵습니다. 중간에 로직을 추가하거나 수정하기 힘듭니다.\n- 에러 처리가 복잡합니다. 각 단계마다 에러를 처리해야 합니다.\n- 디버깅이 어렵습니다. 실행 흐름을 추적하기 힘듭니다.\n\n**콜백 지옥이 발생하는 경우:**\n- 순차적인 비동기 작업이 많을 때 발생합니다. 각 작업이 이전 작업의 결과에 의존합니다.\n- 조건부 분기가 많을 때 더 복잡해집니다.\n- 에러 처리를 모든 단계에서 해야 할 때 심화됩니다.\n\n**콜백 지옥의 해결 방법:**\n- Promise를 사용합니다. 체이닝으로 평탄한 구조를 만들 수 있습니다.\n- async/await를 사용합니다. 동기 코드처럼 작성하여 가독성을 높입니다.\n- 함수를 분리합니다. 각 콜백을 별도의 named 함수로 정의합니다.\n- 제어 흐름 라이브러리를 사용합니다. async.js 같은 도구를 활용합니다.\n\n**콜백 패턴의 장점:**\n- 간단한 비동기 처리에 적합합니다. 단일 작업에서는 직관적입니다.\n- 추가 라이브러리가 필요 없습니다. 기본 JavaScript 기능만으로 구현됩니다.\n- 성능 오버헤드가 없습니다. Promise보다 가볍습니다.\n\n**실무에서의 대처:**\n- 현대적인 코드에서는 Promise나 async/await를 우선 사용합니다.\n- 레거시 코드를 리팩토링할 때 콜백을 Promise로 변환합니다.\n- Node.js의 util.promisify로 콜백 기반 함수를 Promise로 변환할 수 있습니다.\n- 에러 처리는 try-catch나 Promise의 catch를 일관되게 사용합니다.\n- 코드 리뷰에서 콜백 중첩을 경계하고 리팩토링을 권장합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "function"
      ],
      "id": "1763441901792-43v85x12l",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Promise의 동작 원리와 세 가지 상태에 대해 설명해주세요.",
      "answer": "**정의:**\nPromise는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체입니다. 콜백 지옥을 해결하고 비동기 코드를 더 읽기 쉽게 만듭니다.\n\n**Promise의 세 가지 상태:**\n- Pending: 초기 상태로 아직 완료되지도 실패하지도 않은 상태입니다. 비동기 작업이 진행 중입니다.\n- Fulfilled: 작업이 성공적으로 완료된 상태입니다. resolve가 호출되어 결과값을 가집니다.\n- Rejected: 작업이 실패한 상태입니다. reject가 호출되어 에러 정보를 가집니다.\n- 상태는 한 번 변경되면 다시 바뀌지 않습니다. settled 상태라고 하며 불변입니다.\n\n**Promise의 생성과 사용:**\n- new Promise로 생성하며 executor 함수를 전달합니다.\n- executor는 resolve와 reject 함수를 인수로 받습니다.\n- 비동기 작업 성공 시 resolve를 호출합니다. 결과값을 전달합니다.\n- 실패 시 reject를 호출합니다. 에러 객체를 전달합니다.\n\n**Promise 체이닝:**\n- then 메서드로 성공 시 처리를 연결합니다. 새로운 Promise를 반환합니다.\n- catch 메서드로 에러를 처리합니다. 체인 중 어디서든 발생한 에러를 잡습니다.\n- finally 메서드로 성공 실패 관계없이 실행될 코드를 작성합니다.\n- 평탄한 구조로 순차적 비동기 작업을 표현할 수 있습니다.\n\n**Promise의 장점:**\n- 콜백 지옥을 해결합니다. 체이닝으로 가독성이 향상됩니다.\n- 에러 처리가 명확합니다. catch 하나로 모든 에러를 처리할 수 있습니다.\n- 합성이 쉽습니다. Promise.all, Promise.race 등으로 조합할 수 있습니다.\n- 표준화된 인터페이스입니다. 다양한 라이브러리와 호환됩니다.\n\n**Promise 정적 메서드:**\n- Promise.all은 모든 Promise가 완료될 때까지 기다립니다. 하나라도 실패하면 전체가 실패합니다.\n- Promise.race는 가장 먼저 완료되는 Promise의 결과를 반환합니다.\n- Promise.allSettled는 모든 Promise의 결과를 기다립니다. 성공 실패 관계없이 모두 반환합니다.\n- Promise.any는 가장 먼저 성공하는 Promise를 반환합니다.\n\n**실무 활용:**\n- API 호출을 Promise로 감싸서 처리합니다. fetch API가 Promise를 반환합니다.\n- 여러 비동기 작업을 병렬로 처리할 때 Promise.all을 사용합니다.\n- 타임아웃 구현 시 Promise.race를 활용합니다.\n- 에러 처리를 일관되게 catch로 통합합니다.\n- async/await와 함께 사용하여 더욱 직관적인 코드를 작성합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "async",
        "state"
      ],
      "id": "1763441901792-s43l7rqil",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Promise 체이닝과 에러 핸들링 방법은 무엇인가요?",
      "answer": "**정의:**\nPromise 체이닝은 여러 비동기 작업을 순차적으로 연결하는 패턴입니다. 각 then은 새로운 Promise를 반환하여 다음 then으로 값을 전달할 수 있습니다.\n\n**체이닝의 동작 원리:**\n- then은 항상 새로운 Promise를 반환합니다. 값을 반환하면 자동으로 Promise로 감싸집니다.\n- 반환된 값이 다음 then의 인수가 됩니다. 데이터가 체인을 따라 흐릅니다.\n- Promise를 반환하면 해당 Promise가 완료될 때까지 기다립니다. 중첩 없이 순차 처리가 가능합니다.\n- 각 단계는 이전 단계의 결과에 의존합니다.\n\n**값 전달과 변환:**\n- then에서 값을 반환하면 다음 then으로 전달됩니다.\n- 값을 변환하여 파이프라인을 구성할 수 있습니다.\n- undefined를 반환하면 다음 then도 undefined를 받습니다.\n- Promise를 반환하면 자동으로 unwrap됩니다.\n\n**에러 핸들링 방법:**\n- catch 메서드로 에러를 잡습니다. 체인 어디서든 발생한 에러를 처리합니다.\n- then의 두 번째 인수로도 에러를 처리할 수 있습니다. 하지만 catch 사용이 권장됩니다.\n- catch 이후에도 체이닝을 계속할 수 있습니다. 에러에서 복구할 수 있습니다.\n- catch에서 에러를 다시 throw하면 다음 catch로 전파됩니다.\n\n**에러 전파:**\n- Promise 체인 중 하나라도 reject되면 다음 catch로 이동합니다.\n- 중간의 then들은 건너뛰어집니다.\n- catch에서 에러를 처리하지 않으면 계속 전파됩니다.\n- finally는 에러 여부와 관계없이 실행됩니다.\n\n**finally 메서드:**\n- 성공이든 실패든 항상 실행됩니다. 정리 작업에 적합합니다.\n- 인수를 받지 않습니다. 성공/실패를 구분하지 않기 때문입니다.\n- 이전 Promise의 값을 그대로 전달합니다. 값을 변경하지 않습니다.\n- 로딩 상태 해제, 리소스 정리 등에 사용합니다.\n\n**체이닝 시 주의사항:**\n- then에서 Promise를 반환하지 않으면 다음 then이 즉시 실행됩니다.\n- return을 빼먹으면 다음 then이 undefined를 받습니다.\n- catch 후에도 체인이 계속되므로 적절한 위치에 배치해야 합니다.\n- 각 then은 새로운 Promise이므로 원본 Promise는 변경되지 않습니다.\n\n**실무 활용 패턴:**\n- API 호출 후 데이터 변환, 저장, UI 업데이트를 순차적으로 체이닝합니다.\n- 에러 처리는 체인 마지막에 catch 하나로 통합합니다.\n- 공통 정리 작업은 finally에서 처리합니다. 로딩 스피너 숨기기 등입니다.\n- 조건부 분기가 필요하면 then 내부에서 Promise.resolve나 Promise.reject를 반환합니다.\n- 병렬 작업은 Promise.all로, 순차 작업은 체이닝으로 구분하여 사용합니다.\n- async/await로 전환하면 더 읽기 쉬운 코드가 됩니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "async"
      ],
      "id": "1763441901792-a54lu34xj",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "async/await의 동작 원리와 Promise와의 차이점은 무엇인가요?",
      "answer": "**정의:**\nasync/await는 Promise 기반 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법입니다. async 함수는 항상 Promise를 반환하고, await는 Promise가 완료될 때까지 실행을 일시 중지합니다.\n\n**async 함수의 특징:**\n- async 키워드로 선언된 함수는 자동으로 Promise를 반환합니다. 반환값이 Promise로 감싸집니다.\n- 일반 값을 반환해도 Promise.resolve로 자동 변환됩니다.\n- 에러를 throw하면 거부된 Promise를 반환합니다.\n- 함수 내부에서 await를 사용할 수 있습니다.\n\n**await의 동작 원리:**\n- await는 Promise가 settled 될 때까지 함수 실행을 일시 중지합니다.\n- Promise가 fulfilled되면 결과값을 반환합니다.\n- Promise가 rejected되면 에러를 throw합니다.\n- await는 async 함수 내부에서만 사용할 수 있습니다. 최상위 레벨에서는 사용 불가합니다.\n\n**Promise와의 차이점:**\n- 가독성: async/await는 동기 코드처럼 읽힙니다. Promise 체이닝보다 직관적입니다.\n- 에러 처리: try-catch로 통일됩니다. Promise의 catch보다 익숙한 패턴입니다.\n- 디버깅: 스택 트레이스가 명확합니다. 중단점을 설정하기 쉽습니다.\n- 조건 분기: if-else를 자연스럽게 사용할 수 있습니다. Promise는 중첩이 필요합니다.\n\n**async/await의 장점:**\n- 코드 흐름이 명확합니다. 순차적 실행이 한눈에 보입니다.\n- 중간 변수를 쉽게 사용할 수 있습니다. 체이닝처럼 클로저가 필요 없습니다.\n- 에러 처리가 간단합니다. try-catch 하나로 여러 await를 감쌀 수 있습니다.\n- 반복문과 조건문을 자연스럽게 사용합니다.\n\n**병렬 처리 주의사항:**\n- 순차적으로 await하면 직렬 실행됩니다. 불필요하게 시간이 오래 걸립니다.\n- 병렬 실행이 필요하면 Promise.all을 사용합니다.\n- await를 변수 선언과 분리하여 동시 실행을 유도할 수 있습니다.\n- 독립적인 작업은 병렬로, 의존적인 작업은 순차로 처리합니다.\n\n**실무 활용:**\n- API 호출을 동기 코드처럼 작성합니다. 가독성이 크게 향상됩니다.\n- try-catch로 일관된 에러 처리를 구현합니다.\n- 순차적 비동기 작업에 최적입니다. 각 단계가 이전 결과에 의존할 때 유용합니다.\n- Promise.all과 조합하여 병렬 처리도 가능합니다.\n- React에서 데이터 fetching, Node.js에서 파일 처리 등에 널리 사용됩니다.\n- 최신 JavaScript의 표준적인 비동기 처리 방식입니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "async"
      ],
      "id": "1763441901792-5sjf0b5wa",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "이벤트 루프(Event Loop)의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\n이벤트 루프는 JavaScript의 비동기 처리를 가능하게 하는 메커니즘입니다. 단일 스레드 환경에서 비블로킹 작업을 수행하며, 콜 스택과 태스크 큐를 관리하여 코드 실행 순서를 제어합니다.\n\n**JavaScript 런타임 구조:**\n- Call Stack: 실행 중인 함수를 추적하는 스택입니다. 함수 호출 시 push, 종료 시 pop됩니다.\n- Web APIs: 브라우저가 제공하는 비동기 API입니다. setTimeout, fetch, DOM 이벤트 등이 포함됩니다.\n- Task Queue: 실행 대기 중인 콜백 함수들이 저장됩니다. 매크로태스크 큐라고도 합니다.\n- Microtask Queue: Promise 콜백과 MutationObserver가 저장됩니다. 우선순위가 더 높습니다.\n\n**이벤트 루프의 동작 과정:**\n- 콜 스택이 비어있는지 확인합니다. 실행 중인 코드가 없어야 합니다.\n- 마이크로태스크 큐를 먼저 확인합니다. 모든 마이크로태스크를 실행합니다.\n- 마이크로태스크가 없으면 태스크 큐를 확인합니다. 하나의 태스크를 꺼내 실행합니다.\n- 다시 마이크로태스크 큐를 확인합니다. 새로 추가된 마이크로태스크를 모두 실행합니다.\n- 이 과정을 반복합니다.\n\n**실행 순서:**\n- 동기 코드가 가장 먼저 실행됩니다. 콜 스택에서 바로 처리됩니다.\n- 마이크로태스크가 그다음입니다. Promise then, catch, finally가 해당됩니다.\n- 매크로태스크가 마지막입니다. setTimeout, setInterval, I/O 작업이 해당됩니다.\n- 마이크로태스크는 매크로태스크보다 항상 먼저 실행됩니다.\n\n**논블로킹의 원리:**\n- 비동기 작업은 Web API로 위임됩니다. 콜 스택을 차단하지 않습니다.\n- 작업 완료 시 콜백이 큐에 추가됩니다.\n- 콜 스택이 비면 이벤트 루프가 큐에서 콜백을 가져옵니다.\n- 이를 통해 단일 스레드에서도 동시성을 구현합니다.\n\n**setTimeout의 동작:**\n- setTimeout은 타이머를 설정하고 즉시 반환됩니다.\n- 지정된 시간 후 콜백이 태스크 큐에 추가됩니다.\n- 콜 스택이 비고 앞선 태스크들이 처리된 후 실행됩니다.\n- 따라서 정확한 시간 보장이 없습니다. 최소 지연 시간일 뿐입니다.\n\n**실무에서의 이해:**\n- 무거운 동기 작업은 UI를 멈추게 합니다. 이벤트 루프가 블로킹됩니다.\n- 비동기 작업으로 분할하면 응답성을 유지할 수 있습니다.\n- Promise 체인보다 마이크로태스크가 먼저 실행됨을 이해해야 합니다.\n- 무한 마이크로태스크 생성은 매크로태스크를 영원히 차단할 수 있습니다.\n- 이벤트 루프를 이해하면 비동기 코드의 실행 순서를 예측할 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "event"
      ],
      "id": "1763441901792-lstbzg82e",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "마이크로태스크(Microtask)와 매크로태스크(Macrotask)의 차이점은 무엇인가요?",
      "answer": "**정의:**\n마이크로태스크와 매크로태스크는 이벤트 루프에서 관리하는 두 가지 태스크 큐입니다. 실행 우선순위와 처리 방식이 다르며, 비동기 작업의 실행 순서를 결정합니다.\n\n**마이크로태스크의 특징:**\n- Promise의 then, catch, finally 핸들러가 해당됩니다.\n- queueMicrotask로 직접 추가할 수도 있습니다.\n- MutationObserver 콜백도 마이크로태스크입니다.\n- 우선순위가 더 높습니다. 매크로태스크보다 먼저 실행됩니다.\n- 큐가 완전히 비워질 때까지 연속 실행됩니다.\n\n**매크로태스크의 특징:**\n- setTimeout, setInterval 콜백이 해당됩니다.\n- setImmediate는 Node.js의 매크로태스크입니다.\n- I/O 작업과 UI 렌더링도 포함됩니다.\n- 한 번에 하나씩만 실행됩니다.\n- 실행 후 마이크로태스크 큐를 확인합니다.\n\n**실행 우선순위:**\n- 동기 코드가 가장 먼저 실행됩니다.\n- 모든 마이크로태스크가 다음입니다. 큐가 빌 때까지 계속 실행됩니다.\n- 하나의 매크로태스크가 실행됩니다.\n- 다시 모든 마이크로태스크를 실행합니다.\n- 이 사이클이 반복됩니다.\n\n**이벤트 루프 사이클:**\n- 콜 스택을 실행합니다. 동기 코드가 완료될 때까지 진행합니다.\n- 마이크로태스크 큐를 모두 비웁니다. 새로 추가되는 것도 즉시 실행합니다.\n- 필요시 렌더링을 수행합니다. 브라우저가 화면을 업데이트합니다.\n- 하나의 매크로태스크를 실행합니다.\n- 다시 마이크로태스크 큐를 확인합니다.\n\n**마이크로태스크의 위험성:**\n- 무한 루프를 만들 수 있습니다. 계속 새로운 마이크로태스크를 생성하면 매크로태스크가 실행되지 않습니다.\n- UI 렌더링이 차단될 수 있습니다. 마이크로태스크가 끝나야 렌더링이 시작됩니다.\n- 타이머가 지연될 수 있습니다. setTimeout 콜백보다 Promise가 먼저 실행됩니다.\n\n**실무에서의 활용:**\n- 우선순위가 높은 작업은 마이크로태스크로 처리합니다. Promise를 활용합니다.\n- 즉시 실행이 필요하지 않은 작업은 매크로태스크로 처리합니다.\n- 상태 업데이트 후 DOM 변경은 마이크로태스크에서 처리하면 한 번에 렌더링됩니다.\n- 무거운 계산은 여러 매크로태스크로 분할하여 UI를 유지합니다.\n- 실행 순서를 정확히 이해하면 버그를 예방할 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-svtuc8n2c",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Promise.all(), Promise.race(), Promise.allSettled()의 차이점은 무엇인가요?",
      "answer": "**정의:**\n이들은 여러 Promise를 다루는 정적 메서드들입니다. 각각 다른 방식으로 Promise 배열을 처리하며, 병렬 비동기 작업에 활용됩니다.\n\n**Promise.all의 특징:**\n- 모든 Promise가 fulfilled될 때까지 기다립니다.\n- 모든 결과를 배열로 반환합니다. 입력 순서대로 결과가 정렬됩니다.\n- 하나라도 rejected되면 즉시 전체가 실패합니다. 첫 번째 에러를 반환합니다.\n- 나머지 Promise는 계속 실행되지만 결과는 무시됩니다.\n- 모든 작업이 성공해야 하는 경우에 사용합니다.\n\n**Promise.race의 특징:**\n- 가장 먼저 settled되는 Promise의 결과를 반환합니다.\n- 성공이든 실패든 상관없이 첫 번째 결과를 사용합니다.\n- 나머지 Promise는 계속 실행되지만 결과는 무시됩니다.\n- 타임아웃 구현에 유용합니다. Promise와 타이머를 경쟁시킵니다.\n- 여러 소스 중 가장 빠른 응답을 사용할 때 적합합니다.\n\n**Promise.allSettled의 특징:**\n- 모든 Promise가 settled될 때까지 기다립니다. 성공 실패 관계없이 모두 대기합니다.\n- 각 Promise의 상태와 값/에러를 모두 반환합니다.\n- 절대 rejected되지 않습니다. 항상 fulfilled됩니다.\n- 각 결과는 status와 value 또는 reason을 포함합니다.\n- 일부 실패해도 다른 결과를 확인해야 할 때 사용합니다.\n\n**Promise.any의 특징:**\n- 가장 먼저 fulfilled되는 Promise의 결과를 반환합니다.\n- 실패한 Promise는 무시하고 성공만 기다립니다.\n- 모두 rejected되면 AggregateError를 발생시킵니다.\n- 여러 대안 중 하나만 성공하면 되는 경우에 사용합니다.\n\n**사용 사례 비교:**\n- Promise.all: 여러 API를 병렬 호출하고 모든 결과가 필요할 때 사용합니다. 페이지 초기화 시 여러 데이터를 동시에 로드합니다.\n- Promise.race: 타임아웃을 구현하거나 가장 빠른 서버를 선택할 때 사용합니다.\n- Promise.allSettled: 여러 작업의 성공 실패를 모두 확인해야 할 때 사용합니다. 배치 처리 결과를 로깅합니다.\n- Promise.any: 여러 미러 서버 중 하나만 응답하면 되는 경우에 사용합니다.\n\n**실무 활용:**\n- 병렬 API 호출로 성능을 개선합니다. 순차 호출보다 빠릅니다.\n- Promise.all과 async/await를 조합하여 효율적인 코드를 작성합니다.\n- 에러 처리 전략에 따라 적절한 메서드를 선택합니다.\n- Promise.allSettled로 부분 실패를 허용하는 견고한 시스템을 만듭니다.\n- 타임아웃이 필요한 네트워크 요청은 Promise.race로 구현합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "async"
      ],
      "id": "1763441901792-trlay38hw",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "구조 분해 할당(Destructuring)에 대해 설명해주세요.",
      "answer": "**정의:**\n구조 분해 할당은 배열이나 객체의 속성을 해체하여 개별 변수에 할당하는 JavaScript 표현식입니다. 코드를 간결하게 만들고 필요한 값만 추출할 수 있습니다.\n\n**배열 구조 분해:**\n- 배열의 요소를 순서대로 변수에 할당합니다. 인덱스 순서를 따릅니다.\n- 일부 요소를 건너뛸 수 있습니다. 빈 칸을 두면 해당 요소는 무시됩니다.\n- 기본값을 설정할 수 있습니다. undefined인 경우 기본값이 사용됩니다.\n- 나머지 요소를 배열로 수집할 수 있습니다. rest 연산자를 사용합니다.\n- 변수 교환을 간단히 할 수 있습니다. 임시 변수 없이 가능합니다.\n\n**객체 구조 분해:**\n- 속성 이름과 일치하는 변수에 값을 할당합니다. 순서는 상관없습니다.\n- 다른 변수명을 사용할 수 있습니다. 콜론으로 새 이름을 지정합니다.\n- 중첩된 객체도 분해할 수 있습니다. 깊은 속성에 접근합니다.\n- 기본값을 설정할 수 있습니다. 속성이 없거나 undefined일 때 사용됩니다.\n- 나머지 속성을 객체로 수집할 수 있습니다.\n\n**함수 매개변수 구조 분해:**\n- 객체를 매개변수로 받아 즉시 분해합니다.\n- 필요한 속성만 추출하여 사용합니다.\n- 기본값을 설정하여 옵션 매개변수를 구현합니다.\n- 가독성이 높아지고 순서에 구애받지 않습니다.\n\n**구조 분해의 장점:**\n- 코드가 간결해집니다. 반복적인 점 표기법을 줄입니다.\n- 가독성이 향상됩니다. 사용할 변수를 명확히 보여줍니다.\n- 필요한 값만 추출합니다. 불필요한 데이터를 무시할 수 있습니다.\n- 함수 반환값을 쉽게 처리합니다. 여러 값을 배열이나 객체로 반환받습니다.\n\n**실무 활용 사례:**\n- React에서 props와 state를 구조 분해합니다. 컴포넌트 코드가 깔끔해집니다.\n- API 응답에서 필요한 필드만 추출합니다.\n- 설정 객체에서 옵션을 꺼냅니다. 기본값과 함께 사용합니다.\n- 배열의 첫 번째 요소와 나머지를 분리합니다.\n- import 문에서 필요한 모듈만 가져옵니다.\n- 함수가 여러 값을 반환할 때 받는 쪽에서 분해합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-yxqjseca7",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "스프레드 연산자(Spread Operator)와 레스트 파라미터(Rest Parameter)의 차이점은 무엇인가요?",
      "answer": "**정의:**\n스프레드 연산자와 레스트 파라미터는 모두 세 개의 점 문법을 사용하지만 반대 방향으로 동작합니다. 스프레드는 배열이나 객체를 펼치고, 레스트는 여러 요소를 하나로 모읍니다.\n\n**스프레드 연산자의 특징:**\n- 배열이나 객체를 개별 요소로 펼칩니다. 전개한다고 표현합니다.\n- 배열 복사와 병합에 사용됩니다. 얕은 복사가 수행됩니다.\n- 객체 복사와 병합에도 사용됩니다. 속성을 펼쳐서 새 객체를 만듭니다.\n- 함수 호출 시 배열을 인수로 펼칩니다.\n- 이터러블한 모든 객체에 사용할 수 있습니다.\n\n**레스트 파라미터의 특징:**\n- 여러 개의 인수를 배열로 수집합니다. 묶는다고 표현합니다.\n- 함수 매개변수에서 가변 인수를 받습니다. 개수가 정해지지 않은 인수를 처리합니다.\n- 구조 분해 할당에서 나머지 요소를 수집합니다.\n- 항상 마지막 위치에 와야 합니다. 그 이후에 다른 매개변수가 올 수 없습니다.\n- 실제 배열입니다. arguments 객체와 달리 배열 메서드를 바로 사용할 수 있습니다.\n\n**사용 위치에 따른 구분:**\n- 값을 펼치는 위치에서는 스프레드입니다. 배열 리터럴, 객체 리터럴, 함수 호출에서 사용합니다.\n- 값을 수집하는 위치에서는 레스트입니다. 함수 매개변수, 구조 분해 할당에서 사용합니다.\n- 문맥에 따라 같은 문법이 다르게 동작합니다.\n\n**스프레드 연산자 활용:**\n- 배열 복사: 얕은 복사로 새 배열을 만듭니다. 원본이 보호됩니다.\n- 배열 병합: 여러 배열을 하나로 합칩니다. concat보다 간결합니다.\n- 배열 요소 추가: 특정 위치에 요소를 삽입할 수 있습니다.\n- 함수 인수 전달: 배열을 개별 인수로 펼쳐 전달합니다.\n- 객체 복사와 병합: 불변성을 유지하며 객체를 업데이트합니다.\n\n**레스트 파라미터 활용:**\n- 가변 인수 함수: 인수 개수에 관계없이 처리합니다.\n- 일부 인수 분리: 앞의 인수는 개별 변수로, 나머지는 배열로 받습니다.\n- arguments 대체: 더 명확하고 배열 메서드를 바로 사용할 수 있습니다.\n\n**실무 활용 사례:**\n- React에서 props를 펼치거나 수집합니다. 불변 업데이트에 활용합니다.\n- 배열과 객체를 안전하게 복사하고 수정합니다.\n- 유틸리티 함수에서 유연한 인수 처리를 구현합니다.\n- 고차 함수에서 인수를 전달하거나 수집합니다.\n- 이전 문법보다 간결하고 읽기 쉬운 코드를 작성합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-m608wfqba",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "ES6 모듈(import/export)과 CommonJS(require/module.exports)의 차이점은 무엇인가요?",
      "answer": "**정의:**\nES6 모듈과 CommonJS는 JavaScript의 두 가지 모듈 시스템입니다. ES6 모듈은 표준 JavaScript 모듈이고, CommonJS는 Node.js에서 사용되던 모듈 시스템입니다.\n\n**ES6 모듈의 특징:**\n- 정적 구조입니다. 컴파일 타임에 의존성이 결정됩니다.\n- import와 export 키워드를 사용합니다. 선언적이고 명확합니다.\n- 최상위 레벨에서만 사용할 수 있습니다. 조건부나 함수 내에서 사용할 수 없습니다.\n- 엄격 모드가 기본입니다. 자동으로 strict mode가 적용됩니다.\n- this는 undefined입니다. 전역 객체를 가리키지 않습니다.\n- 트리 쉐이킹이 가능합니다. 사용하지 않는 코드를 제거할 수 있습니다.\n\n**CommonJS의 특징:**\n- 동적 구조입니다. 런타임에 모듈이 로드됩니다.\n- require와 module.exports를 사용합니다. 함수처럼 호출합니다.\n- 어디서든 사용할 수 있습니다. 조건부 로딩이 가능합니다.\n- 동기적으로 로드됩니다. 파일을 즉시 읽어옵니다.\n- this는 module.exports를 가리킵니다.\n- Node.js의 기본 모듈 시스템입니다.\n\n**로딩 방식의 차이:**\n- ES6 모듈: 비동기적으로 로드됩니다. 브라우저 환경에 적합합니다. 정적 분석이 가능하여 최적화됩니다.\n- CommonJS: 동기적으로 로드됩니다. 서버 환경에 적합합니다. 파일 시스템 접근이 빠르기 때문입니다.\n\n**내보내기와 가져오기:**\n- ES6 모듈: named export와 default export를 구분합니다. 여러 named export를 할 수 있습니다. 하나의 default export를 가집니다.\n- CommonJS: module.exports에 할당합니다. 객체, 함수, 클래스 등 어떤 값이든 내보낼 수 있습니다.\n\n**호환성과 변환:**\n- ES6 모듈은 최신 브라우저와 Node.js에서 지원됩니다. type=\"module\"이 필요합니다.\n- Babel이나 TypeScript로 CommonJS로 변환할 수 있습니다.\n- Webpack 같은 번들러가 두 시스템을 모두 처리합니다.\n- Node.js에서는 .mjs 확장자나 package.json 설정으로 구분합니다.\n\n**실무에서의 선택:**\n- 새 프로젝트는 ES6 모듈을 사용합니다. 표준이며 미래 지향적입니다.\n- 브라우저용 코드는 ES6 모듈이 적합합니다.\n- 레거시 Node.js 프로젝트는 CommonJS를 유지할 수 있습니다.\n- 라이브러리는 둘 다 지원하도록 빌드합니다.\n- 트리 쉐이킹을 활용하려면 ES6 모듈을 사용해야 합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "ES6"
      ],
      "id": "1763441901792-4hzy23kmp",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "ES6 Class 문법과 프로토타입 기반 상속의 차이점은 무엇인가요?",
      "answer": "**정의:**\nES6 Class는 프로토타입 기반 상속을 더 직관적인 문법으로 작성할 수 있게 해주는 문법적 설탕입니다. 내부적으로는 여전히 프로토타입을 사용하지만 클래스 기반 언어처럼 보입니다.\n\n**Class 문법의 특징:**\n- class 키워드로 선언합니다. 명확하고 읽기 쉽습니다.\n- constructor로 인스턴스를 초기화합니다. 생성자 역할을 명시적으로 정의합니다.\n- 메서드를 간결하게 정의합니다. 프로토타입에 자동으로 추가됩니다.\n- extends로 상속을 선언합니다. 프로토타입 체인을 자동으로 설정합니다.\n- super로 부모 클래스에 접근합니다. 부모의 생성자와 메서드를 호출합니다.\n\n**프로토타입 방식과의 비교:**\n- 문법: Class는 선언적이고 명확합니다. 프로토타입은 명시적으로 설정해야 합니다.\n- 가독성: Class가 훨씬 읽기 쉽습니다. 의도가 명확히 드러납니다.\n- 상속: Class는 extends 하나로 해결됩니다. 프로토타입은 여러 단계가 필요합니다.\n- 동작: 내부적으로는 동일합니다. 프로토타입 체인을 사용합니다.\n\n**Class만의 특징:**\n- 호이스팅되지 않습니다. TDZ가 적용됩니다. 선언 전에 사용할 수 없습니다.\n- 엄격 모드가 기본입니다. 자동으로 strict mode가 적용됩니다.\n- new 없이 호출할 수 없습니다. TypeError가 발생합니다. 생성자 함수는 가능했습니다.\n- 메서드는 열거되지 않습니다. enumerable이 false입니다.\n\n**정적 메서드와 속성:**\n- static 키워드로 정의합니다. 클래스 자체의 메서드와 속성입니다.\n- 인스턴스가 아닌 클래스에서 호출합니다.\n- 유틸리티 함수나 팩토리 메서드로 사용됩니다.\n- 프로토타입에 추가되지 않습니다.\n\n**private 필드:**\n- 해시 기호로 시작합니다. 클래스 내부에서만 접근 가능합니다.\n- 진정한 캡슐화를 제공합니다. 외부에서 접근할 수 없습니다.\n- 비교적 최근에 추가된 기능입니다.\n\n**실무에서의 사용:**\n- 객체 지향 패턴을 구현할 때 Class를 사용합니다. 더 명확하고 유지보수하기 쉽습니다.\n- React 클래스 컴포넌트에서 사용됩니다. 하지만 Hooks로 대체되는 추세입니다.\n- 복잡한 상속 구조는 Class로 표현하기 쉽습니다.\n- TypeScript와 잘 어울립니다. 타입 정의가 자연스럽습니다.\n- 프로토타입의 동작 원리를 이해하면 Class도 더 잘 사용할 수 있습니다.\n- 함수형 프로그래밍이 선호되면서 Class 사용이 줄어드는 경향도 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "prototype",
        "ES6"
      ],
      "id": "1763441901792-pb1am5zad",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Symbol의 용도와 사용 방법은 무엇인가요?",
      "answer": "**정의:**\nmap, filter, reduce는 배열을 다루는 고차 함수들입니다. 각각 변환, 필터링, 축약이라는 명확한 목적을 가지며, 함수형 프로그래밍의 핵심 도구입니다.\n\n**map의 특징:**\n- 배열의 각 요소를 변환합니다. 콜백 함수의 반환값으로 새 배열을 만듭니다.\n- 원본 배열과 같은 길이의 배열을 반환합니다. 일대일 매핑입니다.\n- 원본 배열을 변경하지 않습니다. 불변성을 유지합니다.\n- 각 요소에 동일한 변환을 적용할 때 사용합니다.\n\n**filter의 특징:**\n- 조건에 맞는 요소만 선택합니다. 콜백이 true를 반환하는 요소만 포함합니다.\n- 원본 배열보다 작거나 같은 길이의 배열을 반환합니다.\n- 원본 배열을 변경하지 않습니다.\n- 특정 조건을 만족하는 요소를 추출할 때 사용합니다.\n\n**reduce의 특징:**\n- 배열을 하나의 값으로 축약합니다. 누적 계산을 수행합니다.\n- 콜백과 초기값을 받습니다. 누산기와 현재 값을 처리합니다.\n- 배열이 아닌 단일 값을 반환합니다. 숫자, 객체, 배열 등 어떤 타입도 가능합니다.\n- 합계, 평균, 최댓값, 객체 변환 등에 사용합니다.\n\n**사용 사례 비교:**\n- map: 배열의 모든 요소에 10을 곱하기, 객체 배열에서 특정 속성만 추출하기, 데이터 형식 변환하기\n- filter: 특정 조건을 만족하는 항목 찾기, 중복 제거, null이나 undefined 필터링하기\n- reduce: 배열 합계 구하기, 배열을 객체로 변환하기, 평탄화하기, 그룹화하기\n\n**체이닝과 조합:**\n- 여러 메서드를 연결하여 복잡한 변환을 수행합니다.\n- filter로 필터링하고 map으로 변환하는 패턴이 흔합니다.\n- reduce로 모든 작업을 할 수 있지만 가독성이 떨어질 수 있습니다.\n- 성능을 고려하면 reduce 하나로 통합하는 것이 효율적일 수 있습니다.\n\n**실무 활용:**\n- API 응답 데이터를 UI에 필요한 형태로 변환합니다.\n- 검색, 필터링 기능을 구현합니다.\n- 통계 계산이나 집계 작업을 수행합니다.\n- 선언적 코드로 가독성을 높입니다. for 루프보다 의도가 명확합니다.\n- React에서 컴포넌트 리스트를 렌더링할 때 map을 많이 사용합니다.\n- 불변성을 유지하며 상태를 업데이트할 때 활용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-stsulsj4k",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Template Literal의 특징과 활용 방법은 무엇인가요?",
      "answer": "**정의:**\nforEach와 map은 모두 배열의 각 요소를 순회하는 메서드이지만, 반환값과 사용 목적이 다릅니다. forEach는 반복 작업을, map은 변환 작업을 수행합니다.\n\n**forEach의 특징:**\n- 각 요소에 대해 콜백을 실행합니다. 단순 반복을 위한 메서드입니다.\n- undefined를 반환합니다. 반환값이 없습니다.\n- 부수 효과를 위해 사용합니다. 로깅, DOM 조작 등을 수행합니다.\n- 중간에 종료할 수 없습니다. break나 continue를 사용할 수 없습니다.\n- 체이닝이 불가능합니다. 반환값이 없기 때문입니다.\n\n**map의 특징:**\n- 각 요소를 변환하여 새 배열을 만듭니다. 데이터 변환을 위한 메서드입니다.\n- 새로운 배열을 반환합니다. 원본과 같은 길이입니다.\n- 순수 함수로 사용하기 좋습니다. 부수 효과 없이 값을 반환합니다.\n- 체이닝이 가능합니다. 다른 배열 메서드와 연결할 수 있습니다.\n\n**성능 비교:**\n- 성능은 거의 비슷합니다. 큰 차이가 없습니다.\n- map이 새 배열을 만들므로 메모리를 더 사용합니다.\n- 반환값이 필요 없으면 forEach가 더 적합합니다.\n- 변환이 목적이면 map을 사용해야 합니다.\n\n**사용 시기:**\n- forEach: 부수 효과가 목적일 때 사용합니다. 콘솔 출력, DOM 업데이트, 외부 변수 수정 등입니다.\n- map: 데이터 변환이 목적일 때 사용합니다. 새로운 배열이 필요할 때입니다.\n\n**for 루프와의 비교:**\n- forEach와 map은 더 선언적입니다. 무엇을 할지 명확합니다.\n- for 루프는 더 명령적입니다. 어떻게 할지를 명시합니다.\n- forEach와 map은 스코프가 명확합니다. 콜백마다 새로운 스코프가 생깁니다.\n- for 루프는 break와 continue를 사용할 수 있습니다.\n- 성능은 for 루프가 약간 빠를 수 있습니다. 하지만 차이는 미미합니다.\n\n**실무에서의 선택:**\n- 변환이 목적이면 무조건 map을 사용합니다. 의도가 명확해집니다.\n- 부수 효과만 필요하면 forEach를 사용합니다.\n- map의 반환값을 무시하면 안 됩니다. 메모리 낭비이고 의도가 불명확합니다.\n- 함수형 프로그래밍을 지향한다면 map을 선호합니다.\n- 조기 종료가 필요하면 for 루프나 some/every를 고려합니다.\n- 가독성과 유지보수성을 우선으로 선택합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-t28dcarad",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "map(), filter(), reduce()의 차이점과 사용 사례는 무엇인가요?",
      "answer": "**정의:**\nsome과 every는 배열 요소가 조건을 만족하는지 검사하는 메서드입니다. some은 하나라도 만족하면 true를, every는 모두 만족해야 true를 반환합니다.\n\n**some의 특징:**\n- 하나라도 조건을 만족하면 true를 반환합니다. OR 연산과 비슷합니다.\n- 조건을 만족하는 요소를 찾으면 즉시 중단합니다. 단축 평가를 수행합니다.\n- 모든 요소가 조건을 만족하지 않으면 false를 반환합니다.\n- 빈 배열에 대해서는 항상 false를 반환합니다.\n\n**every의 특징:**\n- 모든 요소가 조건을 만족해야 true를 반환합니다. AND 연산과 비슷합니다.\n- 조건을 만족하지 않는 요소를 찾으면 즉시 중단합니다. 단축 평가를 수행합니다.\n- 하나라도 조건을 만족하지 않으면 false를 반환합니다.\n- 빈 배열에 대해서는 항상 true를 반환합니다. 공허한 참입니다.\n\n**반환값:**\n- 둘 다 불리언 값을 반환합니다. true 또는 false입니다.\n- 배열을 반환하지 않습니다. 존재 여부만 확인합니다.\n- 조건을 만족하는 요소 자체가 필요하면 find나 filter를 사용해야 합니다.\n\n**단축 평가의 효율성:**\n- some: true를 반환할 요소를 찾으면 나머지는 검사하지 않습니다.\n- every: false를 반환할 요소를 찾으면 나머지는 검사하지 않습니다.\n- 큰 배열에서 효율적입니다. 불필요한 연산을 줄입니다.\n- 콜백 함수의 순서가 성능에 영향을 줄 수 있습니다.\n\n**사용 사례:**\n- some: 배열에 특정 값이 존재하는지 확인, 하나라도 유효한지 검사, 조건을 만족하는 항목이 있는지 확인\n- every: 모든 값이 유효한지 검증, 전체 조건 충족 여부 확인, 일관성 검사\n\n**includes와의 비교:**\n- includes는 값의 존재만 확인합니다. 단순 포함 여부입니다.\n- some은 조건을 검사합니다. 더 복잡한 로직을 적용할 수 있습니다.\n- includes는 간단하고 명확합니다. 단순 검사에 적합합니다.\n\n**실무 활용:**\n- 폼 유효성 검사에서 every로 모든 필드가 유효한지 확인합니다.\n- 권한 검사에서 some으로 필요한 권한 중 하나라도 있는지 확인합니다.\n- 데이터 검증에서 every로 모든 데이터가 형식에 맞는지 확인합니다.\n- 검색 기능에서 some으로 검색어와 일치하는 항목이 있는지 확인합니다.\n- filter 전에 some으로 미리 확인하여 불필요한 작업을 줄일 수 있습니다.\n- 조건부 렌더링에서 불리언 값이 필요할 때 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "array"
      ],
      "id": "1763441901792-qax8i81fm",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "forEach()와 map()의 차이점은 무엇인가요?",
      "answer": "**정의:**\nfind는 조건을 만족하는 첫 번째 요소를 반환하고, findIndex는 그 요소의 인덱스를 반환합니다. 둘 다 조건을 만족하는 요소를 찾으면 즉시 중단합니다.\n\n**find의 특징:**\n- 조건을 만족하는 첫 번째 요소를 반환합니다. 요소 자체를 돌려줍니다.\n- 찾지 못하면 undefined를 반환합니다.\n- 객체 배열에서 특정 객체를 찾을 때 유용합니다.\n- 단축 평가로 효율적입니다. 찾으면 즉시 종료합니다.\n\n**findIndex의 특징:**\n- 조건을 만족하는 첫 번째 요소의 인덱스를 반환합니다. 위치 정보를 제공합니다.\n- 찾지 못하면 음수 1을 반환합니다.\n- 배열에서 요소를 수정하거나 삭제할 때 유용합니다.\n- indexOf보다 복잡한 조건을 사용할 수 있습니다.\n\n**filter와의 차이:**\n- find: 첫 번째 요소만 반환합니다. 하나만 필요할 때 효율적입니다.\n- filter: 조건을 만족하는 모든 요소를 배열로 반환합니다.\n- find는 단일 값, filter는 배열입니다.\n- find는 찾으면 중단하지만 filter는 끝까지 검사합니다.\n\n**indexOf와의 차이:**\n- indexOf: 값의 동등성만 검사합니다. 간단한 값 찾기에 적합합니다.\n- findIndex: 콜백 함수로 복잡한 조건을 검사합니다. 객체 배열에 적합합니다.\n- indexOf는 원시 값 배열에, findIndex는 객체 배열에 주로 사용합니다.\n\n**findLast와 findLastIndex:**\n- 배열의 끝에서부터 검색합니다. 최근 제안된 메서드입니다.\n- 역순으로 찾을 때 reverse 없이 사용할 수 있습니다.\n- 브라우저 지원을 확인해야 합니다.\n\n**실무 활용:**\n- ID로 특정 아이템을 찾을 때 find를 사용합니다. 객체 배열에서 검색합니다.\n- 특정 조건의 아이템 위치를 찾아 삭제할 때 findIndex를 사용합니다.\n- 존재 여부만 확인하려면 some을 사용하는 것이 의도가 명확합니다.\n- React에서 state 배열의 특정 요소를 업데이트할 때 findIndex로 위치를 찾습니다.\n- 검색 기능 구현 시 find로 첫 번째 결과를 표시합니다.\n- 중복 검사에서 find로 이미 존재하는지 확인합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "array"
      ],
      "id": "1763441901792-zts272lko",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "some()과 every()의 차이점은 무엇인가요?",
      "answer": "**정의:**\nArray.from과 스프레드 연산자는 모두 이터러블 객체를 배열로 변환하는 방법입니다. 하지만 기능의 범위와 활용도에서 차이가 있습니다.\n\n**Array.from의 특징:**\n- 유사 배열 객체와 이터러블을 배열로 변환합니다. 더 넓은 범위를 지원합니다.\n- 두 번째 인수로 map 함수를 받을 수 있습니다. 변환과 매핑을 동시에 수행합니다.\n- 세 번째 인수로 this 값을 지정할 수 있습니다.\n- 배열의 길이를 지정하여 빈 배열을 만들 수도 있습니다.\n\n**스프레드 연산자의 특징:**\n- 이터러블 객체만 배열로 변환합니다. 유사 배열은 직접 변환할 수 없습니다.\n- 문법이 간결합니다. 더 직관적이고 읽기 쉽습니다.\n- 배열 리터럴 안에서 사용합니다.\n- 여러 배열을 합칠 때 편리합니다.\n\n**유사 배열 객체 처리:**\n- Array.from: 유사 배열을 바로 변환할 수 있습니다. length 속성만 있으면 됩니다.\n- 스프레드: 이터러블이 아닌 유사 배열은 변환할 수 없습니다. Symbol.iterator가 필요합니다.\n- NodeList나 arguments는 둘 다 가능합니다. 이터러블이기 때문입니다.\n\n**매핑 기능:**\n- Array.from은 변환하면서 동시에 매핑할 수 있습니다. 한 번의 순회로 처리됩니다.\n- 스프레드는 배열로 만든 후 map을 체이닝해야 합니다. 두 번 순회합니다.\n- 성능상 Array.from이 약간 유리할 수 있습니다.\n\n**빈 배열 생성:**\n- Array.from으로 특정 길이의 빈 배열을 만들 수 있습니다.\n- 각 요소를 초기화하면서 생성할 수 있습니다.\n- 스프레드로는 불가능합니다.\n\n**실무 활용:**\n- DOM NodeList를 배열로 변환하여 배열 메서드를 사용합니다.\n- 문자열을 문자 배열로 변환합니다. 둘 다 가능하지만 스프레드가 간결합니다.\n- Set이나 Map을 배열로 변환합니다.\n- 범위 배열을 생성할 때 Array.from을 활용합니다.\n- 간단한 변환은 스프레드를, 복잡한 변환은 Array.from을 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-yuwa4ngga",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "find()와 findIndex()는 언제 사용하나요?",
      "answer": "**정의:**\n불변성은 원본 데이터를 변경하지 않고 새로운 데이터를 생성하는 것입니다. React 등 현대 프레임워크에서 중요한 개념이며, 예측 가능한 상태 관리를 가능하게 합니다.\n\n**요소 추가 방법:**\n- 스프레드 연산자: 기존 배열을 펼치고 새 요소를 추가합니다. 앞이나 뒤, 중간 어디든 가능합니다.\n- concat: 배열을 합치는 메서드로 새 배열을 반환합니다. 원본을 변경하지 않습니다.\n- slice와 조합: 원하는 위치에 요소를 삽입할 수 있습니다.\n- push는 원본을 변경하므로 사용하면 안 됩니다.\n\n**요소 삭제 방법:**\n- filter: 특정 조건의 요소를 제외한 새 배열을 만듭니다. 가장 직관적입니다.\n- slice: 특정 인덱스의 요소를 제외하고 복사합니다. 인덱스를 알 때 사용합니다.\n- 스프레드와 slice 조합: 중간 요소를 제거할 때 사용합니다.\n- splice는 원본을 변경하므로 사용하면 안 됩니다.\n\n**요소 수정 방법:**\n- map: 특정 조건의 요소만 수정한 새 배열을 만듭니다.\n- 스프레드와 slice 조합: 특정 인덱스의 요소를 교체합니다.\n- Object.assign이나 스프레드로 객체 요소를 업데이트합니다.\n\n**왜 불변성이 중요한가:**\n- React에서 상태 변화를 감지합니다. 참조가 바뀌어야 리렌더링이 발생합니다.\n- 이전 상태를 보존할 수 있습니다. undo/redo 기능 구현이 쉽습니다.\n- 예측 가능한 코드가 됩니다. 부수 효과가 없어 디버깅이 쉽습니다.\n- 동시성 문제를 피할 수 있습니다. 공유 상태를 안전하게 관리합니다.\n\n**성능 고려사항:**\n- 작은 배열에서는 문제없습니다. 성능 차이가 미미합니다.\n- 큰 배열을 자주 업데이트하면 메모리와 성능에 영향을 줄 수 있습니다.\n- 이때는 Immer 같은 라이브러리를 고려합니다. 불변성을 유지하면서 효율적입니다.\n- 구조적 공유로 최적화할 수 있습니다.\n\n**실무 패턴:**\n- Redux나 Zustand에서 상태 업데이트 시 필수적입니다.\n- React의 useState로 배열 상태를 업데이트할 때 항상 새 배열을 만듭니다.\n- 중첩 배열이나 객체는 깊은 복사가 필요할 수 있습니다.\n- TypeScript의 readonly 타입으로 실수를 방지합니다.\n- ESLint 규칙으로 가변 메서드 사용을 경고할 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-9obpbp4td",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Array.from()과 스프레드 연산자의 차이점은 무엇인가요?",
      "answer": "**정의:**\n디바운싱과 스로틀링은 이벤트 핸들러의 실행 빈도를 제한하는 기법입니다. 성능 최적화와 불필요한 연산 방지에 사용됩니다.\n\n**디바운싱의 특징:**\n- 연속된 이벤트 중 마지막 이벤트만 처리합니다. 이벤트가 멈춘 후 실행됩니다.\n- 일정 시간 동안 추가 이벤트가 없어야 실행됩니다.\n- 타이머를 계속 초기화합니다. 이벤트가 발생할 때마다 지연 시간을 리셋합니다.\n- 검색 자동완성에 적합합니다. 입력이 끝난 후에만 검색합니다.\n\n**스로틀링의 특징:**\n- 일정 시간 간격으로 이벤트를 처리합니다. 주기적으로 실행됩니다.\n- 시간 간격 내에는 한 번만 실행됩니다.\n- 첫 번째 이벤트는 즉시 실행될 수 있습니다.\n- 스크롤 이벤트 처리에 적합합니다. 일정한 간격으로 체크합니다.\n\n**동작 방식 비교:**\n- 디바운싱: 입력이 끝날 때까지 기다립니다. 마지막 호출만 실행합니다.\n- 스로틀링: 일정 간격마다 실행합니다. 중간 호출들도 주기적으로 처리합니다.\n- 디바운싱은 이벤트가 멈춰야 하고, 스로틀링은 멈추지 않아도 됩니다.\n\n**디바운싱 구현:**\n- 타이머 변수를 클로저로 유지합니다.\n- 이벤트 발생 시 기존 타이머를 취소합니다.\n- 새로운 타이머를 설정합니다.\n- 지연 시간 후 함수를 실행합니다.\n\n**스로틀링 구현:**\n- 마지막 실행 시간을 기록합니다.\n- 현재 시간과 비교하여 간격을 확인합니다.\n- 간격이 충분하면 함수를 실행합니다.\n- 또는 타이머로 주기적으로 실행합니다.\n\n**사용 사례:**\n- 디바운싱: 검색 입력, 폼 유효성 검사, 윈도우 리사이즈, 자동 저장\n- 스로틀링: 무한 스크롤, 스크롤 이벤트, 마우스 이동 추적, 버튼 연타 방지\n\n**라이브러리 활용:**\n- Lodash의 debounce와 throttle 함수를 사용할 수 있습니다.\n- 옵션으로 leading, trailing 실행을 제어합니다.\n- 직접 구현보다 안정적이고 기능이 풍부합니다.\n\n**실무 활용:**\n- 검색창에서 디바운싱으로 API 호출을 줄입니다. 타이핑할 때마다 호출하지 않습니다.\n- 스크롤 이벤트에서 스로틀링으로 성능을 개선합니다.\n- 버튼 클릭에서 디바운싱으로 중복 제출을 방지합니다.\n- React에서 useCallback과 함께 사용하여 최적화합니다.\n- 적절한 지연 시간 설정이 중요합니다. 너무 짧으면 효과가 없고 너무 길면 사용자 경험이 나빠집니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "array"
      ],
      "id": "1763441901792-537xdanfs",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "배열의 불변성을 유지하면서 요소를 추가/삭제하는 방법은 무엇인가요?",
      "answer": "**정의:**\n메모이제이션은 함수의 결과를 캐싱하여 동일한 입력에 대해 재계산하지 않는 최적화 기법입니다. 비용이 큰 연산을 반복할 때 성능을 크게 향상시킵니다.\n\n**메모이제이션의 원리:**\n- 함수 호출 결과를 저장합니다. 키-값 쌍으로 캐시합니다.\n- 동일한 인수로 호출되면 캐시된 결과를 반환합니다. 재계산하지 않습니다.\n- 처음 호출될 때만 실제 계산을 수행합니다.\n- 클로저를 사용하여 캐시를 보관합니다.\n\n**메모이제이션이 유용한 경우:**\n- 계산 비용이 큰 순수 함수에 사용합니다. 항상 같은 입력에 같은 출력을 보장해야 합니다.\n- 같은 인수로 자주 호출되는 함수에 적합합니다.\n- 재귀 함수의 성능을 개선합니다. 피보나치 수열 같은 중복 계산을 제거합니다.\n- API 응답 캐싱에도 활용할 수 있습니다.\n\n**구현 방법:**\n- 객체나 Map으로 캐시를 만듭니다. 인수를 키로 결과를 저장합니다.\n- 함수 호출 시 캐시를 먼저 확인합니다.\n- 캐시에 있으면 바로 반환하고, 없으면 계산 후 저장합니다.\n- 고차 함수로 메모이제이션 래퍼를 만들 수 있습니다.\n\n**주의사항:**\n- 순수 함수에만 사용해야 합니다. 부수 효과가 있으면 안 됩니다.\n- 메모리를 사용합니다. 캐시가 무한정 커질 수 있습니다.\n- 복잡한 객체를 인수로 받으면 키 생성이 어렵습니다.\n- 캐시 무효화 전략이 필요할 수 있습니다. LRU 같은 정책을 고려합니다.\n\n**React에서의 메모이제이션:**\n- useMemo 훅으로 값을 메모이제이션합니다. 의존성이 변경될 때만 재계산합니다.\n- useCallback으로 함수를 메모이제이션합니다. 참조 동일성을 유지합니다.\n- React.memo로 컴포넌트를 메모이제이션합니다. props가 같으면 리렌더링하지 않습니다.\n\n**라이브러리 활용:**\n- Lodash의 memoize 함수를 사용할 수 있습니다.\n- Reselect는 Redux 셀렉터를 메모이제이션합니다.\n- React Query는 서버 데이터를 자동으로 캐싱합니다.\n\n**실무 활용:**\n- 복잡한 계산이 포함된 컴포넌트에서 useMemo를 사용합니다.\n- 자주 호출되는 유틸리티 함수를 메모이제이션합니다.\n- 동적 프로그래밍 알고리즘을 구현할 때 활용합니다.\n- 과도한 사용은 오히려 성능을 저하시킬 수 있습니다. 프로파일링 후 선택적으로 적용합니다.\n- 간단한 계산은 메모이제이션 오버헤드가 더 클 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "array"
      ],
      "id": "1763441901792-i5ww735zp",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "디바운싱(Debouncing)과 스로틀링(Throttling)의 차이점과 구현 방법은 무엇인가요?",
      "answer": "**정의:**\n얕은 복사는 객체의 최상위 레벨만 복사하여 내부 객체는 참조를 공유하는 방식입니다. 깊은 복사는 모든 중첩된 객체까지 재귀적으로 복사하여 완전히 독립적인 복사본을 만드는 방식입니다.\n\n**얕은 복사의 특징:**\n- 원시 값은 값이 복사됩니다. 독립적인 값이 생성됩니다.\n- 객체나 배열은 참조가 복사됩니다. 같은 메모리 주소를 가리킵니다.\n- 한 단계만 복사합니다. 중첩된 구조는 공유됩니다.\n- 내부 객체를 수정하면 원본도 영향을 받습니다.\n\n**얕은 복사 방법:**\n- 스프레드 연산자: 가장 간편하고 직관적입니다. 객체와 배열 모두 가능합니다.\n- Object.assign: 여러 객체를 병합하며 복사합니다.\n- Array.from이나 slice: 배열을 복사합니다.\n- 모두 한 단계만 복사합니다.\n\n**깊은 복사의 특징:**\n- 모든 레벨의 값을 복사합니다. 완전히 독립적인 객체가 생성됩니다.\n- 중첩된 객체도 새로운 메모리에 할당됩니다.\n- 원본과 복사본이 완전히 분리됩니다. 서로 영향을 주지 않습니다.\n- 구현이 복잡하고 성능 비용이 있습니다.\n\n**깊은 복사 방법:**\n- JSON 방식: JSON.stringify 후 JSON.parse합니다. 간단하지만 제한사항이 있습니다.\n- 재귀 함수: 모든 속성을 순회하며 복사합니다. 가장 완전하지만 구현이 복잡합니다.\n- structuredClone: 최신 API로 대부분의 타입을 지원합니다. 가장 권장되는 방법입니다.\n- Lodash cloneDeep: 라이브러리를 사용하여 안정적으로 복사합니다.\n\n**JSON 방식의 제한사항:**\n- 함수는 복사되지 않습니다. undefined가 됩니다.\n- undefined와 Symbol은 누락됩니다.\n- Date 객체는 문자열로 변환됩니다.\n- 순환 참조가 있으면 에러가 발생합니다.\n- 프로토타입 체인은 복사되지 않습니다.\n\n**structuredClone의 장점:**\n- 대부분의 타입을 지원합니다. Date, RegExp, Map, Set 등도 복사됩니다.\n- 순환 참조를 처리할 수 있습니다.\n- 네이티브 API로 빠릅니다.\n- 함수와 DOM 노드는 여전히 복사할 수 없습니다.\n\n**실무에서의 선택:**\n- 중첩이 없거나 얕은 복사로 충분하면 스프레드를 사용합니다.\n- 깊은 복사가 필요하면 structuredClone을 우선 고려합니다.\n- 특수한 타입이 있으면 라이브러리나 커스텀 구현을 사용합니다.\n- 성능이 중요하면 필요한 부분만 수동으로 복사합니다.\n- 불변성 라이브러리 사용을 고려합니다. Immer는 편리하고 효율적입니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-5ai4kstvz",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "메모이제이션(Memoization)이란 무엇이고 언제 사용하나요?",
      "answer": "**정의:**\nProxy는 객체의 기본 동작을 가로채고 재정의할 수 있는 메타프로그래밍 기능입니다. 객체 접근, 할당, 함수 호출 등을 커스터마이징할 수 있습니다.\n\n**Proxy의 구조:**\n- target: 원본 객체입니다. 프록시가 감싸는 대상입니다.\n- handler: 트랩 함수들을 정의한 객체입니다. 동작을 가로챕니다.\n- trap: handler의 메서드로 특정 동작을 가로챕니다.\n- Proxy 생성자로 프록시 객체를 만듭니다.\n\n**주요 트랩 종류:**\n- get: 속성 읽기를 가로챕니다. 접근 로깅이나 기본값 제공에 사용합니다.\n- set: 속성 쓰기를 가로챕니다. 유효성 검사나 변경 추적에 사용합니다.\n- has: in 연산자를 가로챕니다. 속성 존재 여부 확인을 커스터마이징합니다.\n- deleteProperty: delete 연산자를 가로챕니다.\n- apply: 함수 호출을 가로챕니다.\n- construct: new 연산자를 가로챕니다.\n\n**Proxy의 활용 사례:**\n- 유효성 검사: 속성 할당 시 값을 검증합니다. 잘못된 값을 차단합니다.\n- 로깅과 디버깅: 객체 접근을 추적합니다. 어떤 속성이 사용되는지 파악합니다.\n- 기본값 제공: 존재하지 않는 속성에 기본값을 반환합니다.\n- 읽기 전용 객체: set 트랩에서 에러를 발생시켜 불변 객체를 만듭니다.\n- 음수 인덱싱: 배열에서 음수 인덱스를 지원합니다.\n\n**반응형 시스템 구현:**\n- Vue 3의 반응성이 Proxy로 구현됩니다.\n- 속성 변경을 자동으로 감지합니다.\n- 의존성을 추적하여 자동 업데이트합니다.\n- Object.defineProperty보다 강력하고 완전합니다.\n\n**Reflect와의 조합:**\n- Reflect는 Proxy 트랩에 대응하는 메서드를 제공합니다.\n- 기본 동작을 수행하면서 커스텀 로직을 추가할 수 있습니다.\n- Reflect.get, Reflect.set 등을 사용합니다.\n- receiver 매개변수로 this 바인딩을 올바르게 처리합니다.\n\n**주의사항:**\n- 성능 오버헤드가 있습니다. 모든 객체에 사용하면 느려질 수 있습니다.\n- 프록시는 원본 객체와 다른 참조입니다. 동등성 비교 시 주의가 필요합니다.\n- 일부 내장 객체는 프록시로 완전히 감쌀 수 없습니다.\n- 디버깅이 복잡해질 수 있습니다.\n\n**실무 활용:**\n- 상태 관리 라이브러리에서 반응성을 구현합니다.\n- API 래퍼로 요청을 가로채고 수정합니다.\n- 폼 데이터의 실시간 유효성 검사를 구현합니다.\n- 객체 접근 로깅으로 사용 패턴을 분석합니다.\n- 지연 로딩을 구현합니다. 실제 접근 시점에 데이터를 로드합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-tthe3pq6s",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이점과 구현 방법은 무엇인가요?",
      "answer": "**정의:**\nReflect는 JavaScript 연산을 메서드로 제공하는 내장 객체입니다. Proxy 트랩과 일대일 대응하며, 객체 조작을 더 명시적이고 안전하게 만듭니다.\n\n**Reflect의 목적:**\n- 객체 연산을 함수화합니다. 연산자 대신 메서드로 제공합니다.\n- Proxy 트랩과 동일한 시그니처를 가집니다. 기본 동작을 쉽게 호출할 수 있습니다.\n- 더 명확한 반환값을 제공합니다. 성공 여부를 불리언으로 반환합니다.\n- 에러 처리가 일관적입니다.\n\n**Reflect의 주요 메서드:**\n- Reflect.get: 속성 값을 가져옵니다. 대괄호 접근과 같지만 receiver를 지정할 수 있습니다.\n- Reflect.set: 속성 값을 설정합니다. 성공 여부를 반환합니다.\n- Reflect.has: in 연산자와 같습니다.\n- Reflect.deleteProperty: delete 연산자와 같습니다. 성공 여부를 반환합니다.\n- Reflect.apply: 함수를 호출합니다. call이나 apply와 비슷하지만 더 명시적입니다.\n- Reflect.construct: new 연산자와 같습니다.\n\n**기존 방식과의 비교:**\n- delete obj.prop 대신 Reflect.deleteProperty를 사용합니다. 반환값이 명확합니다.\n- prop in obj 대신 Reflect.has를 사용할 수 있습니다.\n- 함수 호출도 Reflect.apply로 통일할 수 있습니다.\n- 일관된 인터페이스로 코드가 더 예측 가능해집니다.\n\n**Proxy와 함께 사용:**\n- Proxy 트랩에서 기본 동작을 수행하기 위해 Reflect를 사용합니다.\n- 커스텀 로직을 추가한 후 Reflect로 원래 동작을 실행합니다.\n- receiver 매개변수를 올바르게 전달할 수 있습니다.\n- 코드가 간결하고 명확해집니다.\n\n**receiver 매개변수:**\n- getter나 setter에서 this 값을 지정합니다.\n- 상속 관계에서 올바른 this 바인딩을 보장합니다.\n- Proxy를 통한 접근 시 원래의 this를 유지합니다.\n\n**성공 여부 반환:**\n- Object 메서드는 에러를 throw하거나 undefined를 반환합니다.\n- Reflect 메서드는 성공 시 true, 실패 시 false를 반환합니다.\n- try-catch 없이 성공 여부를 확인할 수 있습니다.\n- 더 함수형 프로그래밍에 가까운 스타일입니다.\n\n**실무 활용:**\n- Proxy 핸들러를 작성할 때 Reflect를 사용하여 기본 동작을 위임합니다.\n- 조건부 객체 조작 시 반환값으로 성공 여부를 확인합니다.\n- 메타프로그래밍에서 명시적인 객체 조작을 구현합니다.\n- 라이브러리나 프레임워크에서 안전한 객체 접근을 제공합니다.\n- 대부분의 경우 직접 사용하기보다 Proxy와 함께 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-qaptcrlru",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "불변성(Immutability)을 유지하는 것이 왜 중요한가요?",
      "answer": "**정의:**\nGenerator는 함수 실행을 중간에 멈추고 재개할 수 있는 특별한 함수입니다. function* 문법으로 선언하며 yield 키워드로 값을 반환하고 일시 정지합니다.\n\n**Generator의 특징:**\n- 함수 실행을 제어할 수 있습니다. 필요할 때만 다음 값을 계산합니다.\n- yield로 값을 반환하고 일시 정지합니다. 여러 번 값을 반환할 수 있습니다.\n- next 메서드로 실행을 재개합니다. 다음 yield까지 실행됩니다.\n- Iterator를 반환합니다. for-of 루프와 스프레드 연산자를 사용할 수 있습니다.\n\n**동작 원리:**\n- Generator 함수를 호출하면 Iterator 객체를 반환합니다. 즉시 실행되지 않습니다.\n- next를 호출하면 다음 yield까지 실행됩니다.\n- yield 표현식의 값이 value로 반환됩니다.\n- done 속성으로 완료 여부를 알 수 있습니다.\n- return 문을 만나거나 함수가 끝나면 done이 true가 됩니다.\n\n**양방향 통신:**\n- next에 인수를 전달하면 yield 표현식의 값이 됩니다.\n- Generator 내부로 값을 전달할 수 있습니다.\n- 호출자와 Generator 간 데이터를 주고받습니다.\n\n**에러 처리:**\n- throw 메서드로 Generator 내부에 에러를 던질 수 있습니다.\n- Generator 내부의 try-catch로 에러를 처리합니다.\n- 제어 흐름을 외부에서 조작할 수 있습니다.\n\n**지연 평가:**\n- 값을 필요할 때만 계산합니다. 무한 시퀀스를 표현할 수 있습니다.\n- 메모리 효율적입니다. 모든 값을 미리 생성하지 않습니다.\n- 큰 데이터셋을 다룰 때 유용합니다.\n\n**사용 사례:**\n- 무한 시퀀스 생성: ID 생성기, 피보나치 수열 등을 구현합니다.\n- 상태 머신: 복잡한 상태 전환 로직을 명확하게 표현합니다.\n- 비동기 흐름 제어: async/await 이전에 사용되었습니다. co 같은 라이브러리와 함께 사용합니다.\n- 데이터 스트리밍: 대용량 데이터를 청크 단위로 처리합니다.\n- 이터레이터 구현: 커스텀 이터레이션 로직을 간단히 작성합니다.\n\n**실무 활용:**\n- Redux Saga에서 사이드 이펙트를 관리합니다. Generator로 복잡한 비동기 흐름을 표현합니다.\n- 테스트 데이터 생성기를 만듭니다. 필요한 만큼만 데이터를 생성합니다.\n- 대용량 파일 처리 시 메모리를 절약합니다.\n- 복잡한 반복 로직을 명확하게 표현합니다.\n- 현대에는 async/await로 대체되는 경향이 있지만 특수한 경우에 여전히 유용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-kmr67vvr0",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Proxy 객체의 동작 원리와 활용 사례는 무엇인가요?",
      "answer": "**정의:**\nIterable은 순회 가능한 객체를 의미하며 Symbol.iterator 메서드를 가집니다. Iterator는 실제 순회를 수행하는 객체로 next 메서드를 가집니다.\n\n**Iterable의 특징:**\n- Symbol.iterator 메서드를 구현합니다. 이 메서드는 Iterator를 반환합니다.\n- for-of 루프에서 사용할 수 있습니다.\n- 스프레드 연산자와 구조 분해 할당이 가능합니다.\n- Array, String, Map, Set 등이 기본적으로 iterable입니다.\n\n**Iterator의 특징:**\n- next 메서드를 가집니다. 이 메서드는 value와 done을 가진 객체를 반환합니다.\n- value는 현재 값입니다.\n- done은 순회 완료 여부를 나타내는 불리언입니다.\n- 순회 상태를 내부적으로 관리합니다.\n\n**동작 방식:**\n- Iterable 객체의 Symbol.iterator를 호출하면 Iterator를 얻습니다.\n- Iterator의 next를 반복 호출하여 값을 가져옵니다.\n- done이 true가 될 때까지 반복합니다.\n- for-of는 이 과정을 자동화합니다.\n\n**커스텀 Iterable 구현:**\n- 객체에 Symbol.iterator 메서드를 추가합니다.\n- 이 메서드는 next 메서드를 가진 객체를 반환해야 합니다.\n- next는 value와 done을 반환해야 합니다.\n- 이를 통해 커스텀 순회 로직을 만들 수 있습니다.\n\n**Iterable 프로토콜의 이점:**\n- 통일된 인터페이스로 다양한 컬렉션을 다룰 수 있습니다.\n- for-of, 스프레드, 구조 분해 등 다양한 문법을 사용할 수 있습니다.\n- 지연 평가가 가능합니다. Generator와 결합하여 효율적입니다.\n- 무한 시퀀스도 표현할 수 있습니다.\n\n**Iterator와 Generator:**\n- Generator 함수는 자동으로 Iterator를 생성합니다.\n- yield로 간단히 Iterator를 구현할 수 있습니다.\n- 수동으로 next를 구현하는 것보다 편리합니다.\n\n**실무 활용:**\n- 커스텀 컬렉션 클래스를 만들 때 Iterable을 구현합니다.\n- 데이터 스트림을 표현할 때 활용합니다.\n- 페이지네이션 API 결과를 순회 가능하게 만듭니다.\n- 복잡한 데이터 구조를 for-of로 순회할 수 있게 합니다.\n- Generator로 간단히 Iterable을 만들어 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "object"
      ],
      "id": "1763441901792-jj3mtqwl5",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Reflect API는 무엇이고 왜 사용하나요?",
      "answer": "**정의:**\nWeakMap과 WeakSet은 약한 참조를 사용하는 특수한 컬렉션입니다. 키로 사용된 객체가 다른 곳에서 참조되지 않으면 자동으로 가비지 컬렉션됩니다.\n\n**WeakMap의 특징:**\n- 키는 반드시 객체여야 합니다. 원시 값은 사용할 수 없습니다.\n- 약한 참조를 사용합니다. 키 객체가 GC 대상이 되면 엔트리도 제거됩니다.\n- 열거할 수 없습니다. keys, values, entries 메서드가 없습니다.\n- 크기를 알 수 없습니다. size 프로퍼티가 없습니다.\n- get, set, has, delete 메서드만 제공합니다.\n\n**WeakSet의 특징:**\n- 값은 반드시 객체여야 합니다.\n- 약한 참조를 사용합니다.\n- 열거할 수 없습니다.\n- add, has, delete 메서드만 제공합니다.\n- 중복을 허용하지 않습니다.\n\n**약한 참조의 의미:**\n- 일반 참조는 객체가 GC되는 것을 방지합니다.\n- 약한 참조는 GC를 방해하지 않습니다.\n- 다른 참조가 없으면 객체가 메모리에서 제거됩니다.\n- WeakMap/WeakSet의 엔트리도 함께 사라집니다.\n\n**메모리 누수 방지:**\n- DOM 노드를 키로 사용할 때 유용합니다. 노드가 제거되면 자동으로 정리됩니다.\n- 이벤트 리스너나 데이터를 저장할 때 메모리 누수를 방지합니다.\n- 순환 참조 문제를 해결할 수 있습니다.\n\n**WeakMap 사용 사례:**\n- private 데이터 저장: 객체의 private 속성을 외부에 저장합니다.\n- 메타데이터 연결: 객체에 추가 정보를 붙입니다. 원본 객체를 변경하지 않습니다.\n- 캐싱: 객체를 키로 하는 캐시를 만듭니다. 객체가 제거되면 캐시도 자동 정리됩니다.\n- DOM 노드 데이터: 노드와 연관된 데이터를 저장합니다.\n\n**WeakSet 사용 사례:**\n- 객체 추적: 특정 객체들의 집합을 유지합니다.\n- 이미 처리한 객체 표시: 중복 처리를 방지합니다.\n- 메서드 호출 제한: 특정 객체에서만 메서드를 호출할 수 있게 합니다.\n\n**Map/Set과의 선택:**\n- 키나 값이 원시 값이면 Map/Set을 사용합니다.\n- 열거가 필요하면 Map/Set을 사용합니다.\n- 자동 정리가 필요하고 객체만 다루면 WeakMap/WeakSet을 사용합니다.\n- 메모리 관리가 중요하면 WeakMap/WeakSet을 고려합니다.\n\n**실무 활용:**\n- React에서 컴포넌트 인스턴스와 데이터를 연결할 때 사용합니다.\n- 캐시 시스템에서 메모리 누수를 방지합니다.\n- DOM 조작 라이브러리에서 요소와 데이터를 매핑합니다.\n- 객체 풀이나 플라이웨이트 패턴을 구현합니다.\n- 디버깅이 어려울 수 있으므로 신중하게 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-mwn5cb279",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Generator 함수의 동작 원리와 사용 사례는 무엇인가요?",
      "answer": "**정의:**\n원시 타입은 불변의 기본 데이터 타입으로 값 자체가 저장됩니다. 참조 타입은 객체로 메모리 주소가 저장되며 가변적입니다.\n\n**원시 타입의 특징:**\n- 값이 직접 저장됩니다. 변수에 실제 값이 담깁니다.\n- 불변입니다. 값 자체를 변경할 수 없습니다.\n- 스택 메모리에 저장됩니다. 접근이 빠릅니다.\n- 복사 시 값이 복사됩니다. 독립적인 값이 생성됩니다.\n- Number, String, Boolean, null, undefined, Symbol, BigInt가 있습니다.\n\n**참조 타입의 특징:**\n- 메모리 주소가 저장됩니다. 변수는 실제 데이터의 위치를 가리킵니다.\n- 가변입니다. 내부 속성을 변경할 수 있습니다.\n- 힙 메모리에 저장됩니다. 스택에는 참조만 저장됩니다.\n- 복사 시 참조가 복사됩니다. 같은 객체를 가리킵니다.\n- Object, Array, Function, Date, RegExp 등이 있습니다.\n\n**값 비교의 차이:**\n- 원시 타입: 값 자체를 비교합니다. 같은 값이면 true입니다.\n- 참조 타입: 참조를 비교합니다. 같은 객체를 가리켜야 true입니다.\n- 내용이 같아도 참조가 다르면 false입니다.\n\n**복사 동작의 차이:**\n- 원시 타입: 값이 복사되어 독립적입니다. 한쪽을 변경해도 다른 쪽에 영향이 없습니다.\n- 참조 타입: 참조가 복사되어 같은 객체를 가리킵니다. 한쪽에서 변경하면 다른 쪽도 변경됩니다.\n- 참조 타입의 독립적인 복사는 명시적으로 해야 합니다.\n\n**함수 인수 전달:**\n- 원시 타입: 값이 전달됩니다. 함수 내부에서 변경해도 원본에 영향이 없습니다.\n- 참조 타입: 참조가 전달됩니다. 함수 내부에서 변경하면 원본도 변경됩니다.\n- JavaScript는 항상 값으로 전달하지만 참조 타입은 참조 값이 전달됩니다.\n\n**메모리 관리:**\n- 원시 타입: 스택에서 자동 관리됩니다. 스코프를 벗어나면 즉시 제거됩니다.\n- 참조 타입: 힙에 저장되고 가비지 컬렉션으로 관리됩니다. 참조가 없어질 때 제거됩니다.\n- 참조 타입은 메모리 누수의 원인이 될 수 있습니다.\n\n**래퍼 객체:**\n- 원시 타입도 메서드를 호출할 수 있습니다. 임시로 래퍼 객체가 생성됩니다.\n- String, Number, Boolean 생성자가 래퍼 역할을 합니다.\n- 메서드 호출 후 래퍼 객체는 제거됩니다.\n- new로 생성하면 참조 타입 래퍼 객체가 됩니다.\n\n**실무에서의 이해:**\n- 상태 관리 시 원시 타입과 참조 타입을 구분해야 합니다.\n- React의 state 업데이트에서 중요합니다. 참조가 바뀌어야 리렌더링됩니다.\n- 깊은 비교와 얕은 비교의 차이를 이해해야 합니다.\n- 함수에 객체를 전달할 때 원본 변경 여부를 고려해야 합니다.\n- 성능 최적화 시 메모리 특성을 활용할 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "function"
      ],
      "id": "1763441901792-rzjxwa9gu",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "Iterator와 Iterable의 차이점은 무엇인가요?",
      "answer": "**정의:**\n타입 변환은 값을 다른 타입으로 바꾸는 과정입니다. 암묵적 변환은 JavaScript가 자동으로 수행하고, 명시적 변환은 개발자가 의도적으로 수행합니다.\n\n**암묵적 타입 변환:**\n- 자동으로 발생합니다. 연산자나 컨텍스트에 따라 변환됩니다.\n- 예측하기 어려울 수 있습니다. 의도하지 않은 결과를 낳을 수 있습니다.\n- 문자열 연결, 산술 연산, 불리언 컨텍스트 등에서 발생합니다.\n- 코드가 간결해지지만 명확성이 떨어집니다.\n\n**명시적 타입 변환:**\n- 개발자가 명시적으로 변환합니다. 의도가 명확합니다.\n- 변환 함수나 생성자를 사용합니다. Number, String, Boolean 등입니다.\n- 예측 가능하고 안전합니다.\n- 코드 가독성이 향상됩니다.\n\n**문자열 변환:**\n- 암묵적: 더하기 연산자로 자동 변환됩니다. 숫자와 문자열을 더하면 문자열이 됩니다.\n- 명시적: String 함수나 toString 메서드를 사용합니다.\n- 템플릿 리터럴도 명시적 변환입니다.\n\n**숫자 변환:**\n- 암묵적: 산술 연산자가 숫자로 변환합니다. 더하기 제외한 연산자는 숫자로 변환합니다.\n- 명시적: Number 함수나 parseInt, parseFloat을 사용합니다.\n- 단항 플러스 연산자도 숫자로 변환하지만 명시적이지 않아 권장되지 않습니다.\n\n**불리언 변환:**\n- 암묵적: 조건문이나 논리 연산자가 불리언으로 변환합니다.\n- 명시적: Boolean 함수나 이중 부정 연산자를 사용합니다.\n- Falsy 값은 false로, 나머지는 true로 변환됩니다.\n\n**Falsy 값:**\n- false, 0, 음수 0, 빈 문자열, null, undefined, NaN이 falsy입니다.\n- 이외의 모든 값은 truthy입니다.\n- 빈 객체와 빈 배열도 truthy입니다.\n\n**동등 연산자의 타입 변환:**\n- 이중 등호는 타입을 변환한 후 비교합니다. 예측하기 어렵습니다.\n- 삼중 등호는 타입 변환 없이 비교합니다. 항상 사용이 권장됩니다.\n- 이중 등호의 변환 규칙은 복잡하고 일관성이 없습니다.\n\n**parseInt와 Number의 차이:**\n- parseInt는 문자열을 파싱합니다. 숫자로 시작하면 그 부분까지만 변환합니다.\n- Number는 전체를 변환합니다. 일부만 숫자면 NaN을 반환합니다.\n- parseInt는 진법을 지정할 수 있습니다.\n\n**실무 권장사항:**\n- 항상 명시적 변환을 사용합니다. 의도를 명확히 합니다.\n- 암묵적 변환에 의존하지 않습니다. 예상치 못한 버그를 방지합니다.\n- 삼중 등호를 기본으로 사용합니다.\n- TypeScript로 타입 안전성을 강화할 수 있습니다.\n- ESLint 규칙으로 암묵적 변환을 경고할 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-orr0et9ls",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "WeakMap과 WeakSet은 언제 사용하나요?",
      "answer": "**정의:**\n이중 등호는 값의 동등성을 비교하며 타입 변환을 수행합니다. 삼중 등호는 엄격한 동등성을 비교하며 타입 변환 없이 타입과 값 모두를 검사합니다.\n\n**이중 등호의 동작:**\n- 타입이 다르면 타입 변환을 시도합니다. 암묵적 변환이 발생합니다.\n- 변환 규칙이 복잡하고 예측하기 어렵습니다.\n- 숫자와 문자열을 비교하면 문자열을 숫자로 변환합니다.\n- null과 undefined는 서로 같다고 판단합니다.\n\n**삼중 등호의 동작:**\n- 타입 변환을 하지 않습니다. 타입이 다르면 즉시 false를 반환합니다.\n- 타입과 값이 모두 같아야 true입니다.\n- 예측 가능하고 명확합니다.\n- 대부분의 상황에서 권장되는 비교 연산자입니다.\n\n**이중 등호의 변환 규칙:**\n- 숫자와 문자열: 문자열을 숫자로 변환합니다.\n- 불리언과 다른 타입: 불리언을 숫자로 먼저 변환합니다.\n- 객체와 원시 타입: 객체를 원시 값으로 변환합니다. valueOf나 toString을 호출합니다.\n- null과 undefined: 서로에 대해서만 true입니다. 다른 값과는 false입니다.\n\n**특이한 경우들:**\n- 빈 문자열과 0은 같습니다. 문자열이 숫자로 변환되기 때문입니다.\n- false와 0은 같습니다. 불리언이 숫자로 변환됩니다.\n- 빈 배열과 0도 같을 수 있습니다. 객체가 원시 값으로 변환됩니다.\n- NaN은 자기 자신과도 같지 않습니다. 유일한 예외입니다.\n\n**null과 undefined:**\n- 이중 등호로는 서로 같습니다. null과 undefined만 이런 관계입니다.\n- 삼중 등호로는 다릅니다. 타입이 다르기 때문입니다.\n- null이나 undefined 체크 시 이중 등호를 사용할 수 있습니다.\n- 하지만 명시적으로 비교하는 것이 더 명확합니다.\n\n**Object.is:**\n- ES6에서 추가된 비교 메서드입니다.\n- 삼중 등호와 거의 같지만 두 가지 차이가 있습니다.\n- 더하기 0과 빼기 0을 다르게 취급합니다.\n- NaN과 NaN을 같다고 판단합니다.\n- 더 정확하지만 특수한 경우에만 필요합니다.\n\n**실무 권장사항:**\n- 기본적으로 삼중 등호를 사용합니다. 일관되고 예측 가능합니다.\n- 이중 등호는 사용하지 않는 것이 좋습니다. 버그의 원인이 될 수 있습니다.\n- null이나 undefined 체크도 명시적으로 합니다.\n- ESLint의 eqeqeq 규칙으로 이중 등호 사용을 금지할 수 있습니다.\n- TypeScript를 사용하면 타입 체크로 많은 문제를 사전에 방지합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "array"
      ],
      "id": "1763441901792-f0hb2a5w5",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "원시 타입(Primitive Type)과 참조 타입(Reference Type)의 차이점은 무엇인가요?",
      "answer": "**정의:**\ntypeof는 값의 타입을 문자열로 반환하는 단항 연산자입니다. 대부분의 경우 예상대로 동작하지만 몇 가지 특이한 경우가 있습니다.\n\n**기본 동작:**\n- 원시 타입에 대해서는 정확히 동작합니다. number, string, boolean, undefined, symbol, bigint를 반환합니다.\n- 함수에 대해서는 function을 반환합니다. Function은 객체지만 구분됩니다.\n- 나머지 모든 객체는 object를 반환합니다.\n\n**null의 특이한 동작:**\n- typeof null은 object를 반환합니다. JavaScript의 오래된 버그입니다.\n- 초기 구현의 실수가 하위 호환성 때문에 유지되고 있습니다.\n- null을 체크하려면 명시적으로 비교해야 합니다.\n- 엄격한 동등 비교로 null인지 확인합니다.\n\n**배열과 객체:**\n- 배열도 object를 반환합니다. 배열을 구분할 수 없습니다.\n- Array.isArray로 배열을 확인해야 합니다.\n- 일반 객체와 배열을 구분하려면 별도 체크가 필요합니다.\n\n**선언되지 않은 변수:**\n- 선언되지 않은 변수에 typeof를 사용하면 undefined를 반환합니다.\n- 에러가 발생하지 않습니다. 유일하게 안전한 참조 방법입니다.\n- 전역 변수 존재 여부를 확인할 때 유용합니다.\n- window 객체 확인 등에 사용됩니다.\n\n**함수 구분:**\n- 일반 함수와 화살표 함수 모두 function을 반환합니다.\n- 클래스도 function을 반환합니다. 내부적으로 함수이기 때문입니다.\n- async 함수도 function을 반환합니다.\n- Generator 함수도 function을 반환합니다.\n\n**특수 객체들:**\n- Date, RegExp, Error 등 모두 object를 반환합니다.\n- Map, Set, WeakMap, WeakSet도 object입니다.\n- Promise도 object를 반환합니다.\n- 구체적인 타입을 확인하려면 instanceof나 constructor를 사용해야 합니다.\n\n**대안적인 타입 체크 방법:**\n- Array.isArray로 배열을 확인합니다.\n- instanceof로 생성자를 확인합니다. 프로토타입 체인을 검사합니다.\n- Object.prototype.toString.call로 정확한 타입을 얻을 수 있습니다.\n- constructor 프로퍼티를 확인할 수도 있습니다.\n\n**실무 활용:**\n- 원시 타입 체크에는 typeof를 사용합니다.\n- 객체의 구체적인 타입은 다른 방법을 사용합니다.\n- null 체크는 명시적 비교로 합니다.\n- TypeScript를 사용하면 컴파일 타임에 타입을 확인할 수 있습니다.\n- 타입 가드 함수를 만들어 재사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-qbq00m7kk",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "타입 변환(Type Coercion)과 명시적 변환의 차이점은 무엇인가요?",
      "answer": "**정의:**\ninstanceof는 객체의 프로토타입 체인에 생성자의 prototype이 존재하는지 확인하는 연산자입니다. 객체가 특정 클래스의 인스턴스인지 판별합니다.\n\n**동작 원리:**\n- 왼쪽 피연산자의 프로토타입 체인을 검색합니다.\n- 오른쪽 피연산자의 prototype과 일치하는지 확인합니다.\n- 체인을 따라 올라가며 검사합니다.\n- 일치하면 true, Object.prototype까지 가도 없으면 false를 반환합니다.\n\n**상속과의 관계:**\n- 부모 클래스에 대해서도 true를 반환합니다.\n- 프로토타입 체인의 어디든 있으면 true입니다.\n- 직접적인 인스턴스뿐 아니라 자손도 포함합니다.\n\n**원시 타입의 제한:**\n- 원시 타입은 객체가 아니므로 instanceof를 사용할 수 없습니다.\n- 문자열, 숫자, 불리언 리터럴은 false를 반환합니다.\n- 래퍼 객체로 생성된 경우에만 true입니다.\n- new String, new Number 등으로 만든 객체만 해당됩니다.\n\n**프로토타입 변경의 문제:**\n- 생성자의 prototype을 변경하면 결과가 달라질 수 있습니다.\n- 이미 생성된 인스턴스도 영향을 받습니다.\n- 동적으로 프로토타입을 조작하면 신뢰할 수 없습니다.\n\n**다른 컨텍스트의 문제:**\n- iframe이나 여러 window 객체가 있을 때 문제가 됩니다.\n- 각 컨텍스트마다 별도의 Array, Object 생성자를 가집니다.\n- 다른 컨텍스트의 배열은 instanceof Array가 false일 수 있습니다.\n- Array.isArray는 이 문제를 해결합니다.\n\n**Symbol.hasInstance:**\n- instanceof의 동작을 커스터마이징할 수 있습니다.\n- 클래스에 정적 메서드로 정의합니다.\n- 커스텀 타입 체크 로직을 구현할 수 있습니다.\n\n**대안적인 타입 체크:**\n- Array.isArray로 배열을 체크합니다. 더 안전합니다.\n- Object.prototype.toString.call로 정확한 타입을 얻습니다.\n- constructor 프로퍼티를 확인할 수 있습니다. 하지만 변경될 수 있어 주의가 필요합니다.\n- duck typing으로 필요한 속성이나 메서드의 존재를 확인합니다.\n\n**실무 활용:**\n- 클래스 인스턴스 확인에 사용합니다.\n- 에러 처리에서 에러 타입을 구분합니다.\n- 타입 가드 함수를 만들 때 활용합니다.\n- 다형성을 구현할 때 타입 확인에 사용합니다.\n- TypeScript에서는 타입 가드와 함께 사용하여 타입을 좁힙니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-a1mm0rw5l",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "==와 ===의 차이점은 무엇인가요?",
      "answer": "**정의:**\n이벤트 버블링은 이벤트가 발생한 요소에서 상위 요소로 전파되는 현상입니다. 이벤트 캡처링은 반대로 최상위 요소에서 이벤트 타겟으로 전파됩니다.\n\n**이벤트 전파의 3단계:**\n- 캡처링 단계: 최상위에서 타겟으로 내려갑니다. window에서 시작해 이벤트 타겟까지 진행합니다.\n- 타겟 단계: 실제 이벤트가 발생한 요소에 도달합니다.\n- 버블링 단계: 타겟에서 최상위로 올라갑니다. 부모 요소들에게 차례로 전파됩니다.\n\n**버블링의 특징:**\n- 기본 동작입니다. addEventListener의 기본값입니다.\n- 자식에서 부모로 전파됩니다.\n- 대부분의 이벤트가 버블링됩니다.\n- focus, blur, load 등 일부 이벤트는 버블링되지 않습니다.\n\n**캡처링의 특징:**\n- 명시적으로 활성화해야 합니다. addEventListener의 세 번째 인수를 true로 설정합니다.\n- 부모에서 자식으로 전파됩니다.\n- 버블링보다 먼저 발생합니다.\n- 특수한 경우에만 사용됩니다.\n\n**이벤트 객체 속성:**\n- target: 실제 이벤트가 발생한 요소입니다. 변하지 않습니다.\n- currentTarget: 현재 이벤트 핸들러가 등록된 요소입니다. 전파되면서 변경됩니다.\n- eventPhase: 현재 전파 단계를 나타냅니다. 1은 캡처링, 2는 타겟, 3은 버블링입니다.\n\n**전파 제어:**\n- stopPropagation: 이벤트 전파를 중단합니다. 상위나 하위 요소로 전파되지 않습니다.\n- stopImmediatePropagation: 같은 요소의 다른 핸들러도 실행하지 않습니다.\n- 기본 동작과는 무관합니다. 전파만 제어합니다.\n\n**기본 동작 제어:**\n- preventDefault: 브라우저의 기본 동작을 취소합니다.\n- 링크 클릭, 폼 제출 등을 막습니다.\n- 이벤트 전파와는 독립적입니다.\n- return false는 jQuery에서 두 가지를 모두 수행합니다.\n\n**이벤트 위임과의 관계:**\n- 버블링을 활용하여 이벤트 위임을 구현합니다.\n- 부모 요소에 핸들러를 등록하여 자식 이벤트를 처리합니다.\n- target으로 실제 클릭된 요소를 확인합니다.\n- 동적으로 추가되는 요소도 처리할 수 있습니다.\n\n**실무 활용:**\n- 대부분 버블링 단계에서 이벤트를 처리합니다.\n- 이벤트 위임으로 많은 요소의 이벤트를 효율적으로 관리합니다.\n- 모달이나 드롭다운 닫기에 활용합니다. 외부 클릭을 감지합니다.\n- 캡처링은 이벤트를 가로채야 할 때 사용합니다. 버블링 전에 처리합니다.\n- React의 합성 이벤트는 버블링을 사용하지만 내부적으로 다르게 구현됩니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-fcqfu8fbe",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "typeof 연산자의 특이한 동작들은 무엇인가요?",
      "answer": "**정의:**\n이벤트 위임은 여러 자식 요소의 이벤트를 부모 요소에서 한 번에 처리하는 패턴입니다. 이벤트 버블링을 활용하여 효율적인 이벤트 관리를 가능하게 합니다.\n\n**동작 원리:**\n- 부모 요소에 이벤트 리스너를 등록합니다. 자식마다 등록하지 않습니다.\n- 자식 요소에서 이벤트가 발생하면 버블링됩니다.\n- 부모의 핸들러에서 event.target으로 실제 타겟을 확인합니다.\n- 조건에 따라 적절히 처리합니다.\n\n**이벤트 위임의 장점:**\n- 메모리 사용량이 줄어듭니다. 리스너 하나만 필요합니다.\n- 동적으로 추가되는 요소도 자동으로 처리됩니다. 새로 등록할 필요가 없습니다.\n- 코드가 간결해집니다. 반복적인 리스너 등록을 피합니다.\n- 제거 시 관리가 쉽습니다. 한 곳에서만 제거하면 됩니다.\n\n**구현 방법:**\n- 부모 요소를 선택합니다. 공통 조상을 찾습니다.\n- 이벤트 리스너를 부모에 등록합니다.\n- event.target으로 실제 클릭된 요소를 확인합니다.\n- 조건문으로 원하는 요소인지 검사합니다. 클래스나 태그를 확인합니다.\n- 적절한 처리를 수행합니다.\n\n**target과 currentTarget 구분:**\n- target은 실제 이벤트가 발생한 요소입니다. 클릭된 정확한 요소입니다.\n- currentTarget은 리스너가 등록된 요소입니다. 항상 부모 요소입니다.\n- 위임에서는 target을 사용하여 자식을 식별합니다.\n\n**closest 메서드 활용:**\n- 이벤트 타겟에서 가장 가까운 조건 요소를 찾습니다.\n- 정확한 요소를 클릭하지 않아도 처리할 수 있습니다.\n- 중첩된 구조에서 유용합니다.\n- 버튼 내부의 아이콘을 클릭해도 버튼을 찾을 수 있습니다.\n\n**matches 메서드:**\n- 요소가 특정 선택자와 일치하는지 확인합니다.\n- 조건부 처리를 간결하게 만듭니다.\n- 복잡한 선택자도 사용할 수 있습니다.\n\n**주의사항:**\n- 모든 이벤트가 버블링되지는 않습니다. focus, blur 등은 위임이 어렵습니다.\n- 너무 깊은 중첩은 성능에 영향을 줄 수 있습니다.\n- stopPropagation을 사용한 요소는 위임에서 처리되지 않습니다.\n- 너무 상위에 등록하면 불필요한 이벤트도 처리하게 됩니다.\n\n**실무 활용:**\n- 목록 아이템의 클릭 이벤트를 처리합니다. 수백 개의 아이템도 효율적으로 관리합니다.\n- 동적으로 생성되는 요소를 다룹니다. Ajax로 추가된 요소도 자동 처리됩니다.\n- 테이블의 행 클릭, 삭제 버튼 등을 구현합니다.\n- 싱글 페이지 애플리케이션에서 라우팅 링크를 처리합니다.\n- React나 Vue 같은 프레임워크도 내부적으로 이벤트 위임을 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-evxk3gfr8",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "instanceof의 동작 원리와 제한사항은 무엇인가요?",
      "answer": "**정의:**\npreventDefault는 브라우저의 기본 동작을 취소하고, stopPropagation은 이벤트 전파를 중단합니다. 목적과 영향 범위가 완전히 다릅니다.\n\n**preventDefault의 동작:**\n- 브라우저의 기본 동작을 막습니다. 링크 이동, 폼 제출 등을 차단합니다.\n- 이벤트 전파에는 영향을 주지 않습니다. 버블링은 계속됩니다.\n- 취소 가능한 이벤트에만 효과가 있습니다.\n- event.defaultPrevented로 취소 여부를 확인할 수 있습니다.\n\n**기본 동작의 예:**\n- 링크 클릭 시 페이지 이동합니다.\n- 폼 제출 시 페이지가 새로고침됩니다.\n- 마우스 우클릭 시 컨텍스트 메뉴가 나타납니다.\n- 텍스트 드래그 시 선택됩니다.\n- Enter 키 시 폼이 제출됩니다.\n\n**preventDefault 사용 사례:**\n- 싱글 페이지 애플리케이션에서 링크를 JavaScript로 처리합니다.\n- Ajax로 폼을 제출합니다. 페이지 새로고침을 막습니다.\n- 커스텀 컨텍스트 메뉴를 구현합니다.\n- 드래그 앤 드롭을 커스터마이징합니다.\n- 키보드 입력을 제한합니다.\n\n**stopPropagation의 동작:**\n- 이벤트 전파를 중단합니다. 부모나 자식으로 전파되지 않습니다.\n- 기본 동작에는 영향을 주지 않습니다. 브라우저 동작은 계속됩니다.\n- 같은 요소의 다른 핸들러는 실행됩니다.\n- 버블링과 캡처링 모두 중단할 수 있습니다.\n\n**stopImmediatePropagation:**\n- stopPropagation보다 강력합니다.\n- 같은 요소의 다른 핸들러도 실행하지 않습니다.\n- 이벤트를 완전히 차단합니다.\n- 핸들러 등록 순서에 따라 일부만 실행될 수 있습니다.\n\n**stopPropagation 사용 사례:**\n- 부모의 클릭 핸들러를 실행하지 않아야 할 때 사용합니다.\n- 중첩된 요소에서 각각 다른 동작을 해야 할 때 유용합니다.\n- 모달 내부 클릭 시 모달이 닫히지 않도록 합니다.\n- 드롭다운 메뉴 내부 클릭을 분리합니다.\n\n**함께 사용:**\n- 두 메서드는 독립적입니다. 동시에 사용할 수 있습니다.\n- 링크의 기본 동작을 막으면서 버블링도 차단할 수 있습니다.\n- 필요에 따라 하나만 사용하거나 둘 다 사용합니다.\n\n**return false의 의미:**\n- jQuery에서는 두 메서드를 모두 호출합니다.\n- 순수 JavaScript에서는 기본 동작만 막습니다. 비표준 동작입니다.\n- 명시적으로 메서드를 호출하는 것이 권장됩니다.\n- 혼란을 피하기 위해 사용을 자제합니다.\n\n**실무 권장사항:**\n- 의도를 명확히 합니다. 무엇을 막으려는지 생각합니다.\n- 기본 동작을 막으려면 preventDefault를 사용합니다.\n- 이벤트 전파를 막으려면 stopPropagation을 사용합니다.\n- stopPropagation은 신중하게 사용합니다. 예상치 못한 부작용이 있을 수 있습니다.\n- 이벤트 위임을 사용할 때는 전파를 막지 않도록 주의합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901792-v0s0621xe",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "이벤트 버블링(Event Bubbling)과 이벤트 캡처링(Event Capturing)의 차이점은 무엇인가요?",
      "answer": "**정의:**\nDOM 조작은 브라우저 렌더링 엔진의 재계산을 유발하여 성능 저하를 일으킵니다. 최소화하면 애플리케이션의 반응성과 성능이 크게 향상됩니다.\n\n**DOM 조작의 비용:**\n- 리플로우가 발생합니다. 레이아웃을 다시 계산합니다. 위치와 크기를 재계산하는 비용이 큽니다.\n- 리페인트가 발생합니다. 화면을 다시 그립니다. 색상 변경 등에서 발생합니다.\n- JavaScript 엔진과 렌더링 엔진 간 통신이 필요합니다. 컨텍스트 전환 비용이 있습니다.\n- 동기적으로 처리됩니다. 다른 작업을 블로킹합니다.\n\n**리플로우를 유발하는 작업:**\n- 요소의 추가, 제거, 크기 변경을 할 때 발생합니다.\n- 클래스 추가나 스타일 변경 시 발생할 수 있습니다.\n- 레이아웃 정보를 읽을 때도 발생합니다. offsetWidth, clientHeight 등을 읽으면 최신 값을 계산합니다.\n- 폰트 변경, 윈도우 리사이즈 시 발생합니다.\n\n**성능 저하 사례:**\n- 반복문에서 DOM을 여러 번 조작하면 매번 리플로우가 발생합니다.\n- 레이아웃 정보를 읽고 쓰기를 반복하면 강제 동기 레이아웃이 발생합니다.\n- 애니메이션에서 레이아웃 속성을 변경하면 성능이 크게 저하됩니다.\n\n**최적화 방법:**\n- 배치 처리: 여러 변경을 한 번에 적용합니다. DocumentFragment를 사용합니다.\n- 클래스 사용: 여러 스타일을 한 번에 변경합니다. 클래스 추가로 통합합니다.\n- 오프라인 DOM: 요소를 DOM에서 분리하여 작업한 후 다시 붙입니다.\n- 레이아웃 스래싱 방지: 읽기와 쓰기를 분리합니다. 읽기를 먼저 모두 수행합니다.\n\n**DocumentFragment 활용:**\n- 여러 요소를 메모리에서 조립합니다.\n- DOM에 한 번만 추가합니다. 리플로우를 최소화합니다.\n- 대량의 요소를 추가할 때 효과적입니다.\n- 임시 컨테이너 역할을 합니다.\n\n**가상 DOM의 개념:**\n- React 등에서 사용하는 최적화 기법입니다.\n- JavaScript 객체로 DOM을 표현합니다.\n- 변경사항을 가상 DOM에서 계산합니다.\n- 최소한의 실제 DOM 조작만 수행합니다.\n- 배치 업데이트로 성능을 개선합니다.\n\n**CSS 활용:**\n- transform과 opacity는 리플로우를 유발하지 않습니다. GPU 가속을 활용합니다.\n- position: absolute나 fixed는 다른 요소에 영향을 주지 않습니다.\n- will-change 속성으로 브라우저에 최적화 힌트를 줍니다.\n- CSS 애니메이션이 JavaScript보다 성능이 좋을 수 있습니다.\n\n**실무 권장사항:**\n- 불필요한 DOM 조작을 피합니다. 상태 변경을 먼저 고려합니다.\n- 반복문에서 DOM 조작을 최소화합니다. 템플릿을 만들어 한 번에 추가합니다.\n- 성능 프로파일링으로 병목을 찾습니다. 크롬 개발자 도구의 Performance 탭을 활용합니다.\n- 프레임워크를 활용하여 최적화를 자동화합니다.\n- requestAnimationFrame으로 애니메이션을 최적화합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "event"
      ],
      "id": "1763441901792-wdw4ygp6q",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "이벤트 위임(Event Delegation)이란 무엇이고 왜 사용하나요?",
      "answer": "**정의:**\nDocumentFragment는 경량 문서 객체로, DOM 트리에 추가되지 않은 채 여러 요소를 담을 수 있는 컨테이너입니다. 성능 최적화를 위해 배치 DOM 조작에 사용됩니다.\n\n**DocumentFragment의 특징:**\n- 부모 노드가 없는 최소한의 문서 객체입니다.\n- 자식 요소를 가질 수 있습니다. 일반 요소처럼 appendChild 등을 사용합니다.\n- DOM 트리에 삽입 시 자신은 사라지고 자식만 추가됩니다.\n- 리플로우를 한 번만 발생시킵니다.\n- 메모리 효율적입니다.\n\n**생성 방법:**\n- document.createDocumentFragment로 생성합니다.\n- 빈 fragment 객체가 반환됩니다.\n- 일반 DOM 메서드로 요소를 추가할 수 있습니다.\n\n**사용 시나리오:**\n- 여러 요소를 한 번에 추가할 때 사용합니다. 반복문에서 요소를 생성하는 경우입니다.\n- 복잡한 구조를 조립한 후 추가합니다. 테이블이나 리스트를 만들 때 유용합니다.\n- 성능이 중요한 대량 DOM 조작에 적합합니다.\n\n**성능 이점:**\n- 리플로우가 한 번만 발생합니다. 각 요소를 따로 추가하면 여러 번 발생합니다.\n- 레이아웃 계산이 최소화됩니다.\n- 특히 많은 요소를 추가할 때 효과가 큽니다.\n- 수백 개 이상의 요소에서 체감 가능합니다.\n\n**일반적인 패턴:**\n- fragment를 생성합니다.\n- 반복문에서 요소를 만들어 fragment에 추가합니다.\n- 완성된 fragment를 실제 DOM에 한 번에 추가합니다.\n- 간단하고 효과적인 최적화입니다.\n\n**innerHTML과의 비교:**\n- innerHTML은 문자열로 처리합니다. 간단하지만 보안 위험이 있습니다.\n- DocumentFragment는 DOM 메서드를 사용합니다. 더 안전합니다.\n- innerHTML은 파싱 비용이 있습니다.\n- DocumentFragment는 타입 안전합니다.\n\n**template 요소와의 관계:**\n- template 요소의 content가 DocumentFragment입니다.\n- 템플릿을 복제하여 fragment를 얻습니다.\n- HTML에서 템플릿을 정의하고 JavaScript에서 복제합니다.\n- 재사용 가능한 구조를 만들 때 유용합니다.\n\n**현대적인 대안:**\n- 프레임워크의 가상 DOM이 비슷한 역할을 합니다.\n- 하지만 바닐라 JavaScript에서는 여전히 유용합니다.\n- insertAdjacentHTML도 대안이 될 수 있습니다.\n- 상황에 따라 적절한 방법을 선택합니다.\n\n**주의사항:**\n- fragment 자체는 DOM에 남지 않습니다. 자식만 추가됩니다.\n- 이벤트 리스너는 fragment가 아닌 자식에 추가해야 합니다.\n- fragment를 재사용할 수 없습니다. 한 번 추가되면 비워집니다.\n\n**실무 활용:**\n- 리스트 렌더링 시 대량의 아이템을 효율적으로 추가합니다.\n- 테이블 행을 동적으로 생성할 때 사용합니다.\n- Ajax 응답 데이터를 DOM에 반영할 때 활용합니다.\n- 성능이 중요한 대시보드나 데이터 시각화에 적합합니다.\n- 간단한 최적화로 큰 효과를 볼 수 있습니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "event"
      ],
      "id": "1763441901792-ktvbhkafl",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "preventDefault()와 stopPropagation()의 차이점은 무엇인가요?",
      "answer": "**정의:**\ntry-catch-finally는 JavaScript에서 런타임 에러를 처리하는 구문입니다. try 블록에서 발생한 에러를 catch로 잡아 처리하고, finally는 결과와 관계없이 항상 실행됩니다.\n\n**try-catch의 기본 동작:**\n- try 블록에서 코드를 실행합니다. 에러가 발생할 수 있는 코드를 감쌉니다.\n- 에러가 발생하면 즉시 catch 블록으로 이동합니다. 나머지 try 코드는 실행되지 않습니다.\n- catch는 에러 객체를 매개변수로 받습니다. 에러 정보를 담고 있습니다.\n- 에러가 없으면 catch는 건너뜁니다.\n\n**finally 블록:**\n- 에러 발생 여부와 무관하게 항상 실행됩니다.\n- 리소스 정리에 사용합니다. 파일 닫기, 연결 해제 등입니다.\n- return문이 있어도 finally가 먼저 실행됩니다.\n- try나 catch에서 return해도 finally는 실행됩니다.\n\n**에러 객체:**\n- Error 객체는 name과 message 속성을 가집니다.\n- stack 속성으로 호출 스택을 확인할 수 있습니다.\n- 다양한 에러 타입이 있습니다. SyntaxError, TypeError, ReferenceError 등입니다.\n- 커스텀 에러를 만들 수도 있습니다. Error를 상속합니다.\n\n**에러 던지기:**\n- throw 문으로 에러를 발생시킵니다. 어떤 값이든 던질 수 있습니다.\n- Error 객체를 던지는 것이 권장됩니다. 스택 트레이스를 포함합니다.\n- 조건부로 에러를 발생시켜 예외 상황을 알립니다.\n- 함수 내에서 throw하면 호출자에게 전파됩니다.\n\n**에러 전파:**\n- catch하지 않은 에러는 호출 스택을 따라 올라갑니다.\n- 최상위까지 처리되지 않으면 프로그램이 종료됩니다.\n- 중간에 catch하면 그곳에서 처리됩니다.\n- catch 후 다시 throw하여 전파를 계속할 수 있습니다.\n\n**에러 타입별 처리:**\n- catch에서 에러 타입을 확인할 수 있습니다. instanceof로 타입을 검사합니다.\n- 타입에 따라 다른 처리를 수행합니다.\n- 처리할 수 없는 에러는 다시 throw합니다.\n- 세밀한 에러 처리가 가능합니다.\n\n**비동기 코드의 에러 처리:**\n- setTimeout이나 콜백의 에러는 try-catch로 잡을 수 없습니다. 다른 실행 컨텍스트에서 발생하기 때문입니다.\n- Promise는 catch 메서드로 처리합니다.\n- async/await는 try-catch를 사용할 수 있습니다. 동기 코드처럼 처리됩니다.\n- 에러 처리 방식이 통일되어 편리합니다.\n\n**전역 에러 핸들러:**\n- window.onerror로 처리되지 않은 에러를 잡습니다.\n- Promise의 unhandled rejection도 감지할 수 있습니다.\n- 로깅이나 모니터링에 활용합니다.\n- 사용자에게 친화적인 에러 메시지를 표시합니다.\n\n**실무 권장사항:**\n- 예상 가능한 에러는 미리 검증합니다. try-catch는 예외적인 상황에 사용합니다.\n- 에러 메시지는 명확하고 구체적으로 작성합니다.\n- 민감한 정보를 에러 메시지에 포함하지 않습니다.\n- 에러를 적절히 로깅합니다. 디버깅에 도움이 됩니다.\n- 사용자에게는 이해하기 쉬운 메시지를 보여줍니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "event"
      ],
      "id": "1763441901792-yh102wos0",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "DOM 조작을 최소화해야 하는 이유는 무엇인가요?",
      "answer": "**정의:**\nSymbol은 ES6에서 추가된 원시 타입으로, 고유하고 변경 불가능한 값을 생성합니다. 주로 객체의 유일한 프로퍼티 키를 만들거나 메타프로그래밍에 사용됩니다.\n\n**Symbol의 특징:**\n- 항상 고유한 값입니다. 같은 설명으로 만들어도 다른 Symbol입니다.\n- 불변입니다. 생성 후 변경할 수 없습니다.\n- new 연산자를 사용할 수 없습니다. 원시 타입이기 때문입니다.\n- 설명 문자열을 선택적으로 제공할 수 있습니다. 디버깅에 도움이 됩니다.\n\n**고유 프로퍼티 키:**\n- 객체의 프로퍼티 키로 사용할 수 있습니다.\n- 다른 코드와 충돌하지 않습니다. 완전히 고유합니다.\n- 숨겨진 프로퍼티처럼 동작합니다. 일반적인 순회에 나타나지 않습니다.\n- private 프로퍼티를 흉내낼 수 있습니다.\n\n**Well-known Symbols:**\n- JavaScript 내장 Symbol들입니다. 언어 동작을 커스터마이징합니다.\n- Symbol.iterator는 이터러블 구현에 사용됩니다.\n- Symbol.toStringTag는 Object.prototype.toString 결과를 변경합니다.\n- Symbol.hasInstance는 instanceof 동작을 재정의합니다.\n- Symbol.toPrimitive는 타입 변환을 제어합니다.\n\n**전역 Symbol 레지스트리:**\n- Symbol.for로 전역 Symbol을 생성하거나 가져옵니다.\n- 같은 키로 호출하면 같은 Symbol을 반환합니다.\n- Symbol.keyFor로 전역 Symbol의 키를 얻습니다.\n- 코드 간에 Symbol을 공유할 때 사용합니다.\n\n**Symbol과 프로퍼티 열거:**\n- for-in 루프에 나타나지 않습니다.\n- Object.keys에도 포함되지 않습니다.\n- Object.getOwnPropertySymbols로만 가져올 수 있습니다.\n- Reflect.ownKeys는 Symbol도 포함합니다.\n\n**사용 사례:**\n- 프라이빗 프로퍼티 흉내: 외부에서 쉽게 접근할 수 없습니다. 완벽하지는 않지만 효과적입니다.\n- 메타데이터 저장: 객체에 추가 정보를 붙입니다. 원본 구조를 해치지 않습니다.\n- 프로토콜 구현: 이터레이터, 비동기 이터레이터 등을 만듭니다.\n- 열거형 값: 고유한 상수가 필요할 때 사용합니다.\n\n**Symbol vs String 키:**\n- String 키는 충돌 가능성이 있습니다. 같은 이름을 사용하면 덮어씁니다.\n- Symbol은 절대 충돌하지 않습니다.\n- String 키는 열거됩니다. 일반적인 순회에 포함됩니다.\n- Symbol 키는 숨겨집니다. 의도적으로 찾지 않으면 보이지 않습니다.\n\n**JSON 직렬화:**\n- Symbol 키는 JSON.stringify에서 무시됩니다.\n- 직렬화가 필요하면 String 키를 사용해야 합니다.\n- 전송이 필요 없는 내부 데이터에만 Symbol을 사용합니다.\n\n**실무 활용:**\n- 라이브러리에서 내부 프로퍼티를 안전하게 저장합니다.\n- 프레임워크의 메타데이터 시스템에 활용됩니다.\n- 이터러블 프로토콜을 구현합니다.\n- 상수를 정의할 때 고유성을 보장합니다.\n- React 등에서 내부적으로 Symbol을 사용합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS",
        "DOM"
      ],
      "id": "1763441901793-ixk16nema",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "DocumentFragment는 언제 사용하나요?",
      "answer": "**정의:**\nTemplate Literal은 백틱으로 감싸는 문자열 리터럴로, 문자열 보간과 여러 줄 문자열을 쉽게 만들 수 있습니다. 표현식 삽입과 태그 함수로 강력한 기능을 제공합니다.\n\n**기본 기능:**\n- 백틱으로 문자열을 감쌉니다. 일반 따옴표 대신 사용합니다.\n- 여러 줄 문자열을 자연스럽게 작성할 수 있습니다. 줄바꿈이 그대로 유지됩니다.\n- 이스케이프 문자 없이 줄바꿈합니다.\n- 백틱 자체를 사용하려면 이스케이프합니다.\n\n**문자열 보간:**\n- 달러 기호와 중괄호로 표현식을 삽입합니다.\n- 변수, 연산, 함수 호출 등 모든 표현식이 가능합니다.\n- 결과가 자동으로 문자열로 변환됩니다.\n- 중첩도 가능합니다. 템플릿 내부에 템플릿을 넣을 수 있습니다.\n\n**일반 문자열과의 차이:**\n- 일반 문자열은 연결 연산자가 필요합니다. 가독성이 떨어집니다.\n- Template Literal은 자연스럽고 읽기 쉽습니다.\n- HTML이나 다중 줄 텍스트 작성이 편리합니다.\n\n**Tagged Template:**\n- 함수로 템플릿을 처리할 수 있습니다.\n- 첫 번째 인수는 문자열 배열입니다. 표현식으로 나뉜 부분들입니다.\n- 나머지 인수는 표현식의 값들입니다.\n- 커스텀 처리 로직을 적용할 수 있습니다.\n\n**Tagged Template 활용:**\n- 국제화: 문자열을 번역하는 함수로 처리합니다.\n- 이스케이핑: XSS를 방지하는 HTML 이스케이프를 적용합니다.\n- 쿼리 빌더: SQL 인젝션을 방지하는 쿼리를 생성합니다.\n- 스타일: styled-components에서 CSS를 작성합니다.\n\n**Raw 문자열:**\n- String.raw는 이스케이프를 처리하지 않습니다.\n- 백슬래시를 그대로 유지합니다.\n- 정규표현식이나 파일 경로에 유용합니다.\n\n**중첩 구조:**\n- 배열이나 객체를 렌더링할 때 유용합니다.\n- map과 함께 사용하여 리스트를 만듭니다.\n- 조건부 렌더링도 가능합니다. 삼항 연산자를 활용합니다.\n\n**실무 활용:**\n- HTML 템플릿 생성: DOM을 동적으로 만듭니다.\n- API URL 구성: 변수를 포함한 엔드포인트를 만듭니다.\n- 로그 메시지: 변수를 포함한 로그를 작성합니다.\n- SQL 쿼리: 파라미터화된 쿼리를 안전하게 만듭니다.\n- styled-components: CSS-in-JS를 구현합니다.\n- GraphQL: 쿼리 문자열을 작성합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901793-xbjl86ap8",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    },
    {
      "question": "에러 처리(try-catch-finally)와 에러 전파에 대해 설명해주세요.",
      "answer": "**정의:**\n불변성은 데이터를 직접 변경하지 않고 새로운 데이터를 생성하는 원칙입니다. 예측 가능하고 안전한 코드를 작성하는 데 핵심적인 개념입니다.\n\n**불변성의 중요성:**\n- 예측 가능성이 높아집니다. 데이터가 언제 어디서 변경되는지 명확합니다.\n- 부수 효과를 방지합니다. 함수가 외부 상태를 변경하지 않습니다.\n- 디버깅이 쉬워집니다. 상태 변화를 추적하기 쉽습니다.\n- 시간 여행 디버깅이 가능합니다. 이전 상태를 보존할 수 있습니다.\n\n**React에서의 불변성:**\n- 상태 변경을 감지합니다. 참조 비교로 빠르게 확인합니다.\n- 리렌더링을 최적화합니다. 변경되지 않은 컴포넌트는 건너뜁니다.\n- PureComponent와 React.memo가 제대로 작동합니다.\n- 상태 업데이트가 명확해집니다. 언제 무엇이 바뀌는지 알 수 있습니다.\n\n**불변성 유지 방법:**\n- 원시 값은 자동으로 불변입니다.\n- 객체는 스프레드 연산자로 복사합니다. 새 객체를 만듭니다.\n- 배열은 map, filter, concat 등을 사용합니다. 새 배열을 반환합니다.\n- push, splice, sort 같은 가변 메서드는 피합니다.\n\n**중첩 객체의 불변 업데이트:**\n- 중첩된 각 레벨을 새로 만들어야 합니다.\n- 스프레드를 중첩하여 사용합니다. 코드가 복잡해질 수 있습니다.\n- Immer 같은 라이브러리를 활용합니다. 가변 문법으로 불변 업데이트를 구현합니다.\n\n**함수형 프로그래밍:**\n- 불변성은 함수형 프로그래밍의 핵심입니다.\n- 순수 함수를 만들 수 있습니다. 같은 입력은 항상 같은 출력을 보장합니다.\n- 함수 합성이 안전해집니다. 예상치 못한 부작용이 없습니다.\n- 테스트하기 쉬워집니다. 입출력만 확인하면 됩니다.\n\n**성능 고려사항:**\n- 복사 비용이 발생합니다. 큰 객체는 메모리와 시간이 소요됩니다.\n- 하지만 참조 비교가 빠릅니다. 깊은 비교보다 훨씬 효율적입니다.\n- 구조적 공유로 최적화할 수 있습니다. 변경되지 않은 부분은 재사용합니다.\n- 대부분의 경우 성능 문제는 미미합니다.\n\n**불변 데이터 구조:**\n- Immutable.js는 특화된 자료구조를 제공합니다.\n- 구조적 공유로 메모리를 절약합니다.\n- 대량의 데이터를 다룰 때 유용합니다.\n- 하지만 학습 곡선과 번들 크기가 단점입니다.\n\n**Undo/Redo 구현:**\n- 이전 상태를 배열에 저장합니다.\n- 불변성 덕분에 안전하게 보관할 수 있습니다.\n- 시간 여행 기능을 쉽게 만듭니다.\n- Redux DevTools가 이를 활용합니다.\n\n**실무 권장사항:**\n- 상태 관리에서 불변성을 항상 유지합니다.\n- 복잡한 업데이트는 Immer를 사용합니다.\n- 불변 메서드를 기본으로 사용합니다. map, filter, concat 등입니다.\n- ESLint 규칙으로 가변 메서드 사용을 경고합니다.\n- TypeScript의 readonly로 타입 레벨에서 강제합니다.",
      "type": "essay",
      "tags": [
        "JavaScript",
        "JS"
      ],
      "id": "1763441901793-vjjaegwns",
      "createdAt": "2025-11-18T04:58:21.792166",
      "studyCount": 0
    }
  ]
}