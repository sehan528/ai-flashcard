{
  "name": "프로그래밍 언어",
  "description": "프로그래밍 언어 핵심 개념 및 면접 질문",
  "cards": [
    {
      "question": "JVM의 구조와 동작 원리에 대해 설명해주세요.",
      "answer": "**정의:**\nJVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신으로, 플랫폼 독립성을 제공하는 자바의 핵심 구성 요소입니다. JVM은 자바 컴파일러가 생성한 .class 파일을 읽어 해당 운영체제에서 실행 가능한 형태로 변환하여 실행합니다.\n\n**특징/원리:**\n- 플랫폼 독립성: \"Write Once, Run Anywhere\" 철학을 구현하여 한 번 작성된 코드가 JVM이 설치된 모든 플랫폼에서 실행 가능\n- 자동 메모리 관리: 가비지 컬렉션을 통해 사용하지 않는 객체를 자동으로 메모리에서 제거\n- 보안성: 바이트코드 검증기를 통해 악의적인 코드 실행을 방지\n- 최적화 기능: JIT 컴파일러를 통해 자주 실행되는 코드를 네이티브 코드로 컴파일하여 성능 향상\n\n**주요 구성 요소:**\n- 클래스 로더(Class Loader): .class 파일을 메모리에 로드하고 링크하는 역할 수행\n- 실행 엔진(Execution Engine): 바이트코드를 해석하고 실행하며, 인터프리터와 JIT 컴파일러로 구성\n- 런타임 데이터 영역(Runtime Data Area): 메모리 공간으로 Heap, Stack, Method Area, PC Register, Native Method Stack으로 구분\n- 가비지 컬렉터(Garbage Collector): 더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제\n\n**실무 활용:**\n- 애플리케이션 성능 튜닝 시 JVM 옵션 설정을 통해 힙 메모리 크기, GC 알고리즘 선택 등을 최적화\n- 운영 중인 시스템의 메모리 누수나 성능 문제 진단 시 JVM 모니터링 도구 활용\n- 다양한 플랫폼에서 동일한 자바 애플리케이션을 배포하고 실행할 수 있어 유지보수 비용 절감",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "JVM",
        "GC"
      ],
      "id": "1763437633096-vaszh6j3",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "JVM의 메모리 구조(Heap, Stack, Method Area 등)를 설명해주세요.",
      "answer": "**정의:**\nJVM의 메모리 구조는 런타임 데이터 영역으로 구성되며, 프로그램 실행에 필요한 데이터를 저장하는 공간입니다. 각 영역은 특정 목적에 따라 구분되어 있으며, 일부는 모든 스레드가 공유하고 일부는 스레드별로 독립적으로 생성됩니다.\n\n**특징/원리:**\n- 스레드 공유 여부에 따른 구분: Heap과 Method Area는 모든 스레드가 공유하며, Stack, PC Register, Native Method Stack은 스레드별로 생성\n- 생명주기 차이: Method Area와 Heap은 JVM 시작 시 생성되고 종료 시 소멸되며, 스레드 전용 영역은 스레드 생성/종료 시 함께 생성/소멸\n- 가비지 컬렉션 대상: Heap과 Method Area는 GC의 대상이 되지만, Stack 영역은 자동으로 메모리가 해제됨\n\n**메모리 영역별 특징:**\n- Heap: 객체 인스턴스와 배열이 저장되는 공간으로 GC의 주요 대상이며, Young Generation과 Old Generation으로 구분\n- Stack: 메서드 호출 시 생성되는 지역 변수, 매개변수, 리턴 값 등을 저장하며 LIFO 구조로 동작\n- Method Area: 클래스 메타데이터, static 변수, 상수 풀 등이 저장되며 Java 8부터 Metaspace로 대체\n- PC Register: 현재 실행 중인 JVM 명령어 주소를 저장하는 스레드별 레지스터\n- Native Method Stack: 네이티브 메서드 실행 시 사용되는 스택 영역\n\n**실무 활용:**\n- OutOfMemoryError 발생 시 어느 영역에서 발생했는지 파악하여 적절한 JVM 옵션으로 메모리 크기 조정\n- 스레드 덤프 분석 시 Stack 영역 정보를 활용하여 데드락이나 무한 루프 문제 진단\n- 힙 덤프 분석을 통해 메모리 누수가 발생하는 객체를 식별하고 코드 개선",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "JVM",
        "GC"
      ],
      "id": "1763437633096-uict9z6r",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Garbage Collection의 동작 원리와 종류에 대해 설명해주세요.",
      "answer": "**정의:**\n가비지 컬렉션(GC)은 JVM의 힙 메모리에서 더 이상 사용되지 않는 객체를 자동으로 찾아 제거하는 메모리 관리 기법입니다. 개발자가 명시적으로 메모리를 해제할 필요 없이 JVM이 자동으로 메모리를 관리하여 메모리 누수를 방지합니다.\n\n**특징/원리:**\n- Stop-The-World: GC 실행 중에는 애플리케이션 스레드가 일시 중지되며, 이 시간을 최소화하는 것이 GC 성능의 핵심\n- Reachability 기반: GC Root로부터 참조 체인을 따라 도달 가능한 객체는 살아있는 객체로 판단\n- 세대별 관리: 대부분의 객체는 생성 후 금방 사라진다는 Weak Generational Hypothesis에 기반하여 Young과 Old 영역으로 구분\n- Mark and Sweep: 살아있는 객체를 표시(Mark)하고 표시되지 않은 객체를 제거(Sweep)하는 방식으로 동작\n\n**주요 GC 알고리즘:**\n- Serial GC: 단일 스레드로 동작하며 작은 힙 크기에 적합하고 Stop-The-World 시간이 김\n- Parallel GC: 여러 스레드를 사용하여 Young Generation을 병렬로 처리하며 처리량 중심 최적화\n- CMS GC: 애플리케이션 스레드와 동시에 실행되어 Stop-The-World 시간을 최소화하지만 메모리 단편화 발생 가능\n- G1 GC: 힙을 여러 리전으로 나누어 관리하며 예측 가능한 정지 시간 목표를 제공\n- ZGC/Shenandoah GC: 매우 짧은 정지 시간을 목표로 하는 최신 GC 알고리즘\n\n**실무 활용:**\n- 애플리케이션 특성에 따라 적절한 GC 알고리즘 선택하여 응답 시간이나 처리량 최적화\n- GC 로그 분석을 통해 Full GC 빈도와 정지 시간을 모니터링하고 튜닝 포인트 발견\n- 메모리 누수 의심 시 힙 덤프를 분석하여 GC되지 않는 객체의 참조 체인 추적",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "JVM",
        "GC"
      ],
      "id": "1763437633096-njirch0d",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "G1 GC와 다른 GC 알고리즘의 차이점은 무엇인가요?",
      "answer": "**정의:**\nG1(Garbage First) GC는 Java 7에서 도입되어 Java 9부터 기본 GC로 채택된 알고리즘으로, 대용량 힙 메모리에서 예측 가능한 정지 시간을 제공하는 것을 목표로 합니다. 기존 GC와 달리 힙을 고정된 크기의 리전으로 나누어 관리하는 새로운 접근 방식을 사용합니다.\n\n**특징/원리:**\n- 리전 기반 구조: 힙을 동일한 크기의 리전으로 나누고 각 리전이 Eden, Survivor, Old 역할을 동적으로 변경\n- 예측 가능한 정지 시간: 사용자가 설정한 정지 시간 목표 내에서 GC를 수행하도록 최적화\n- 점진적 수집: 전체 힙을 한 번에 수집하지 않고 우선순위가 높은 리전부터 점진적으로 수집\n- 동시 마킹: 애플리케이션 실행과 동시에 마킹 작업을 수행하여 정지 시간 최소화\n\n**다른 GC와의 차이점:**\n- Parallel GC 대비: Parallel GC는 전체 Young/Old Generation을 한 번에 처리하지만, G1은 리전 단위로 선택적 수집\n- CMS GC 대비: CMS는 메모리 단편화 문제가 있지만 G1은 컴팩션을 통해 단편화 해결하며, 더 예측 가능한 정지 시간 제공\n- Serial GC 대비: Serial은 단일 스레드이지만 G1은 멀티 스레드로 병렬 처리하여 대용량 힙에 적합\n- ZGC 대비: ZGC는 매우 짧은 정지 시간(10ms 미만)을 목표로 하지만, G1은 균형 잡힌 처리량과 응답성 제공\n\n**실무 활용:**\n- 4GB 이상의 대용량 힙을 사용하는 서버 애플리케이션에서 안정적인 응답 시간 보장\n- MaxGCPauseMillis 옵션으로 목표 정지 시간을 설정하여 애플리케이션 요구사항에 맞는 튜닝\n- 실시간성이 중요한 웹 서비스에서 일관된 응답 속도를 유지하기 위해 G1 GC 선택",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "메모리"
      ],
      "id": "1763437633096-5u33ol3k",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 클래스 로딩 과정을 설명해주세요.",
      "answer": "**정의:**\n클래스 로딩은 JVM이 .class 파일을 읽어 메모리에 적재하고 사용 가능한 상태로 만드는 과정입니다. 클래스 로더가 이 작업을 수행하며, 필요한 시점에 동적으로 클래스를 로드하는 동적 로딩 방식을 사용합니다.\n\n**특징/원리:**\n- 동적 로딩: 런타임에 필요한 시점에 클래스를 로드하여 초기 구동 시간을 단축하고 메모리 효율성 향상\n- 계층 구조: Bootstrap, Extension, Application 클래스 로더가 계층 구조를 이루며 상위 로더에서 하위 로더 순서로 위임\n- 위임 모델: 클래스 로딩 요청을 받으면 먼저 부모 클래스 로더에게 위임하고, 부모가 로드하지 못할 때만 직접 로드\n- 네임스페이스 분리: 각 클래스 로더는 독립된 네임스페이스를 가져 같은 이름의 클래스도 다른 로더에 의해 별도로 로드 가능\n\n**클래스 로딩 단계:**\n- Loading: 클래스 파일을 찾아 바이너리 데이터를 읽어 메모리에 적재하고 Class 객체 생성\n- Linking: Verification(바이트코드 검증), Preparation(static 변수 메모리 할당 및 기본값 초기화), Resolution(심볼릭 참조를 직접 참조로 변환)의 세 단계로 구성\n- Initialization: static 변수를 개발자가 지정한 값으로 초기화하고 static 블록 실행\n\n**실무 활용:**\n- 커스텀 클래스 로더를 구현하여 암호화된 클래스 파일을 로드하거나 네트워크에서 클래스를 동적으로 다운로드\n- 플러그인 시스템 구현 시 독립적인 클래스 로더를 사용하여 플러그인 간 클래스 충돌 방지\n- ClassNotFoundException이나 NoClassDefFoundError 발생 시 클래스패스와 클래스 로딩 순서 확인하여 문제 해결",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "JVM",
        "메모리"
      ],
      "id": "1763437633096-q2udet72",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "static 키워드의 의미와 사용 시 주의사항은 무엇인가요?",
      "answer": "**정의:**\nstatic 키워드는 클래스 레벨에서 공유되는 멤버를 선언할 때 사용하며, 인스턴스가 아닌 클래스 자체에 속하는 변수나 메서드를 정의합니다. static 멤버는 클래스가 메모리에 로드될 때 단 한 번만 생성되어 모든 인스턴스가 공유합니다.\n\n**특징/원리:**\n- 클래스 레벨 소속: 객체 생성 없이 클래스명으로 직접 접근 가능하며 인스턴스와 독립적으로 존재\n- 메모리 효율성: 모든 인스턴스가 하나의 static 변수를 공유하므로 메모리 사용량 절감\n- 초기화 시점: 클래스가 처음 로드될 때 초기화되며, static 블록을 통해 복잡한 초기화 가능\n- 접근 제한: static 메서드 내에서는 인스턴스 변수나 메서드에 직접 접근 불가능\n\n**사용 시 주의사항:**\n- 멀티스레드 환경: static 변수는 모든 스레드가 공유하므로 동시성 문제 발생 가능하며 동기화 필요\n- 메모리 누수: static 컬렉션에 객체를 계속 추가하면 GC가 회수하지 못해 메모리 누수 발생 가능\n- 테스트 어려움: static 변수의 상태가 테스트 간에 공유되어 테스트 독립성 저하\n- 객체지향 원칙 위배: 과도한 static 사용은 캡슐화를 해치고 절차 지향적 코드가 될 수 있음\n\n**실무 활용:**\n- 유틸리티 클래스의 헬퍼 메서드를 static으로 구현하여 인스턴스 생성 없이 사용\n- 상수 값을 static final로 선언하여 전역적으로 공유되는 불변 값 정의\n- 싱글톤 패턴 구현 시 static 변수로 유일한 인스턴스를 저장하고 static 메서드로 접근 제공",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633096-imhim2z5",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "final, finally, finalize의 차이점을 설명해주세요.",
      "answer": "**정의:**\nfinal, finally, finalize는 모두 다른 목적과 사용 방식을 가진 Java의 키워드 또는 메서드입니다. final은 불변성을 나타내는 키워드, finally는 예외 처리의 일부, finalize는 가비지 컬렉션과 관련된 메서드입니다.\n\n**특징/원리:**\n- 사용 위치: final은 변수, 메서드, 클래스에 적용되며, finally는 try-catch 블록과 함께 사용되고, finalize는 Object 클래스의 메서드\n- 실행 시점: final은 컴파일 타임에 체크되며, finally는 예외 발생 여부와 무관하게 실행되고, finalize는 GC가 객체를 수거하기 전에 호출\n- 보장 수준: final은 불변성을 강제하고, finally는 실행을 보장하지만, finalize는 실행 시점과 실행 여부가 불확실\n\n**각각의 특징:**\n- final: 변수에 사용 시 재할당 불가, 메서드에 사용 시 오버라이딩 불가, 클래스에 사용 시 상속 불가능하며 불변성과 안정성 제공\n- finally: try-catch 블록 뒤에 위치하여 예외 발생 여부와 관계없이 항상 실행되며 리소스 정리 등에 활용\n- finalize: Object 클래스의 메서드로 GC가 객체를 수거하기 전 호출되지만, Java 9부터 deprecated되어 사용 권장되지 않음\n\n**실무 활용:**\n- final 키워드로 중요 상수를 정의하거나 불변 객체를 만들어 스레드 안전성 확보\n- finally 블록에서 데이터베이스 연결, 파일 스트림 등의 리소스를 안전하게 해제\n- finalize 대신 try-with-resources나 AutoCloseable 인터페이스를 사용하여 명시적으로 리소스 관리",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "동시성"
      ],
      "id": "1763437633096-owfgapa4",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "추상 클래스와 인터페이스의 차이점과 사용 시나리오를 설명해주세요.",
      "answer": "**정의:**\n추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스로 인스턴스를 직접 생성할 수 없으며, 인터페이스는 구현을 포함하지 않는 순수한 추상 타입을 정의합니다. 두 가지 모두 추상화를 통해 다형성을 구현하는 수단이지만 목적과 사용 방식이 다릅니다.\n\n**특징/원리:**\n- 상속 제약: 추상 클래스는 단일 상속만 가능하지만, 인터페이스는 다중 구현이 가능하여 유연성 제공\n- 구현 포함: 추상 클래스는 일반 메서드와 필드를 가질 수 있지만, 인터페이스는 Java 8 이전에는 상수와 추상 메서드만 가능\n- 접근 제어: 추상 클래스는 다양한 접근 제어자를 사용할 수 있지만, 인터페이스의 메서드는 기본적으로 public\n- 생성자: 추상 클래스는 생성자를 가질 수 있지만, 인터페이스는 생성자를 가질 수 없음\n\n**차이점 비교:**\n- 목적: 추상 클래스는 \"is-a\" 관계의 공통 기능 제공에 적합하고, 인터페이스는 \"can-do\" 관계의 계약 정의에 적합\n- Java 8 이후: 인터페이스에 default 메서드와 static 메서드가 추가되어 일부 구현 제공 가능\n- 상태 관리: 추상 클래스는 인스턴스 변수로 상태를 가질 수 있지만, 인터페이스는 상수만 가능\n- 변경 영향도: 추상 클래스에 메서드 추가 시 하위 클래스 영향이 적지만, 인터페이스는 모든 구현 클래스에 영향\n\n**실무 활용:**\n- 공통 기능과 상태를 공유해야 하는 관련 클래스들의 기반으로 추상 클래스 사용\n- 서로 관련 없는 클래스들이 동일한 행위를 구현해야 할 때 인터페이스로 계약 정의\n- 프레임워크 설계 시 확장 포인트를 인터페이스로 제공하여 사용자가 자유롭게 구현하도록 지원",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633096-ca0v2hgf",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java 8 이후 인터페이스의 default 메서드와 static 메서드에 대해 설명해주세요.",
      "answer": "**정의:**\nJava 8에서 인터페이스에 default 메서드와 static 메서드가 추가되어 인터페이스가 구현을 포함할 수 있게 되었습니다. default 메서드는 구현체에서 재정의할 수 있는 기본 구현을 제공하며, static 메서드는 인터페이스 레벨의 유틸리티 메서드를 정의합니다.\n\n**특징/원리:**\n- 하위 호환성: 기존 인터페이스에 새로운 메서드를 추가해도 구현 클래스를 수정하지 않아도 되어 API 확장 용이\n- 선택적 오버라이딩: default 메서드는 구현 클래스에서 필요에 따라 오버라이드할 수 있어 유연성 제공\n- 다중 상속 문제: 여러 인터페이스가 같은 시그니처의 default 메서드를 가질 경우 명시적으로 선택 필요\n- 인스턴스 독립: static 메서드는 인터페이스명으로 직접 호출되며 구현 클래스와 독립적으로 동작\n\n**default 메서드 특징:**\n- 구현 제공: 인터페이스에서 메서드의 기본 동작을 구현하여 모든 구현 클래스가 사용 가능\n- 오버라이딩 가능: 구현 클래스에서 필요 시 재정의하여 커스터마이징 가능\n- 다이아몬드 문제: 여러 인터페이스의 default 메서드가 충돌할 경우 컴파일 에러 발생하며 명시적 해결 필요\n- 함수형 인터페이스: Stream API 등 함수형 프로그래밍 지원을 위한 핵심 기능\n\n**static 메서드 특징:**\n- 유틸리티 기능: 인터페이스와 관련된 헬퍼 메서드를 제공하여 별도 유틸리티 클래스 불필요\n- 오버라이딩 불가: 구현 클래스에서 재정의할 수 없으며 인터페이스명으로만 호출\n- 상속되지 않음: 인터페이스를 구현한 클래스에서 static 메서드는 상속되지 않음\n\n**실무 활용:**\n- 기존 인터페이스에 새로운 기능을 추가할 때 default 메서드로 구현하여 하위 호환성 유지\n- Collection 인터페이스의 stream() 메서드처럼 공통 기능을 default 메서드로 제공\n- Comparator.comparing()과 같은 팩토리 메서드를 static 메서드로 제공하여 편의성 향상",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633096-0e3x4k79",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Checked Exception과 Unchecked Exception의 차이점은 무엇인가요?",
      "answer": "**정의:**\nChecked Exception은 컴파일 시점에 처리 여부를 확인하는 예외로 Exception 클래스를 상속하며, Unchecked Exception은 런타임 시점에 발생하는 예외로 RuntimeException을 상속합니다. 두 예외의 처리 방식과 사용 목적이 다릅니다.\n\n**특징/원리:**\n- 컴파일러 검사: Checked Exception은 컴파일러가 예외 처리를 강제하지만, Unchecked Exception은 선택적으로 처리\n- 발생 시점: Checked Exception은 예측 가능한 상황에서 발생하며, Unchecked Exception은 프로그래밍 오류로 발생\n- 복구 가능성: Checked Exception은 복구 가능한 상황을 나타내고, Unchecked Exception은 프로그램 로직 오류를 나타냄\n- 트랜잭션 처리: Spring 프레임워크에서 Unchecked Exception은 기본적으로 롤백되지만 Checked Exception은 롤백되지 않음\n\n**Checked Exception 특징:**\n- 명시적 처리 필요: try-catch 블록으로 처리하거나 throws 키워드로 전파 선언 필수\n- 대표 예외: IOException, SQLException, ClassNotFoundException 등\n- 복구 시나리오: 파일이 없을 때 재시도, 네트워크 오류 시 재접속 등 복구 로직 구현 가능\n- API 계약: 메서드 시그니처에 명시되어 호출자에게 발생 가능한 예외 정보 제공\n\n**Unchecked Exception 특징:**\n- 선택적 처리: 명시적 처리가 강제되지 않으며 처리하지 않아도 컴파일 가능\n- 대표 예외: NullPointerException, IllegalArgumentException, ArrayIndexOutOfBoundsException 등\n- 프로그래밍 오류: 대부분 개발자의 실수나 검증 누락으로 발생하며 코드 수정으로 해결\n- 전파 용이: throws 선언 없이도 자동으로 호출 스택을 따라 전파\n\n**실무 활용:**\n- 파일 입출력이나 데이터베이스 작업 등 외부 리소스 접근 시 Checked Exception 처리하여 안정성 확보\n- 메서드 파라미터 검증 실패 시 IllegalArgumentException 같은 Unchecked Exception 발생시켜 프로그래밍 오류 표시\n- 비즈니스 예외는 커스텀 Unchecked Exception으로 정의하여 Spring의 트랜잭션 롤백 기능 활용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "네트워크",
        "Spring"
      ],
      "id": "1763437633096-oo3wvhqt",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "try-with-resources 구문의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\ntry-with-resources는 Java 7에서 도입된 구문으로 AutoCloseable 인터페이스를 구현한 리소스를 자동으로 해제하는 기능을 제공합니다. try 블록이 종료될 때 선언된 리소스의 close() 메서드가 자동으로 호출되어 명시적인 리소스 해제 코드가 불필요합니다.\n\n**특징/원리:**\n- 자동 리소스 관리: try 괄호 안에 선언된 리소스는 try 블록 종료 시 자동으로 close() 호출되어 메모리 누수 방지\n- 예외 안전성: 리소스 해제 중 예외 발생 시에도 원본 예외 정보가 보존되며 suppressed exception으로 추가\n- 역순 해제: 여러 리소스가 선언된 경우 선언의 역순으로 close() 호출되어 의존성 문제 해결\n- 간결한 코드: finally 블록에서 명시적으로 close()를 호출하는 보일러플레이트 코드 제거\n\n**동작 메커니즘:**\n- AutoCloseable 인터페이스: 리소스 클래스는 AutoCloseable 또는 Closeable 인터페이스를 구현해야 함\n- 컴파일 변환: 컴파일러가 try-with-resources 구문을 try-finally 블록으로 자동 변환\n- 예외 처리 순서: try 블록의 예외가 주 예외가 되고, close() 중 발생한 예외는 suppressed exception으로 추가\n- 다중 리소스: 세미콜론으로 구분하여 여러 리소스를 한 번에 선언 가능\n\n**실무 활용:**\n- 파일 입출력 시 FileInputStream, BufferedReader 등을 try-with-resources로 선언하여 안전하게 리소스 해제\n- 데이터베이스 Connection, Statement, ResultSet을 try-with-resources로 관리하여 커넥션 누수 방지\n- 커스텀 리소스 클래스 작성 시 AutoCloseable을 구현하여 try-with-resources 패턴 활용 가능하도록 설계",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633096-hw7lsz4d",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "equals()와 hashCode()의 관계와 오버라이딩 시 주의사항은 무엇인가요?",
      "answer": "**정의:**\nequals()와 hashCode()는 Object 클래스에 정의된 메서드로 객체의 동등성 비교와 해시 기반 컬렉션에서의 사용을 위한 핵심 메서드입니다. 두 메서드는 밀접한 관계가 있으며, 하나를 오버라이드하면 다른 하나도 함께 오버라이드해야 합니다.\n\n**특징/원리:**\n- equals-hashCode 계약: equals()로 같다고 판단된 두 객체는 반드시 같은 hashCode 값을 반환해야 함\n- 일관성 유지: equals()와 hashCode()의 계산에 사용되는 필드는 동일해야 하며, 불변 필드 사용 권장\n- 성능 영향: hashCode()는 HashMap, HashSet 등에서 버킷 결정에 사용되어 성능에 직접적 영향\n- 대칭성과 추이성: equals()는 대칭성, 추이성, 일관성, null 비교 등의 계약을 준수해야 함\n\n**equals() 오버라이딩 규칙:**\n- 반사성: x.equals(x)는 항상 true 반환\n- 대칭성: x.equals(y)가 true면 y.equals(x)도 true\n- 추이성: x.equals(y)와 y.equals(z)가 true면 x.equals(z)도 true\n- 일관성: 여러 번 호출해도 동일한 결과 반환\n- null 처리: x.equals(null)은 항상 false\n\n**hashCode() 오버라이딩 규칙:**\n- 일관성: 동일 객체에 대해 여러 번 호출 시 equals() 비교에 사용된 정보가 변경되지 않았다면 같은 값 반환\n- equals 연계: equals()로 같다고 판단되면 hashCode()도 같은 값 반환 필수\n- 분산성: 서로 다른 객체는 가능한 한 다른 해시 값을 가져야 해시 충돌 최소화\n\n**실무 활용:**\n- HashMap, HashSet 등 해시 기반 컬렉션에 커스텀 객체를 키로 사용할 때 반드시 두 메서드 오버라이드\n- IDE의 자동 생성 기능이나 Lombok의 @EqualsAndHashCode 어노테이션으로 안전하게 구현\n- 불변 객체로 설계하여 equals()와 hashCode()의 일관성을 보장하고 스레드 안전성 확보",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성"
      ],
      "id": "1763437633096-v5b3k45e",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "String, StringBuilder, StringBuffer의 차이점을 설명해주세요.",
      "answer": "**정의:**\nString, StringBuilder, StringBuffer는 모두 문자열을 다루는 Java 클래스이지만 가변성과 스레드 안전성 측면에서 차이가 있습니다. String은 불변 객체이고, StringBuilder와 StringBuffer는 가변 객체로 문자열 수정이 가능합니다.\n\n**특징/원리:**\n- 불변성: String은 한 번 생성되면 변경 불가능하며, 수정 시 새로운 객체가 생성되어 메모리 낭비 발생 가능\n- 성능: StringBuilder가 가장 빠르고, StringBuffer는 동기화로 인해 약간 느리며, String은 연산 시마다 객체 생성으로 가장 느림\n- 스레드 안전성: StringBuffer는 synchronized로 스레드 안전하지만, StringBuilder는 스레드 안전하지 않음\n- 메모리: String은 String Pool을 사용하여 같은 값의 문자열은 재사용되지만, StringBuilder와 StringBuffer는 힙에 개별 생성\n\n**각 클래스의 특징:**\n- String: 불변 객체로 스레드 안전하며, + 연산자 사용 가능하지만 반복적인 문자열 연결 시 성능 저하\n- StringBuilder: 가변 객체로 단일 스레드 환경에서 문자열 연산 시 최고 성능 제공\n- StringBuffer: 가변 객체로 멀티스레드 환경에서 안전하게 사용 가능하지만 동기화 오버헤드 존재\n- 사용 메서드: append(), insert(), delete() 등 다양한 문자열 조작 메서드 제공\n\n**실무 활용:**\n- 고정된 문자열이나 상수는 String 사용하여 불변성의 이점 활용\n- 단일 스레드에서 반복적인 문자열 연결 작업은 StringBuilder 사용하여 성능 최적화\n- 멀티스레드 환경에서 공유되는 문자열 버퍼는 StringBuffer 사용하여 데이터 무결성 보장",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633096-5w711kqp",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 Generic에 대해 설명하고, Type Erasure란 무엇인가요?",
      "answer": "**정의:**\nGeneric은 클래스나 메서드에서 사용할 타입을 파라미터화하여 타입 안전성을 제공하는 기능입니다. Type Erasure는 컴파일 시점에 Generic 타입 정보를 제거하고 원시 타입으로 변환하는 Java의 Generic 구현 방식입니다.\n\n**특징/원리:**\n- 타입 안전성: 컴파일 타임에 타입 체크를 수행하여 런타임 ClassCastException 방지\n- 코드 재사용성: 동일한 코드로 다양한 타입을 처리할 수 있어 중복 코드 제거\n- 하위 호환성: Type Erasure를 통해 Generic이 없던 이전 버전의 Java 코드와 호환성 유지\n- 성능: 런타임에 타입 정보가 없어 리플렉션으로 Generic 타입을 알 수 없는 제약 존재\n\n**Type Erasure 동작 방식:**\n- 타입 파라미터 제거: 컴파일 시 모든 타입 파라미터를 제거하고 경계 타입이나 Object로 대체\n- 타입 캐스팅 추가: 필요한 위치에 자동으로 타입 캐스팅 코드 삽입\n- 브릿지 메서드 생성: 다형성 유지를 위해 컴파일러가 자동으로 브릿지 메서드 생성\n- 런타임 정보 손실: 런타임에는 타입 파라미터 정보가 없어 instanceof나 new 연산자 사용 불가\n\n**제약사항:**\n- 기본 타입 사용 불가: int, double 등 기본 타입은 Generic 타입으로 사용 불가하며 래퍼 클래스 사용 필요\n- 타입 배열 생성 불가: new T[]와 같은 Generic 타입의 배열 생성 불가\n- static 멤버 제약: static 멤버에서 클래스의 타입 파라미터 사용 불가\n- 예외 클래스 불가: Generic 클래스가 Throwable을 상속할 수 없음\n\n**실무 활용:**\n- Collection 프레임워크에서 타입 안전한 자료구조 사용하여 런타임 오류 방지\n- DAO나 Repository 같은 공통 인터페이스를 Generic으로 정의하여 코드 재사용성 향상\n- 와일드카드를 활용하여 유연한 메서드 파라미터 정의 및 공변성/반공변성 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633096-qd7o8bcb",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Comparable과 Comparator의 차이점을 설명해주세요.",
      "answer": "**정의:**\nComparable과 Comparator는 객체의 정렬 기준을 정의하는 인터페이스입니다. Comparable은 객체 자체의 자연스러운 순서를 정의하며, Comparator는 외부에서 별도의 비교 기준을 제공합니다.\n\n**특징/원리:**\n- 위치: Comparable은 정렬 대상 클래스 내부에 구현되고, Comparator는 별도 클래스나 람다로 외부에서 제공\n- 메서드: Comparable은 compareTo() 하나, Comparator는 compare() 메서드를 구현\n- 정렬 기준: Comparable은 단일 정렬 기준(기본 정렬)을 제공하고, Comparator는 다양한 정렬 기준 제공 가능\n- 클래스 수정: Comparable은 원본 클래스를 수정해야 하지만, Comparator는 원본 클래스 수정 없이 사용 가능\n\n**Comparable 특징:**\n- 자연스러운 순서: 객체의 기본 정렬 순서를 정의하며 Collections.sort()에서 자동 사용\n- compareTo() 메서드: 현재 객체와 매개변수 객체를 비교하여 음수, 0, 양수 반환\n- 일관성: equals()와 일관된 결과를 제공해야 하며, compareTo()가 0이면 equals()도 true 권장\n- String, Integer 등: 대부분의 기본 클래스들이 Comparable 구현하여 자연스러운 정렬 제공\n\n**Comparator 특징:**\n- 외부 정렬 기준: 정렬 대상 클래스를 수정하지 않고 다양한 정렬 방식 제공 가능\n- compare() 메서드: 두 객체를 비교하여 음수, 0, 양수 반환\n- 다중 정렬 기준: 여러 Comparator를 정의하여 상황에 따라 다른 정렬 적용 가능\n- Java 8 개선: 람다 표현식과 Comparator.comparing() 등의 유틸리티 메서드로 간결한 구현 가능\n\n**실무 활용:**\n- 도메인 객체에 기본 정렬 순서가 명확한 경우 Comparable 구현하여 자연스러운 정렬 제공\n- 다양한 정렬 기준이 필요한 경우 여러 Comparator를 정의하여 상황에 맞게 선택\n- Stream API에서 Comparator를 활용하여 정렬, 최대/최소값 찾기 등 다양한 연산 수행",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633096-ij0712zc",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 Collection Framework 구조를 설명해주세요.",
      "answer": "**정의:**\nJava Collection Framework는 데이터 그룹을 효율적으로 저장하고 관리하기 위한 표준화된 아키텍처입니다. 인터페이스, 구현 클래스, 알고리즘으로 구성되어 있으며 다양한 자료구조를 일관된 방식으로 사용할 수 있게 합니다.\n\n**특징/원리:**\n- 인터페이스 기반 설계: Collection, List, Set, Queue, Map 등의 인터페이스로 계층 구조 정의\n- 다형성 활용: 인터페이스 타입으로 선언하고 구체적인 구현 클래스는 필요에 따라 교체 가능\n- 일관된 API: 모든 컬렉션이 유사한 메서드를 제공하여 학습 및 사용 용이\n- 성능 최적화: 각 구현 클래스는 특정 상황에 최적화된 내부 구조와 알고리즘 사용\n\n**주요 인터페이스 계층:**\n- Collection: 모든 컬렉션의 최상위 인터페이스로 기본 메서드 정의\n- List: 순서가 있고 중복을 허용하는 컬렉션으로 ArrayList, LinkedList, Vector 등이 구현\n- Set: 순서가 없고 중복을 허용하지 않는 컬렉션으로 HashSet, TreeSet, LinkedHashSet 등이 구현\n- Queue: FIFO 구조의 컬렉션으로 PriorityQueue, ArrayDeque 등이 구현\n- Map: 키-값 쌍을 저장하는 컬렉션으로 HashMap, TreeMap, LinkedHashMap 등이 구현\n\n**구현 클래스 특징:**\n- ArrayList: 동적 배열 기반으로 인덱스 접근이 빠르지만 중간 삽입/삭제는 느림\n- LinkedList: 이중 연결 리스트로 삽입/삭제가 빠르지만 인덱스 접근은 느림\n- HashSet: 해시 테이블 기반으로 빠른 검색과 삽입 제공하지만 순서 보장 안 됨\n- TreeSet: 레드-블랙 트리 기반으로 정렬된 순서 유지하며 O(log n) 성능\n- HashMap: 해시 테이블 기반으로 빠른 키-값 검색 제공\n\n**실무 활용:**\n- 요구사항에 맞는 적절한 컬렉션 선택하여 성능 최적화 (빠른 검색은 HashSet, 정렬 필요 시 TreeSet)\n- 인터페이스 타입으로 변수 선언하여 구현체 교체가 용이한 유연한 코드 작성\n- Stream API와 결합하여 선언적이고 간결한 컬렉션 처리 로직 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633096-hwsyn749",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "ArrayList와 LinkedList의 차이점과 사용 시나리오는 무엇인가요?",
      "answer": "**정의:**\nArrayList와 LinkedList는 모두 List 인터페이스를 구현한 클래스로 순서가 있는 데이터를 저장합니다. ArrayList는 동적 배열을 기반으로 하고, LinkedList는 이중 연결 리스트 구조를 사용하여 내부 구조와 성능 특성이 다릅니다.\n\n**특징/원리:**\n- 내부 구조: ArrayList는 연속된 메모리 공간의 배열을 사용하고, LinkedList는 노드들이 포인터로 연결된 구조\n- 메모리 사용: ArrayList는 배열만 필요하지만, LinkedList는 각 노드마다 이전/다음 노드 참조를 저장하여 메모리 오버헤드 존재\n- 동적 크기 조정: ArrayList는 배열이 가득 차면 새로운 배열을 생성하고 복사하며, LinkedList는 노드 추가만으로 확장\n- 인터페이스 구현: LinkedList는 List뿐만 아니라 Queue와 Deque 인터페이스도 구현\n\n**성능 비교:**\n- 인덱스 접근: ArrayList는 O(1)로 즉시 접근 가능하지만, LinkedList는 O(n)으로 순차 탐색 필요\n- 끝 추가/삭제: 둘 다 O(1)이지만, ArrayList는 배열 확장 시 O(n) 발생 가능\n- 중간 삽입/삭제: ArrayList는 O(n)으로 요소 이동 필요, LinkedList는 O(1)이지만 탐색 시간 O(n) 추가\n- 메모리: ArrayList가 메모리 효율적이지만 확장 시 여유 공간 필요, LinkedList는 노드당 추가 메모리 필요\n\n**사용 시나리오:**\n- ArrayList 적합: 조회가 빈번하고 삽입/삭제가 적은 경우, 인덱스 기반 접근이 많은 경우, 메모리 효율이 중요한 경우\n- LinkedList 적합: 중간 삽입/삭제가 빈번한 경우, Queue나 Deque로 사용하는 경우, 순차 접근만 필요한 경우\n\n**실무 활용:**\n- 대부분의 경우 ArrayList를 기본으로 사용하며, 특별한 이유가 있을 때만 LinkedList 선택\n- 큐 구조가 필요한 경우 ArrayDeque가 LinkedList보다 일반적으로 더 나은 성능 제공\n- 빈번한 수정이 필요하면서 동시성 제어가 필요한 경우 CopyOnWriteArrayList 고려",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633096-wprjfj14",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "HashMap의 동작 원리와 해시 충돌 해결 방법을 설명해주세요.",
      "answer": "**정의:**\nHashMap은 키-값 쌍을 저장하는 해시 테이블 기반의 자료구조로, 키의 해시값을 이용하여 빠른 검색, 삽입, 삭제를 제공합니다. 평균적으로 O(1)의 시간 복잡도를 가지지만, 해시 충돌 처리가 성능에 중요한 영향을 미칩니다.\n\n**특징/원리:**\n- 해시 함수: 키의 hashCode()를 호출하여 해시값을 계산하고, 이를 배열 인덱스로 변환\n- 버킷 구조: 내부적으로 배열을 사용하며 각 배열 요소를 버킷이라 하고, 버킷에는 Entry 객체가 저장\n- 동적 크기 조정: 요소 개수가 임계값을 초과하면 배열 크기를 2배로 확장하고 모든 요소를 재배치(rehashing)\n- null 허용: 키와 값 모두 null을 허용하며, null 키는 항상 0번 버킷에 저장\n\n**해시 충돌 해결 방법:**\n- Separate Chaining: Java 7까지는 연결 리스트로 충돌 처리하여 같은 버킷의 Entry들을 리스트로 연결\n- 트리화: Java 8부터는 한 버킷의 요소가 8개 이상이면 연결 리스트를 레드-블랙 트리로 변환하여 O(log n) 성능 보장\n- 역트리화: 요소가 6개 이하로 감소하면 다시 연결 리스트로 변환하여 메모리 효율성 향상\n- 해시 함수 개선: 상위 비트와 하위 비트를 XOR 연산하여 해시값을 더 고르게 분산\n\n**주요 메서드 동작:**\n- put(): 키의 해시값으로 버킷 찾기, 같은 키가 있으면 값 교체, 없으면 새 Entry 추가\n- get(): 키의 해시값으로 버킷 찾기, 버킷 내에서 equals()로 키 비교하여 값 반환\n- remove(): 키의 해시값으로 버킷 찾기, 해당 Entry 제거\n- resize(): 로드 팩터(기본 0.75) 초과 시 배열 크기 확장 및 재해싱 수행\n\n**실무 활용:**\n- 빠른 검색이 필요한 캐시 구현이나 인덱싱에 HashMap 활용\n- equals()와 hashCode()를 올바르게 구현한 객체를 키로 사용하여 정확한 동작 보장\n- 초기 용량과 로드 팩터를 적절히 설정하여 불필요한 rehashing 방지 및 성능 최적화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "캐시"
      ],
      "id": "1763437633096-a7yg0ytt",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "ConcurrentHashMap의 동작 원리와 HashMap과의 차이점은 무엇인가요?",
      "answer": "**정의:**\nConcurrentHashMap은 멀티스레드 환경에서 안전하게 사용할 수 있는 동시성 컬렉션으로, HashMap과 달리 내부적으로 세그먼트 또는 버킷 단위의 잠금을 사용하여 높은 동시성을 제공합니다. Java 8에서 구조가 크게 개선되어 성능이 향상되었습니다.\n\n**특징/원리:**\n- 세그먼트 기반 잠금: Java 7까지는 여러 세그먼트로 나누어 각 세그먼트별로 독립적인 잠금 사용\n- 버킷 레벨 잠금: Java 8부터는 세그먼트 없이 각 버킷에 CAS와 synchronized를 조합하여 세밀한 동시성 제어\n- Non-blocking 읽기: 읽기 작업은 대부분 잠금 없이 수행되어 높은 읽기 성능 제공\n- 약한 일관성: 반복자는 fail-fast가 아닌 weakly consistent 정책으로 동작\n\n**HashMap과의 차이점:**\n- 동시성 안전: HashMap은 스레드 안전하지 않아 멀티스레드 환경에서 데이터 손상 가능, ConcurrentHashMap은 안전\n- null 허용: HashMap은 null 키와 값을 허용하지만, ConcurrentHashMap은 null 허용 안 함\n- 성능: 단일 스레드에서는 HashMap이 더 빠르지만, 멀티스레드에서는 ConcurrentHashMap이 훨씬 효율적\n- 반복자: HashMap의 반복자는 fail-fast이지만, ConcurrentHashMap은 weakly consistent\n\n**동시성 제어 메커니즘:**\n- CAS 연산: Compare-And-Swap을 사용하여 락 없이 원자적 업데이트 수행\n- synchronized 블록: 해시 충돌 발생 시 해당 버킷에만 synchronized 적용하여 다른 버킷은 동시 접근 가능\n- volatile 변수: 테이블과 주요 필드를 volatile로 선언하여 가시성 보장\n- 분할 잠금: 서로 다른 버킷에 대한 작업은 동시에 수행 가능하여 처리량 향상\n\n**실무 활용:**\n- 멀티스레드 환경에서 공유되는 캐시나 설정 정보 저장에 ConcurrentHashMap 사용\n- Collections.synchronizedMap()보다 훨씬 나은 동시성 성능 제공하므로 우선적으로 고려\n- 높은 읽기 비율의 작업에서 뛰어난 성능 발휘하며, putIfAbsent() 등의 원자적 연산 제공",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성",
        "캐시"
      ],
      "id": "1763437633097-o52220vb",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 동기화 방법(synchronized, volatile, Atomic 클래스 등)을 설명해주세요.",
      "answer": "**정의:**\nJava는 멀티스레드 환경에서 공유 자원에 대한 안전한 접근을 보장하기 위해 다양한 동기화 메커니즘을 제공합니다. synchronized, volatile, Atomic 클래스 등은 각각 다른 수준과 방식으로 동시성 제어를 수행합니다.\n\n**특징/원리:**\n- 가시성: 한 스레드의 변경사항이 다른 스레드에게 즉시 보이도록 보장\n- 원자성: 작업이 중간에 중단되지 않고 완전히 실행되거나 전혀 실행되지 않도록 보장\n- 순서성: 명령어의 재배치를 제한하여 프로그램의 의도된 순서대로 실행 보장\n- 성능 트레이드오프: 동기화는 성능 오버헤드를 발생시키므로 필요한 최소 범위에만 적용\n\n**synchronized 키워드:**\n- 메서드 또는 블록 단위로 동기화를 제공하며 모니터 락을 사용하여 상호 배제 보장\n- 가시성과 원자성을 모두 보장하지만 락 획득/해제로 인한 오버헤드 존재\n- 암묵적 락으로 자동으로 획득/해제되어 사용이 간편하지만 유연성은 제한적\n- 재진입 가능하여 같은 스레드가 이미 획득한 락을 다시 획득 가능\n\n**volatile 키워드:**\n- 변수의 읽기/쓰기를 메인 메모리에서 직접 수행하도록 강제하여 가시성 보장\n- 단순 읽기/쓰기에는 원자성 보장하지만 복합 연산(증가, 감소 등)에는 원자성 미보장\n- synchronized보다 가볍고 빠르지만 기능이 제한적이어서 플래그나 상태 변수에 적합\n- happens-before 관계를 형성하여 메모리 일관성 보장\n\n**Atomic 클래스:**\n- AtomicInteger, AtomicLong 등은 CAS 연산을 사용하여 락 없이 원자적 업데이트 제공\n- incrementAndGet(), compareAndSet() 등의 메서드로 원자적 복합 연산 지원\n- volatile 변수의 가시성과 CAS의 원자성을 결합하여 높은 성능과 안전성 제공\n- 경쟁이 심하지 않은 상황에서 synchronized보다 훨씬 빠른 성능\n\n**실무 활용:**\n- 단순 플래그나 상태 변수는 volatile 사용하여 가볍게 동기화\n- 복합 연산이 필요한 카운터나 누적기는 Atomic 클래스로 락 없는 동시성 제어\n- 여러 변수에 대한 일관성 있는 업데이트가 필요하면 synchronized 블록 사용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633097-8ywxvlsh",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "volatile 키워드의 의미와 사용 시나리오는 무엇인가요?",
      "answer": "**정의:**\nvolatile은 변수가 여러 스레드에 의해 동시에 접근될 때 메인 메모리로부터 직접 읽고 쓰도록 강제하는 키워드입니다. CPU 캐시가 아닌 메인 메모리를 사용하여 모든 스레드가 항상 최신 값을 볼 수 있도록 가시성을 보장합니다.\n\n**특징/원리:**\n- 가시성 보장: 한 스레드가 volatile 변수를 수정하면 다른 모든 스레드에게 즉시 보임\n- 캐시 무효화: volatile 변수 읽기/쓰기 시 CPU 캐시를 거치지 않고 메인 메모리에 직접 접근\n- Happens-Before 관계: volatile 쓰기 이전의 모든 쓰기 작업이 volatile 읽기 이후의 모든 읽기 작업보다 먼저 발생\n- 재배치 방지: 컴파일러와 CPU의 명령어 재배치를 제한하여 프로그램 순서 보장\n\n**원자성과 한계:**\n- 읽기/쓰기 원자성: 64비트 변수(long, double)도 원자적으로 읽고 쓸 수 있음\n- 복합 연산 비원자성: 증가(count++), 감소(count--) 같은 읽기-수정-쓰기 연산은 원자성 보장 안 됨\n- synchronized 대비: volatile은 가벼운 동기화로 락 오버헤드가 없지만 기능이 제한적\n- 경쟁 조건: 여러 스레드가 동시에 수정하는 경우 여전히 경쟁 조건 발생 가능\n\n**사용 시나리오:**\n- 상태 플래그: 작업 완료, 중단 요청 등의 boolean 플래그를 여러 스레드가 확인하는 경우\n- 싱글톤 DCL: Double-Checked Locking 패턴에서 인스턴스 변수를 volatile로 선언하여 안전성 확보\n- 읽기 주체: 하나의 스레드만 쓰고 여러 스레드가 읽는 상황에서 최신 값 보장\n- 이벤트 발행: 한 스레드가 이벤트를 발행하고 다른 스레드들이 감지하는 패턴\n\n**실무 활용:**\n- 스레드 종료 플래그를 volatile boolean으로 선언하여 작업 스레드에게 종료 신호 전달\n- 캐시 값의 갱신 여부를 나타내는 플래그로 사용하여 다른 스레드들이 갱신 시점 감지\n- AtomicReference와 함께 사용하여 불변 객체의 참조를 안전하게 교체",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633097-wl3euifa",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java Memory Model에 대해 설명해주세요.",
      "answer": "**정의:**\nJava Memory Model(JMM)은 멀티스레드 환경에서 공유 변수에 대한 읽기/쓰기 작업의 가시성과 순서를 정의하는 명세입니다. JMM은 스레드 간 메모리 접근 규칙을 정의하여 플랫폼에 독립적인 동시성 프로그래밍을 가능하게 합니다.\n\n**특징/원리:**\n- 추상 모델: 실제 하드웨어 메모리 구조와 무관하게 스레드가 메모리를 어떻게 보는지 정의\n- Happens-Before 관계: 한 작업의 결과가 다른 작업에게 보이는 순서를 정의하는 핵심 개념\n- 메모리 가시성: 한 스레드의 변경사항이 다른 스레드에게 언제 보이는지 규정\n- 재배치 제한: 컴파일러와 프로세서의 최적화로 인한 명령어 재배치를 제어\n\n**Happens-Before 규칙:**\n- 프로그램 순서 규칙: 한 스레드 내에서 앞의 작업이 뒤의 작업보다 먼저 발생\n- 모니터 잠금 규칙: 락 해제가 같은 락의 획득보다 먼저 발생\n- volatile 변수 규칙: volatile 변수 쓰기가 같은 변수의 읽기보다 먼저 발생\n- 스레드 시작 규칙: Thread.start() 호출이 시작된 스레드의 모든 작업보다 먼저 발생\n- 스레드 종료 규칙: 스레드의 모든 작업이 Thread.join() 리턴보다 먼저 발생\n\n**메모리 일관성 문제:**\n- 캐시 일관성: 각 스레드가 자신의 CPU 캐시를 가져 메인 메모리와 값이 다를 수 있음\n- 명령어 재배치: 성능 최적화를 위해 컴파일러나 CPU가 명령어 순서를 변경할 수 있음\n- 가시성 문제: 한 스레드의 변경이 다른 스레드에게 즉시 보이지 않을 수 있음\n- 원자성 부족: 복합 연산이 중간에 중단되어 일관성 없는 상태 발생 가능\n\n**실무 활용:**\n- synchronized, volatile, Lock 등의 동기화 메커니즘을 이해하고 올바르게 사용\n- 불변 객체를 활용하여 안전한 발행(safe publication) 패턴 구현\n- Happens-Before 규칙을 이해하여 불필요한 동기화를 피하고 성능 최적화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633097-t9w8lzet",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "ThreadLocal의 동작 원리와 주의사항은 무엇인가요?",
      "answer": "**정의:**\nThreadLocal은 각 스레드가 독립적인 변수 복사본을 가질 수 있도록 하는 클래스입니다. 같은 ThreadLocal 인스턴스를 여러 스레드가 접근해도 각 스레드는 자신만의 값을 저장하고 읽을 수 있어 스레드 간 격리를 제공합니다.\n\n**특징/원리:**\n- 스레드별 저장소: 각 스레드는 자신만의 ThreadLocalMap을 가지며 이곳에 ThreadLocal 변수 저장\n- 참조 구조: Thread 객체가 ThreadLocalMap을 필드로 가지고, ThreadLocal 객체가 키 역할을 함\n- 격리성: 스레드 간 데이터 공유가 없어 동기화 불필요하며 경쟁 조건 발생하지 않음\n- 상속 가능: InheritableThreadLocal을 사용하면 부모 스레드의 값을 자식 스레드가 상속 가능\n\n**동작 메커니즘:**\n- set() 메서드: 현재 스레드의 ThreadLocalMap에 값을 저장\n- get() 메서드: 현재 스레드의 ThreadLocalMap에서 값을 조회하며, 없으면 initialValue() 호출\n- remove() 메서드: 현재 스레드의 ThreadLocalMap에서 값을 제거\n- WeakReference: ThreadLocalMap의 키는 WeakReference로 ThreadLocal이 GC되면 자동 제거\n\n**주의사항:**\n- 메모리 누수: 스레드 풀 환경에서 ThreadLocal 값을 remove()하지 않으면 스레드가 재사용되면서 이전 값이 남아있어 메모리 누수 발생\n- 명시적 정리: 사용 후 반드시 remove()를 호출하여 값을 제거해야 하며 finally 블록 활용 권장\n- 상속 문제: InheritableThreadLocal은 스레드 생성 시점의 값만 복사하며 이후 변경은 반영 안 됨\n- 컨텍스트 전환: 비동기 작업이나 스레드 풀 사용 시 컨텍스트가 유실될 수 있어 주의 필요\n\n**실무 활용:**\n- Spring Security의 SecurityContextHolder가 ThreadLocal로 인증 정보를 스레드별로 관리\n- 트랜잭션 컨텍스트나 데이터베이스 연결을 스레드별로 관리하여 격리 보장\n- 웹 요청별 사용자 정보나 추적 ID를 저장하여 전역적으로 접근 가능하면서도 스레드 안전성 확보",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633097-qaldsicn",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Executor Framework와 Thread Pool에 대해 설명해주세요.",
      "answer": "**정의:**\nExecutor Framework는 Java에서 스레드의 생성, 관리, 실행을 추상화한 고수준 동시성 API입니다. Thread Pool은 미리 생성된 스레드들을 재사용하여 작업을 처리하는 패턴으로, 스레드 생성/소멸 비용을 줄이고 시스템 리소스를 효율적으로 관리합니다.\n\n**특징/원리:**\n- 작업과 실행 분리: Runnable/Callable 작업과 실제 실행을 분리하여 유연성 제공\n- 스레드 재사용: 스레드를 미리 생성하여 풀에 보관하고 작업이 들어오면 할당하여 재사용\n- 큐 기반 처리: 작업을 BlockingQueue에 저장하고 가용 스레드가 순차적으로 처리\n- 생명주기 관리: 스레드 풀의 시작, 종료, 셧다운 등을 체계적으로 관리\n\n**주요 인터페이스와 클래스:**\n- Executor: execute() 메서드만 제공하는 가장 단순한 인터페이스\n- ExecutorService: 작업 제출, 종료 관리, Future 반환 등 확장된 기능 제공\n- ScheduledExecutorService: 지연 실행이나 주기적 실행을 지원하는 인터페이스\n- ThreadPoolExecutor: 스레드 풀의 핵심 구현 클래스로 세밀한 설정 가능\n- Executors: 다양한 유형의 스레드 풀을 생성하는 팩토리 메서드 제공\n\n**주요 Thread Pool 유형:**\n- newFixedThreadPool: 고정된 개수의 스레드를 가진 풀로 안정적이지만 큐가 무제한 증가 가능\n- newCachedThreadPool: 필요에 따라 스레드를 생성하고 60초간 유휴 상태면 제거하며 단기 비동기 작업에 적합\n- newSingleThreadExecutor: 단일 스레드로 작업을 순차 처리하며 작업 순서 보장\n- newScheduledThreadPool: 지연 실행이나 주기적 실행이 필요한 작업에 사용\n\n**실무 활용:**\n- 웹 서버에서 클라이언트 요청을 처리하는 스레드 풀을 구성하여 동시 접속 처리\n- 배치 작업이나 대량 데이터 처리 시 적절한 크기의 스레드 풀로 병렬 처리하여 성능 향상\n- Executors 대신 ThreadPoolExecutor를 직접 생성하여 코어 스레드, 최대 스레드, 큐 크기 등을 상황에 맞게 튜닝",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성",
        "캐시"
      ],
      "id": "1763437633097-og9bm7oh",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Fork/Join Framework의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\nFork/Join Framework는 Java 7에서 도입된 병렬 처리 프레임워크로, 큰 작업을 작은 하위 작업으로 분할(Fork)하고 각각을 병렬로 처리한 후 결과를 합치는(Join) 분할 정복 알고리즘을 구현합니다. Work-Stealing 알고리즘을 사용하여 효율적인 부하 분산을 제공합니다.\n\n**특징/원리:**\n- 분할 정복: 작업을 재귀적으로 더 작은 단위로 분할하여 병렬 처리하고 결과를 합침\n- Work-Stealing: 유휴 스레드가 다른 스레드의 작업 큐에서 작업을 가져와 처리하여 CPU 활용도 향상\n- ForkJoinPool: 작업 스레드들이 자신만의 덱(Deque)을 가지며 LIFO 방식으로 작업 처리\n- 재귀 병렬화: 작업이 충분히 작아질 때까지 재귀적으로 분할하여 최적의 병렬성 달성\n\n**핵심 클래스:**\n- ForkJoinPool: Fork/Join 작업을 실행하는 특수한 ExecutorService 구현체\n- ForkJoinTask: Fork/Join 작업의 추상 클래스로 fork()와 join() 메서드 제공\n- RecursiveTask: 결과를 반환하는 작업을 정의하며 compute() 메서드 구현 필요\n- RecursiveAction: 결과를 반환하지 않는 작업을 정의하며 compute() 메서드 구현 필요\n\n**Work-Stealing 알고리즘:**\n- 각 스레드가 자신의 덱을 가지고 새로운 작업은 덱의 앞쪽에 추가\n- 자신의 덱에서 작업을 가져올 때는 LIFO 방식으로 앞쪽에서 꺼냄\n- 다른 스레드의 덱에서 작업을 훔칠 때는 FIFO 방식으로 뒤쪽에서 꺼냄\n- 이를 통해 큰 작업은 도난당하기 쉽고 작은 작업은 원래 스레드가 빠르게 처리\n\n**실무 활용:**\n- 대용량 배열의 정렬, 검색, 변환 등 분할 가능한 데이터 처리 작업에 활용\n- Java 8의 parallel Stream이 내부적으로 ForkJoinPool의 common pool 사용\n- 재귀적으로 처리 가능한 트리 구조나 그래프 탐색 알고리즘을 병렬화하여 성능 향상",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성"
      ],
      "id": "1763437633097-jgf1623v",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 Stream API 동작 원리와 병렬 처리 방법을 설명해주세요.",
      "answer": "**정의:**\nStream API는 Java 8에서 도입된 함수형 프로그래밍 스타일의 데이터 처리 API로, 컬렉션이나 배열의 요소를 선언적으로 처리할 수 있게 합니다. 내부 반복을 사용하고 지연 연산을 통해 효율적인 데이터 처리를 제공하며, 병렬 스트림으로 멀티코어를 활용한 병렬 처리가 가능합니다.\n\n**특징/원리:**\n- 선언적 프로그래밍: 무엇을 할지 기술하고 어떻게 할지는 Stream API가 처리\n- 지연 연산: 중간 연산은 즉시 실행되지 않고 최종 연산이 호출될 때 한꺼번에 처리\n- 내부 반복: 외부 반복자 대신 Stream이 내부적으로 반복을 관리하여 최적화 가능\n- 일회용: 스트림은 한 번 사용하면 소비되어 재사용 불가능\n\n**스트림 연산 분류:**\n- 중간 연산: filter, map, flatMap, sorted, distinct 등으로 스트림을 변환하며 지연 실행\n- 최종 연산: collect, forEach, reduce, count, findFirst 등으로 결과를 생성하며 스트림 소비\n- 쇼트 서킷: anyMatch, findFirst 등은 모든 요소를 처리하지 않고 조건 만족 시 즉시 종료\n- 상태 기반/무상태: sorted, distinct는 상태를 유지하고, filter, map은 무상태 연산\n\n**병렬 처리 방법:**\n- parallel() 메서드: 순차 스트림을 병렬 스트림으로 변환하여 ForkJoinPool의 공통 풀 사용\n- parallelStream(): 컬렉션에서 직접 병렬 스트림 생성\n- 자동 분할: 소스 데이터를 여러 청크로 분할하여 각 스레드가 독립적으로 처리\n- 결과 합치기: 각 스레드의 부분 결과를 combine 함수로 합쳐 최종 결과 생성\n\n**병렬 스트림 주의사항:**\n- 공유 상태 회피: 병렬 스트림에서 공유 변수를 수정하면 경쟁 조건 발생하여 부정확한 결과 초래\n- 데이터 크기: 작은 데이터셋은 병렬화 오버헤드가 이득보다 클 수 있어 순차 스트림이 더 빠를 수 있음\n- 분할 가능성: ArrayList는 분할이 쉽지만 LinkedList는 어려워 병렬화 효과가 적음\n- 연산 특성: stateful 연산이나 순서 의존적인 연산은 병렬화 시 성능 저하 가능\n\n**실무 활용:**\n- 대용량 데이터 필터링, 변환, 집계 작업을 선언적이고 간결한 코드로 구현\n- CPU 집약적인 작업에 병렬 스트림을 적용하여 멀티코어 활용도 향상\n- Collectors를 활용하여 groupingBy, partitioningBy 등 복잡한 집계 로직을 간단하게 표현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성"
      ],
      "id": "1763437633097-cwjcwn5b",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Optional 클래스의 필요성과 올바른 사용 방법은 무엇인가요?",
      "answer": "**정의:**\nOptional은 Java 8에서 도입된 컨테이너 클래스로, 값이 있을 수도 없을 수도 있는 상황을 명시적으로 표현합니다. null 참조로 인한 NullPointerException을 방지하고, 값의 존재 여부를 타입 시스템으로 표현하여 안전한 코드 작성을 유도합니다.\n\n**특징/원리:**\n- null 안전성: null을 직접 다루지 않고 Optional로 감싸 NullPointerException 위험 감소\n- 명시적 표현: 메서드 반환 타입을 Optional로 선언하여 값이 없을 수 있음을 명시\n- 함수형 API: map, flatMap, filter, orElse 등 함수형 메서드로 안전하고 간결한 처리\n- 불변 컨테이너: Optional 객체는 불변이며 값의 유무만 나타냄\n\n**주요 메서드:**\n- of(): null이 아닌 값으로 Optional 생성, null 전달 시 NullPointerException 발생\n- ofNullable(): null일 수 있는 값으로 Optional 생성, null이면 empty Optional 반환\n- empty(): 빈 Optional 인스턴스 생성\n- isPresent(): 값이 있으면 true, isEmpty()는 값이 없으면 true\n- get(): 값을 반환하지만 값이 없으면 NoSuchElementException 발생하여 사용 지양\n- orElse(): 값이 있으면 반환하고 없으면 기본값 반환\n- orElseGet(): 값이 없을 때만 Supplier 실행하여 기본값 생성\n- orElseThrow(): 값이 없으면 예외 발생\n\n**잘못된 사용 패턴:**\n- isPresent() 확인 후 get() 호출: null 체크와 다를 바 없어 Optional의 이점 상실\n- Optional을 필드로 사용: 직렬화 불가하고 메모리 오버헤드 증가\n- Optional을 메서드 파라미터로 사용: 호출자에게 부담을 주며 null 전달 가능성 여전히 존재\n- 컬렉션을 Optional로 감싸기: 빈 컬렉션으로 충분하며 불필요한 복잡도 증가\n\n**올바른 사용 방법:**\n- 메서드 반환 타입으로만 사용하여 값이 없을 수 있음을 명시\n- orElse, orElseGet, orElseThrow로 값이 없는 경우를 명시적으로 처리\n- map, flatMap을 체이닝하여 null 체크 없이 안전하게 변환\n- filter로 조건을 추가하고 ifPresent로 값이 있을 때만 동작 수행\n\n**실무 활용:**\n- 데이터베이스 조회 결과가 없을 수 있는 경우 Optional로 반환하여 호출자가 안전하게 처리\n- 설정값이 선택적인 경우 Optional로 표현하여 기본값 처리 로직 간결화\n- Stream API와 결합하여 findFirst(), findAny() 등의 결과를 안전하게 처리",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633097-b766i3tg",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Functional Interface와 Lambda Expression에 대해 설명해주세요.",
      "answer": "**정의:**\nFunctional Interface는 단 하나의 추상 메서드만 가진 인터페이스로, Java 8의 람다 표현식과 메서드 참조의 타입으로 사용됩니다. Lambda Expression은 익명 함수를 간결하게 표현하는 문법으로, 함수형 프로그래밍 스타일을 Java에 도입합니다.\n\n**특징/원리:**\n- SAM 인터페이스: Single Abstract Method를 가진 인터페이스만 Functional Interface로 인정\n- @FunctionalInterface: 어노테이션으로 명시하여 컴파일러가 검증하도록 하며 선택사항\n- 타입 추론: 람다 표현식의 파라미터 타입은 컨텍스트로부터 추론 가능하여 생략 가능\n- 클로저: 람다는 자신이 정의된 스코프의 변수를 캡처할 수 있지만 effectively final이어야 함\n\n**주요 내장 Functional Interface:**\n- Predicate: T를 받아 boolean 반환, test() 메서드로 조건 검사\n- Function: T를 받아 R 반환, apply() 메서드로 변환 수행\n- Consumer: T를 받아 void 반환, accept() 메서드로 소비 동작 수행\n- Supplier: 파라미터 없이 T 반환, get() 메서드로 값 공급\n- BiFunction, BiConsumer: 두 개의 파라미터를 받는 변형\n- UnaryOperator, BinaryOperator: 입력과 출력 타입이 같은 특수 Function\n\n**Lambda 문법:**\n- 기본 형식: (파라미터) -> { 실행문 }\n- 단일 표현식: (파라미터) -> 표현식, 중괄호와 return 생략 가능\n- 파라미터 타입 생략: 타입 추론 가능하면 (x, y) -> x + y 형태로 간결하게 작성\n- 단일 파라미터: 괄호 생략 가능하여 x -> x * 2 형태 가능\n\n**실무 활용:**\n- Stream API의 filter, map, reduce 등에 람다로 간결한 데이터 처리 로직 전달\n- 이벤트 리스너나 콜백을 람다로 구현하여 익명 클래스의 보일러플레이트 제거\n- 전략 패턴 구현 시 여러 구현 클래스 대신 람다로 다양한 전략을 간단하게 정의",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-u9jrr81a",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Method Reference의 종류와 사용 방법을 설명해주세요.",
      "answer": "**정의:**\nMethod Reference는 람다 표현식을 더욱 간결하게 표현하는 문법으로, 이미 존재하는 메서드를 참조하여 사용합니다. 람다가 단순히 메서드를 호출하기만 하는 경우, 메서드 참조로 더 명확하고 간결하게 표현할 수 있습니다.\n\n**특징/원리:**\n- 가독성 향상: 람다보다 더 직관적이고 간결한 표현으로 코드 의도 명확화\n- 재사용성: 기존 메서드를 재사용하여 중복 코드 제거\n- 컴파일러 검증: 메서드 시그니처가 Functional Interface와 일치하는지 컴파일 타임에 검증\n- 이중 콜론 연산자: :: 기호를 사용하여 클래스나 인스턴스와 메서드를 연결\n\n**Method Reference 종류:**\n- 정적 메서드 참조: ClassName::staticMethod 형태로 클래스의 정적 메서드 참조\n- 인스턴스 메서드 참조: instance::instanceMethod 형태로 특정 객체의 인스턴스 메서드 참조\n- 타입의 인스턴스 메서드 참조: ClassName::instanceMethod 형태로 첫 번째 파라미터가 메서드 호출 대상\n- 생성자 참조: ClassName::new 형태로 생성자를 참조하여 객체 생성\n\n**각 종류의 사용 예시:**\n- 정적 메서드: Integer::parseInt는 String을 받아 int를 반환하는 Function으로 사용\n- 인스턴스 메서드: System.out::println은 Object를 받아 출력하는 Consumer로 사용\n- 타입 메서드: String::toUpperCase는 String을 받아 대문자로 변환하는 Function으로 사용\n- 생성자: ArrayList::new는 새로운 ArrayList를 생성하는 Supplier로 사용\n\n**실무 활용:**\n- Stream API에서 map(String::trim), forEach(System.out::println) 등으로 간결한 처리\n- Comparator.comparing(Person::getName)처럼 getter 메서드 참조로 정렬 기준 정의\n- collect(Collectors.toCollection(LinkedList::new))로 특정 컬렉션 타입으로 수집",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-fhmhi7vi",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "CompletableFuture의 동작 원리와 사용 방법을 설명해주세요.",
      "answer": "**정의:**\nCompletableFuture는 Java 8에서 도입된 비동기 프로그래밍을 위한 클래스로, Future 인터페이스를 확장하여 명시적으로 완료 가능하고 함수형 스타일로 조합할 수 있는 기능을 제공합니다. 비동기 작업의 결과를 다루고 여러 비동기 작업을 조합하는 강력한 API를 제공합니다.\n\n**특징/원리:**\n- 명시적 완료: complete() 메서드로 수동으로 결과를 설정 가능\n- 비블로킹: get() 대신 thenApply, thenAccept 등으로 비블로킹 방식으로 결과 처리\n- 함수형 조합: 여러 비동기 작업을 체이닝하거나 병합하여 복잡한 비동기 로직 구성\n- 예외 처리: exceptionally, handle 등으로 비동기 작업의 예외를 우아하게 처리\n\n**주요 메서드:**\n- supplyAsync: Supplier를 비동기로 실행하고 결과를 CompletableFuture로 반환\n- runAsync: Runnable을 비동기로 실행하며 결과가 없는 CompletableFuture 반환\n- thenApply: 결과를 변환하는 Function을 적용하여 새로운 CompletableFuture 반환\n- thenAccept: 결과를 소비하는 Consumer를 적용하며 void CompletableFuture 반환\n- thenCompose: 중첩된 CompletableFuture를 평탄화하여 순차 비동기 작업 체이닝\n- thenCombine: 두 CompletableFuture를 병렬로 실행하고 결과를 조합\n\n**비동기 작업 조합:**\n- allOf: 여러 CompletableFuture가 모두 완료될 때까지 대기\n- anyOf: 여러 CompletableFuture 중 하나라도 완료되면 진행\n- 순차 처리: thenCompose로 앞 작업의 결과를 다음 작업의 입력으로 사용\n- 병렬 처리: thenCombine으로 독립적인 작업을 동시 실행하고 결과 병합\n\n**예외 처리:**\n- exceptionally: 예외 발생 시 기본값 반환하거나 대체 로직 실행\n- handle: 정상 결과와 예외를 모두 처리하는 BiFunction 제공\n- whenComplete: 결과나 예외를 소비하지만 값을 변경하지 않음\n- completeExceptionally: 수동으로 예외 상태로 완료 설정\n\n**실무 활용:**\n- 여러 외부 API 호출을 병렬로 수행하고 모든 결과를 조합하여 응답 생성\n- 데이터베이스 조회와 캐시 조회를 동시에 수행하고 먼저 완료된 결과 사용\n- 긴 실행 시간의 작업을 백그라운드에서 비동기로 처리하고 완료 시 콜백 실행",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "캐시"
      ],
      "id": "1763437633097-at76x3f3",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 리플렉션(Reflection)이란 무엇이고 언제 사용하나요?",
      "answer": "**정의:**\n리플렉션은 런타임에 클래스, 메서드, 필드 등의 정보를 조사하고 조작할 수 있는 Java API입니다. 컴파일 타임에 알 수 없는 클래스를 동적으로 로드하고 인스턴스를 생성하며, private 멤버에도 접근할 수 있는 강력하지만 신중하게 사용해야 하는 기능입니다.\n\n**특징/원리:**\n- 런타임 타입 정보: Class 객체를 통해 클래스의 구조와 메타데이터를 런타임에 확인\n- 동적 접근: private, protected 멤버에도 setAccessible(true)로 접근 가능\n- 타입 안전성 부재: 컴파일 타임 타입 체크 없이 런타임에 ClassCastException 발생 가능\n- 성능 오버헤드: 일반 메서드 호출보다 리플렉션을 통한 호출이 훨씬 느림\n\n**주요 클래스와 메서드:**\n- Class: 클래스 정보를 담는 객체로 getClass(), forName(), getName() 등 제공\n- Field: 필드 정보를 담으며 get(), set()으로 값을 읽고 쓸 수 있음\n- Method: 메서드 정보를 담으며 invoke()로 메서드를 동적으로 호출\n- Constructor: 생성자 정보를 담으며 newInstance()로 객체를 동적으로 생성\n- Modifier: 접근 제어자, static, final 등의 수정자 정보 확인\n\n**사용 사례:**\n- 프레임워크: Spring의 DI 컨테이너가 리플렉션으로 빈을 생성하고 의존성 주입\n- 직렬화: Jackson, Gson 등의 라이브러리가 리플렉션으로 객체를 JSON으로 변환\n- ORM: Hibernate, JPA가 리플렉션으로 엔티티 객체와 데이터베이스 매핑\n- 테스트: Mockito 같은 목 프레임워크가 리플렉션으로 동적 프록시 생성\n- 플러그인 시스템: 런타임에 동적으로 클래스를 로드하여 확장 기능 제공\n\n**주의사항:**\n- 성능: 자주 호출되는 코드에는 부적합하며 캐싱 등으로 최적화 필요\n- 보안: 접근 제어를 우회하므로 SecurityManager가 있는 환경에서 제약\n- 캡슐화 위반: private 멤버 접근은 객체지향 원칙을 해치므로 최후의 수단으로만 사용\n- 유지보수: 컴파일 타임 검증이 안 되어 리팩토링 시 오류 발견이 어려움\n\n**실무 활용:**\n- 애노테이션 기반 설정을 읽어 자동으로 빈을 등록하거나 검증 로직 수행\n- 범용 유틸리티 메서드로 임의의 객체를 복사하거나 비교하는 기능 구현\n- 레거시 코드의 private 메서드를 테스트하기 위해 제한적으로 리플렉션 사용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "Spring",
        "DI"
      ],
      "id": "1763437633097-ctxqds6j",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "동적 프록시(Dynamic Proxy)의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\n동적 프록시는 런타임에 인터페이스의 구현체를 동적으로 생성하는 기술로, 원본 객체에 대한 접근을 제어하거나 부가 기능을 추가할 수 있습니다. Java의 Proxy 클래스와 InvocationHandler 인터페이스를 사용하여 구현하며, AOP의 핵심 메커니즘입니다.\n\n**특징/원리:**\n- 런타임 생성: 컴파일 타임이 아닌 런타임에 프록시 클래스를 생성하여 유연성 제공\n- 인터페이스 기반: Java의 동적 프록시는 인터페이스를 구현하는 방식으로만 동작\n- 메서드 가로채기: 모든 메서드 호출이 InvocationHandler의 invoke() 메서드로 전달\n- 투명성: 클라이언트는 프록시인지 실제 객체인지 알 필요 없이 인터페이스로 접근\n\n**핵심 구성 요소:**\n- Proxy 클래스: newProxyInstance() 정적 메서드로 프록시 인스턴스 생성\n- InvocationHandler: invoke() 메서드를 구현하여 메서드 호출 시 실행될 로직 정의\n- ClassLoader: 프록시 클래스를 로드할 클래스 로더 지정\n- Interfaces: 프록시가 구현할 인터페이스 배열\n\n**동작 흐름:**\n- 프록시 인스턴스 생성 시 ClassLoader, 인터페이스 배열, InvocationHandler 전달\n- 클라이언트가 프록시의 메서드를 호출하면 InvocationHandler의 invoke() 메서드로 위임\n- invoke() 메서드에서 원본 객체의 메서드 호출 전후로 부가 기능 수행\n- 메서드 실행 결과를 클라이언트에게 반환\n\n**활용 패턴:**\n- 로깅: 메서드 호출 전후로 로그를 기록하여 디버깅이나 모니터링 지원\n- 트랜잭션: 메서드 실행 전 트랜잭션 시작하고 완료 후 커밋 또는 예외 시 롤백\n- 권한 검사: 메서드 실행 전 사용자 권한을 확인하여 접근 제어\n- 캐싱: 메서드 결과를 캐시하여 동일한 요청 시 캐시된 값 반환\n- 지연 로딩: 실제 메서드 호출 시점까지 리소스 로딩을 지연\n\n**실무 활용:**\n- Spring AOP가 내부적으로 JDK 동적 프록시나 CGLIB을 사용하여 횡단 관심사 구현\n- MyBatis의 Mapper 인터페이스가 동적 프록시로 구현되어 SQL 실행\n- Mock 프레임워크인 Mockito가 동적 프록시로 테스트 더블 생성",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "캐시",
        "Spring"
      ],
      "id": "1763437633097-2ppihxfe",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Annotation의 동작 원리와 커스텀 Annotation 작성 방법은 무엇인가요?",
      "answer": "**정의:**\nAnnotation은 코드에 메타데이터를 추가하는 선언적 방식으로, 컴파일러나 런타임에 추가 정보를 제공합니다. @ 기호로 시작하며, 클래스, 메서드, 필드 등에 적용되어 코드의 동작을 변경하거나 추가 처리를 지시할 수 있습니다.\n\n**특징/원리:**\n- 메타데이터: 코드에 대한 데이터로, 코드 자체는 변경하지 않고 추가 정보만 제공\n- 컴파일러 지시: @Override, @SuppressWarnings 등은 컴파일 타임에 검증이나 경고 제어\n- 런타임 처리: 리플렉션을 통해 런타임에 어노테이션 정보를 읽어 동적으로 처리\n- 타입 안전성: 어노테이션 요소는 타입이 있어 컴파일 타임에 유효성 검증\n\n**주요 메타 어노테이션:**\n- @Target: 어노테이션을 적용할 수 있는 위치 지정 (TYPE, METHOD, FIELD 등)\n- @Retention: 어노테이션 정보를 유지할 시점 지정 (SOURCE, CLASS, RUNTIME)\n- @Documented: JavaDoc에 어노테이션 정보를 포함할지 여부\n- @Inherited: 하위 클래스가 상위 클래스의 어노테이션을 상속받을지 여부\n- @Repeatable: 같은 어노테이션을 여러 번 적용 가능하도록 지정\n\n**커스텀 Annotation 작성:**\n- @interface 키워드로 어노테이션 타입 정의\n- 요소는 메서드 형태로 선언하며 기본값 지정 가능\n- 요소 타입은 기본 타입, String, Class, enum, 어노테이션, 배열만 가능\n- @Retention을 RUNTIME으로 설정해야 리플렉션으로 읽을 수 있음\n\n**어노테이션 처리 방법:**\n- 컴파일 타임: Annotation Processor API로 컴파일 시 코드 생성이나 검증\n- 런타임: 리플렉션으로 getAnnotation(), isAnnotationPresent() 등을 사용하여 정보 읽기\n- 프레임워크 통합: Spring, JPA 등이 어노테이션을 읽어 자동 설정 및 기능 제공\n\n**실무 활용:**\n- Spring의 @Component, @Service, @Repository로 빈 자동 등록 및 역할 명시\n- JPA의 @Entity, @Table, @Column으로 객체-관계 매핑 정보 선언\n- 커스텀 검증 어노테이션을 작성하여 비즈니스 규칙을 선언적으로 표현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "프로세스",
        "Spring"
      ],
      "id": "1763437633097-peoamz1h",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 직렬화(Serialization)와 역직렬화에 대해 설명해주세요.",
      "answer": "**정의:**\n직렬화는 객체를 바이트 스트림으로 변환하는 과정이며, 역직렬화는 바이트 스트림을 다시 객체로 복원하는 과정입니다. 객체를 파일에 저장하거나 네트워크로 전송하기 위해 사용되며, Serializable 인터페이스를 구현하여 직렬화 가능하게 만듭니다.\n\n**특징/원리:**\n- 마커 인터페이스: Serializable은 메서드가 없는 마커 인터페이스로 직렬화 가능함을 표시\n- 자동 직렬화: ObjectOutputStream이 객체의 모든 필드를 자동으로 직렬화\n- 그래프 순회: 객체가 참조하는 다른 객체들도 재귀적으로 직렬화\n- 타입 정보 포함: 클래스 메타데이터가 포함되어 역직렬화 시 타입 복원\n\n**직렬화 프로세스:**\n- ObjectOutputStream의 writeObject()로 객체를 바이트 스트림으로 변환\n- 모든 인스턴스 필드가 직렬화되며, static과 transient 필드는 제외\n- 참조하는 객체들도 모두 Serializable이어야 하며, 아니면 NotSerializableException 발생\n- serialVersionUID로 클래스 버전을 식별하여 호환성 관리\n\n**역직렬화 프로세스:**\n- ObjectInputStream의 readObject()로 바이트 스트림을 객체로 복원\n- 생성자를 호출하지 않고 리플렉션으로 객체를 생성하여 필드 값 설정\n- serialVersionUID가 일치하지 않으면 InvalidClassException 발생\n- 보안상 신뢰할 수 없는 데이터의 역직렬화는 위험하므로 주의 필요\n\n**커스터마이징:**\n- writeObject()와 readObject() 메서드를 정의하여 직렬화 과정 커스터마이징\n- writeReplace()로 직렬화 전 다른 객체로 대체\n- readResolve()로 역직렬화 후 객체를 변경하거나 싱글톤 보장\n- Externalizable 인터페이스로 완전히 수동으로 직렬화 제어\n\n**주의사항:**\n- 보안: 역직렬화는 임의의 코드 실행을 유발할 수 있어 신뢰할 수 없는 데이터에는 사용 금지\n- 호환성: 클래스 구조 변경 시 이전 버전과의 호환성 깨질 수 있음\n- 성능: 직렬화/역직렬화는 느리고 바이트 스트림 크기가 큼\n- 대안: JSON, Protocol Buffers 등 더 효율적이고 안전한 직렬화 방식 고려\n\n**실무 활용:**\n- 세션 정보를 직렬화하여 분산 환경에서 공유하거나 영속화\n- 캐시 저장소에 객체를 직렬화하여 저장하고 필요 시 복원\n- 메시징 시스템에서 메시지 객체를 직렬화하여 전송",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "네트워크",
        "세션"
      ],
      "id": "1763437633097-yaxk1xr8",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "serialVersionUID의 역할은 무엇인가요?",
      "answer": "**정의:**\nserialVersionUID는 직렬화된 클래스의 버전을 식별하는 고유 식별자로, 역직렬화 시 클래스의 호환성을 검증하는 데 사용됩니다. 명시적으로 선언하지 않으면 컴파일러가 자동 생성하지만, 명시적 선언을 권장합니다.\n\n**특징/원리:**\n- 버전 관리: 직렬화된 객체와 역직렬화할 클래스의 버전이 동일한지 확인\n- 호환성 검증: serialVersionUID가 일치하지 않으면 InvalidClassException 발생\n- 자동 생성: 명시하지 않으면 클래스 구조를 기반으로 해시값 자동 생성\n- 타입: private static final long으로 선언\n\n**자동 생성의 문제점:**\n- 예측 불가능: 컴파일러마다 생성 알고리즘이 다를 수 있어 일관성 부족\n- 불필요한 변경: 메서드 추가나 주석 변경 같은 사소한 수정에도 값이 변경될 수 있음\n- 호환성 깨짐: 의도치 않게 serialVersionUID가 변경되어 기존 직렬화 데이터를 읽지 못함\n- 디버깅 어려움: 호환성 문제 발생 시 원인 파악이 어려움\n\n**명시적 선언 이점:**\n- 버전 제어: 개발자가 의도적으로 버전을 관리하여 호환성 결정\n- 안정성: 클래스 변경에도 serialVersionUID를 유지하여 하위 호환성 보장\n- 명확성: 직렬화 가능 클래스임을 명시적으로 표현\n- 성능: 자동 생성 오버헤드 제거\n\n**버전 관리 전략:**\n- 초기값: 일반적으로 1L로 시작하여 필요 시 증가\n- 호환 가능 변경: 필드 추가, 메서드 추가 등은 serialVersionUID 유지\n- 비호환 변경: 필드 타입 변경, 삭제 등은 serialVersionUID 증가\n- 마이그레이션: readObject()에서 이전 버전 데이터를 새 버전으로 변환하는 로직 구현\n\n**실무 활용:**\n- 모든 Serializable 클래스에 명시적으로 serialVersionUID 선언하여 예측 가능한 동작 보장\n- IDE의 경고를 활성화하여 serialVersionUID 누락 시 알림 받도록 설정\n- 버전 관리 정책을 문서화하여 팀원들이 일관되게 관리",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-kwh70qlr",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Java의 모듈 시스템(Java 9+)에 대해 설명해주세요.",
      "answer": "**정의:**\nJava 모듈 시스템(JPMS, Java Platform Module System)은 Java 9에서 도입된 기능으로, 코드를 모듈 단위로 구조화하고 명시적으로 의존성을 선언하여 캡슐화와 신뢰성을 향상시킵니다. module-info.java 파일로 모듈을 정의하며, 강력한 캡슐화를 제공합니다.\n\n**특징/원리:**\n- 강력한 캡슐화: 명시적으로 export하지 않은 패키지는 외부에서 접근 불가\n- 명시적 의존성: requires 키워드로 필요한 모듈을 명시하여 의존 관계 명확화\n- 신뢰성: 컴파일 타임과 런타임에 모듈 의존성 검증하여 ClassNotFoundException 방지\n- 성능: 필요한 모듈만 로드하여 메모리 사용량 감소 및 시작 시간 단축\n\n**module-info.java 구성 요소:**\n- module 선언: 모듈 이름을 고유하게 정의\n- requires: 이 모듈이 의존하는 다른 모듈 명시\n- exports: 외부에 공개할 패키지 선언\n- opens: 리플렉션 접근을 허용할 패키지 지정\n- provides와 uses: 서비스 제공자와 소비자 관계 정의\n\n**주요 키워드:**\n- requires: 다른 모듈에 대한 의존성 선언, requires transitive로 전이적 의존성 표현\n- exports: 패키지를 모든 모듈에 공개, exports to로 특정 모듈에만 공개\n- opens: 리플렉션을 위해 패키지를 런타임에 개방, opens to로 특정 모듈에만 개방\n- uses: 서비스 인터페이스 사용 선언\n- provides with: 서비스 구현체 제공 선언\n\n**모듈 유형:**\n- 명명된 모듈: module-info.java를 가진 모듈로 강력한 캡슐화 적용\n- 자동 모듈: module-info가 없는 JAR를 모듈 경로에 두면 자동으로 모듈화되며 모든 패키지 export\n- 무명 모듈: 클래스 경로에 있는 모든 코드로 모듈 시스템 밖에 존재\n\n**실무 활용:**\n- 대규모 프로젝트를 모듈로 분리하여 명확한 경계와 의존성 관리\n- 내부 API를 숨기고 공개 API만 export하여 캡슐화 강화\n- 서비스 로더 패턴을 uses와 provides로 구현하여 플러그인 아키텍처 구축",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633097-52zai658",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "var 키워드(Java 10+)의 사용과 제한사항은 무엇인가요?",
      "answer": "**정의:**\nvar 키워드는 Java 10에서 도입된 지역 변수 타입 추론 기능으로, 컴파일러가 초기화 표현식으로부터 변수의 타입을 자동으로 추론합니다. 명시적 타입 선언을 생략하여 코드를 간결하게 만들지만, 가독성을 해치지 않는 범위에서 사용해야 합니다.\n\n**특징/원리:**\n- 컴파일 타임 추론: 컴파일러가 우변의 표현식으로부터 타입을 추론하며 런타임 오버헤드 없음\n- 강타입 유지: 추론된 후에는 해당 타입으로 고정되며 다른 타입 할당 불가\n- 지역 변수 전용: 메서드 내 지역 변수에만 사용 가능하며 필드, 메서드 파라미터, 리턴 타입에는 사용 불가\n- 초기화 필수: var 선언 시 반드시 초기화 표현식 필요\n\n**사용 가능한 위치:**\n- 지역 변수: 메서드 내에서 선언하는 변수에 사용 가능\n- for 루프: 향상된 for문과 전통적 for문의 초기화 부분에서 사용 가능\n- try-with-resources: 리소스 선언에 사용 가능\n- 람다 파라미터: Java 11부터 람다 표현식의 파라미터에도 사용 가능하며 어노테이션 추가 가능\n\n**제한사항:**\n- 초기화 없는 선언 불가: var x; 같은 선언은 불가능하며 반드시 초기값 필요\n- null 초기화 불가: var x = null;은 타입 추론 불가하여 컴파일 에러\n- 필드 불가: 클래스나 인스턴스 필드에는 사용 불가\n- 메서드 시그니처 불가: 파라미터, 리턴 타입에는 사용 불가\n- 배열 초기화: var arr = {1, 2, 3};은 불가하며 new int[]{1, 2, 3} 필요\n\n**가독성 고려사항:**\n- 명확한 경우: var list = new ArrayList<String>(); 처럼 우변이 명확하면 사용 권장\n- 불명확한 경우: var result = process(); 처럼 반환 타입이 명확하지 않으면 사용 지양\n- 다이아몬드 연산자: var map = new HashMap<>();는 HashMap<Object, Object>로 추론되므로 주의\n- 네이밍: 변수명을 명확하게 작성하여 추론된 타입을 알 수 있도록 함\n\n**실무 활용:**\n- 긴 제네릭 타입 선언을 var로 간결하게 표현하여 가독성 향상\n- Stream API나 복잡한 빌더 패턴 사용 시 var로 중간 변수 타입 생략\n- 코드 리팩토링 시 타입 변경이 자동으로 반영되어 유지보수성 향상",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-s40jpypy",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Record 클래스(Java 14+)의 특징과 사용 시나리오를 설명해주세요.",
      "answer": "**정의:**\nRecord는 Java 14에서 프리뷰로 도입되어 Java 16에서 정식 기능이 된 특수한 클래스로, 불변 데이터를 저장하는 투명한 캐리어 역할을 합니다. 보일러플레이트 코드 없이 간결하게 데이터 클래스를 정의할 수 있으며, 자동으로 생성자, getter, equals, hashCode, toString을 제공합니다.\n\n**특징/원리:**\n- 불변성: 모든 필드가 final이며 setter가 없어 생성 후 변경 불가\n- 자동 생성: 컴파일러가 표준 메서드들을 자동으로 생성하여 보일러플레이트 제거\n- 투명성: 클래스의 상태가 선언된 필드로만 구성되어 예측 가능하고 명확\n- 간결성: 한 줄로 데이터 클래스 정의 가능하여 코드 양 대폭 감소\n\n**자동 생성 메서드:**\n- 정규 생성자: 모든 필드를 파라미터로 받는 생성자 자동 생성\n- 접근자 메서드: 각 필드에 대한 getter 자동 생성하며, getX() 형태가 아닌 필드명과 동일한 메서드\n- equals(): 모든 필드 값을 비교하는 equals() 메서드 자동 생성\n- hashCode(): 모든 필드를 기반으로 한 hashCode() 메서드 자동 생성\n- toString(): 클래스명과 모든 필드 값을 포함하는 toString() 메서드 자동 생성\n\n**커스터마이징:**\n- Compact 생성자: 파라미터 목록 없이 검증 로직만 작성하면 정규 생성자에 자동 통합\n- 명시적 생성자: 정규 생성자를 명시적으로 정의하여 검증이나 정규화 수행\n- 메서드 오버라이드: 자동 생성된 메서드를 재정의하여 커스텀 동작 구현\n- 추가 메서드: 일반 메서드와 static 메서드 정의 가능\n\n**제약사항:**\n- 상속 불가: Record는 암묵적으로 final이며 다른 클래스를 상속하거나 상속될 수 없음\n- 필드 불변: 모든 필드는 final이어야 하며 변경 불가\n- 인스턴스 필드 추가 불가: 선언한 필드 외에 추가 인스턴스 필드 정의 불가\n- 네이티브 메서드 불가: Record에서는 네이티브 메서드 정의 불가\n\n**실무 활용:**\n- DTO나 VO 같은 데이터 전달 객체를 Record로 간결하게 정의\n- 불변 설정 클래스나 설정 객체를 Record로 구현하여 안전성 확보\n- Stream API의 중간 결과나 튜플처럼 여러 값을 묶어 반환할 때 사용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-nhpzi9bn",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Sealed Class(Java 17+)란 무엇이고 왜 필요한가요?",
      "answer": "**정의:**\nSealed Class는 Java 17에서 정식 기능이 된 것으로, 어떤 클래스가 이 클래스를 상속하거나 구현할 수 있는지를 명시적으로 제한하는 기능입니다. permits 키워드로 허용된 하위 타입만 상속 가능하여 타입 계층을 더 안전하고 예측 가능하게 만듭니다.\n\n**특징/원리:**\n- 제한된 상속: sealed 클래스는 permits로 명시된 클래스만 상속 가능\n- 완전성 검증: 컴파일러가 모든 하위 타입을 알고 있어 switch 문에서 완전성 체크 가능\n- 명시적 계층: 타입 계층 구조를 코드에 명확히 표현하여 이해하기 쉬움\n- 하위 타입 선택: 하위 클래스는 final, sealed, non-sealed 중 하나로 선언 필수\n\n**하위 클래스 수정자:**\n- final: 더 이상 상속 불가능하며 계층 종료\n- sealed: 또 다시 제한된 하위 타입만 허용하는 sealed 클래스\n- non-sealed: sealed 제약을 해제하여 누구나 상속 가능하게 개방\n\n**permits 절:**\n- 명시적 선언: permits 키워드로 허용할 하위 클래스 나열\n- 같은 모듈/패키지: 허용된 하위 클래스는 같은 모듈이나 패키지에 있어야 함\n- 암묵적 permits: 같은 파일에 모든 하위 클래스가 있으면 permits 생략 가능\n\n**패턴 매칭과의 시너지:**\n- 완전한 switch: 모든 하위 타입을 알고 있어 switch 문에서 default 불필요\n- 컴파일 검증: 새로운 하위 타입 추가 시 switch 문을 업데이트하지 않으면 컴파일 에러\n- 타입 안전성: instanceof 패턴 매칭과 결합하여 타입 안전한 분기 처리\n\n**실무 활용:**\n- 도메인 모델의 제한된 타입 계층 표현 (예: 결제 수단을 카드, 현금, 포인트로 제한)\n- 상태 패턴 구현 시 가능한 모든 상태를 명시적으로 선언\n- API 설계 시 확장 가능한 부분과 불가능한 부분을 명확히 구분",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-jn4vkgll",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Pattern Matching(Java 14+)의 개선사항을 설명해주세요.",
      "answer": "**정의:**\nPattern Matching은 Java 14부터 단계적으로 도입된 기능으로, 타입 검사와 형변환을 하나의 표현식으로 결합하여 코드를 간결하고 안전하게 만듭니다. instanceof, switch 문 등에서 패턴 매칭을 지원하여 조건 분기 로직을 더 직관적으로 작성할 수 있습니다.\n\n**특징/원리:**\n- 타입 패턴: 타입 검사와 동시에 변수 바인딩을 수행하여 명시적 캐스팅 불필요\n- 스코프: 패턴 변수는 해당 패턴이 성공하는 범위에서만 사용 가능\n- 타입 안전성: 컴파일러가 타입을 보장하여 ClassCastException 방지\n- 가독성: 의도가 명확하게 드러나는 선언적 코드 작성 가능\n\n**instanceof 패턴 매칭:**\n- 전통적 방식: instanceof로 타입 체크 후 명시적 캐스팅 필요\n- 패턴 매칭: if (obj instanceof String s)로 타입 체크와 변수 선언을 동시에 수행\n- 스코프: 조건이 true인 블록 내에서만 패턴 변수 사용 가능\n- 논리 연산: && 연산자로 연결 시 후속 조건에서도 패턴 변수 사용 가능\n\n**switch 표현식 패턴 매칭:**\n- 타입 패턴: case String s -> 형태로 타입별 분기 처리\n- 가드 조건: case String s when s.length() > 10 -> 처럼 추가 조건 지정\n- 완전성: sealed 클래스와 함께 사용 시 모든 하위 타입을 다루면 default 불필요\n- null 처리: case null -> 로 null을 명시적으로 처리 가능\n\n**Record 패턴:**\n- 분해: Record의 컴포넌트를 패턴으로 추출하여 중첩된 구조 분해 가능\n- 네스팅: 중첩된 Record를 한 번에 분해하여 깊은 구조 접근 간소화\n- 타입 안전: 컴파일러가 Record 구조를 검증하여 안전성 보장\n\n**실무 활용:**\n- 다형성 처리 시 instanceof 패턴 매칭으로 타입별 로직을 간결하게 구현\n- sealed 클래스의 하위 타입을 switch로 처리하여 모든 경우를 완전하게 다룸\n- JSON 파싱이나 이벤트 처리 등에서 타입에 따른 분기를 명확하고 안전하게 표현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-gj9z7kin",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "JavaScript의 데이터 타입에 대해 설명해주세요.",
      "answer": "**정의:**\nJavaScript의 데이터 타입은 원시 타입(Primitive Type)과 참조 타입(Reference Type)으로 구분됩니다. 원시 타입은 불변 값으로 스택에 저장되며, 참조 타입은 객체로 힙에 저장되고 참조를 통해 접근합니다.\n\n**특징/원리:**\n- 동적 타입: 변수의 타입이 런타임에 결정되며 실행 중 변경 가능\n- 타입 변환: 암묵적 타입 변환(Type Coercion)이 자동으로 발생하여 예상치 못한 결과 발생 가능\n- typeof 연산자: 변수의 타입을 문자열로 반환하지만 null은 object로 반환되는 버그 존재\n- 느슨한 타입 체크: 동등 연산자(==)는 타입 변환 후 비교하고, 일치 연산자(===)는 타입까지 비교\n\n**원시 타입:**\n- Number: 정수와 실수를 구분하지 않으며 IEEE 754 표준의 64비트 부동소수점 사용\n- String: 문자열로 불변이며 UTF-16 인코딩 사용\n- Boolean: true와 false 두 가지 값만 가짐\n- undefined: 선언되었지만 값이 할당되지 않은 변수의 기본값\n- null: 의도적으로 값이 없음을 나타내는 특수 값\n- Symbol: ES6에서 추가된 유일한 식별자를 생성하는 타입\n- BigInt: ES2020에서 추가된 큰 정수를 다루는 타입\n\n**참조 타입:**\n- Object: 키-값 쌍의 컬렉션으로 객체, 배열, 함수 등이 모두 객체\n- Array: 순서가 있는 값의 목록으로 인덱스로 접근\n- Function: 실행 가능한 코드 블록으로 일급 객체이며 변수에 할당 가능\n- Date, RegExp, Map, Set: 특수 목적의 내장 객체\n\n**실무 활용:**\n- 타입 체크 시 typeof를 사용하되 null과 배열은 별도 처리 필요\n- 일치 연산자(===)를 기본으로 사용하여 예상치 못한 타입 변환 방지\n- TypeScript를 도입하여 정적 타입 체크로 타입 관련 오류를 컴파일 타임에 발견",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-9zbpmp3t",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "var, let, const의 차이점과 호이스팅에 대해 설명해주세요.",
      "answer": "**정의:**\nvar, let, const는 JavaScript에서 변수를 선언하는 키워드로, 스코프, 호이스팅, 재할당 가능 여부 등에서 차이가 있습니다. 호이스팅은 변수와 함수 선언이 스코프의 최상단으로 끌어올려지는 JavaScript의 특성입니다.\n\n**특징/원리:**\n- 스코프: var는 함수 스코프, let과 const는 블록 스코프를 가짐\n- 호이스팅: 모두 호이스팅되지만 let과 const는 Temporal Dead Zone이 존재\n- 재선언: var는 재선언 가능, let과 const는 같은 스코프에서 재선언 불가\n- 재할당: var와 let은 재할당 가능, const는 재할당 불가\n\n**var의 특징:**\n- 함수 스코프: 함수 내에서 선언하면 함수 전체에서 접근 가능하며 블록 무시\n- 호이스팅: 선언이 스코프 최상단으로 끌어올려지고 undefined로 초기화\n- 재선언 허용: 같은 스코프에서 여러 번 선언 가능하여 의도치 않은 버그 발생 가능\n- 전역 객체 속성: 전역 스코프의 var 변수는 window 객체의 속성으로 추가\n\n**let의 특징:**\n- 블록 스코프: 중괄호로 둘러싸인 블록 내에서만 접근 가능\n- TDZ: 선언 전까지 Temporal Dead Zone에 있어 접근 시 ReferenceError 발생\n- 재할당 가능: 값을 변경할 수 있지만 재선언은 불가\n- 반복문: for 루프에서 반복마다 새로운 바인딩 생성\n\n**const의 특징:**\n- 블록 스코프: let과 동일한 블록 스코프\n- 재할당 불가: 선언과 동시에 초기화 필수이며 이후 재할당 불가\n- 객체 불변 아님: 객체나 배열을 가리키는 참조는 고정되지만 내부 속성은 변경 가능\n- 상수 선언: 변경되지 않아야 하는 값을 선언할 때 사용\n\n**호이스팅:**\n- var 호이스팅: 선언이 최상단으로 올라가고 undefined로 초기화되어 선언 전에도 접근 가능\n- let/const 호이스팅: 선언은 올라가지만 초기화는 안 되어 TDZ 구간에서 접근 시 오류\n- 함수 호이스팅: 함수 선언문은 전체가 호이스팅되어 선언 전 호출 가능\n- 함수 표현식: 변수 호이스팅 규칙을 따름\n\n**실무 활용:**\n- const를 기본으로 사용하고, 재할당이 필요한 경우만 let 사용\n- var는 레거시 코드를 제외하고는 사용하지 않음\n- 블록 스코프를 활용하여 변수의 생명주기를 최소화하고 의도치 않은 접근 방지",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-v1darxfo",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "실행 컨텍스트와 스코프 체인에 대해 설명해주세요.",
      "answer": "**정의:**\n실행 컨텍스트는 JavaScript 코드가 실행되는 환경으로, 변수, 함수, this 등의 정보를 담고 있습니다. 스코프 체인은 변수를 찾을 때 현재 스코프부터 상위 스코프로 순차적으로 탐색하는 메커니즘입니다.\n\n**특징/원리:**\n- 실행 스택: 실행 컨텍스트가 LIFO 구조의 스택에 쌓여 관리됨\n- 생성 단계: 변수와 함수 선언을 메모리에 할당하는 Creation Phase\n- 실행 단계: 실제 코드를 한 줄씩 실행하는 Execution Phase\n- 렉시컬 스코프: 함수가 정의된 위치에 따라 스코프가 결정되는 정적 스코프\n\n**실행 컨텍스트 구성 요소:**\n- Variable Environment: var로 선언된 변수와 함수 선언을 저장\n- Lexical Environment: let, const로 선언된 변수를 저장하며 블록 스코프 지원\n- this 바인딩: 함수 호출 방식에 따라 this가 가리키는 객체 결정\n- Outer Environment Reference: 외부 렉시컬 환경에 대한 참조로 스코프 체인 형성\n\n**실행 컨텍스트 종류:**\n- 전역 실행 컨텍스트: 코드 실행 시 가장 먼저 생성되며 하나만 존재\n- 함수 실행 컨텍스트: 함수 호출 시마다 생성되며 여러 개 존재 가능\n- Eval 실행 컨텍스트: eval() 함수 실행 시 생성되지만 사용 권장되지 않음\n\n**스코프 체인:**\n- 변수 검색: 현재 스코프에서 변수를 찾지 못하면 외부 스코프로 이동하여 검색\n- 렉시컬 환경: 함수가 정의될 때 외부 환경에 대한 참조를 저장하여 체인 형성\n- 종료 조건: 전역 스코프까지 도달했는데 변수를 못 찾으면 ReferenceError 발생\n- 성능: 스코프 체인이 길수록 변수 검색 시간이 증가하므로 지역 변수 사용 권장\n\n**실무 활용:**\n- 클로저 이해와 활용을 위한 기본 개념으로 스코프 체인 메커니즘 숙지\n- 변수를 가능한 한 가까운 스코프에 선언하여 검색 속도 향상\n- 전역 변수 남발을 피하고 모듈 패턴이나 IIFE로 스코프 격리",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633097-79lua7jr",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "클로저(Closure)란 무엇이고 어떻게 활용할 수 있나요?",
      "answer": "**정의:**\n클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합으로, 외부 함수의 변수에 접근할 수 있는 내부 함수를 말합니다. 외부 함수가 종료된 후에도 내부 함수는 외부 함수의 변수를 기억하고 접근할 수 있어 데이터 은닉과 상태 유지에 활용됩니다.\n\n**특징/원리:**\n- 렉시컬 스코프: 함수가 정의될 때의 스코프를 기억하여 외부 변수에 접근\n- 메모리 유지: 외부 함수 종료 후에도 내부 함수가 참조하는 변수는 가비지 컬렉션되지 않음\n- 데이터 은닉: 외부에서 직접 접근할 수 없는 private 변수 구현 가능\n- 함수 팩토리: 클로저를 반환하는 함수로 설정이 다른 함수들을 생성\n\n**동작 메커니즘:**\n- 외부 함수 실행: 외부 함수가 호출되어 실행 컨텍스트 생성\n- 내부 함수 정의: 내부 함수가 정의되면서 외부 렉시컬 환경을 참조\n- 외부 함수 종료: 외부 함수가 종료되어 실행 컨텍스트는 스택에서 제거되지만 렉시컬 환경은 유지\n- 클로저 실행: 내부 함수가 실행될 때 저장된 외부 환경에 접근하여 변수 사용\n\n**활용 패턴:**\n- 데이터 캡슐화: private 변수를 만들어 외부에서 직접 접근 못하게 하고 메서드로만 접근 허용\n- 함수 팩토리: 매개변수를 받아 특정 동작을 하는 함수를 생성하여 반환\n- 콜백 함수: 이벤트 핸들러나 setTimeout에서 외부 변수를 기억하는 함수 전달\n- 모듈 패턴: 즉시 실행 함수와 클로저로 private/public 멤버를 가진 모듈 구현\n\n**주의사항:**\n- 메모리 누수: 클로저가 더 이상 필요 없는데도 외부 변수를 참조하면 메모리 누수 발생 가능\n- 반복문 주의: var로 선언된 변수를 클로저에서 참조 시 예상과 다른 값 참조 가능\n- 성능: 클로저 생성과 메모리 유지에 오버헤드가 있으므로 과도한 사용 지양\n- 디버깅: 스코프 체인이 복잡해져 디버깅이 어려울 수 있음\n\n**실무 활용:**\n- React의 useState 훅이 클로저를 활용하여 상태를 함수 외부에서 유지\n- 이벤트 핸들러에서 특정 데이터를 기억하는 콜백 함수 생성\n- 모듈 패턴으로 라이브러리의 내부 구현을 숨기고 공개 API만 노출",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "메모리"
      ],
      "id": "1763437633097-opthgplp",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "this 바인딩의 종류와 동작 원리를 설명해주세요.",
      "answer": "**정의:**\nthis는 함수가 호출될 때 결정되는 특수한 식별자로, 함수가 속한 객체나 실행 컨텍스트를 가리킵니다. JavaScript의 this는 함수 호출 방식에 따라 동적으로 바인딩되며, 명시적으로 바인딩을 변경할 수도 있습니다.\n\n**특징/원리:**\n- 동적 바인딩: 함수 정의 시점이 아닌 호출 시점에 this가 결정됨\n- 호출 방식 의존: 어떻게 함수를 호출하느냐에 따라 this가 가리키는 대상이 달라짐\n- 암묵적 소실: 메서드를 변수에 할당하거나 콜백으로 전달하면 this 바인딩이 소실될 수 있음\n- 화살표 함수 예외: 화살표 함수는 this를 바인딩하지 않고 상위 스코프의 this 사용\n\n**this 바인딩 종류:**\n- 기본 바인딩: 일반 함수 호출 시 전역 객체(브라우저에서는 window)에 바인딩되며, strict mode에서는 undefined\n- 암묵적 바인딩: 객체의 메서드로 호출 시 해당 객체에 바인딩\n- 명시적 바인딩: call, apply, bind 메서드로 명시적으로 this를 지정\n- new 바인딩: new 키워드로 생성자 함수 호출 시 새로 생성된 객체에 바인딩\n\n**명시적 바인딩 메서드:**\n- call: 첫 번째 인자로 this를 지정하고 나머지는 개별 인자로 전달하여 함수 즉시 실행\n- apply: call과 유사하지만 인자를 배열로 전달\n- bind: this가 고정된 새로운 함수를 반환하며 나중에 호출 가능\n\n**바인딩 우선순위:**\n- new 바인딩이 가장 높은 우선순위\n- 명시적 바인딩(bind, call, apply)이 그 다음\n- 암묵적 바인딩(객체 메서드)이 그 다음\n- 기본 바인딩이 가장 낮은 우선순위\n\n**실무 활용:**\n- 이벤트 핸들러에서 bind로 this를 고정하여 컴포넌트 메서드를 안전하게 전달\n- 배열 메서드의 두 번째 인자로 this를 전달하여 콜백 내에서 원하는 객체 참조\n- 화살표 함수를 사용하여 상위 스코프의 this를 자동으로 유지",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-sk7pba0k",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "화살표 함수와 일반 함수의 차이점은 무엇인가요?",
      "answer": "**정의:**\n화살표 함수는 ES6에서 도입된 간결한 함수 표현식으로, function 키워드 대신 화살표(=>)를 사용합니다. 일반 함수와는 this 바인딩, arguments 객체, 생성자 사용 등에서 중요한 차이가 있습니다.\n\n**특징/원리:**\n- 간결한 문법: function 키워드와 중괄호를 생략할 수 있어 코드가 간결함\n- 렉시컬 this: 자신만의 this를 생성하지 않고 상위 스코프의 this를 그대로 사용\n- 비생성자: 생성자 함수로 사용할 수 없으며 new 키워드와 함께 사용 불가\n- arguments 없음: arguments 객체를 갖지 않으며 rest 파라미터로 대체\n\n**this 바인딩 차이:**\n- 일반 함수: 호출 방식에 따라 this가 동적으로 결정됨\n- 화살표 함수: 정의될 때 상위 스코프의 this를 캡처하여 고정\n- 메서드: 객체 메서드는 일반 함수로 정의해야 객체를 this로 참조 가능\n- 콜백: 콜백 함수는 화살표 함수로 정의하면 외부 this를 자연스럽게 유지\n\n**생성자 함수 차이:**\n- 일반 함수: new 키워드로 인스턴스 생성 가능하며 prototype 프로퍼티 보유\n- 화살표 함수: new로 호출 시 TypeError 발생하며 prototype 프로퍼티 없음\n- 메서드 정의: 클래스 메서드나 객체 메서드는 일반 함수로 정의 필요\n\n**arguments 객체:**\n- 일반 함수: 모든 인자를 담은 유사 배열 객체인 arguments 제공\n- 화살표 함수: arguments가 없으며 상위 함수의 arguments 참조\n- rest 파라미터: 화살표 함수에서는 ...args로 가변 인자 처리\n\n**실무 활용:**\n- 콜백 함수나 고차 함수의 인자로는 화살표 함수 사용하여 this 문제 해결\n- 객체 메서드나 프로토타입 메서드는 일반 함수로 정의하여 올바른 this 바인딩\n- React 컴포넌트의 이벤트 핸들러를 화살표 함수로 정의하여 자동 this 바인딩",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-nb5e5bt0",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "프로토타입 체인과 상속에 대해 설명해주세요.",
      "answer": "**정의:**\n프로토타입 체인은 JavaScript의 상속 메커니즘으로, 객체가 자신에게 없는 프로퍼티나 메서드를 프로토타입 객체에서 찾는 과정입니다. 모든 객체는 [[Prototype]] 내부 슬롯을 가지며 이를 통해 다른 객체를 참조하여 체인을 형성합니다.\n\n**특징/원리:**\n- 프로토타입 링크: 모든 객체는 생성 시 프로토타입 객체에 대한 숨겨진 링크를 가짐\n- 체인 탐색: 프로퍼티 접근 시 자신에게 없으면 프로토타입 체인을 따라 상위로 검색\n- 최상위: 체인의 끝은 Object.prototype이며, 여기에도 없으면 undefined 반환\n- 동적 확장: 프로토타입에 프로퍼티를 추가하면 모든 인스턴스에 즉시 반영\n\n**프로토타입 접근:**\n- __proto__: 객체의 프로토타입을 가리키는 접근자 프로퍼티이지만 비표준이며 사용 권장되지 않음\n- Object.getPrototypeOf: 객체의 프로토타입을 반환하는 표준 메서드\n- Object.setPrototypeOf: 객체의 프로토타입을 설정하는 메서드이지만 성능상 권장되지 않음\n- prototype 프로퍼티: 생성자 함수만 가지며 new로 생성될 인스턴스의 프로토타입을 가리킴\n\n**생성자 함수와 프로토타입:**\n- 생성자 함수: 함수가 생성될 때 자동으로 prototype 프로퍼티가 생성됨\n- constructor: 프로토타입 객체는 constructor 프로퍼티로 생성자 함수를 역참조\n- 인스턴스 생성: new 키워드로 인스턴스 생성 시 생성자 함수의 prototype이 인스턴스의 프로토타입이 됨\n- 메서드 공유: 프로토타입에 정의된 메서드는 모든 인스턴스가 공유하여 메모리 효율적\n\n**프로토타입 상속:**\n- 프로토타입 연결: 자식 생성자의 prototype을 부모 인스턴스로 설정하여 상속 구현\n- Object.create: 지정한 프로토타입을 가진 새 객체를 생성하는 메서드\n- 다중 상속 불가: JavaScript는 단일 프로토타입 체인만 지원하여 다중 상속 불가\n- 믹스인 패턴: Object.assign으로 여러 객체의 프로퍼티를 복사하여 다중 상속 효과\n\n**실무 활용:**\n- 공통 메서드를 프로토타입에 정의하여 모든 인스턴스가 공유하도록 메모리 최적화\n- Object.create로 순수한 프로토타입 상속을 구현하여 깔끔한 객체 계층 구조 생성\n- instanceof 연산자로 프로토타입 체인을 검사하여 객체의 타입 확인",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633097-5hsgzm0u",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "ES6 Class 문법과 프로토타입 기반 상속의 차이점은 무엇인가요?",
      "answer": "**정의:**\nES6 Class는 프로토타입 기반 상속을 클래스 기반 언어처럼 보이도록 제공하는 문법적 설탕입니다. 내부적으로는 여전히 프로토타입을 사용하지만, 더 직관적이고 명확한 문법으로 객체지향 프로그래밍을 지원합니다.\n\n**특징/원리:**\n- 문법적 설탕: 새로운 객체 생성 메커니즘이 아니라 기존 프로토타입 기반 상속의 문법적 개선\n- 엄격 모드: 클래스 내부 코드는 자동으로 strict mode로 실행됨\n- 호이스팅 차이: 클래스 선언은 호이스팅되지만 초기화는 되지 않아 TDZ 존재\n- 명시적 구조: constructor, 메서드, static 메서드 등을 명확하게 구분\n\n**Class 문법 특징:**\n- constructor: 인스턴스 생성 및 초기화를 담당하는 특수 메서드로 클래스당 하나만 존재\n- 인스턴스 메서드: 프로토타입에 자동으로 추가되며 모든 인스턴스가 공유\n- static 메서드: 클래스 자체에 속하며 인스턴스 없이 호출 가능\n- getter/setter: get과 set 키워드로 접근자 프로퍼티 정의\n\n**상속 구현:**\n- extends: 간단하게 부모 클래스를 상속받을 수 있음\n- super: 부모 클래스의 constructor나 메서드를 호출하는 키워드\n- 오버라이딩: 부모 메서드와 같은 이름의 메서드를 정의하여 재정의\n- 프로토타입 체인: extends는 내부적으로 프로토타입 체인을 올바르게 설정\n\n**프로토타입 방식과의 차이:**\n- 가독성: Class 문법이 더 직관적이고 객체지향 언어에 익숙한 개발자가 이해하기 쉬움\n- 간결성: 상속 구현이 프로토타입 방식보다 훨씬 간단하고 명확\n- 생성자 호출: 클래스는 반드시 new와 함께 호출해야 하며 일반 함수처럼 호출 불가\n- super 키워드: 프로토타입 방식에서는 부모 메서드 호출이 복잡하지만 Class는 super로 간단히 처리\n\n**실무 활용:**\n- 새로운 코드는 Class 문법을 사용하여 명확하고 유지보수하기 쉬운 코드 작성\n- React 컴포넌트를 클래스형으로 작성할 때 extends Component로 상속\n- 복잡한 도메인 모델을 클래스 계층 구조로 표현하여 코드 구조화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-lcmtizrl",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Promise의 동작 원리와 상태에 대해 설명해주세요.",
      "answer": "**정의:**\nPromise는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체로, 콜백 지옥을 해결하고 비동기 코드를 더 직관적으로 작성할 수 있게 합니다. Promise는 pending, fulfilled, rejected 세 가지 상태를 가지며 한 번 결정되면 상태가 변경되지 않습니다.\n\n**특징/원리:**\n- 상태 불변성: 한 번 fulfilled나 rejected 상태가 되면 다시 변경되지 않음\n- 체이닝: then, catch, finally를 연결하여 순차적인 비동기 작업 처리 가능\n- 에러 전파: 체인 중간에 발생한 에러가 가장 가까운 catch로 전파됨\n- 비동기 처리: Promise 생성자의 executor 함수는 동기적으로 실행되지만 then은 비동기로 실행\n\n**Promise 상태:**\n- pending: 초기 상태로 비동기 작업이 아직 완료되지 않음\n- fulfilled: 비동기 작업이 성공적으로 완료되어 결과값을 가짐\n- rejected: 비동기 작업이 실패하여 에러를 가짐\n- settled: fulfilled나 rejected 상태를 통칭하며 더 이상 상태 변경 안 됨\n\n**주요 메서드:**\n- then: fulfilled 상태일 때 실행될 콜백과 rejected 상태일 때 실행될 콜백을 등록\n- catch: rejected 상태일 때 실행될 에러 핸들러를 등록하며 then(undefined, onRejected)와 동일\n- finally: 상태와 무관하게 항상 실행되는 콜백을 등록하며 리소스 정리에 사용\n- Promise.resolve: 주어진 값으로 즉시 fulfilled 상태의 Promise 생성\n- Promise.reject: 주어진 이유로 즉시 rejected 상태의 Promise 생성\n\n**정적 메서드:**\n- Promise.all: 여러 Promise를 병렬로 실행하고 모두 성공하면 결과 배열 반환, 하나라도 실패하면 즉시 reject\n- Promise.allSettled: 모든 Promise의 성공/실패 여부와 관계없이 모든 결과를 배열로 반환\n- Promise.race: 가장 먼저 완료된 Promise의 결과를 반환\n- Promise.any: 가장 먼저 성공한 Promise의 결과를 반환하며 모두 실패하면 reject\n\n**실무 활용:**\n- API 호출 결과를 Promise로 래핑하여 then으로 성공 처리, catch로 에러 처리\n- 여러 API를 병렬로 호출할 때 Promise.all로 모든 결과를 기다림\n- Promise 체이닝으로 순차적인 비동기 작업을 가독성 좋게 표현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-nsjdz2l1",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "async/await와 Promise의 차이점은 무엇인가요?",
      "answer": "**정의:**\nasync/await는 ES2017에서 도입된 문법으로 Promise를 더 간결하고 동기 코드처럼 작성할 수 있게 합니다. async 함수는 항상 Promise를 반환하며, await는 Promise가 settled될 때까지 함수 실행을 일시 중지합니다.\n\n**특징/원리:**\n- 문법적 설탕: 내부적으로 Promise를 사용하지만 동기 코드처럼 작성 가능\n- 에러 처리: try-catch 문으로 동기/비동기 에러를 일관되게 처리\n- 가독성: 콜백이나 then 체이닝보다 코드 흐름이 직관적이고 이해하기 쉬움\n- 디버깅: 스택 트레이스가 명확하여 디버깅이 용이\n\n**async 함수:**\n- 선언: function 앞에 async 키워드를 붙여 선언\n- 반환값: 함수가 값을 반환하면 자동으로 Promise.resolve로 래핑\n- 에러: 함수에서 예외가 발생하면 자동으로 Promise.reject로 래핑\n- await 필수: async 함수 내에서만 await 사용 가능\n\n**await 키워드:**\n- 일시 중지: Promise가 settled될 때까지 함수 실행을 중지하고 결과를 반환\n- 병렬 처리: 여러 await를 순차적으로 사용하면 직렬 처리되므로 Promise.all로 병렬 처리 필요\n- 최상위 await: ES2022부터 모듈의 최상위 레벨에서도 await 사용 가능\n- 에러: Promise가 reject되면 에러를 throw하므로 try-catch로 처리\n\n**Promise와의 비교:**\n- 가독성: async/await가 중첩 없이 순차적으로 작성되어 더 읽기 쉬움\n- 에러 처리: Promise는 catch 메서드, async/await는 try-catch로 처리하여 동기 코드와 일관성\n- 조건 분기: async/await는 if문, 반복문 등을 자연스럽게 사용 가능\n- 디버깅: async/await는 일반 코드처럼 breakpoint를 설정하고 단계별 실행 가능\n\n**실무 활용:**\n- API 호출이 많은 코드는 async/await로 작성하여 가독성과 유지보수성 향상\n- 에러 처리가 복잡한 경우 try-catch로 여러 await를 한 번에 처리\n- 병렬 처리가 필요한 경우 Promise.all과 await를 조합하여 사용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-2otn3iax",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "이벤트 루프(Event Loop)의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\n이벤트 루프는 JavaScript의 비동기 실행 모델의 핵심으로, 콜 스택과 태스크 큐를 모니터링하며 콜 스택이 비어있을 때 큐의 작업을 스택으로 이동시킵니다. 단일 스레드인 JavaScript가 비동기 작업을 처리할 수 있게 하는 메커니즘입니다.\n\n**특징/원리:**\n- 단일 스레드: JavaScript 엔진은 하나의 콜 스택만 가지며 한 번에 하나의 작업만 실행\n- 논블로킹: 시간이 오래 걸리는 작업을 백그라운드로 넘기고 다음 코드 계속 실행\n- 이벤트 기반: 작업 완료 시 이벤트가 발생하고 등록된 콜백이 큐에 추가됨\n- 우선순위: 마이크로태스크가 매크로태스크보다 높은 우선순위를 가짐\n\n**구성 요소:**\n- 콜 스택: 현재 실행 중인 함수들이 쌓이는 LIFO 구조의 스택\n- 힙: 객체가 할당되는 메모리 영역\n- 태스크 큐: 비동기 작업의 콜백이 대기하는 FIFO 구조의 큐\n- 마이크로태스크 큐: Promise 콜백 등이 대기하는 우선순위 높은 큐\n- Web APIs: 타이머, DOM 이벤트, AJAX 등 브라우저가 제공하는 비동기 API\n\n**동작 과정:**\n- 동기 코드 실행: 전역 코드가 콜 스택에서 순차적으로 실행됨\n- 비동기 작업 등록: setTimeout, addEventListener 등이 Web API로 전달되고 타이머나 이벤트 대기\n- 콜백 큐 추가: 비동기 작업 완료 시 콜백이 태스크 큐에 추가됨\n- 이벤트 루프 동작: 콜 스택이 비면 큐에서 콜백을 꺼내 스택에 추가하여 실행\n\n**마이크로태스크와 매크로태스크:**\n- 마이크로태스크: Promise의 then/catch/finally, queueMicrotask, MutationObserver 등\n- 매크로태스크: setTimeout, setInterval, setImmediate, I/O, UI 렌더링 등\n- 실행 순서: 콜 스택 비움 → 모든 마이크로태스크 실행 → 매크로태스크 하나 실행 → 반복\n- 렌더링: 마이크로태스크 큐가 비고 매크로태스크 실행 전에 UI 렌더링 발생 가능\n\n**실무 활용:**\n- 이벤트 루프를 이해하여 비동기 코드의 실행 순서를 정확히 예측\n- 마이크로태스크 큐가 막히지 않도록 주의하여 UI 블로킹 방지\n- setTimeout(fn, 0)을 사용하여 현재 실행 흐름을 마치고 나중에 실행되도록 스케줄링",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633097-zj85bwyz",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "마이크로태스크와 매크로태스크의 차이점은 무엇인가요?",
      "answer": "**정의:**\n마이크로태스크와 매크로태스크는 이벤트 루프에서 처리되는 비동기 작업의 두 가지 범주로, 실행 우선순위와 처리 방식이 다릅니다. 마이크로태스크가 매크로태스크보다 항상 먼저 처리되어 Promise 기반 코드가 타이머보다 우선 실행됩니다.\n\n**특징/원리:**\n- 우선순위: 마이크로태스크가 매크로태스크보다 높은 우선순위를 가짐\n- 처리 방식: 마이크로태스크는 큐가 빌 때까지 모두 처리하지만, 매크로태스크는 한 번에 하나씩 처리\n- 렌더링 차단: 마이크로태스크가 많으면 UI 렌더링이 지연될 수 있음\n- 재귀적 추가: 마이크로태스크 처리 중 새로운 마이크로태스크가 추가되면 즉시 처리\n\n**마이크로태스크 종류:**\n- Promise 콜백: then, catch, finally에 등록된 핸들러\n- queueMicrotask: 명시적으로 마이크로태스크 큐에 작업 추가\n- MutationObserver: DOM 변경 감지 콜백\n- process.nextTick: Node.js의 마이크로태스크로 Promise보다 우선순위 높음\n\n**매크로태스크 종류:**\n- setTimeout: 지정된 시간 후 콜백 실행\n- setInterval: 지정된 간격마다 콜백 반복 실행\n- setImmediate: Node.js의 매크로태스크로 다음 이벤트 루프 사이클에 실행\n- I/O 작업: 파일 읽기/쓰기, 네트워크 요청 등\n- UI 렌더링: 브라우저의 화면 갱신\n\n**실행 순서:**\n- 현재 매크로태스크 완료\n- 마이크로태스크 큐의 모든 작업 처리\n- 필요시 UI 렌더링 수행\n- 다음 매크로태스크 하나 처리\n- 위 과정 반복\n\n**실무 활용:**\n- Promise 체인이 길면 마이크로태스크가 계속 추가되어 렌더링 블로킹 주의\n- 긴급한 작업은 Promise로 래핑하여 마이크로태스크로 우선 처리\n- setTimeout을 사용하여 무거운 작업을 여러 매크로태스크로 분할하여 UI 반응성 유지",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "네트워크"
      ],
      "id": "1763437633097-256l9yir",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "디바운싱(Debouncing)과 스로틀링(Throttling)의 차이와 구현 방법은 무엇인가요?",
      "answer": "**정의:**\n디바운싱과 스로틀링은 이벤트 핸들러의 실행 빈도를 제한하는 기법으로, 성능 최적화에 사용됩니다. 디바운싱은 연속된 호출을 그룹화하여 마지막 호출 후 일정 시간이 지나면 실행하고, 스로틀링은 일정 시간 간격으로 최대 한 번만 실행합니다.\n\n**특징/원리:**\n- 성능 최적화: 빈번한 이벤트 발생 시 불필요한 함수 실행을 줄여 성능 향상\n- 사용자 경험: 과도한 API 호출이나 렌더링을 방지하여 부드러운 UX 제공\n- 타이머 활용: setTimeout을 사용하여 지연 실행 구현\n- 클로저 사용: 타이머 ID를 클로저로 유지하여 취소 가능\n\n**디바운싱:**\n- 동작 원리: 연속 호출 시 이전 타이머를 취소하고 새 타이머 설정하며, 마지막 호출 후 대기 시간이 지나면 실행\n- 사용 사례: 검색창 자동완성으로 입력이 멈춘 후 API 호출, 창 크기 조절 완료 후 레이아웃 재계산\n- leading/trailing: 첫 호출 시 즉시 실행할지(leading), 마지막 호출 후 실행할지(trailing) 선택 가능\n- 완전한 대기: 연속 입력 중에는 절대 실행되지 않고 입력이 멈춰야 실행\n\n**스로틀링:**\n- 동작 원리: 일정 시간 간격으로 최대 한 번만 실행되도록 제한\n- 사용 사례: 스크롤 이벤트 처리, 무한 스크롤 구현, 마우스 이동 추적\n- 정기적 실행: 연속 호출 중에도 일정 간격마다 주기적으로 실행\n- 즉시 실행: 첫 호출은 즉시 실행되고 이후 대기 시간 동안은 무시\n\n**구현 차이:**\n- 디바운싱: clearTimeout으로 이전 타이머를 계속 취소하고 새로 설정\n- 스로틀링: 플래그나 타임스탬프로 실행 가능 여부를 판단\n- 실행 빈도: 디바운싱은 연속 호출 시 0번, 스로틀링은 일정 간격으로 실행\n- 응답성: 스로틀링이 더 즉각적인 피드백 제공\n\n**실무 활용:**\n- 검색창 자동완성은 디바운싱으로 입력 완료 후 API 호출하여 불필요한 요청 방지\n- 무한 스크롤은 스로틀링으로 스크롤 중에도 일정 간격으로 데이터 로드\n- Lodash 라이브러리의 debounce, throttle 함수를 사용하여 간편하게 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-31hvntp1",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "얕은 복사와 깊은 복사의 차이점과 구현 방법은 무엇인가요?",
      "answer": "**정의:**\n얕은 복사는 객체의 최상위 속성만 복사하여 중첩된 객체는 참조를 공유하고, 깊은 복사는 모든 레벨의 속성을 재귀적으로 복사하여 완전히 독립적인 객체를 생성합니다. JavaScript의 객체는 참조 타입이므로 복사 시 주의가 필요합니다.\n\n**특징/원리:**\n- 참조 공유: 얕은 복사는 중첩 객체의 참조를 복사하여 원본과 복사본이 같은 객체를 가리킴\n- 완전 분리: 깊은 복사는 모든 객체를 새로 생성하여 원본과 완전히 독립적\n- 메모리: 얕은 복사는 메모리 효율적이지만, 깊은 복사는 모든 객체를 복제하여 메모리 많이 사용\n- 순환 참조: 깊은 복사 시 순환 참조가 있으면 무한 루프 발생 가능\n\n**얕은 복사 방법:**\n- 스프레드 연산자: 객체나 배열에 ...을 사용하여 최상위 레벨만 복사\n- Object.assign: 첫 번째 인자 객체에 나머지 객체들의 속성을 복사\n- Array.slice: 배열의 일부나 전체를 복사하지만 요소가 객체면 참조 복사\n- Array.from: 유사 배열이나 이터러블을 배열로 변환하며 얕은 복사\n\n**깊은 복사 방법:**\n- JSON 방식: JSON.stringify로 문자열로 변환 후 JSON.parse로 파싱하지만 함수, undefined, Symbol 등은 손실\n- 재귀 함수: 객체를 순회하며 재귀적으로 복사하되 순환 참조 처리 필요\n- Lodash cloneDeep: 라이브러리 함수로 순환 참조, 함수, Symbol 등을 안전하게 처리\n- structuredClone: 최신 브라우저에서 제공하는 표준 API로 깊은 복사 지원\n\n**주의사항:**\n- JSON 방식: Date는 문자열로 변환되고, 함수와 undefined는 제거되며, NaN과 Infinity는 null로 변환\n- 프로토타입: 대부분의 깊은 복사 방법은 프로토타입 체인을 복사하지 않음\n- 성능: 깊은 복사는 비용이 크므로 필요한 경우에만 사용\n- 불변성: React나 Redux에서는 얕은 복사로 새 참조를 만들어 변경 감지\n\n**실무 활용:**\n- 상태 관리 시 스프레드 연산자로 얕은 복사하여 불변성 유지\n- 중첩된 설정 객체를 수정할 때 깊은 복사하여 원본 보존\n- 불필요한 깊은 복사를 피하고 필요한 부분만 복사하여 성능 최적화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633097-1k0e8puh",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "구조 분해 할당(Destructuring)에 대해 설명해주세요.",
      "answer": "**정의:**\n구조 분해 할당은 배열이나 객체의 속성을 해체하여 개별 변수에 할당하는 문법입니다. ES6에서 도입되어 코드를 간결하게 만들고 필요한 값만 추출할 수 있어 가독성을 향상시킵니다.\n\n**특징/원리:**\n- 패턴 매칭: 좌변의 패턴과 우변의 구조를 매칭하여 값을 추출\n- 기본값: 값이 undefined인 경우 사용할 기본값 지정 가능\n- 나머지 패턴: rest 연산자로 나머지 요소를 배열이나 객체로 수집\n- 중첩 구조: 깊게 중첩된 객체나 배열도 한 번에 분해 가능\n\n**배열 구조 분해:**\n- 기본 사용: 배열 요소를 순서대로 변수에 할당\n- 요소 건너뛰기: 빈 자리를 남겨 특정 인덱스의 요소만 추출\n- 기본값: 배열 길이가 짧을 때 사용할 기본값 지정\n- 나머지 요소: rest 연산자로 남은 모든 요소를 배열로 수집\n- 값 교환: 임시 변수 없이 두 변수의 값을 교환 가능\n\n**객체 구조 분해:**\n- 기본 사용: 속성 이름과 동일한 변수명으로 값 추출\n- 다른 변수명: 콜론을 사용하여 다른 이름의 변수에 할당\n- 기본값: 속성이 없을 때 사용할 기본값 지정\n- 중첩 객체: 점 표기법처럼 중첩된 구조를 한 번에 분해\n- 계산된 속성명: 대괄호로 동적 속성명 사용 가능\n\n**함수 파라미터:**\n- 객체 파라미터: 함수가 많은 옵션을 받을 때 객체 구조 분해로 명시적으로 표현\n- 기본값 조합: 파라미터 기본값과 구조 분해 기본값을 함께 사용 가능\n- 가독성: 함수 시그니처만 봐도 어떤 속성을 사용하는지 명확히 알 수 있음\n\n**실무 활용:**\n- React 컴포넌트에서 props를 구조 분해하여 간결하게 사용\n- API 응답에서 필요한 필드만 추출하여 변수에 할당\n- 배열의 첫 번째와 나머지 요소를 분리하여 재귀 함수 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-nixegsa2",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "스프레드 연산자와 레스트 파라미터의 차이점은 무엇인가요?",
      "answer": "**정의:**\n스프레드 연산자와 레스트 파라미터는 모두 점 세 개(...) 문법을 사용하지만 반대 역할을 합니다. 스프레드는 배열이나 객체를 펼쳐서 개별 요소로 분리하고, 레스트는 개별 요소들을 모아서 배열이나 객체로 수집합니다.\n\n**특징/원리:**\n- 문법 위치: 스프레드는 값이 필요한 곳에, 레스트는 변수를 선언하는 곳에 사용\n- 반대 동작: 스프레드는 펼치기(spreading), 레스트는 모으기(gathering)\n- 얕은 복사: 스프레드로 복사한 객체나 배열은 새로운 참조를 가지지만 중첩 객체는 참조 공유\n- 불변성: 원본을 수정하지 않고 새로운 배열이나 객체 생성\n\n**스프레드 연산자:**\n- 배열 펼치기: 배열의 요소들을 개별 인자로 펼쳐서 함수에 전달하거나 다른 배열에 삽입\n- 객체 펼치기: 객체의 속성들을 펼쳐서 새 객체에 복사하거나 병합\n- 배열 복사: 얕은 복사로 새로운 배열 생성\n- 배열 연결: 여러 배열을 하나로 합치기\n- 객체 병합: 여러 객체를 하나로 합치며 나중 것이 우선순위\n\n**레스트 파라미터:**\n- 함수 파라미터: 가변 인자를 배열로 수집하여 처리\n- 구조 분해: 배열이나 객체에서 일부만 추출하고 나머지를 모음\n- arguments 대체: 화살표 함수에서 arguments 객체 대신 레스트 파라미터 사용\n- 마지막 위치: 레스트 파라미터는 항상 마지막 파라미터여야 함\n\n**사용 위치 구분:**\n- 함수 호출: 스프레드로 배열을 개별 인자로 펼침\n- 함수 정의: 레스트로 여러 인자를 배열로 모음\n- 배열 리터럴: 스프레드로 배열 요소 삽입\n- 구조 분해 할당: 레스트로 나머지 요소 수집\n- 객체 리터럴: 스프레드로 속성 복사\n\n**실무 활용:**\n- 불변성 유지를 위해 스프레드로 배열이나 객체를 복사하여 수정\n- 함수에 가변 개수의 인자를 받을 때 레스트 파라미터 사용\n- Math.max 같은 함수에 배열의 요소들을 스프레드로 전달",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-kxxhvq0h",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Map과 Object의 차이점은 무엇인가요?",
      "answer": "**정의:**\nMap은 ES6에서 도입된 키-값 쌍을 저장하는 컬렉션으로, Object와 유사하지만 여러 측면에서 차이가 있습니다. Map은 어떤 타입이든 키로 사용할 수 있고 순서를 보장하며 크기를 쉽게 알 수 있는 등의 장점이 있습니다.\n\n**특징/원리:**\n- 키 타입: Map은 객체, 함수, 원시값 등 모든 타입을 키로 사용 가능하지만, Object는 문자열과 Symbol만 키로 사용\n- 순서 보장: Map은 삽입 순서를 유지하지만, Object는 ES2015 이전에는 순서가 보장되지 않음\n- 크기: Map은 size 프로퍼티로 크기를 즉시 알 수 있지만, Object는 수동으로 계산 필요\n- 반복: Map은 이터러블이라 for-of로 직접 순회 가능하지만, Object는 Object.keys() 등 필요\n\n**Map의 장점:**\n- 키 타입 자유: 객체를 키로 사용할 수 있어 복잡한 데이터 구조 표현 가능\n- 성능: 빈번한 추가/삭제가 있는 경우 Map이 더 나은 성능\n- 크기 확인: size로 O(1) 시간에 요소 개수 확인\n- 프로토타입 오염 없음: Object는 프로토타입 체인의 키와 충돌 가능하지만 Map은 안전\n\n**Map 주요 메서드:**\n- set(key, value): 키-값 쌍 추가하고 Map 반환하여 체이닝 가능\n- get(key): 키에 해당하는 값 반환, 없으면 undefined\n- has(key): 키 존재 여부를 불리언으로 반환\n- delete(key): 키-값 쌍 삭제하고 성공 여부 반환\n- clear(): 모든 요소 제거\n- keys(), values(), entries(): 각각 키, 값, 키-값 쌍의 이터레이터 반환\n\n**Object 사용이 적합한 경우:**\n- JSON 직렬화: Object는 JSON과 호환되지만 Map은 직렬화 필요\n- 단순 구조: 키가 문자열이고 구조가 단순한 경우\n- 프로퍼티 접근: 점 표기법이나 대괄호로 편리하게 접근\n- 리터럴 생성: 객체 리터럴로 간결하게 생성 가능\n\n**실무 활용:**\n- DOM 요소를 키로 사용하는 캐시나 메타데이터 저장에 Map 활용\n- 순서가 중요한 키-값 쌍 관리에 Map 사용\n- 빈번한 추가/삭제가 있는 동적 컬렉션은 Map으로 성능 향상",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "캐시"
      ],
      "id": "1763437633097-29s0206q",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Set과 WeakSet, Map과 WeakMap의 차이점을 설명해주세요.",
      "answer": "**정의:**\nSet과 Map의 Weak 버전은 키에 대한 약한 참조를 사용하여 가비지 컬렉션을 방해하지 않습니다. WeakSet은 객체만 저장 가능하고, WeakMap은 객체만 키로 사용 가능하며, 참조된 객체가 더 이상 사용되지 않으면 자동으로 제거됩니다.\n\n**특징/원리:**\n- 약한 참조: Weak 버전은 객체에 대한 약한 참조를 유지하여 다른 참조가 없으면 GC 대상\n- 객체 전용: WeakSet과 WeakMap은 원시값을 저장할 수 없고 오직 객체만 가능\n- 열거 불가: Weak 버전은 이터러블이 아니라 순회나 크기 확인 불가능\n- 메모리 효율: 객체가 더 이상 필요 없어지면 자동으로 정리되어 메모리 누수 방지\n\n**Set vs WeakSet:**\n- 저장 타입: Set은 모든 타입 저장 가능, WeakSet은 객체만 가능\n- 순회: Set은 이터러블이지만 WeakSet은 순회 불가능\n- 크기: Set은 size로 크기 확인 가능, WeakSet은 불가능\n- 메서드: WeakSet은 add, has, delete만 제공\n\n**Map vs WeakMap:**\n- 키 타입: Map은 모든 타입을 키로 사용 가능, WeakMap은 객체만 키로 사용\n- 순회: Map은 이터러블이지만 WeakMap은 순회 불가능\n- 크기: Map은 size로 크기 확인 가능, WeakMap은 불가능\n- 메서드: WeakMap은 get, set, has, delete만 제공\n\n**사용 사례:**\n- WeakMap 메타데이터: DOM 요소에 대한 메타데이터를 WeakMap에 저장하여 요소 제거 시 자동 정리\n- WeakSet 방문 추적: 객체의 방문 여부를 추적하되 객체 수명에 영향 주지 않음\n- 프라이빗 데이터: WeakMap으로 객체의 private 데이터를 저장하여 캡슐화\n- 캐싱: WeakMap으로 계산 결과를 캐시하되 원본 객체가 사라지면 자동 삭제\n\n**실무 활용:**\n- React 컴포넌트의 인스턴스 데이터를 WeakMap에 저장하여 컴포넌트 언마운트 시 자동 정리\n- DOM 이벤트 핸들러 정보를 WeakMap에 저장하여 엘리먼트 제거 시 메모리 누수 방지\n- 순환 참조 감지 시 WeakSet으로 방문한 객체 추적",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "메모리"
      ],
      "id": "1763437633097-nd0jwgm5",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Symbol의 용도와 사용 방법을 설명해주세요.",
      "answer": "**정의:**\nSymbol은 ES6에서 도입된 원시 타입으로, 고유하고 변경 불가능한 값을 생성합니다. 주로 객체의 고유한 프로퍼티 키를 만들어 충돌을 방지하고, 내부 동작을 커스터마이징하는 Well-Known Symbol을 제공합니다.\n\n**특징/원리:**\n- 고유성: 매번 Symbol()을 호출하면 새롭고 고유한 값이 생성되어 절대 중복되지 않음\n- 불변성: Symbol 값은 생성 후 변경할 수 없는 원시 타입\n- 은닉성: for-in, Object.keys() 등에서 Symbol 키는 나타나지 않아 의도치 않은 접근 방지\n- 설명: 선택적 설명 문자열을 추가할 수 있지만 고유성에는 영향 없음\n\n**Symbol 생성:**\n- Symbol(): 새로운 고유 Symbol 생성하며 선택적으로 설명 추가\n- Symbol.for(key): 전역 Symbol 레지스트리에서 키로 검색하거나 없으면 생성하여 공유\n- Symbol.keyFor(symbol): Symbol.for로 생성된 Symbol의 키를 반환\n- 리터럴 불가: Symbol은 리터럴 문법이 없고 함수 호출로만 생성\n\n**Well-Known Symbols:**\n- Symbol.iterator: 객체를 이터러블로 만들어 for-of로 순회 가능하게 함\n- Symbol.toStringTag: Object.prototype.toString()의 반환값을 커스터마이징\n- Symbol.hasInstance: instanceof 연산자의 동작을 커스터마이징\n- Symbol.toPrimitive: 객체를 원시값으로 변환하는 방법 정의\n\n**프로퍼티 키로 사용:**\n- 충돌 방지: 라이브러리나 프레임워크가 객체에 프로퍼티를 추가할 때 기존 키와 충돌 없음\n- 은닉: Symbol 키는 일반적인 열거 메서드로 나타나지 않아 내부 구현 숨김\n- 접근: Object.getOwnPropertySymbols()나 Reflect.ownKeys()로만 Symbol 키 접근 가능\n\n**실무 활용:**\n- 이터레이터 프로토콜 구현 시 Symbol.iterator로 커스텀 순회 로직 정의\n- 라이브러리에서 객체에 메타데이터 추가 시 Symbol 키로 충돌 방지\n- 내부 상태나 메서드를 Symbol 키로 정의하여 외부 접근 제한",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-t6nn7j8u",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Proxy와 Reflect API에 대해 설명해주세요.",
      "answer": "**정의:**\nProxy는 객체에 대한 기본 연산을 가로채고 재정의할 수 있는 메타프로그래밍 기능입니다. Reflect는 Proxy 핸들러에서 사용할 수 있는 메서드들을 제공하는 내장 객체로, 기본 동작을 수행하거나 객체 조작을 더 명확하게 표현합니다.\n\n**특징/원리:**\n- 가로채기: 프로퍼티 읽기, 쓰기, 삭제, 함수 호출 등 기본 연산을 가로채서 커스텀 동작 수행\n- 투명성: 프록시는 원본 객체를 감싸지만 외부에서는 투명하게 동작\n- 취소 가능: Proxy.revocable()로 생성한 프록시는 나중에 비활성화 가능\n- 체이닝: 프록시를 다시 프록시로 감싸서 여러 레이어의 동작 추가 가능\n\n**Proxy 핸들러 트랩:**\n- get: 프로퍼티 읽기를 가로채어 기본값 제공, 접근 제어, 로깅 등 수행\n- set: 프로퍼티 쓰기를 가로채어 유효성 검증, 변경 감지, 읽기 전용 구현\n- has: in 연산자를 가로채어 프로퍼티 존재 여부 커스터마이징\n- deleteProperty: delete 연산자를 가로채어 삭제 방지나 로깅\n- apply: 함수 호출을 가로채어 인자 검증, 로깅, 결과 변환\n- construct: new 연산자를 가로채어 인스턴스 생성 제어\n\n**Reflect API:**\n- 메서드 대응: Proxy의 모든 트랩에 대응하는 메서드를 제공\n- 기본 동작: Reflect 메서드로 기본 동작을 수행하여 프록시에서 원래 동작 위임\n- 일관성: Object의 메서드들보다 일관된 반환값과 에러 처리 제공\n- 함수형: Reflect 메서드들은 함수형 프로그래밍 스타일에 더 적합\n\n**Reflect 주요 메서드:**\n- Reflect.get(target, key): 프로퍼티 값 반환\n- Reflect.set(target, key, value): 프로퍼티 설정하고 성공 여부 반환\n- Reflect.has(target, key): 프로퍼티 존재 여부 반환\n- Reflect.deleteProperty(target, key): 프로퍼티 삭제하고 성공 여부 반환\n- Reflect.apply(func, thisArg, args): 함수 호출\n- Reflect.construct(constructor, args): 인스턴스 생성\n\n**실무 활용:**\n- Vue 3의 반응성 시스템이 Proxy로 데이터 변경을 감지하고 자동으로 UI 업데이트\n- 유효성 검증 프록시로 객체에 값 설정 시 자동으로 검증 수행\n- 기본값 프록시로 존재하지 않는 프로퍼티 접근 시 기본값 반환",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-oatw9cl4",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Generator 함수와 Iterator의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\nGenerator는 실행을 일시 중지하고 재개할 수 있는 특수한 함수로, Iterator를 쉽게 생성하는 방법을 제공합니다. Iterator는 next() 메서드를 가진 객체로 순차적으로 값을 반환하며, Generator 함수는 function* 문법으로 정의하고 yield로 값을 생성합니다.\n\n**특징/원리:**\n- 지연 평가: 필요할 때만 값을 생성하여 메모리 효율적\n- 상태 유지: 함수 실행이 중지된 위치와 지역 변수 상태를 기억\n- 양방향 통신: next()로 값을 전달받고 yield로 값을 반환하는 양방향 통신 가능\n- 이터러블 프로토콜: Generator 객체는 이터러블이자 이터레이터\n\n**Generator 함수:**\n- function* 문법: 별표로 Generator 함수임을 표시\n- yield: 값을 생성하고 함수 실행을 일시 중지\n- return: Generator를 종료하고 마지막 값 반환\n- yield*: 다른 Generator나 이터러블에 위임\n\n**Iterator 프로토콜:**\n- next() 메서드: {value, done} 형태의 객체 반환\n- value: 현재 생성된 값\n- done: Iterator가 완료되었는지 나타내는 불리언\n- Symbol.iterator: 객체를 이터러블로 만드는 메서드\n\n**Generator 메서드:**\n- next(value): Generator를 재개하고 value를 yield 표현식의 결과로 전달\n- return(value): Generator를 종료하고 value를 반환\n- throw(error): Generator 내부에서 예외를 발생시킴\n\n**사용 사례:**\n- 무한 시퀀스: 피보나치 수열, ID 생성기 등 무한히 값을 생성\n- 대용량 데이터: 메모리를 절약하면서 큰 데이터셋을 순회\n- 비동기 흐름 제어: co 라이브러리처럼 Generator로 비동기 코드를 동기식으로 작성\n- 상태 머신: 복잡한 상태 전이를 Generator로 깔끔하게 표현\n\n**실무 활용:**\n- 페이지네이션 데이터를 Generator로 구현하여 필요한 만큼만 로드\n- Redux-Saga에서 Generator로 복잡한 비동기 로직을 선언적으로 표현\n- 대용량 파일을 청크 단위로 읽는 Generator 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "가상메모리"
      ],
      "id": "1763437633097-4qs76tbr",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "모듈 시스템(CommonJS, ES6 Module)의 차이점은 무엇인가요?",
      "answer": "**정의:**\nCommonJS와 ES6 Module은 JavaScript 코드를 모듈화하는 두 가지 주요 방식입니다. CommonJS는 Node.js에서 사용하는 동기적 모듈 시스템이고, ES6 Module은 ECMAScript 표준의 정적 모듈 시스템으로 브라우저와 Node.js 모두에서 지원됩니다.\n\n**특징/원리:**\n- 로딩 방식: CommonJS는 런타임에 동기적으로 로드하고, ES6 Module은 컴파일 타임에 정적으로 분석\n- 값 전달: CommonJS는 값의 복사본을 내보내고, ES6 Module은 값에 대한 라이브 바인딩\n- 최적화: ES6 Module은 정적 분석이 가능하여 트리 쉐이킹과 같은 최적화 가능\n- 환경: CommonJS는 Node.js 전용이었지만, ES6 Module은 브라우저와 Node.js 모두 지원\n\n**CommonJS:**\n- require(): 동기적으로 모듈을 로드하고 객체를 반환\n- module.exports: 모듈에서 내보낼 값을 할당\n- exports 단축: exports 객체에 속성을 추가하여 여러 값 내보내기\n- 동적 로딩: 조건문 안에서도 require() 사용 가능\n- 런타임 결정: 어떤 모듈을 로드할지 런타임에 결정 가능\n\n**ES6 Module:**\n- import: 정적으로 모듈을 가져오며 호이스팅됨\n- export: 모듈에서 내보낼 값을 선언\n- export default: 모듈의 기본 내보내기 정의\n- 정적 구조: import/export는 최상위 레벨에만 위치하며 동적 사용 불가\n- import(): 동적 import를 위한 함수로 Promise 반환\n\n**주요 차이점:**\n- 구문: CommonJS는 할당 기반, ES6는 선언적 구문\n- 타이밍: CommonJS는 런타임 로딩, ES6는 파싱 타임 분석\n- 트리 쉐이킹: ES6 Module은 정적 분석으로 사용하지 않는 코드 제거 가능\n- this: CommonJS 모듈의 this는 exports 객체, ES6 Module의 this는 undefined\n- 순환 참조: 처리 방식이 다르며 ES6가 더 예측 가능\n\n**상호 운용성:**\n- Node.js: package.json의 type 필드로 모듈 시스템 지정\n- 번들러: Webpack, Rollup 등이 두 시스템을 모두 처리하여 변환\n- 혼용: ES6에서 CommonJS를 import 가능하지만 반대는 제한적\n\n**실무 활용:**\n- 새로운 프로젝트는 ES6 Module을 사용하여 표준을 따르고 최적화 이점 활용\n- Node.js 라이브러리는 CommonJS와 ES6 Module 둘 다 제공하여 호환성 확보\n- 브라우저 환경에서는 ES6 Module을 기본으로 사용하고 번들러로 빌드",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-y70dn2my",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 타입 시스템에 대해 설명해주세요.",
      "answer": "**정의:**\nTypeScript는 JavaScript에 정적 타입 시스템을 추가한 슈퍼셋 언어로, 컴파일 타임에 타입 검사를 수행하여 런타임 오류를 사전에 방지합니다. 구조적 타입 시스템을 사용하며 타입 추론, 제네릭, 유니온/인터섹션 타입 등 강력한 타입 기능을 제공합니다.\n\n**특징/원리:**\n- 정적 타입: 변수, 함수 파라미터, 반환값 등에 타입을 명시하여 컴파일 타임에 검증\n- 구조적 타이핑: 이름이 아닌 구조(속성과 메서드)로 타입 호환성 판단\n- 타입 추론: 명시하지 않아도 값으로부터 타입을 자동으로 추론\n- 점진적 타입: JavaScript 코드에 점진적으로 타입을 추가 가능하며 any로 타입 검사 생략 가능\n\n**기본 타입:**\n- 원시 타입: number, string, boolean, null, undefined, symbol, bigint\n- 배열: number[], Array<number> 형태로 표현\n- 튜플: 고정된 길이와 타입의 배열로 각 위치마다 다른 타입 가능\n- enum: 관련된 상수 집합을 정의\n- any: 모든 타입 허용하며 타입 검사 비활성화\n- unknown: any보다 안전한 최상위 타입으로 사용 전 타입 체크 필요\n- void: 반환값이 없는 함수의 반환 타입\n- never: 절대 발생하지 않는 값의 타입\n\n**고급 타입:**\n- 유니온 타입: 여러 타입 중 하나일 수 있음을 표현\n- 인터섹션 타입: 여러 타입을 모두 만족하는 타입 생성\n- 리터럴 타입: 특정 값만 허용하는 타입\n- 타입 별칭: type 키워드로 복잡한 타입에 이름 부여\n- 인터페이스: 객체의 구조를 정의하며 확장과 구현 가능\n\n**타입 추론:**\n- 초기화: 변수 선언 시 초기값으로부터 타입 추론\n- 반환값: 함수 본문으로부터 반환 타입 추론\n- 문맥적 타이핑: 표현식의 위치로부터 타입 추론\n- Best common type: 여러 타입을 고려하여 가장 적합한 타입 선택\n\n**실무 활용:**\n- 대규모 프로젝트에서 TypeScript로 타입 안전성 확보하여 리팩토링과 유지보수 용이\n- IDE의 자동완성과 타입 체크로 개발 생산성 향상\n- 명시적 타입 정의로 코드 자체가 문서 역할 수행",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-3g0hnt8t",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 제네릭(Generic) 사용 방법과 제약사항은 무엇인가요?",
      "answer": "**정의:**\n제네릭은 타입을 파라미터화하여 재사용 가능한 컴포넌트를 만드는 기능입니다. 함수, 클래스, 인터페이스에서 사용할 타입을 호출 시점에 결정하여 타입 안전성을 유지하면서도 유연한 코드를 작성할 수 있습니다.\n\n**특징/원리:**\n- 타입 파라미터: 꺾쇠 괄호 안에 타입 변수를 선언하여 타입을 매개변수화\n- 타입 안전성: 특정 타입으로 제한하지 않으면서도 타입 체크 유지\n- 재사용성: 동일한 로직을 다양한 타입에 적용 가능\n- 타입 추론: 대부분의 경우 타입 인자를 명시하지 않아도 자동 추론\n\n**제네릭 함수:**\n- 선언: 함수명 뒤에 타입 파라미터 선언\n- 사용: 함수 파라미터나 반환 타입에 타입 변수 사용\n- 호출: 타입 인자를 명시하거나 추론에 맡김\n- 다중 타입 파라미터: 여러 타입 변수를 쉼표로 구분하여 선언\n\n**제네릭 클래스:**\n- 선언: 클래스명 뒤에 타입 파라미터 선언\n- 인스턴스 생성: new 키워드로 인스턴스 생성 시 타입 인자 전달\n- static 멤버: static 멤버에서는 클래스의 타입 파라미터 사용 불가\n- 상속: 제네릭 클래스를 상속할 때 타입 인자 전달하거나 새로운 타입 파라미터 사용\n\n**제약 조건:**\n- extends: 타입 파라미터가 특정 타입을 확장하도록 제약\n- 인터페이스 제약: 타입이 특정 속성이나 메서드를 가지도록 보장\n- 타입 파라미터 제약: 한 타입 파라미터가 다른 타입 파라미터를 확장\n- keyof: 객체 타입의 키로 타입 파라미터 제약\n\n**유틸리티 타입:**\n- Partial: 모든 속성을 선택적으로 만듦\n- Required: 모든 속성을 필수로 만듦\n- Pick: 특정 속성만 선택하여 타입 생성\n- Omit: 특정 속성을 제외하고 타입 생성\n- Record: 키-값 쌍의 타입 생성\n\n**실무 활용:**\n- API 응답 타입을 제네릭으로 정의하여 다양한 데이터 타입에 재사용\n- 컨테이너 컴포넌트를 제네릭으로 구현하여 여러 타입의 아이템 관리\n- 유틸리티 함수를 제네릭으로 작성하여 타입 안전성과 재사용성 확보",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-szefdevn",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 Union Type과 Intersection Type의 차이점은 무엇인가요?",
      "answer": "**정의:**\nUnion Type은 여러 타입 중 하나일 수 있는 값을 표현하고, Intersection Type은 여러 타입을 모두 만족하는 값을 표현합니다. Union은 OR 논리를 사용하여 타입을 결합하고, Intersection은 AND 논리를 사용하여 타입을 결합합니다.\n\n**특징/원리:**\n- Union Type: 파이프(|) 기호로 연결하며 타입 중 하나에 속하면 유효\n- Intersection Type: 앰퍼샌드(&) 기호로 연결하며 모든 타입의 속성을 가져야 유효\n- 타입 좁히기: Union Type은 타입 가드로 구체적인 타입으로 좁혀서 사용\n- 타입 확장: Intersection Type은 기존 타입에 새로운 속성을 추가하여 확장\n\n**Union Type 특징:**\n- 여러 가능성: 함수가 여러 타입의 값을 받거나 반환할 수 있음을 표현\n- 공통 속성: Union의 모든 타입에 공통으로 존재하는 속성만 안전하게 접근 가능\n- 타입 가드: typeof, instanceof, in 연산자로 타입을 좁혀서 특정 타입의 속성 접근\n- 리터럴 Union: 문자열 리터럴이나 숫자 리터럴을 Union으로 열거형처럼 사용\n\n**Intersection Type 특징:**\n- 타입 결합: 여러 타입의 모든 속성과 메서드를 가진 새로운 타입 생성\n- 믹스인: 여러 인터페이스나 타입을 결합하여 복합 타입 생성\n- 충돌 해결: 같은 이름의 속성이 다른 타입이면 never 타입으로 결정\n- 객체 타입: 주로 객체 타입을 결합하는 데 사용\n\n**사용 사례:**\n- Union Type: 함수 파라미터가 문자열이나 숫자를 받을 수 있는 경우, API 응답이 성공 또는 에러 타입인 경우\n- Intersection Type: 여러 믹스인을 결합하여 풍부한 기능을 가진 타입 생성, 기존 타입에 새로운 속성 추가\n\n**타입 가드:**\n- typeof: 원시 타입 구분\n- instanceof: 클래스 인스턴스 구분\n- in 연산자: 속성 존재 여부로 타입 구분\n- 사용자 정의 타입 가드: 반환 타입으로 타입 predicate 사용\n\n**실무 활용:**\n- API 응답을 성공과 실패 타입의 Union으로 정의하여 에러 처리 강제\n- Intersection으로 여러 인터페이스를 결합하여 복잡한 도메인 모델 표현\n- Union Type과 타입 가드로 다형성을 타입 안전하게 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-7200k87e",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 타입 가드(Type Guard) 종류와 사용 방법을 설명해주세요.",
      "answer": "**정의:**\n타입 가드는 런타임에 변수의 타입을 좁혀서 TypeScript가 더 구체적인 타입으로 추론할 수 있게 하는 기법입니다. 조건문 내에서 타입을 검사하면 해당 블록 안에서는 좁혀진 타입으로 안전하게 사용할 수 있습니다.\n\n**특징/원리:**\n- 타입 좁히기: 넓은 타입에서 구체적인 타입으로 범위를 좁힘\n- 컴파일러 이해: TypeScript 컴파일러가 타입 가드를 인식하여 타입 추론\n- 런타임 검사: 실제 런타임에 값의 타입을 검사하는 코드 실행\n- 스코프: 타입 가드가 적용되는 스코프 내에서만 타입이 좁혀짐\n\n**typeof 타입 가드:**\n- 원시 타입 검사: string, number, boolean, symbol, undefined, function 구분\n- 제한: object는 객체와 null 모두 포함하여 세밀한 구분 불가\n- 사용: if (typeof x === 'string') 형태로 사용\n\n**instanceof 타입 가드:**\n- 클래스 인스턴스 검사: 객체가 특정 클래스의 인스턴스인지 확인\n- 프로토타입 체인: 프로토타입 체인을 따라 생성자 함수 확인\n- 사용: if (x instanceof Date) 형태로 사용\n\n**in 연산자 타입 가드:**\n- 속성 존재 확인: 객체에 특정 속성이 있는지 검사\n- 옵셔널 속성: 선택적 속성의 존재 여부로 타입 구분\n- 사용: if ('propertyName' in obj) 형태로 사용\n\n**사용자 정의 타입 가드:**\n- 타입 predicate: 함수 반환 타입을 'parameterName is Type' 형태로 선언\n- 복잡한 검사: 여러 조건을 조합하여 타입을 판별하는 로직 구현\n- 재사용성: 타입 가드 함수를 정의하여 여러 곳에서 재사용\n- 명확성: 타입 검사 로직에 의미 있는 이름 부여\n\n**실무 활용:**\n- Union Type을 다룰 때 타입 가드로 각 타입에 맞는 처리 분기\n- API 응답의 성공/실패를 타입 가드로 구분하여 안전하게 처리\n- 사용자 정의 타입 가드 함수로 복잡한 타입 판별 로직을 캡슐화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-u0vjwuo9",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 유틸리티 타입(Partial, Pick, Omit 등)에 대해 설명해주세요.",
      "answer": "**정의:**\n유틸리티 타입은 TypeScript가 제공하는 내장 제네릭 타입으로, 기존 타입을 변환하여 새로운 타입을 생성합니다. 코드 중복을 줄이고 타입 변환을 선언적으로 표현하여 타입 정의를 간결하고 유지보수하기 쉽게 만듭니다.\n\n**특징/원리:**\n- 타입 변환: 기존 타입을 기반으로 새로운 타입 자동 생성\n- 제네릭 활용: 타입 파라미터를 받아 유연하게 동작\n- 조건부 타입: 내부적으로 조건부 타입과 매핑된 타입 사용\n- 표준 제공: TypeScript가 기본 제공하여 별도 정의 불필요\n\n**Partial<T>:**\n- 모든 속성 선택적: 모든 속성을 optional로 만들어 일부만 제공 가능\n- 사용 사례: 업데이트 함수에서 변경할 필드만 받을 때\n- 구현: 매핑된 타입과 옵셔널 수정자 사용\n\n**Required<T>:**\n- 모든 속성 필수: 모든 속성을 required로 만들어 반드시 제공하도록 강제\n- Partial 반대: Partial의 반대 개념\n- 사용 사례: 선택적 속성을 가진 타입을 모두 필수로 변환할 때\n\n**Pick<T, K>:**\n- 속성 선택: T 타입에서 K에 해당하는 속성만 선택하여 새 타입 생성\n- 부분 타입: 큰 타입에서 필요한 일부만 추출\n- 사용 사례: DTO에서 특정 필드만 선택하여 뷰 모델 생성\n\n**Omit<T, K>:**\n- 속성 제외: T 타입에서 K에 해당하는 속성을 제외한 나머지로 새 타입 생성\n- Pick 반대: Pick과 반대로 제외할 속성 지정\n- 사용 사례: 민감한 정보를 제외한 공개 타입 생성\n\n**Record<K, T>:**\n- 키-값 매핑: K를 키 타입으로, T를 값 타입으로 하는 객체 타입 생성\n- 사용 사례: 문자열 키와 특정 타입 값의 딕셔너리 정의\n\n**Readonly<T>:**\n- 읽기 전용: 모든 속성을 읽기 전용으로 만들어 수정 방지\n- 불변성: 불변 객체 타입 정의에 사용\n- 사용 사례: 설정 객체나 상수 객체 타입 정의\n\n**Extract<T, U>와 Exclude<T, U>:**\n- Extract: T에서 U에 할당 가능한 타입만 추출\n- Exclude: T에서 U에 할당 가능한 타입을 제외\n- Union 타입 필터링: Union Type을 필터링하여 부분집합 생성\n\n**ReturnType<T>:**\n- 반환 타입 추출: 함수 타입 T의 반환 타입 추출\n- 사용 사례: 함수의 반환 타입을 변수 타입으로 재사용\n\n**실무 활용:**\n- API 요청과 응답 타입을 Pick/Omit으로 변환하여 코드 중복 제거\n- Partial로 업데이트 함수의 파라미터 타입 정의하여 선택적 업데이트 지원\n- Record로 열거형 값을 키로 하는 매핑 객체 타입 정의",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-9lwa61nt",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 never 타입은 언제 사용하나요?",
      "answer": "**정의:**\nnever 타입은 절대 발생하지 않는 값의 타입으로, 함수가 절대 반환하지 않거나 도달할 수 없는 코드를 표현합니다. 타입 시스템에서 불가능한 상황을 나타내며 철저한 타입 체크를 가능하게 합니다.\n\n**특징/원리:**\n- 최하위 타입: 모든 타입의 서브타입이지만 never의 서브타입은 never만 존재\n- 할당 불가: 어떤 값도 never 타입에 할당할 수 없음\n- 빈 Union: never는 Union Type에서 자동으로 제거됨\n- 완전성 검사: 모든 경우를 다루었는지 컴파일러가 검증\n\n**never를 반환하는 경우:**\n- 예외 발생 함수: 항상 예외를 던지는 함수는 절대 정상 반환하지 않음\n- 무한 루프: 무한 루프로 절대 종료되지 않는 함수\n- 반환문 없음: 모든 경로에서 예외를 던지거나 무한 루프인 함수\n\n**타입 가드에서의 활용:**\n- Exhaustive check: switch 문에서 모든 케이스를 처리했는지 확인\n- default 절: default에서 never 타입으로 할당하여 누락된 케이스 감지\n- 컴파일 에러: 새로운 케이스가 추가되면 default 절에서 컴파일 에러 발생\n\n**조건부 타입에서의 활용:**\n- 타입 필터링: 조건부 타입에서 특정 타입을 제거할 때 never 사용\n- 불가능한 타입: 조건을 만족하지 않는 경우 never로 표시\n\n**Union Type과의 관계:**\n- 자동 제거: string | never는 자동으로 string으로 단순화\n- 교집합: 서로 교집합이 없는 타입의 Intersection은 never\n- 유효성: never가 결과로 나오면 타입 정의에 문제가 있음을 시사\n\n**실무 활용:**\n- switch 문의 exhaustive check로 모든 Union Type 케이스를 처리했는지 컴파일 타임에 검증\n- 에러 처리 유틸리티 함수의 반환 타입을 never로 지정하여 의도 명확화\n- 조건부 타입에서 특정 타입을 필터링할 때 never 사용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-wzsqf2lg",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 컴파일 과정과 설정 옵션을 설명해주세요.",
      "answer": "**정의:**\nTypeScript 컴파일러(tsc)는 TypeScript 코드를 JavaScript로 변환하는 과정을 수행하며, tsconfig.json 파일로 컴파일 옵션을 설정합니다. 컴파일 과정에서 타입 검사를 수행하고, 최신 JavaScript 문법을 구 버전으로 변환하며, 모듈 시스템을 처리합니다.\n\n**특징/원리:**\n- 타입 제거: 컴파일 결과물에는 타입 정보가 포함되지 않고 순수 JavaScript만 출력\n- 다운레벨링: 최신 ES 문법을 구버전 JavaScript로 변환하여 호환성 확보\n- 타입 검사: 컴파일 시 타입 오류를 검출하여 런타임 전에 문제 발견\n- 증분 컴파일: 변경된 파일만 다시 컴파일하여 빌드 시간 단축\n\n**컴파일 과정:**\n- 파싱: TypeScript 파일을 읽어 AST(Abstract Syntax Tree) 생성\n- 타입 검사: AST를 분석하여 타입 오류 검출 및 타입 추론 수행\n- 변환: AST를 JavaScript AST로 변환하고 타입 정보 제거\n- 생성: JavaScript AST로부터 JavaScript 코드와 선언 파일 생성\n- 방출: 컴파일 결과물을 파일로 출력\n\n**주요 컴파일러 옵션:**\n- target: 출력 JavaScript 버전 지정 (ES5, ES6, ES2020 등)\n- module: 모듈 시스템 지정 (CommonJS, ES2015, ESNext 등)\n- lib: 컴파일에 포함할 라이브러리 파일 지정\n- outDir: 출력 파일이 생성될 디렉토리 지정\n- rootDir: 입력 파일의 루트 디렉토리 지정\n- sourceMap: 디버깅을 위한 소스맵 파일 생성 여부\n\n**엄격성 옵션:**\n- strict: 모든 엄격한 타입 검사 옵션 활성화\n- noImplicitAny: 암묵적 any 타입 사용 시 오류 발생\n- strictNullChecks: null과 undefined를 명시적으로 처리하도록 강제\n- strictFunctionTypes: 함수 타입의 매개변수를 더 엄격하게 검사\n- noUnusedLocals: 사용하지 않는 지역 변수 시 오류\n- noUnusedParameters: 사용하지 않는 매개변수 시 오류\n\n**모듈 해석 옵션:**\n- moduleResolution: 모듈 해석 전략 (node, classic)\n- baseUrl: 비상대적 모듈 이름을 해석할 기준 디렉토리\n- paths: 모듈 이름을 경로로 매핑하는 패턴\n- esModuleInterop: CommonJS 모듈을 ES 모듈처럼 import 가능하게 함\n\n**실무 활용:**\n- strict 모드를 활성화하여 타입 안전성 최대화\n- 프로젝트 루트에 tsconfig.json을 배치하여 팀 전체가 일관된 설정 사용\n- incremental 옵션으로 증분 컴파일 활성화하여 빌드 속도 향상",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-r5zoa9zj",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "TypeScript의 데코레이터(Decorator)에 대해 설명해주세요.",
      "answer": "**정의:**\n데코레이터는 클래스, 메서드, 프로퍼티, 매개변수에 메타데이터를 추가하거나 동작을 수정하는 특수한 선언입니다. @ 기호로 시작하며, 실험적 기능으로 tsconfig.json에서 experimentalDecorators를 활성화해야 사용할 수 있습니다.\n\n**특징/원리:**\n- 선언적 메타프로그래밍: 코드에 메타데이터를 선언적으로 추가\n- 관심사 분리: 핵심 로직과 부가 기능을 분리하여 코드 간결화\n- 재사용성: 공통 패턴을 데코레이터로 추출하여 여러 곳에서 재사용\n- 실행 시점: 클래스 정의 시점에 실행되며 런타임 동작 수정\n\n**데코레이터 종류:**\n- 클래스 데코레이터: 클래스 전체에 적용되며 생성자 함수를 인자로 받음\n- 메서드 데코레이터: 메서드에 적용되며 메서드의 프로퍼티 디스크립터 수정 가능\n- 프로퍼티 데코레이터: 프로퍼티에 적용되며 메타데이터 추가\n- 매개변수 데코레이터: 메서드 매개변수에 적용되며 주로 메타데이터 기록\n- 접근자 데코레이터: getter/setter에 적용되며 프로퍼티 디스크립터 수정\n\n**데코레이터 팩토리:**\n- 함수 반환: 데코레이터 팩토리는 데코레이터 함수를 반환하는 함수\n- 매개변수화: 팩토리에 인자를 전달하여 동작을 커스터마이징\n- 유연성: 같은 데코레이터를 다른 설정으로 재사용 가능\n\n**적용 순서:**\n- 인스턴스 멤버: 프로퍼티 → 접근자 → 매개변수 → 메서드\n- 정적 멤버: 프로퍼티 → 접근자 → 매개변수 → 메서드\n- 생성자: 매개변수 → 클래스\n- 여러 데코레이터: 아래에서 위로 평가하고 위에서 아래로 실행\n\n**주요 사용 사례:**\n- 로깅: 메서드 실행 전후로 로그 기록\n- 검증: 메서드 매개변수 유효성 검사\n- 권한: 메서드 실행 전 권한 확인\n- 캐싱: 메서드 결과를 캐시하여 재사용\n- 의존성 주입: 클래스에 의존성 자동 주입\n\n**실무 활용:**\n- NestJS에서 @Controller, @Get, @Post 등의 데코레이터로 라우팅 정의\n- Angular에서 @Component, @Injectable 등으로 의존성 주입 설정\n- TypeORM에서 @Entity, @Column 등으로 데이터베이스 매핑 선언",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "캐시"
      ],
      "id": "1763437633097-6yjtde9l",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 메모리 관리 방식을 설명해주세요.",
      "answer": "**정의:**\nPython은 자동 메모리 관리를 제공하며, 참조 카운팅과 가비지 컬렉션을 결합하여 메모리를 관리합니다. 모든 객체는 힙에 할당되고, 참조 카운트가 0이 되면 즉시 메모리가 해제되며, 순환 참조는 가비지 컬렉터가 처리합니다.\n\n**특징/원리:**\n- 동적 할당: 모든 객체가 힙 메모리에 동적으로 할당됨\n- 자동 관리: 개발자가 명시적으로 메모리를 할당하거나 해제할 필요 없음\n- 참조 카운팅: 각 객체는 자신을 참조하는 개수를 추적\n- 가비지 컬렉션: 순환 참조를 감지하고 제거하는 GC 제공\n\n**참조 카운팅:**\n- 카운트 증가: 변수에 할당, 리스트에 추가, 함수 인자로 전달 시 증가\n- 카운트 감소: 변수가 스코프를 벗어남, del로 삭제, 컨테이너에서 제거 시 감소\n- 즉시 해제: 참조 카운트가 0이 되면 즉시 메모리 해제\n- 오버헤드: 모든 참조 변경 시 카운트 업데이트 필요\n\n**가비지 컬렉션:**\n- 순환 참조 처리: 참조 카운팅으로 처리 못하는 순환 참조 객체 수집\n- 세대별 수집: 객체를 0세대, 1세대, 2세대로 분류하여 효율적으로 수집\n- 임계값: 각 세대마다 GC를 트리거하는 임계값 존재\n- gc 모듈: 가비지 컬렉션을 수동으로 제어하거나 통계 확인 가능\n\n**메모리 할당 전략:**\n- 작은 객체: 전용 메모리 풀(arena)에서 빠르게 할당\n- 큰 객체: 시스템의 malloc을 직접 호출하여 할당\n- 객체 재사용: 작은 정수, 빈 튜플 등 자주 사용되는 객체는 캐싱하여 재사용\n- 메모리 단편화: 메모리 풀 방식으로 단편화 최소화\n\n**인터닝과 캐싱:**\n- 문자열 인터닝: 동일한 문자열 리터럴은 하나의 객체로 공유\n- 작은 정수: -5부터 256까지 정수는 미리 생성되어 재사용\n- 싱글톤: None, True, False는 싱글톤 객체\n\n**실무 활용:**\n- 순환 참조를 피하기 위해 weakref 모듈 사용\n- 메모리 누수 의심 시 gc 모듈로 수집되지 않는 객체 추적\n- 대용량 데이터 처리 시 제너레이터로 메모리 사용량 최소화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "메모리"
      ],
      "id": "1763437633097-3p8fg3jk",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 GIL(Global Interpreter Lock)이란 무엇인가요?",
      "answer": "**정의:**\nGIL은 CPython 인터프리터에서 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있도록 하는 뮤텍스 잠금입니다. 멀티스레드 프로그램에서 여러 스레드가 있어도 실제로는 동시에 하나의 스레드만 실행되어 CPU-bound 작업에서는 병렬 처리 효과가 없습니다.\n\n**특징/원리:**\n- 뮤텍스 잠금: 전역적인 하나의 락으로 Python 객체 접근 보호\n- 단일 실행: 여러 스레드가 있어도 한 시점에 하나만 바이트코드 실행 가능\n- 메모리 안전성: 참조 카운팅 기반 메모리 관리를 스레드 안전하게 보호\n- CPython 특징: Jython, IronPython 등 다른 구현체는 GIL이 없음\n\n**GIL의 장점:**\n- 구현 단순성: C 확장 모듈 작성과 인터프리터 구현이 단순해짐\n- 빠른 단일 스레드: 단일 스레드 프로그램은 락 오버헤드가 적어 빠름\n- 참조 카운팅 보호: 복잡한 동기화 없이 메모리 관리를 스레드 안전하게 유지\n- C 라이브러리 통합: 스레드 안전하지 않은 C 라이브러리도 안전하게 사용\n\n**GIL의 단점:**\n- CPU-bound 제약: CPU 집약적 작업은 멀티스레딩으로 성능 향상 불가\n- 멀티코어 미활용: 여러 CPU 코어가 있어도 하나만 사용\n- 경쟁 조건: 스레드 전환 시 GIL을 획득하려는 경쟁으로 성능 저하 가능\n- 병렬 처리 제한: 진정한 병렬 실행이 필요하면 다른 방법 필요\n\n**GIL 우회 방법:**\n- Multiprocessing: 별도 프로세스로 실행하여 각각 독립적인 GIL 보유\n- C 확장: NumPy, Pandas 등 C로 작성된 라이브러리는 GIL을 해제하고 병렬 실행\n- 비동기 IO: asyncio로 I/O-bound 작업을 동시에 처리\n- Jython, IronPython: GIL이 없는 다른 Python 구현체 사용\n\n**I/O-bound vs CPU-bound:**\n- I/O-bound: 네트워크, 파일 I/O 등은 GIL을 해제하므로 멀티스레딩 효과적\n- CPU-bound: 계산 집약적 작업은 multiprocessing 사용 필요\n- 혼합 작업: I/O와 CPU 작업이 섞인 경우 적절한 방법 선택 필요\n\n**실무 활용:**\n- 웹 크롤링이나 API 호출 등 I/O-bound 작업은 멀티스레딩으로 처리\n- 데이터 분석이나 머신러닝 같은 CPU-bound 작업은 multiprocessing 또는 NumPy 활용\n- 비동기 웹 서버는 asyncio로 많은 동시 연결 처리",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633097-ulwx27g1",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 데이터 타입과 가변/불변 객체를 설명해주세요.",
      "answer": "**정의:**\nPython의 데이터 타입은 가변(mutable) 객체와 불변(immutable) 객체로 구분됩니다. 불변 객체는 생성 후 값을 변경할 수 없고, 가변 객체는 내용을 수정할 수 있습니다. 이 구분은 성능, 해싱, 스레드 안전성 등에 영향을 미칩니다.\n\n**특징/원리:**\n- 객체 참조: Python의 모든 변수는 객체에 대한 참조를 저장\n- 불변성: 불변 객체를 수정하려면 새로운 객체를 생성해야 함\n- 가변성: 가변 객체는 동일한 메모리 위치에서 내용을 직접 변경 가능\n- 해시 가능성: 불변 객체만 딕셔너리 키나 세트 원소로 사용 가능\n\n**불변 객체:**\n- 숫자: int, float, complex는 불변이며 연산 시 새 객체 생성\n- 문자열: str은 불변이어서 문자열 조작은 새 문자열 반환\n- 튜플: tuple은 불변이지만 내부에 가변 객체를 포함할 수 있음\n- frozenset: set의 불변 버전\n- bytes: 불변 바이트 시퀀스\n\n**가변 객체:**\n- 리스트: list는 가변이어서 append, remove 등으로 직접 수정 가능\n- 딕셔너리: dict는 가변이어서 키-값 쌍 추가/삭제 가능\n- 세트: set은 가변이어서 원소 추가/제거 가능\n- bytearray: 가변 바이트 시퀀스\n\n**가변성의 영향:**\n- 함수 인자: 가변 객체를 함수에 전달하면 함수 내에서 수정이 원본에 영향\n- 기본 인자: 가변 객체를 기본 인자로 사용하면 모든 호출이 같은 객체 공유\n- 복사: 얕은 복사는 가변 객체의 참조를 복사하고, 깊은 복사는 재귀적으로 복사\n- 성능: 불변 객체는 수정마다 새 객체 생성으로 오버헤드 발생 가능\n\n**실무 활용:**\n- 딕셔너리 키나 세트 원소는 불변 객체만 사용하여 해시 값 일관성 유지\n- 함수의 기본 인자로 가변 객체 사용 피하고 None으로 대체\n- 불변 객체를 사용하여 스레드 안전성 확보하고 의도치 않은 수정 방지",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633097-72u7ja5l",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 얕은 복사와 깊은 복사의 차이점은 무엇인가요?",
      "answer": "**정의:**\n얕은 복사는 컨테이너의 구조만 복사하고 내부 객체는 참조를 복사하며, 깊은 복사는 중첩된 모든 객체를 재귀적으로 복사하여 완전히 독립적인 복사본을 만듭니다. 가변 객체를 다룰 때 복사 방식에 따라 원본과 복사본의 독립성이 달라집니다.\n\n**특징/원리:**\n- 참조 vs 복사: 얕은 복사는 참조만 복사하고, 깊은 복사는 객체 자체를 복사\n- 중첩 구조: 중첩된 가변 객체가 있을 때 차이가 명확히 드러남\n- 불변 객체: 불변 객체는 복사 방식과 무관하게 안전하게 공유 가능\n- copy 모듈: copy.copy()는 얕은 복사, copy.deepcopy()는 깊은 복사 수행\n\n**얕은 복사 방법:**\n- 슬라이싱: list[:]나 dict.copy()로 최상위 컨테이너만 복사\n- copy.copy(): copy 모듈의 copy() 함수 사용\n- 생성자: list(original), dict(original) 등으로 복사\n- copy 메서드: 객체의 copy() 메서드 호출\n\n**깊은 복사 방법:**\n- copy.deepcopy(): 재귀적으로 모든 중첩 객체 복사\n- 순환 참조 처리: deepcopy는 순환 참조를 감지하고 처리\n- 커스터마이징: __deepcopy__ 메서드로 깊은 복사 동작 커스터마이징\n\n**복사 시나리오:**\n- 중첩 리스트: 얕은 복사는 내부 리스트가 공유되지만, 깊은 복사는 별도로 복사\n- 딕셔너리: 값이 가변 객체면 얕은 복사로는 독립성 보장 안 됨\n- 사용자 정의 객체: 속성이 가변 객체를 참조하면 깊은 복사 필요\n\n**성능 고려사항:**\n- 얕은 복사: 빠르고 메모리 효율적이지만 내부 객체 공유\n- 깊은 복사: 느리고 메모리를 많이 사용하지만 완전한 독립성 보장\n- 선택 기준: 실제 필요에 따라 적절한 방법 선택\n\n**실무 활용:**\n- 설정 객체를 수정할 때 원본을 보존하려면 깊은 복사 사용\n- 대용량 데이터는 불필요한 깊은 복사를 피하고 필요한 부분만 복사\n- 테스트에서 픽스처를 복사할 때 독립성 필요 여부에 따라 복사 방식 선택",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633097-s5eau2qr",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 *args와 **kwargs에 대해 설명해주세요.",
      "answer": "**정의:**\n*args와 **kwargs는 함수에 가변 개수의 인자를 전달하는 문법입니다. *args는 위치 인자들을 튜플로 수집하고, **kwargs는 키워드 인자들을 딕셔너리로 수집합니다. 이를 통해 유연한 함수 시그니처를 정의할 수 있습니다.\n\n**특징/원리:**\n- 언패킹: 별표 연산자로 시퀀스나 매핑을 개별 인자로 펼침\n- 수집: 함수 정의에서 여러 인자를 하나의 변수로 모음\n- 네이밍: args와 kwargs는 관례적 이름이며 다른 이름 사용 가능\n- 순서: 일반 인자, *args, 키워드 전용 인자, **kwargs 순서로 배치\n\n**'*args 사용:**\n- 정의: 함수 정의에서 *args로 가변 개수의 위치 인자 받기\n- 튜플: 전달된 위치 인자들이 튜플로 수집됨\n- 언패킹: 시퀀스 앞에 *를 붙여 개별 인자로 펼침\n- 유연성: 인자 개수에 제약 없이 함수 호출 가능\n\n**'**kwargs 사용:**\n- 정의: 함수 정의에서 **kwargs로 가변 개수의 키워드 인자 받기\n- 딕셔너리: 전달된 키워드 인자들이 딕셔너리로 수집됨\n- 언패킹: 딕셔너리 앞에 **를 붙여 키워드 인자로 펼침\n- 옵션 전달: 설정 옵션을 유연하게 전달할 때 유용\n\n**매개변수 순서:**\n- 위치 매개변수: 필수 위치 인자가 먼저 옴\n- *args: 가변 위치 인자\n- 키워드 전용 매개변수: *args 뒤의 매개변수는 반드시 키워드로 전달\n- **kwargs: 가변 키워드 인자가 마지막\n- 기본값: 각 매개변수는 기본값 가질 수 있음\n\n**실무 활용:**\n- 데코레이터에서 *args, **kwargs로 원본 함수의 인자를 그대로 전달\n- 래퍼 함수나 프록시 함수에서 모든 인자를 다음 함수로 위임\n- 설정 옵션이 많은 함수에서 **kwargs로 유연하게 옵션 받기",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633097-i1afm1tn",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 데코레이터(Decorator)란 무엇이고 어떻게 동작하나요?",
      "answer": "**정의:**\n데코레이터는 함수나 클래스를 수정하지 않고 기능을 추가하거나 변경하는 고차 함수입니다. @decorator 문법으로 함수나 클래스 위에 적용하며, 원본 객체를 래핑하여 전후 처리를 추가하거나 동작을 변경합니다.\n\n**특징/원리:**\n- 고차 함수: 함수를 인자로 받고 함수를 반환하는 함수\n- 문법적 설탕: @decorator는 func = decorator(func)의 간결한 표현\n- 클로저: 데코레이터는 클로저를 활용하여 원본 함수를 기억\n- 체이닝: 여러 데코레이터를 겹쳐서 적용 가능\n\n**기본 구조:**\n- 래퍼 함수: 데코레이터 내부에서 원본 함수를 감싸는 함수 정의\n- 원본 호출: 래퍼 함수 내에서 원본 함수 호출\n- 반환: 래퍼 함수를 반환하여 원본 함수 대체\n- functools.wraps: 원본 함수의 메타데이터 보존\n\n**데코레이터 종류:**\n- 함수 데코레이터: 함수에 적용하여 함수 동작 수정\n- 클래스 데코레이터: 클래스에 적용하여 클래스 생성 수정\n- 메서드 데코레이터: 클래스 메서드에 적용\n- 파라미터화 데코레이터: 인자를 받는 데코레이터 팩토리\n\n**파라미터화 데코레이터:**\n- 이중 중첩: 데코레이터 팩토리가 실제 데코레이터를 반환\n- 설정 전달: 데코레이터의 동작을 인자로 커스터마이징\n- 유연성: 같은 데코레이터를 다른 설정으로 재사용\n\n**주요 사용 사례:**\n- 로깅: 함수 실행 전후로 로그 기록\n- 타이밍: 함수 실행 시간 측정\n- 캐싱: 함수 결과를 캐시하여 재사용\n- 권한 검사: 함수 실행 전 권한 확인\n- 재시도: 실패 시 자동으로 재시도\n\n**내장 데코레이터:**\n- @staticmethod: 클래스의 정적 메서드 정의\n- @classmethod: 클래스 메서드 정의하며 첫 인자로 클래스 받음\n- @property: 메서드를 속성처럼 접근 가능하게 함\n- @functools.lru_cache: 함수 결과를 캐싱하여 성능 향상\n\n**실무 활용:**\n- Flask/Django에서 @app.route나 @login_required로 라우팅과 인증 처리\n- functools.lru_cache로 비용이 큰 함수 결과를 캐싱\n- 커스텀 데코레이터로 공통 전처리 로직을 재사용 가능하게 추상화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "캐시"
      ],
      "id": "1763437633097-464gmyu8",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 제너레이터(Generator)와 이터레이터(Iterator)를 설명해주세요.",
      "answer": "**정의:**\n이터레이터는 next() 메서드를 구현하여 순차적으로 값을 반환하는 객체이며, 제너레이터는 yield 문을 사용하여 이터레이터를 쉽게 생성하는 함수입니다. 제너레이터는 함수의 실행 상태를 저장하고 재개할 수 있어 메모리 효율적인 데이터 생성이 가능합니다.\n\n**특징/원리:**\n- 지연 평가: 값을 미리 모두 생성하지 않고 필요할 때만 생성\n- 메모리 효율: 대용량 데이터셋을 메모리에 모두 올리지 않고 순차 처리\n- 상태 유지: 함수의 실행 상태와 지역 변수를 보존\n- 일회용: 한 번 소진되면 재사용 불가능\n\n**이터레이터 프로토콜:**\n- __iter__(): 이터레이터 객체 자신을 반환\n- __next__(): 다음 값을 반환하며, 더 이상 값이 없으면 StopIteration 예외 발생\n- 이터러블: __iter__()를 구현한 객체로 for 루프에서 사용 가능\n- 내장 이터러블: list, tuple, str, dict 등이 이터러블 객체\n\n**제너레이터 함수:**\n- yield 문: 값을 생성하고 함수 실행을 일시 중지\n- 자동 이터레이터: yield를 포함한 함수는 자동으로 이터레이터 프로토콜 구현\n- 여러 yield: 함수 내에 여러 yield 문을 가질 수 있음\n- return: 제너레이터를 종료하고 StopIteration에 값을 포함\n\n**제너레이터 표현식:**\n- 문법: 리스트 컴프리헨션과 유사하지만 괄호 사용\n- 메모리 효율: 모든 값을 메모리에 생성하지 않고 필요시 생성\n- 단일 반복: 한 번만 순회 가능하고 재사용 불가\n\n**제너레이터 메서드:**\n- send(): 제너레이터에 값을 전달하여 yield 표현식의 결과로 사용\n- throw(): 제너레이터 내부에서 예외 발생\n- close(): 제너레이터를 종료하고 GeneratorExit 예외 발생\n\n**실무 활용:**\n- 대용량 파일을 한 줄씩 읽어 처리하여 메모리 절약\n- 무한 시퀀스를 제너레이터로 구현하여 필요한 만큼만 생성\n- 데이터 파이프라인을 여러 제너레이터로 체이닝하여 단계별 처리",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633098-o33ggzma",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 컨텍스트 매니저(Context Manager)란 무엇인가요?",
      "answer": "**정의:**\n컨텍스트 매니저는 with 문과 함께 사용되어 리소스의 획득과 해제를 자동으로 관리하는 객체입니다. __enter__()와 __exit__() 메서드를 구현하여 설정과 정리 작업을 보장하며, 예외 발생 시에도 안전하게 리소스를 정리합니다.\n\n**특징/원리:**\n- 자동 정리: with 블록을 벗어날 때 자동으로 리소스 해제\n- 예외 안전: 예외 발생 시에도 __exit__()가 반드시 호출됨\n- 가독성: 설정과 정리 코드를 명시적으로 구조화\n- 재사용성: 공통 패턴을 컨텍스트 매니저로 추상화하여 재사용\n\n**프로토콜:**\n- __enter__(): with 문 진입 시 호출되며 리소스를 획득하고 반환\n- __exit__(exc_type, exc_value, traceback): with 블록 종료 시 호출되며 리소스 해제 및 예외 처리\n- 반환값: __exit__()가 True를 반환하면 예외를 억제\n- as 절: __enter__()의 반환값이 as 뒤의 변수에 할당\n\n**내장 컨텍스트 매니저:**\n- 파일 객체: open()으로 생성된 파일은 자동으로 닫힘\n- 락 객체: threading.Lock의 with 사용으로 자동 획득/해제\n- 데이터베이스 연결: 트랜잭션을 자동으로 커밋하거나 롤백\n\n**contextlib 모듈:**\n- @contextmanager: 제너레이터 함수를 컨텍스트 매니저로 변환하는 데코레이터\n- yield: 설정 코드 실행 후 yield로 제어를 넘기고, 블록 종료 후 정리 코드 실행\n- suppress(): 특정 예외를 억제하는 컨텍스트 매니저\n- closing(): close() 메서드를 가진 객체를 자동으로 닫음\n\n**클래스 기반 구현:**\n- __enter__(): 리소스 획득 로직 구현하고 사용할 객체 반환\n- __exit__(): 정리 로직 구현하고 예외 처리 여부 결정\n- 재사용: 여러 번 with 문에서 사용 가능한 재사용 가능 객체 생성\n\n**실무 활용:**\n- 파일, 네트워크 연결, 데이터베이스 커넥션 등 리소스를 with로 안전하게 관리\n- 타이머 컨텍스트 매니저로 코드 블록 실행 시간 자동 측정\n- 임시 디렉토리 변경이나 환경 변수 설정을 컨텍스트 매니저로 구현하여 자동 복원",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "네트워크"
      ],
      "id": "1763437633098-81znvf30",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 리스트 컴프리헨션과 제너레이터 표현식의 차이점은 무엇인가요?",
      "answer": "**정의:**\n리스트 컴프리헨션은 리스트를 생성하는 간결한 문법이고, 제너레이터 표현식은 제너레이터를 생성하는 유사한 문법입니다. 리스트 컴프리헨션은 모든 값을 메모리에 즉시 생성하지만, 제너레이터 표현식은 값을 지연 평가하여 메모리 효율적입니다.\n\n**특징/원리:**\n- 즉시 vs 지연: 리스트 컴프리헨션은 즉시 모든 요소 생성, 제너레이터는 필요시 생성\n- 메모리: 리스트는 모든 요소를 메모리에 저장, 제너레이터는 상태만 저장\n- 재사용: 리스트는 여러 번 순회 가능, 제너레이터는 일회용\n- 성능: 작은 데이터는 리스트가 빠르지만, 대용량은 제너레이터가 효율적\n\n**리스트 컴프리헨션:**\n- 문법: 대괄호 사용하여 [expression for item in iterable if condition]\n- 즉시 평가: 모든 요소를 즉시 계산하여 리스트로 반환\n- 인덱싱: 리스트이므로 인덱스 접근, 슬라이싱, len() 사용 가능\n- 중첩: 2D 리스트 생성이나 복잡한 변환에 유용\n\n**제너레이터 표현식:**\n- 문법: 괄호 사용하여 (expression for item in iterable if condition)\n- 지연 평가: next()나 for 루프로 요청할 때마다 하나씩 생성\n- 메모리 효율: 큰 데이터셋도 메모리 부담 없이 처리\n- 파이프라인: 여러 제너레이터를 체이닝하여 데이터 처리 파이프라인 구성\n\n**선택 기준:**\n- 크기: 결과가 작으면 리스트 컴프리헨션, 크면 제너레이터 표현식\n- 재사용: 여러 번 순회 필요하면 리스트, 한 번만 사용하면 제너레이터\n- 즉시 필요: 모든 값이 즉시 필요하면 리스트, 순차 처리면 제너레이터\n- 성능: 전체를 빠르게 생성하려면 리스트, 첫 값을 빠르게 얻으려면 제너레이터\n\n**실무 활용:**\n- 대용량 파일 처리는 제너레이터 표현식으로 메모리 절약\n- UI에 표시할 작은 결과 집합은 리스트 컴프리헨션으로 즉시 생성\n- sum(), max() 등 집계 함수에 전달할 때는 제너레이터 표현식으로 메모리 효율화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633098-q78bfvp3",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 람다 함수의 특징과 제한사항은 무엇인가요?",
      "answer": "**정의:**\n람다 함수는 lambda 키워드로 정의하는 익명의 간단한 함수로, 한 줄로 표현 가능한 단순한 함수를 간결하게 작성합니다. 이름이 없고 단일 표현식만 가질 수 있어, 주로 고차 함수의 인자로 사용됩니다.\n\n**특징/원리:**\n- 익명 함수: 이름 없이 정의되며 변수에 할당하거나 인자로 전달\n- 단일 표현식: 하나의 표현식만 포함하며 그 결과를 자동으로 반환\n- 간결성: def 문보다 짧고 간단하게 함수 정의\n- 일급 객체: 변수에 할당, 함수 인자로 전달, 함수에서 반환 가능\n\n**문법:**\n- 기본 형식: lambda parameters: expression\n- 매개변수: 쉼표로 구분된 매개변수 목록\n- 표현식: 단일 표현식이며 return 문 없이 결과 자동 반환\n- 타입 힌트: 람다 함수에는 타입 힌트 사용 불가\n\n**제한사항:**\n- 단일 표현식: 여러 문장이나 복잡한 로직 작성 불가\n- 문 사용 불가: if 문, for 문, while 문 등 사용 불가하며 표현식만 가능\n- 어노테이션 불가: 타입 힌트나 데코레이터 사용 불가\n- 문서화 어려움: docstring을 추가할 수 없어 의도 설명 어려움\n- 디버깅: 이름이 없어 스택 트레이스에서 식별 어려움\n\n**사용 사례:**\n- 정렬 키: sorted()나 list.sort()의 key 인자로 간단한 정렬 기준 제공\n- 필터링: filter() 함수의 조건으로 사용\n- 매핑: map() 함수의 변환 함수로 사용\n- 고차 함수: functools.reduce() 등의 인자로 사용\n\n**일반 함수 vs 람다:**\n- 복잡성: 복잡한 로직은 def로 정의하고 이름 부여\n- 재사용성: 여러 곳에서 사용할 함수는 def로 정의\n- 가독성: 람다가 복잡해지면 가독성이 떨어지므로 def 사용\n- 일회용: 한 번만 사용하고 간단한 경우 람다 사용\n\n**실무 활용:**\n- 리스트의 딕셔너리를 특정 키로 정렬할 때 lambda로 키 함수 제공\n- filter와 map을 사용한 간단한 데이터 변환 파이프라인\n- GUI 프레임워크에서 간단한 이벤트 핸들러를 람다로 정의",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-48t3543t",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 클로저(Closure)와 nonlocal 키워드에 대해 설명해주세요.",
      "answer": "**정의:**\n클로저는 외부 함수의 변수를 내부 함수가 기억하고 접근할 수 있는 기능입니다. nonlocal 키워드는 중첩 함수에서 외부 함수의 변수를 수정할 수 있게 하며, 변수가 전역이 아닌 가장 가까운 외부 스코프에 있음을 나타냅니다.\n\n**특징/원리:**\n- 렉시컬 스코프: 함수가 정의된 위치의 스코프를 기억\n- 변수 캡처: 외부 함수 종료 후에도 외부 변수에 접근 가능\n- 데이터 은닉: 외부에서 직접 접근할 수 없는 private 변수 구현\n- 상태 유지: 함수 호출 간에 상태를 보존\n\n**클로저 동작:**\n- 외부 함수 실행: 외부 함수가 호출되어 지역 변수 생성\n- 내부 함수 정의: 내부 함수가 외부 변수를 참조\n- 함수 반환: 외부 함수가 내부 함수를 반환\n- 변수 접근: 반환된 함수가 외부 변수에 계속 접근 가능\n\n**nonlocal 키워드:**\n- 변수 바인딩: 가장 가까운 외부 스코프의 변수를 참조\n- 수정 가능: nonlocal 선언 후 외부 변수를 수정 가능\n- 전역 제외: global 변수는 대상이 아니며 중첩 스코프만 해당\n- 선언 필수: nonlocal 없이 할당하면 새로운 지역 변수 생성\n\n**global vs nonlocal:**\n- global: 전역 스코프의 변수를 수정\n- nonlocal: 외부 함수의 변수를 수정\n- 범위: global은 모듈 레벨, nonlocal은 중첩 함수 레벨\n- 사용: 전역 변수 수정은 지양하고 nonlocal로 캡슐화 유지\n\n**활용 패턴:**\n- 팩토리 함수: 매개변수로 설정을 받아 특화된 함수 생성\n- 콜백 함수: 이벤트 핸들러에서 외부 컨텍스트 참조\n- 데코레이터: 외부 함수의 설정을 내부 래퍼가 사용\n- 카운터: 호출 횟수를 추적하는 함수 구현\n\n**실무 활용:**\n- 설정 값을 클로저로 캡처하여 설정에 따라 다르게 동작하는 함수 생성\n- 이벤트 핸들러에서 외부 컨텍스트 정보를 클로저로 기억\n- nonlocal로 카운터나 누적기 같은 상태를 유지하는 함수 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-ve8bhv8u",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 클래스 변수와 인스턴스 변수의 차이점은 무엇인가요?",
      "answer": "**정의:**\n클래스 변수는 클래스 자체에 속하며 모든 인스턴스가 공유하는 변수이고, 인스턴스 변수는 각 인스턴스마다 독립적으로 존재하는 변수입니다. 클래스 변수는 클래스 정의 내에서 선언하고, 인스턴스 변수는 주로 __init__() 메서드에서 self로 선언합니다.\n\n**특징/원리:**\n- 공유 vs 독립: 클래스 변수는 모든 인스턴스가 공유, 인스턴스 변수는 각자 소유\n- 네임스페이스: 클래스 변수는 클래스 네임스페이스, 인스턴스 변수는 인스턴스 네임스페이스\n- 접근 순서: 인스턴스에서 속성 조회 시 인스턴스 네임스페이스 먼저, 없으면 클래스 네임스페이스 검색\n- 메모리: 클래스 변수는 하나만 존재, 인스턴스 변수는 인스턴스 개수만큼 존재\n\n**클래스 변수:**\n- 선언 위치: 클래스 정의 내에서 메서드 밖에 선언\n- 접근: 클래스명이나 인스턴스를 통해 접근 가능\n- 수정: 클래스명으로 수정하면 모든 인스턴스에 반영\n- 용도: 모든 인스턴스가 공유할 설정, 카운터, 상수 등\n\n**인스턴스 변수:**\n- 선언 위치: 주로 __init__() 메서드에서 self.variable로 선언\n- 접근: 인스턴스를 통해서만 접근\n- 독립성: 각 인스턴스마다 다른 값을 가질 수 있음\n- 용도: 객체의 고유한 상태나 속성 저장\n\n**주의사항:**\n- 가변 기본값: 클래스 변수로 리스트나 딕셔너리를 선언하면 모든 인스턴스가 공유하여 의도치 않은 동작 발생\n- 쉐도잉: 인스턴스 변수가 클래스 변수와 같은 이름이면 인스턴스 변수가 우선\n- 수정: 인스턴스를 통해 클래스 변수를 수정하려 하면 실제로는 새로운 인스턴스 변수 생성\n\n**실무 활용:**\n- 인스턴스 카운터를 클래스 변수로 구현하여 생성된 객체 수 추적\n- 설정 값이나 상수를 클래스 변수로 정의하여 모든 인스턴스가 공유\n- 인스턴스 변수로 객체별 상태를 저장하여 독립적인 동작 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633098-jv7mlikh",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 매직 메서드(__init__, __str__, __repr__ 등)에 대해 설명해주세요.",
      "answer": "**정의:**\n매직 메서드는 더블 언더스코어로 시작하고 끝나는 특수 메서드로, Python 객체의 내장 동작을 커스터마이징합니다. 연산자 오버로딩, 객체 생성, 문자열 표현, 컨테이너 동작 등을 정의하여 객체를 Python의 내장 타입처럼 동작하게 만듭니다.\n\n**특징/원리:**\n- 암묵적 호출: 직접 호출하지 않고 특정 연산이나 문법에 의해 자동 호출\n- 연산자 오버로딩: 사용자 정의 클래스에서 +, -, ==  등의 연산자 의미 정의\n- 덕 타이핑: 적절한 매직 메서드를 구현하면 내장 타입처럼 동작\n- 프로토콜: 특정 매직 메서드 집합을 구현하면 해당 프로토콜을 만족\n\n**생성과 초기화:**\n- __new__(cls): 인스턴스를 생성하는 정적 메서드로 __init__() 전에 호출\n- __init__(self): 인스턴스를 초기화하며 생성자 역할\n- __del__(self): 인스턴스가 소멸될 때 호출되는 소멸자\n\n**문자열 표현:**\n- __str__(self): str()이나 print()로 호출되며 사용자 친화적 문자열 반환\n- __repr__(self): repr()로 호출되며 개발자를 위한 명확한 표현 반환, 디버깅에 유용\n- __format__(self, format_spec): format()이나 f-string에서 사용할 포맷팅 정의\n\n**비교 연산자:**\n- __eq__(self, other): == 연산자\n- __ne__(self, other): != 연산자\n- __lt__(self, other): < 연산자\n- __le__(self, other): <= 연산자\n- __gt__(self, other): > 연산자\n- __ge__(self, other): >= 연산자\n\n**산술 연산자:**\n- __add__(self, other): + 연산자\n- __sub__(self, other): - 연산자\n- __mul__(self, other): * 연산자\n- __truediv__(self, other): / 연산자\n- __iadd__(self, other): += 연산자 (in-place 버전)\n\n**컨테이너:**\n- __len__(self): len() 함수 지원\n- __getitem__(self, key): 인덱스 접근 obj[key]\n- __setitem__(self, key, value): 인덱스 할당 obj[key] = value\n- __delitem__(self, key): 인덱스 삭제 del obj[key]\n- __contains__(self, item): in 연산자 지원\n- __iter__(self): 이터레이터 반환하여 for 루프 지원\n\n**컨텍스트 매니저:**\n- __enter__(self): with 문 진입 시 호출\n- __exit__(self, exc_type, exc_value, traceback): with 블록 종료 시 호출\n\n**실무 활용:**\n- __str__과 __repr__을 구현하여 객체의 가독성 있는 출력 제공\n- __eq__와 __hash__를 구현하여 객체를 딕셔너리 키나 세트 원소로 사용\n- 수학적 객체를 표현할 때 산술 연산자를 오버로딩하여 직관적인 코드 작성",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-r97n2fon",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 프로퍼티(Property)와 디스크립터(Descriptor)를 설명해주세요.",
      "answer": "**정의:**\n프로퍼티는 메서드를 속성처럼 접근할 수 있게 하는 기능으로 getter, setter, deleter를 정의합니다. 디스크립터는 __get__, __set__, __delete__ 메서드를 구현하여 속성 접근을 제어하는 더 일반적이고 강력한 메커니즘입니다.\n\n**특징/원리:**\n- 캡슐화: 내부 구현을 숨기고 제어된 접근 제공\n- 유효성 검증: setter에서 값의 유효성을 검사\n- 계산된 속성: getter에서 동적으로 값을 계산하여 반환\n- 하위 호환성: 공개 속성을 나중에 프로퍼티로 변경해도 외부 코드는 수정 불필요\n\n**프로퍼티:**\n- @property: getter 메서드를 정의하는 데코레이터\n- @x.setter: setter 메서드를 정의하는 데코레이터\n- @x.deleter: deleter 메서드를 정의하는 데코레이터\n- 읽기 전용: setter 없이 getter만 정의하면 읽기 전용 속성\n\n**디스크립터 프로토콜:**\n- __get__(self, instance, owner): 속성 접근 시 호출\n- __set__(self, instance, value): 속성 할당 시 호출\n- __delete__(self, instance): 속성 삭제 시 호출\n- __set_name__(self, owner, name): 디스크립터가 클래스 속성으로 할당될 때 호출\n\n**데이터 vs 비데이터 디스크립터:**\n- 데이터 디스크립터: __set__이나 __delete__를 구현하여 인스턴스 속성보다 우선순위 높음\n- 비데이터 디스크립터: __get__만 구현하여 인스턴스 속성에 의해 가려질 수 있음\n\n**사용 사례:**\n- 프로퍼티: 간단한 getter/setter 로직이나 계산된 속성\n- 디스크립터: 여러 클래스에서 재사용할 속성 검증 로직\n- 내장 디스크립터: @staticmethod, @classmethod, @property가 디스크립터로 구현됨\n\n**실무 활용:**\n- 클래스의 private 속성에 검증 로직을 추가한 프로퍼티로 안전하게 접근\n- 타입 검증이나 범위 체크를 디스크립터로 구현하여 여러 속성에 재사용\n- 지연 평가나 캐싱을 프로퍼티로 구현하여 성능 최적화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-zmzxlct0",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 다중 상속과 MRO(Method Resolution Order)에 대해 설명해주세요.",
      "answer": "**정의:**\nPython은 다중 상속을 지원하여 클래스가 여러 부모 클래스를 상속받을 수 있습니다. MRO는 메서드를 찾을 때 클래스 계층을 탐색하는 순서를 정의하며, C3 Linearization 알고리즘을 사용하여 일관성 있고 예측 가능한 순서를 보장합니다.\n\n**특징/원리:**\n- 다이아몬드 문제: 여러 경로로 같은 부모를 상속받을 때 발생하는 문제\n- C3 알고리즘: Python 3의 MRO는 C3 Linearization으로 계산되어 일관성 보장\n- 왼쪽 우선: 상속 목록에서 왼쪽 클래스가 오른쪽보다 우선순위 높음\n- 깊이 우선: 부모 클래스보다 자식 클래스가 우선순위 높음\n\n**MRO 규칙:**\n- 자식 우선: 메서드는 자식 클래스에서 먼저 찾음\n- 왼쪽에서 오른쪽: 상속 목록 순서대로 탐색\n- 일관성: 부모의 MRO 순서를 위반하지 않음\n- object: 모든 클래스의 최상위 부모인 object가 마지막\n\n**MRO 확인:**\n- Class.__mro__: 튜플 형태로 MRO 순서 반환\n- Class.mro(): 리스트 형태로 MRO 순서 반환\n- super(): MRO 순서에 따라 다음 클래스의 메서드 호출\n\n**super() 함수:**\n- 동작: MRO에서 현재 클래스 다음 클래스의 메서드 호출\n- 협력적 다중 상속: 모든 부모의 __init__()을 호출하기 위해 super() 사용\n- 매개변수 전달: super().__init__()으로 부모 생성자에 인자 전달\n\n**다이아몬드 문제 해결:**\n- C3 알고리즘: 일관된 순서로 탐색하여 같은 부모를 한 번만 방문\n- 명시적 호출: super() 대신 부모 클래스를 명시적으로 호출하면 여러 번 호출 가능\n- 설계: 가능하면 다이아몬드 상속 구조를 피하고 단순하게 설계\n\n**실무 활용:**\n- 믹스인 클래스로 기능을 조합하여 다양한 클래스 생성\n- super()를 사용하여 모든 부모 클래스의 초기화 메서드를 올바르게 호출\n- __mro__를 확인하여 다중 상속 구조를 디버깅하고 이해",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-3vqjtd9f",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 추상 클래스(ABC)와 인터페이스 구현 방법은 무엇인가요?",
      "answer": "**정의:**\n추상 클래스는 인스턴스를 직접 생성할 수 없고 서브클래스에서 추상 메서드를 구현하도록 강제하는 클래스입니다. abc 모듈의 ABC 클래스와 @abstractmethod 데코레이터를 사용하여 정의하며, 인터페이스와 유사한 역할을 합니다.\n\n**특징/원리:**\n- 인스턴스 생성 불가: 추상 메서드가 있는 클래스는 직접 인스턴스화 불가\n- 강제 구현: 서브클래스가 모든 추상 메서드를 구현해야 인스턴스 생성 가능\n- 부분 구현: 추상 클래스는 일반 메서드와 추상 메서드를 모두 가질 수 있음\n- 타입 체크: isinstance()와 issubclass()로 추상 클래스 확인 가능\n\n**abc 모듈:**\n- ABC: 추상 클래스의 기반 클래스\n- ABCMeta: 추상 클래스의 메타클래스\n- @abstractmethod: 추상 메서드를 정의하는 데코레이터\n- @abstractproperty: 추상 프로퍼티 정의 (deprecated, @property와 @abstractmethod 조합 사용)\n\n**추상 메서드:**\n- 선언: @abstractmethod 데코레이터로 메서드 선언\n- 구현 없음: 메서드 본문은 pass나 NotImplementedError\n- 다중 데코레이터: @classmethod, @staticmethod와 함께 사용 가능하며 @abstractmethod가 가장 안쪽\n- 구현 강제: 서브클래스에서 반드시 구현해야 인스턴스 생성 가능\n\n**인터페이스 패턴:**\n- 순수 인터페이스: 모든 메서드가 추상 메서드인 추상 클래스\n- 프로토콜: typing 모듈의 Protocol로 구조적 서브타이핑 구현\n- 덕 타이핑: 명시적 상속 없이도 같은 인터페이스를 구현하면 호환\n\n**가상 서브클래스:**\n- register(): ABC.register()로 클래스를 가상 서브클래스로 등록\n- isinstance 통과: 등록된 클래스는 isinstance 검사를 통과하지만 메서드 구현 강제 안 됨\n- 덕 타이핑 지원: 실제 상속 없이도 타입 호환성 표현\n\n**실무 활용:**\n- 플러그인 시스템에서 추상 기반 클래스로 인터페이스 정의\n- 템플릿 메서드 패턴으로 알고리즘 구조를 정의하고 세부 단계는 서브클래스에서 구현\n- 타입 힌트와 함께 사용하여 명확한 계약 정의하고 정적 분석 도구 활용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-yy5pxu70",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 Duck Typing이란 무엇인가요?",
      "answer": "**정의:**\nDuck Typing은 객체의 타입보다는 객체가 특정 메서드나 속성을 가지고 있는지로 판단하는 동적 타이핑 방식입니다. \"오리처럼 걷고 오리처럼 울면 오리다\"라는 철학으로, 명시적 타입이나 상속 관계보다 실제 동작을 중시합니다.\n\n**특징/원리:**\n- 인터페이스 기반: 객체가 어떤 클래스인지보다 어떤 메서드를 제공하는지가 중요\n- 런타임 검사: 컴파일 타임이 아닌 실행 시점에 메서드 존재 여부 확인\n- 유연성: 명시적 상속 없이도 같은 인터페이스를 구현하면 호환 가능\n- EAFP: \"허락보다 용서가 쉽다\" 원칙으로 일단 시도하고 예외 처리\n\n**장점:**\n- 느슨한 결합: 구체적인 타입에 의존하지 않아 결합도 낮음\n- 재사용성: 다양한 타입의 객체를 동일하게 처리 가능\n- 간결성: 타입 체크나 변환 코드가 필요 없어 코드가 간결\n- 프로토타입 기반: 프로토타이핑과 빠른 개발에 유리\n\n**단점:**\n- 런타임 에러: 타입 불일치가 런타임에 발견되어 디버깅 어려움\n- 문서 필요: 어떤 메서드가 필요한지 명시적이지 않아 문서화 중요\n- IDE 지원: 정적 타입이 아니라 자동완성이나 리팩토링 지원 제한적\n- 예측 어려움: 코드만 보고 어떤 타입이 전달될지 예측 어려움\n\n**Duck Typing vs Static Typing:**\n- Duck Typing: 유연하고 간결하지만 런타임 에러 가능\n- Static Typing: 안전하고 예측 가능하지만 보일러플레이트 증가\n- 타입 힌트: Python 3.5+에서 타입 힌트로 두 방식의 장점 결합 가능\n\n**EAFP vs LBYL:**\n- EAFP: Easier to Ask for Forgiveness than Permission, 일단 시도하고 예외 처리\n- LBYL: Look Before You Leap, 미리 조건 확인 후 실행\n- Pythonic: EAFP가 더 Pythonic한 스타일로 권장됨\n\n**실무 활용:**\n- 파일 유사 객체를 받는 함수에서 실제 파일인지 StringIO인지 구분하지 않고 read() 메서드만 호출\n- 이터러블을 기대하는 함수에 리스트, 튜플, 제너레이터 등 다양한 타입 전달 가능\n- 타입 힌트와 Protocol을 사용하여 Duck Typing의 유연성과 정적 분석의 안전성 결합",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-r41ce3sd",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 타입 힌팅(Type Hinting)과 정적 타입 체커(mypy)에 대해 설명해주세요?",
      "answer": "**정의:**\n타입 힌팅은 Python 3.5+에서 도입된 기능으로 변수, 함수 파라미터, 반환값의 타입을 주석으로 표시합니다. mypy는 타입 힌트를 분석하여 컴파일 타임에 타입 오류를 검출하는 정적 타입 체커로, 런타임 전에 타입 관련 버그를 발견합니다.\n\n**특징/원리:**\n- 선택적: 타입 힌트는 선택 사항이며 런타임 동작에 영향 없음\n- 점진적 타이핑: 기존 코드에 점진적으로 타입 힌트 추가 가능\n- 정적 분석: mypy 같은 도구로 타입 검사를 수행하여 오류 사전 발견\n- 문서화: 타입 힌트 자체가 함수의 인터페이스를 명확히 문서화\n\n**기본 타입 힌트:**\n- 변수: x: int = 5 형태로 변수의 타입 명시\n- 함수 파라미터: def func(name: str, age: int) 형태로 파라미터 타입 명시\n- 반환값: def func() -> str 형태로 반환 타입 명시\n- 내장 타입: int, str, float, bool, list, dict, tuple 등 사용\n\n**typing 모듈:**\n- List, Dict, Tuple: 제네릭 타입으로 요소의 타입까지 명시\n- Optional: None이 될 수 있는 타입, Optional[int]는 int | None과 동일\n- Union: 여러 타입 중 하나, Union[int, str]은 int 또는 str\n- Callable: 함수 타입, Callable[[int, str], bool]은 int와 str를 받아 bool 반환\n- TypeVar: 제네릭 타입 변수 정의\n- Protocol: 구조적 서브타이핑 지원\n\n**mypy:**\n- 설치: pip install mypy로 설치\n- 실행: mypy script.py로 타입 검사 수행\n- 설정: mypy.ini나 pyproject.toml로 검사 옵션 설정\n- 점진적: --ignore-missing-imports로 타입 힌트 없는 라이브러리 무시\n\n**고급 타입:**\n- Generic: 제네릭 클래스나 함수 정의\n- Literal: 특정 값으로 제한된 타입\n- Final: 재할당 불가능한 상수 표시\n- TypedDict: 딕셔너리의 키와 값 타입을 명시\n- Annotated: 타입에 메타데이터 추가\n\n**실무 활용:**\n- 대규모 프로젝트에서 타입 힌트로 인터페이스를 명확히 하고 리팩토링 안전성 향상\n- mypy를 CI/CD 파이프라인에 통합하여 타입 오류를 자동으로 검출\n- IDE의 자동완성과 타입 체크 기능을 활용하여 개발 생산성 향상",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-ohxfg076",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 동시성 처리 방법(Threading, Multiprocessing, Asyncio)을 비교해주세요.",
      "answer": "**정의:**\nPython은 Threading, Multiprocessing, Asyncio 세 가지 주요 동시성 처리 방법을 제공합니다. Threading은 단일 프로세스 내 여러 스레드, Multiprocessing은 여러 프로세스, Asyncio는 단일 스레드에서 협력적 멀티태스킹을 사용하며, 작업 유형에 따라 적절한 방법을 선택해야 합니다.\n\n**특징/원리:**\n- Threading: GIL로 인해 I/O-bound 작업에만 효과적이며 CPU-bound에는 부적합\n- Multiprocessing: 별도 프로세스로 GIL 우회하여 CPU-bound 작업에 적합하지만 오버헤드 큼\n- Asyncio: 이벤트 루프 기반으로 많은 I/O 작업을 효율적으로 처리하지만 CPU-bound에는 부적합\n\n**Threading:**\n- 사용: threading 모듈로 스레드 생성 및 관리\n- GIL 제약: 한 번에 하나의 스레드만 Python 바이트코드 실행\n- I/O 대기: I/O 작업 중에는 GIL을 해제하여 다른 스레드 실행 가능\n- 공유 메모리: 스레드 간 메모리 공유로 통신 간편하지만 동기화 필요\n- 컨텍스트 전환: 운영체제가 스레드 스케줄링하여 선점형 멀티태스킹\n\n**Multiprocessing:**\n- 사용: multiprocessing 모듈로 프로세스 생성 및 관리\n- GIL 우회: 각 프로세스가 독립적인 GIL을 가져 진정한 병렬 실행\n- CPU-bound: CPU 집약적 작업을 여러 코어에서 동시 실행\n- 독립 메모리: 프로세스 간 메모리 독립적이어서 통신에 Queue, Pipe 필요\n- 오버헤드: 프로세스 생성과 IPC 비용이 스레드보다 큼\n\n**Asyncio:**\n- 사용: asyncio 모듈과 async/await 문법 사용\n- 이벤트 루프: 단일 스레드에서 이벤트 루프가 작업 스케줄링\n- 협력적: 명시적으로 await할 때만 제어를 양보하는 협력형 멀티태스킹\n- 높은 동시성: 수천 개의 동시 I/O 작업을 효율적으로 처리\n- Non-blocking: I/O 대기 중에도 다른 작업 실행 가능\n\n**선택 기준:**\n- I/O-bound + 간단: Threading 사용, 스레드 풀로 관리\n- I/O-bound + 고동시성: Asyncio 사용, 웹 서버나 크롤러에 적합\n- CPU-bound: Multiprocessing 사용, 데이터 분석이나 계산 작업에 적합\n- 혼합: 적절히 조합하여 사용, asyncio에서 CPU 작업을 ProcessPoolExecutor로 위임\n\n**실무 활용:**\n- 웹 크롤러는 asyncio로 많은 HTTP 요청을 동시에 처리\n- 데이터 처리 파이프라인은 multiprocessing으로 병렬 계산\n- 백그라운드 작업은 threading으로 간단하게 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633098-mu15fnsx",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 asyncio와 비동기 프로그래밍에 대해 설명해주세요.",
      "answer": "**정의:**\nasyncio는 Python의 표준 라이브러리로 async/await 문법을 사용하여 비동기 프로그래밍을 지원합니다. 이벤트 루프 기반으로 I/O-bound 작업을 효율적으로 처리하며, 단일 스레드에서 수천 개의 동시 작업을 관리할 수 있습니다.\n\n**특징/원리:**\n- 이벤트 루프: 작업을 스케줄링하고 실행하는 핵심 구성 요소\n- 코루틴: async def로 정의되며 await로 실행을 중단하고 재개 가능\n- Non-blocking: I/O 대기 중에도 다른 작업 실행하여 CPU 효율성 향상\n- 단일 스레드: 스레드 안전 문제 없이 많은 동시 작업 처리\n\n**async/await 문법:**\n- async def: 코루틴 함수를 정의하며 호출 시 코루틴 객체 반환\n- await: 코루틴이나 Future가 완료될 때까지 대기하며 제어를 양보\n- 비동기 컨텍스트: async with와 async for로 비동기 컨텍스트 매니저와 이터레이터 사용\n- 제약: await는 async 함수 내에서만 사용 가능\n\n**핵심 개념:**\n- Task: 코루틴을 이벤트 루프에서 실행하는 래퍼\n- Future: 비동기 작업의 최종 결과를 나타내는 저수준 객체\n- create_task(): 코루틴을 Task로 래핑하여 이벤트 루프에 스케줄\n- gather(): 여러 코루틴을 동시에 실행하고 모든 결과를 기다림\n\n**이벤트 루프:**\n- asyncio.run(): 이벤트 루프를 생성하고 코루틴 실행 후 정리\n- get_event_loop(): 현재 이벤트 루프 가져오기\n- run_until_complete(): 코루틴이 완료될 때까지 이벤트 루프 실행\n- 스케줄링: 코루틴, 콜백, Task를 관리하고 실행\n\n**동시성 제어:**\n- Semaphore: 동시 실행 가능한 작업 수 제한\n- Lock: 공유 리소스에 대한 배타적 접근 보장\n- Queue: 비동기 생산자-소비자 패턴 구현\n- Event: 스레드 간 신호 전달\n\n**주의사항:**\n- 블로킹 작업: 블로킹 I/O나 CPU 작업은 run_in_executor()로 스레드/프로세스 풀에 위임\n- 동기 코드 통합: 동기 라이브러리를 직접 사용하면 전체 이벤트 루프 블로킹\n- 디버깅: 비동기 코드는 디버깅이 어려우므로 로깅과 테스트 중요\n\n**실무 활용:**\n- 비동기 웹 프레임워크(FastAPI, aiohttp)로 높은 동시성의 웹 서버 구축\n- 웹 스크래핑 시 aiohttp로 수백 개의 페이지를 동시에 다운로드\n- 마이크로서비스 간 비동기 통신으로 응답성 향상",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성",
        "프로세스"
      ],
      "id": "1763437633098-gk2wfriq",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python 2와 Python 3의 주요 차이점은 무엇인가요?",
      "answer": "**정의:**\nPython 3는 2008년에 출시된 메이저 버전으로, Python 2와의 하위 호환성을 깨고 언어의 일관성과 현대성을 개선했습니다. 2020년에 Python 2 지원이 종료되었으며, 현재는 Python 3만 사용이 권장됩니다.\n\n**특징/원리:**\n- 하위 호환 불가: Python 2 코드가 Python 3에서 바로 실행되지 않을 수 있음\n- 점진적 개선: Python 3가 계속 발전하며 새로운 기능 추가\n- 마이그레이션 도구: 2to3, six 등의 도구로 마이그레이션 지원\n- 지원 종료: Python 2는 2020년 1월 1일부터 공식 지원 종료\n\n**주요 차이점:**\n- print 함수: Python 2는 print 문, Python 3는 print() 함수\n- 정수 나눗셈: Python 2는 3/2=1, Python 3는 3/2=1.5, 정수 나눗셈은 //\n- 문자열: Python 2는 str과 unicode 분리, Python 3는 str이 유니코드이고 bytes는 별도\n- range: Python 2는 range가 리스트 반환, Python 3는 이터레이터 반환하여 메모리 효율적\n- 예외 처리: Python 2는 except Exception, e 문법, Python 3는 except Exception as e\n\n**문자열과 인코딩:**\n- Python 2: str은 바이트 문자열, unicode는 유니코드 문자열로 혼란 발생\n- Python 3: str은 항상 유니코드, bytes는 바이트 시퀀스로 명확히 구분\n- 기본 인코딩: Python 3는 소스 파일이 기본적으로 UTF-8\n- 문자열 리터럴: Python 2는 u\"문자열\", Python 3는 기본이 유니코드\n\n**이터레이터:**\n- range, zip, map, filter: Python 3에서 모두 이터레이터 반환하여 메모리 효율\n- dict 메서드: keys(), values(), items()가 Python 3에서 뷰 객체 반환\n- 지연 평가: Python 3가 더 많은 곳에서 지연 평가 사용\n\n**기타 변경사항:**\n- input: Python 2의 raw_input()이 Python 3의 input()이 됨\n- 정수 타입: Python 2는 int와 long 분리, Python 3는 int만 존재하고 자동 확장\n- 메타클래스: Python 3는 metaclass=Meta 문법으로 더 명확\n- super: Python 3는 인자 없는 super() 지원으로 간결\n\n**마이그레이션:**\n- 2to3 도구: 자동으로 Python 2 코드를 Python 3로 변환\n- six 라이브러리: Python 2와 3 호환 코드 작성 지원\n- __future__: Python 2에서 from __future__ import로 Python 3 기능 사용\n- 점진적 전환: 테스트 커버리지 확보 후 단계적으로 마이그레이션\n\n**실무 활용:**\n- 새 프로젝트는 무조건 Python 3 사용\n- 레거시 코드는 테스트를 작성하고 점진적으로 Python 3로 마이그레이션\n- 라이브러리는 Python 3만 지원하거나 six로 양쪽 지원",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633098-wkwmis69",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 패키지 관리 도구(pip, pipenv, poetry)를 비교해주세요.",
      "answer": "**정의:**\nPython의 패키지 관리 도구는 의존성을 설치하고 관리하는 도구로, pip는 기본 도구이고, pipenv와 poetry는 가상 환경과 의존성을 통합 관리하는 현대적 도구입니다. 각각 장단점이 있어 프로젝트 특성에 맞게 선택합니다.\n\n**특징/원리:**\n- 의존성 관리: 프로젝트에 필요한 패키지와 버전을 명시하고 설치\n- 가상 환경: 프로젝트별로 독립된 환경을 만들어 의존성 충돌 방지\n- 재현성: 동일한 의존성 버전으로 어디서나 같은 환경 구축\n- 잠금 파일: 정확한 버전을 고정하여 일관된 환경 보장\n\n**pip:**\n- 기본 도구: Python 설치 시 기본 포함되는 패키지 관리자\n- requirements.txt: 의존성 목록을 텍스트 파일로 관리\n- 간단함: 가장 기본적이고 널리 사용됨\n- 한계: 가상 환경을 별도로 관리해야 하고 의존성 해결이 약함\n\n**pipenv:**\n- 통합 관리: 가상 환경과 패키지 관리를 통합\n- Pipfile: requirements.txt를 대체하는 TOML 형식 파일\n- Pipfile.lock: 정확한 버전과 해시를 기록하여 보안과 재현성 향상\n- 자동 생성: pipenv install 시 자동으로 가상 환경 생성\n- 단점: 느린 속도와 복잡한 의존성 해결\n\n**poetry:**\n- 현대적: 최신 Python 프로젝트 관리 도구\n- pyproject.toml: PEP 518 표준 설정 파일 사용\n- poetry.lock: 의존성 잠금 파일로 정확한 재현\n- 빌드 시스템: 패키지 빌드와 배포까지 통합 지원\n- 빠른 의존성 해결: pipenv보다 빠르고 정확한 의존성 해결\n- 가상 환경: 자동으로 생성하고 관리\n\n**비교:**\n- 사용 편의성: poetry > pipenv > pip + venv\n- 속도: pip > poetry > pipenv\n- 기능: poetry > pipenv > pip\n- 표준 준수: poetry > pipenv > pip\n- 학습 곡선: pip < pipenv < poetry\n\n**선택 기준:**\n- 간단한 프로젝트: pip와 venv로 충분\n- 협업 프로젝트: pipenv나 poetry로 의존성 정확히 관리\n- 라이브러리 개발: poetry로 빌드와 배포까지 통합 관리\n- 레거시: 기존 requirements.txt 사용 중이면 점진적 전환\n\n**실무 활용:**\n- 새 프로젝트는 poetry로 시작하여 현대적인 의존성 관리\n- CI/CD에서 잠금 파일을 사용하여 일관된 환경에서 테스트\n- Docker 이미지 빌드 시 잠금 파일로 재현 가능한 환경 구축",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-shyiskww",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 가상 환경(venv, virtualenv)이 필요한 이유는 무엇인가요?",
      "answer": "**정의:**\n가상 환경은 Python 프로젝트마다 독립된 패키지 설치 공간을 제공하는 도구입니다. venv는 Python 3.3+에 내장된 표준 도구이고, virtualenv는 더 다양한 기능을 제공하는 서드파티 도구로, 프로젝트 간 의존성 충돌을 방지하고 클린한 개발 환경을 유지합니다.\n\n**특징/원리:**\n- 격리: 프로젝트별로 독립된 Python 인터프리터와 패키지 디렉토리 제공\n- 의존성 관리: 각 프로젝트가 다른 버전의 패키지 사용 가능\n- 시스템 보호: 시스템 전역 Python 환경을 건드리지 않음\n- 재현성: 가상 환경과 requirements.txt로 동일한 환경 재구성 가능\n\n**필요한 이유:**\n- 버전 충돌: 프로젝트 A는 Django 2.2, 프로젝트 B는 Django 3.2 필요 시 충돌 방지\n- 깔끔한 환경: 테스트나 실험용 패키지가 시스템을 오염시키지 않음\n- 권한 문제: 시스템 Python에 패키지 설치 시 관리자 권한 필요할 수 있지만 가상 환경은 불필요\n- 배포: 프로덕션 환경에 정확히 필요한 패키지만 설치 가능\n\n**venv:**\n- 표준 라이브러리: Python 3.3+에 내장되어 별도 설치 불필요\n- 생성: python -m venv myenv로 가상 환경 생성\n- 활성화: Windows는 myenv\\\\Scripts\\\\activate, Unix는 source myenv/bin/activate\n- 경량: 최소한의 기능만 제공하여 가볍고 빠름\n\n**virtualenv:**\n- 서드파티: pip install virtualenv로 설치 필요\n- Python 2 지원: Python 2.7에서도 사용 가능\n- 추가 기능: 더 빠른 생성, 다양한 Python 버전 지원 등\n- 플러그인: 확장 가능한 아키텍처\n\n**사용 패턴:**\n- 환경 생성: 프로젝트 시작 시 가상 환경 생성\n- 활성화: 작업 전 가상 환경 활성화하여 격리된 공간에서 작업\n- 의존성 기록: pip freeze > requirements.txt로 패키지 목록 저장\n- 재구성: pip install -r requirements.txt로 같은 환경 재구성\n\n**실무 활용:**\n- 모든 Python 프로젝트에서 가상 환경을 기본으로 사용\n- Docker 컨테이너 내에서도 가상 환경 사용하여 명확한 의존성 관리\n- CI/CD 파이프라인에서 가상 환경 생성하고 의존성 설치하여 테스트",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-5ku0ivmi",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 모듈 import 방식과 __init__.py의 역할을 설명해주세요.",
      "answer": "**정의:**\nPython의 모듈 시스템은 코드를 재사용 가능한 단위로 구조화하며, import 문으로 다른 모듈이나 패키지를 불러옵니다. __init__.py는 디렉토리를 패키지로 인식하게 하고 패키지 초기화 코드를 실행하는 특수 파일입니다.\n\n**특징/원리:**\n- 모듈: 단일 .py 파일로 함수, 클래스, 변수를 포함\n- 패키지: 모듈을 포함하는 디렉토리로 __init__.py 파일 필요 (Python 3.3+에서는 선택적)\n- 네임스페이스: 각 모듈은 독립된 네임스페이스를 가져 이름 충돌 방지\n- 캐싱: 모듈은 최초 import 시 한 번만 로드되고 sys.modules에 캐싱\n\n**import 방식:**\n- import module: 모듈 전체를 가져오고 module.name으로 접근\n- from module import name: 특정 이름만 가져와 직접 사용\n- from module import *: 모듈의 모든 공개 이름 가져오기 (권장되지 않음)\n- import module as alias: 모듈에 별칭 부여\n- from module import name as alias: 특정 이름에 별칭 부여\n\n**__init__.py 역할:**\n- 패키지 표시: 디렉토리가 Python 패키지임을 표시 (Python 3.3+ namespace package 제외)\n- 초기화: 패키지 import 시 실행되는 초기화 코드 포함\n- 네임스페이스: __all__ 변수로 from package import * 시 가져올 이름 제어\n- 편의성: 하위 모듈을 패키지 레벨에서 재export하여 접근 경로 단축\n\n**import 검색 경로:**\n- 현재 디렉토리: 스크립트가 실행되는 디렉토리\n- PYTHONPATH: 환경 변수로 지정된 디렉토리\n- 표준 라이브러리: Python 설치 디렉토리\n- site-packages: pip로 설치된 패키지 디렉토리\n- sys.path: 검색 경로 리스트로 런타임에 수정 가능\n\n**상대 import:**\n- 명시적 상대: from .module import name처럼 점 표기법 사용\n- 암묵적 상대: Python 2에서 가능했지만 Python 3에서 제거\n- 패키지 내부: 같은 패키지 내 모듈 간 상대 import로 참조\n- 제약: 스크립트로 직접 실행되는 파일에서는 상대 import 불가\n\n**순환 import 문제:**\n- 원인: 모듈 A가 B를 import하고 B가 A를 import하면 순환 참조\n- 해결: import 위치 변경, 함수 내부로 이동, 중간 모듈 도입\n- 설계: 의존성 방향을 명확히 하여 순환 참조 방지\n\n**실무 활용:**\n- __init__.py에서 자주 사용하는 함수/클래스를 패키지 레벨로 올려 사용자 편의성 향상\n- __all__로 공개 API를 명시하여 의도치 않은 내부 구현 노출 방지\n- 절대 import를 기본으로 사용하고 상대 import는 패키지 내부에서만 사용",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-lrfhi7p2",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Python의 성능 최적화 방법에는 어떤 것들이 있나요?",
      "answer": "**정의:**\nPython의 성능 최적화는 코드 실행 속도를 향상시키거나 메모리 사용량을 줄이는 기법들입니다. 프로파일링으로 병목 지점을 찾고, 알고리즘 개선, 내장 함수 활용, C 확장, JIT 컴파일 등 다양한 방법을 적용합니다.\n\n**특징/원리:**\n- 측정 우선: 추측하지 말고 프로파일링으로 실제 병목 확인\n- 80/20 법칙: 전체 시간의 80%를 차지하는 20% 코드에 집중\n- 알고리즘 우선: 작은 최적화보다 올바른 알고리즘 선택이 중요\n- 가독성 균형: 성능과 가독성/유지보수성 사이 균형 유지\n\n**프로파일링:**\n- cProfile: 표준 라이브러리 프로파일러로 함수별 실행 시간 측정\n- line_profiler: 라인 단위로 실행 시간 측정\n- memory_profiler: 메모리 사용량을 라인별로 분석\n- timeit: 작은 코드 조각의 실행 시간 정확히 측정\n\n**내장 함수와 자료구조:**\n- 내장 함수: sum(), min(), max() 등은 C로 구현되어 빠름\n- 리스트 컴프리헨션: for 루프보다 빠르고 간결\n- 제너레이터: 대용량 데이터를 메모리 효율적으로 처리\n- set과 dict: O(1) 검색으로 list의 O(n)보다 빠름\n- collections: deque, Counter, defaultdict 등 최적화된 자료구조\n\n**알고리즘 최적화:**\n- 적절한 자료구조: 빈번한 검색은 set/dict, 순서 유지는 list\n- 캐싱: functools.lru_cache로 반복 계산 결과 저장\n- 조기 종료: any(), all()로 조건 만족 시 즉시 종료\n- 불필요한 작업 제거: 루프 내 상수 계산을 루프 밖으로 이동\n\n**C 확장과 라이브러리:**\n- NumPy: 배열 연산을 C로 처리하여 수백 배 빠름\n- Pandas: 대용량 데이터 처리에 최적화\n- Cython: Python 코드를 C로 컴파일하여 성능 향상\n- numba: JIT 컴파일러로 함수를 기계어로 컴파일\n\n**병렬 처리:**\n- multiprocessing: CPU-bound 작업을 여러 프로세스로 병렬 처리\n- concurrent.futures: ThreadPoolExecutor, ProcessPoolExecutor로 간편한 병렬화\n- asyncio: I/O-bound 작업을 비동기로 처리하여 대기 시간 감소\n\n**메모리 최적화:**\n- __slots__: 클래스의 메모리 사용량 감소\n- 제너레이터: 전체 리스트 대신 필요시 생성\n- del: 불필요한 객체를 명시적으로 삭제하여 메모리 해제\n- 약한 참조: weakref로 순환 참조 방지\n\n**실무 활용:**\n- 데이터 분석은 Pandas와 NumPy로 벡터화 연산 활용\n- 병목 구간을 Cython이나 C 확장으로 재작성하여 성능 향상\n- 웹 애플리케이션은 캐싱과 비동기 I/O로 응답 속도 개선",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633098-3zy3nkmz",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go 언어의 특징과 장단점을 설명해주세요.",
      "answer": "**정의:**\nGo는 Google이 2009년에 발표한 컴파일 언어로, 간결성, 동시성, 성능에 중점을 둔 시스템 프로그래밍 언어입니다. C언어의 성능과 Python의 생산성을 결합하려는 목표로 설계되었으며, 클라우드 인프라와 마이크로서비스 개발에 널리 사용됩니다.\n\n**특징/원리:**\n- 간결성: 최소한의 키워드와 간단한 문법으로 빠른 학습 곡선\n- 컴파일 언어: 네이티브 기계어로 컴파일되어 빠른 실행 속도\n- 정적 타입: 컴파일 타임 타입 검사로 안정성 제공\n- 가비지 컬렉션: 자동 메모리 관리로 메모리 안전성 보장\n- 동시성: 고루틴과 채널로 경량 스레드 기반 동시성 지원\n\n**장점:**\n- 빠른 컴파일: 대규모 프로젝트도 몇 초 내에 컴파일 완료\n- 높은 성능: C/C++에 근접한 실행 속도로 성능 집약적 작업에 적합\n- 간단한 동시성: 고루틴으로 수천 개의 동시 작업을 쉽게 관리\n- 표준 라이브러리: HTTP 서버, JSON 처리 등 풍부한 표준 라이브러리\n- 정적 링크: 단일 바이너리로 배포되어 의존성 관리 간편\n- 크로스 컴파일: 다양한 플랫폼용 바이너리를 쉽게 빌드\n\n**단점:**\n- 제한된 표현력: 제네릭이 최근에야 추가되어 코드 재사용성 제약\n- 에러 처리: 명시적 에러 처리로 보일러플레이트 코드 증가\n- 패키지 관리: 초기에는 의존성 관리가 약했으나 Go Modules로 개선\n- 함수형 기능 부족: map, filter 등 고차 함수가 표준 라이브러리에 없음\n- 상속 없음: 구조체 임베딩으로 대체하지만 전통적 OOP와 다름\n\n**주요 사용 사례:**\n- 클라우드 인프라: Docker, Kubernetes 등 컨테이너 오케스트레이션\n- 마이크로서비스: gRPC와 결합하여 고성능 서비스 구축\n- CLI 도구: 빠른 실행과 단일 바이너리로 배포 용이\n- 네트워크 서버: 높은 동시성이 필요한 웹 서버나 프록시\n- 데이터 파이프라인: 대용량 데이터 처리와 ETL 작업\n\n**실무 활용:**\n- 마이크로서비스 아키텍처에서 고성능 백엔드 서비스 개발\n- Kubernetes 같은 대규모 분산 시스템 구축\n- RESTful API나 gRPC 서버를 빠르게 개발하고 배포",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "메모리"
      ],
      "id": "1763437633098-rsoat6v5",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 고루틴(Goroutine)과 스레드의 차이점은 무엇인가요?",
      "answer": "**정의:**\n고루틴은 Go 런타임이 관리하는 경량 스레드로, 매우 적은 메모리로 시작하고 필요에 따라 스택이 증가합니다. OS 스레드보다 훨씬 가볍고 빠르게 생성되어, 수천에서 수백만 개의 고루틴을 동시에 실행할 수 있습니다.\n\n**특징/원리:**\n- 경량: 고루틴은 2KB 정도로 시작하지만 OS 스레드는 1-2MB 필요\n- M:N 스케줄링: 여러 고루틴이 적은 수의 OS 스레드에서 멀티플렉싱\n- 협력적 스케줄링: 고루틴이 명시적으로 양보하거나 블로킹 시 스케줄링\n- 동적 스택: 스택이 필요에 따라 자동으로 증가하고 감소\n\n**고루틴 vs OS 스레드:**\n- 생성 비용: 고루틴은 마이크로초, 스레드는 밀리초 수준\n- 메모리: 고루틴은 KB 단위, 스레드는 MB 단위\n- 컨텍스트 전환: 고루틴은 사용자 공간에서 처리되어 매우 빠름\n- 수량: 고루틴은 수백만 개 가능, 스레드는 수천 개 정도가 한계\n- 스케줄링: 고루틴은 Go 런타임이, 스레드는 OS가 스케줄링\n\n**Go 스케줄러:**\n- G-M-P 모델: G(Goroutine), M(Machine/OS thread), P(Processor)로 구성\n- Work Stealing: 유휴 P가 다른 P의 고루틴을 가져와 처리\n- 시스템 콜 처리: 블로킹 시스템 콜 시 M을 분리하여 다른 고루틴 계속 실행\n- 비선점형: Go 1.14부터 비동기 선점형 스케줄링 도입\n\n**고루틴 생성:**\n- go 키워드: go func()로 함수를 고루틴으로 실행\n- 익명 함수: go func() { }()로 즉시 실행\n- 클로저: 외부 변수를 캡처하는 클로저로 고루틴 생성 가능\n- 메인 종료: main 함수 종료 시 모든 고루틴도 강제 종료\n\n**동기화:**\n- WaitGroup: 여러 고루틴의 완료를 기다림\n- 채널: 고루틴 간 안전한 통신과 동기화\n- Mutex: 공유 자원에 대한 배타적 접근\n- Context: 타임아웃, 취소 신호 전파\n\n**실무 활용:**\n- 웹 서버에서 각 요청을 별도 고루틴으로 처리하여 높은 동시성 달성\n- 배치 처리 시 고루틴 풀을 만들어 작업을 병렬로 처리\n- 이벤트 처리, 로그 수집 등 백그라운드 작업을 고루틴으로 실행",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633098-hkippykk",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 채널(Channel)의 동작 원리와 사용 방법을 설명해주세요.",
      "answer": "**정의:**\n채널은 고루틴 간 안전하게 데이터를 주고받는 통신 메커니즘입니다. 타입 안전한 큐처럼 동작하며, 보내는 쪽과 받는 쪽을 동기화하여 고루틴 간 협력을 가능하게 합니다. \"공유 메모리로 통신하지 말고, 통신으로 메모리를 공유하라\"는 Go의 철학을 구현합니다.\n\n**특징/원리:**\n- 타입 안전: 특정 타입의 데이터만 전송 가능\n- 동기화: 송신과 수신이 만날 때까지 블로킹되어 동기화 제공\n- FIFO: 먼저 보낸 데이터가 먼저 수신됨\n- 양방향: 기본적으로 양방향이지만 단방향으로 제약 가능\n\n**채널 종류:**\n- 버퍼 없는 채널: make(chan T)로 생성하며 송수신이 동시에 일어나야 함\n- 버퍼 있는 채널: make(chan T, capacity)로 생성하며 버퍼가 찰 때까지 블로킹 안 됨\n- 단방향 채널: chan<- T는 송신 전용, <-chan T는 수신 전용으로 타입 안전성 향상\n\n**기본 연산:**\n- 송신: ch <- value로 채널에 값 전송\n- 수신: value := <-ch로 채널에서 값 수신\n- 닫기: close(ch)로 채널 닫기, 닫힌 채널에서 수신 시 제로값과 false 반환\n- 수신 확인: value, ok := <-ch로 채널이 열려있는지 확인\n\n**select 문:**\n- 다중 채널: 여러 채널 중 준비된 것 선택\n- 비블로킹: default 케이스로 블로킹 없이 즉시 반환\n- 타임아웃: time.After와 함께 사용하여 타임아웃 구현\n- 임의 선택: 여러 케이스가 준비되면 무작위로 하나 선택\n\n**패턴:**\n- 팬아웃: 하나의 입력을 여러 고루틴에 분배\n- 팬인: 여러 고루틴의 출력을 하나로 합침\n- 파이프라인: 채널로 고루틴을 연결하여 데이터 처리 파이프라인 구성\n- Done 채널: 빈 struct 채널로 완료 신호 전파\n\n**주의사항:**\n- 데드락: 송수신이 짝을 이루지 않으면 데드락 발생\n- 닫힌 채널: 닫힌 채널에 송신 시 패닉 발생\n- nil 채널: nil 채널에 송수신 시 영구 블로킹\n- 채널 방향: 함수 시그니처에 채널 방향 명시하여 오용 방지\n\n**실무 활용:**\n- 워커 풀 패턴으로 작업을 채널로 분배하고 결과를 수집\n- 타임아웃이 있는 RPC 호출을 select로 구현\n- 이벤트 브로드캐스팅이나 pub-sub 패턴을 채널로 구현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동기화"
      ],
      "id": "1763437633098-ale76a0k",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 select 문의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\nselect 문은 여러 채널 연산 중 준비된 것을 선택하여 실행하는 제어 구조입니다. switch 문과 유사한 문법이지만 채널 연산만 케이스로 사용하며, 여러 고루틴의 통신을 조율하는 핵심 도구입니다.\n\n**특징/원리:**\n- 동시 대기: 모든 채널 연산을 동시에 대기\n- 즉시 실행: 준비된 케이스를 즉시 실행\n- 무작위 선택: 여러 케이스가 준비되면 무작위로 하나 선택하여 공정성 보장\n- 블로킹: 준비된 케이스가 없으면 하나라도 준비될 때까지 블로킹\n\n**기본 문법:**\n- case: 각 case는 채널 송신이나 수신 연산\n- default: 준비된 케이스가 없을 때 즉시 실행되는 비블로킹 옵션\n- 실행: 준비된 케이스의 통신이 실행되고 해당 블록 실행\n- 반복: select 자체는 한 번만 실행되므로 반복하려면 for 루프 사용\n\n**사용 패턴:**\n- 타임아웃: time.After 채널과 함께 사용하여 타임아웃 구현\n- 비블로킹 수신: default 케이스로 채널에 값이 없어도 즉시 반환\n- 여러 입력: 여러 소스로부터 데이터를 받아 처리\n- Done 신호: done 채널로 고루틴 종료 신호 감지\n\n**타임아웃 구현:**\n- time.After: 지정된 시간 후 현재 시각을 보내는 채널 반환\n- Context: context.WithTimeout으로 타임아웃 있는 컨텍스트 생성\n- Ticker: 주기적인 이벤트 처리\n\n**주의사항:**\n- 빈 select: case가 없는 select는 영구 블로킹\n- nil 채널: nil 채널은 절대 준비되지 않아 해당 case 무시됨\n- 송신 케이스: 채널이 닫히지 않았고 버퍼에 공간이 있어야 준비됨\n- 공정성: Go 런타임이 무작위 선택으로 기아 상태 방지\n\n**실무 활용:**\n- HTTP 요청에 타임아웃을 적용하여 무한 대기 방지\n- 여러 워커의 결과를 먼저 도착하는 순서대로 처리\n- 주기적인 작업과 이벤트 처리를 하나의 select로 통합",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "HTTP"
      ],
      "id": "1763437633098-mp2m538r",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 인터페이스(Interface)와 타입 시스템에 대해 설명해주세요.",
      "answer": "**정의:**\nGo의 인터페이스는 메서드 시그니처의 집합으로, 명시적 선언 없이 메서드만 구현하면 자동으로 인터페이스를 만족하는 구조적 타입 시스템을 사용합니다. \"작은 인터페이스가 좋은 인터페이스\"라는 철학으로 간결하고 조합 가능한 추상화를 제공합니다.\n\n**특징/원리:**\n- 암묵적 구현: implements 키워드 없이 메서드만 구현하면 인터페이스 만족\n- 구조적 타이핑: 타입의 이름이 아니라 구조로 호환성 판단\n- 빈 인터페이스: interface{}는 모든 타입을 받을 수 있는 최상위 타입\n- 다형성: 인터페이스 타입으로 다양한 구체 타입을 추상화\n\n**인터페이스 정의:**\n- 메서드 집합: 타입이 구현해야 할 메서드 시그니처 나열\n- 임베딩: 다른 인터페이스를 임베딩하여 합성 가능\n- 컨벤션: 메서드가 하나면 -er로 끝나는 이름 사용 (Reader, Writer)\n\n**타입 단언:**\n- 단언: value.(Type)으로 인터페이스의 구체 타입 추출\n- 안전 단언: value, ok := interfaceValue.(Type)으로 패닉 방지\n- 타입 스위치: 여러 타입을 한 번에 처리\n\n**빈 인터페이스:**\n- interface{}: 메서드가 없어 모든 타입이 만족\n- 제네릭 대용: 제네릭 추가 전에는 빈 인터페이스로 범용 코드 작성\n- 타입 안전성 부족: 런타임에 타입 단언 필요하여 오류 가능성\n\n**인터페이스 값:**\n- 동적 타입: 인터페이스 값은 동적 타입과 동적 값을 저장\n- nil 인터페이스: 동적 타입과 값이 모두 nil일 때만 nil\n- 비교: 동적 타입이 같고 값이 같으면 동일\n\n**실무 활용:**\n- io.Reader, io.Writer로 다양한 입출력 소스를 추상화\n- 작은 인터페이스를 정의하여 테스트 가능하고 확장 가능한 코드 작성\n- 덕 타이핑으로 외부 라이브러리 타입도 인터페이스로 추상화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-s7y127lr",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 포인터와 값 타입의 차이점은 무엇인가요?",
      "answer": "**정의:**\nGo는 값 타입과 포인터 타입을 명확히 구분하며, 값 타입은 데이터를 복사하고 포인터 타입은 메모리 주소를 전달합니다. 함수 호출이나 할당 시 어느 방식을 사용하느냐에 따라 성능과 동작이 달라집니다.\n\n**특징/원리:**\n- 값 전달: 기본적으로 값 타입은 복사되어 전달됨\n- 포인터: 메모리 주소를 전달하여 원본 데이터에 직접 접근\n- 명시적: &로 주소 획득, *로 역참조하여 명시적으로 포인터 사용\n- 안전성: 포인터 연산 불가능하여 C보다 안전\n\n**값 타입 특징:**\n- 복사: 할당이나 함수 호출 시 값 전체가 복사됨\n- 독립성: 복사본은 원본과 독립적이어서 수정해도 원본에 영향 없음\n- 성능: 작은 구조체는 복사가 빠르지만 큰 구조체는 비효율적\n- 스택: 작은 값은 스택에 할당되어 빠름\n\n**포인터 타입 특징:**\n- 참조: 메모리 주소만 복사되어 동일한 데이터를 가리킴\n- 수정: 포인터를 통해 원본 데이터 수정 가능\n- 효율성: 큰 구조체를 전달할 때 주소만 복사하여 효율적\n- 힙: 포인터가 가리키는 데이터는 힙에 할당될 수 있음\n\n**메서드 리시버:**\n- 값 리시버: 메서드가 복사본에 작동하여 원본 수정 불가\n- 포인터 리시버: 메서드가 원본을 수정할 수 있음\n- 관례: 큰 구조체나 수정이 필요하면 포인터 리시버 사용\n- 일관성: 하나의 타입에는 값이나 포인터 리시버 중 하나로 통일\n\n**nil 포인터:**\n- nil: 포인터의 제로값은 nil이며 유효한 주소를 가리키지 않음\n- 패닉: nil 포인터를 역참조하면 패닉 발생\n- 검사: 사용 전 nil 검사 필요\n\n**실무 활용:**\n- 큰 구조체는 포인터로 전달하여 복사 비용 절감\n- 함수에서 구조체를 수정해야 하면 포인터 파라미터 사용\n- 슬라이스, 맵, 채널은 이미 참조 타입처럼 동작하므로 포인터로 전달할 필요 없음",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633098-tc2e17l3",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 슬라이스(Slice)와 배열(Array)의 차이점을 설명해주세요.",
      "answer": "**정의:**\n배열은 고정 크기의 연속된 메모리 블록이고, 슬라이스는 배열의 일부를 참조하는 동적 크기의 뷰입니다. 배열은 값 타입이지만 슬라이스는 참조 타입처럼 동작하여 Go에서는 주로 슬라이스를 사용합니다.\n\n**특징/원리:**\n- 배열: 크기가 타입의 일부이며 변경 불가능\n- 슬라이스: 동적 크기로 필요에 따라 증가 가능\n- 복사: 배열은 전체가 복사되지만 슬라이스는 헤더만 복사되어 같은 배열 참조\n- 효율성: 대부분의 경우 슬라이스가 더 유연하고 효율적\n\n**배열 특징:**\n- 고정 크기: [5]int처럼 크기가 타입의 일부\n- 값 타입: 할당 시 전체 복사됨\n- 스택 할당: 작은 배열은 스택에 할당\n- 제한: 크기를 변경할 수 없어 유연성 부족\n\n**슬라이스 구조:**\n- 헤더: 포인터(배열 주소), len(길이), cap(용량)으로 구성\n- 동적 크기: len은 현재 길이, cap은 최대 길이\n- 확장: append로 요소 추가 시 cap 초과하면 새 배열 할당하고 복사\n\n**슬라이스 연산:**\n- 생성: make([]T, len, cap)으로 생성하거나 리터럴 사용\n- 슬라이싱: slice[low:high]로 부분 슬라이스 생성\n- append: 요소 추가하며 필요시 재할당\n- copy: 슬라이스 간 복사\n- nil 슬라이스: 제로값은 nil이며 길이와 용량 0\n\n**용량과 재할당:**\n- 용량 부족: append 시 cap 초과하면 새 배열 할당 (보통 2배 증가)\n- 성능: 재할당은 비용이 크므로 예상 크기로 make 사용\n- 공유: 여러 슬라이스가 같은 배열 참조 가능하여 수정 시 주의\n\n**실무 활용:**\n- 거의 모든 경우 배열 대신 슬라이스 사용하여 유연성 확보\n- 예상 크기를 알면 make로 용량 지정하여 재할당 방지\n- 슬라이싱 시 원본 배열이 변경될 수 있음을 주의",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633098-gsi7z42g",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 맵(Map)의 내부 구조와 동작 원리는 무엇인가요?",
      "answer": "**정의:**\n맵은 키-값 쌍을 저장하는 해시 테이블 기반 자료구조로, 키를 사용하여 빠르게 값을 조회, 삽입, 삭제할 수 있습니다. 참조 타입처럼 동작하며 동적으로 크기가 증가합니다.\n\n**특징/원리:**\n- 해시 테이블: 내부적으로 해시 테이블로 구현되어 평균 O(1) 성능\n- 참조 타입: 맵 변수는 헤더를 가리키는 포인터로 동작\n- 동적 크기: 요소 추가 시 자동으로 확장\n- 비순서: 키의 순서가 보장되지 않음\n\n**맵 연산:**\n- 생성: make(map[K]V)로 생성하거나 리터럴 사용\n- 삽입/수정: m[key] = value로 키-값 쌍 저장\n- 조회: value := m[key]로 값 조회, 없으면 제로값 반환\n- 안전 조회: value, ok := m[key]로 존재 여부 확인\n- 삭제: delete(m, key)로 키-값 쌍 제거\n- 길이: len(m)으로 요소 개수 확인\n\n**nil 맵:**\n- nil 맵: var m map[K]V는 nil 맵으로 읽기는 가능하지만 쓰기 시 패닉\n- 초기화: make로 초기화해야 쓰기 가능\n- 검사: 사용 전 nil 확인 필요\n\n**동시성:**\n- 비안전: 맵은 동시성 안전하지 않아 여러 고루틴에서 동시 접근 시 경쟁 조건\n- sync.Map: 동시성 안전한 맵 구현체\n- sync.RWMutex: 맵을 뮤텍스로 보호하여 동시성 제어\n\n**순회:**\n- for range: for key, value := range m으로 순회\n- 무작위 순서: 순회 순서는 보장되지 않으며 실행마다 달라질 수 있음\n- 안전한 삭제: 순회 중 요소 삭제 가능\n\n**실무 활용:**\n- 설정 값이나 캐시를 맵으로 저장하여 빠른 조회\n- 중복 제거나 집합 연산에 맵의 키만 사용\n- 멀티스레드 환경에서는 sync.Map 사용하거나 뮤텍스로 보호",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성",
        "캐시"
      ],
      "id": "1763437633098-i0k1kgza",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 defer, panic, recover에 대해 설명해주세요.",
      "answer": "**정의:**\ndefer는 함수 종료 시 실행될 코드를 예약하고, panic은 프로그램 실행을 중단시키며, recover는 panic을 복구합니다. 이 세 가지는 Go의 에러 처리와 리소스 정리 메커니즘의 핵심입니다.\n\n**특징/원리:**\n- defer: 함수 반환 직전에 실행되어 리소스 정리 보장\n- panic: 복구 불가능한 에러 시 프로그램 중단\n- recover: defer 함수 내에서만 panic 복구 가능\n- 스택 해제: panic 발생 시 defer 함수들을 실행하며 스택 해제\n\n**defer 특징:**\n- LIFO 순서: 여러 defer는 스택처럼 역순으로 실행\n- 인자 평가: defer 문 실행 시점에 인자 평가되지만 실행은 나중\n- 반환값 수정: 명명된 반환값을 defer에서 수정 가능\n- 리소스 정리: 파일 닫기, 락 해제 등에 활용\n\n**panic 특징:**\n- 프로그램 중단: 호출 스택을 거슬러 올라가며 프로그램 종료\n- defer 실행: panic 중에도 defer 함수는 실행됨\n- 명시적 호출: panic(value)로 명시적으로 발생 가능\n- 런타임 에러: 배열 인덱스 초과, nil 포인터 역참조 등도 panic 발생\n\n**recover 특징:**\n- defer 내부: defer 함수 안에서만 호출 의미 있음\n- panic 복구: recover()가 nil이 아니면 panic 발생 중\n- 반환값: panic에 전달된 값을 반환\n- 재panic: recover 후 다시 panic 호출 가능\n\n**에러 처리 철학:**\n- 일반 에러: error 타입으로 반환하고 호출자가 처리\n- 치명적 에러: 복구 불가능한 상황만 panic 사용\n- 라이브러리: 라이브러리는 panic 대신 error 반환 권장\n- 경계: 패키지 경계에서 panic 복구하여 error로 변환\n\n**실무 활용:**\n- 파일이나 락을 열었을 때 defer로 자동 해제하여 누수 방지\n- 웹 서버에서 핸들러의 panic을 복구하여 서버 다운 방지\n- 설정 로딩 실패 같은 치명적 에러는 panic으로 빠른 실패",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-emeaybj0",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 에러 처리 방식과 모범 사례는 무엇인가요?",
      "answer": "**정의:**\nGo는 예외(exception) 대신 error 타입을 반환값으로 사용하는 명시적 에러 처리 방식을 채택합니다. 함수는 마지막 반환값으로 error를 반환하고, 호출자는 반드시 에러를 확인하여 처리해야 합니다.\n\n**특징/원리:**\n- 명시적: 예외와 달리 에러를 반환값으로 명시적으로 처리\n- error 인터페이스: Error() string 메서드만 가진 간단한 인터페이스\n- 다중 반환값: 정상 결과와 에러를 함께 반환\n- 지역성: 에러 처리 로직이 에러 발생 지점 근처에 위치\n\n**error 인터페이스:**\n- 정의: Error() string 메서드만 가진 내장 인터페이스\n- errors.New: 간단한 에러 문자열로 에러 생성\n- fmt.Errorf: 포맷팅된 에러 메시지 생성\n- 커스텀: 구조체에 Error() 메서드 구현하여 풍부한 에러 정보 제공\n\n**에러 체크 패턴:**\n- 즉시 확인: 함수 호출 직후 if err != nil로 즉시 확인\n- 조기 반환: 에러 발생 시 빠르게 반환하여 중첩 최소화\n- 래핑: fmt.Errorf의 %w로 에러를 래핑하여 컨텍스트 추가\n- 전파: 에러를 처리하거나 상위 레벨로 전파\n\n**에러 래핑:**\n- fmt.Errorf(\"%w\", err): 원본 에러를 래핑하여 컨텍스트 추가\n- errors.Unwrap: 래핑된 에러에서 원본 에러 추출\n- errors.Is: 에러 체인에서 특정 에러와 일치하는지 확인\n- errors.As: 에러 체인에서 특정 타입의 에러 추출\n\n**커스텀 에러:**\n- 구조체: 에러 타입을 구조체로 정의하여 추가 정보 포함\n- Error() 메서드: 구조체에 Error() 메서드 구현\n- 타입 단언: 에러를 특정 타입으로 단언하여 상세 정보 접근\n- 센티널 에러: var ErrNotFound = errors.New(\"not found\")처럼 변수로 정의\n\n**모범 사례:**\n- 에러 무시 금지: 모든 에러를 확인하고 처리\n- 컨텍스트 추가: 에러 발생 위치와 상황을 에러 메시지에 포함\n- 에러 래핑: %w로 원본 에러를 보존하면서 컨텍스트 추가\n- 에러 타입: 복잡한 에러는 커스텀 타입으로 정의\n- 일관성: 패키지 내에서 일관된 에러 처리 패턴 유지\n\n**실무 활용:**\n- HTTP 핸들러에서 비즈니스 로직 에러를 적절한 HTTP 상태 코드로 변환\n- 에러 래핑으로 호출 스택 정보를 유지하며 디버깅 용이성 향상\n- 센티널 에러로 특정 에러 조건을 명시적으로 표현",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "HTTP"
      ],
      "id": "1763437633098-vy1jlm8h",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 컨텍스트(Context) 패키지의 용도와 사용 방법은 무엇인가요?",
      "answer": "**정의:**\ncontext 패키지는 요청 범위의 값, 취소 신호, 타임아웃, 데드라인을 고루틴 간에 전파하는 표준 방법을 제공합니다. API 경계를 넘어 요청 수명 주기를 관리하고, 고루틴 트리 전체에 취소 신호를 전파할 수 있습니다.\n\n**특징/원리:**\n- 취소 전파: 부모 컨텍스트 취소 시 자식 컨텍스트도 자동 취소\n- 타임아웃: 일정 시간 후 자동으로 취소되는 컨텍스트 생성\n- 값 전달: 요청 범위의 값을 컨텍스트에 저장하여 전파\n- 불변: 컨텍스트는 불변이며 새로운 컨텍스트를 파생하여 사용\n\n**주요 함수:**\n- context.Background: 최상위 컨텍스트로 취소되지 않음\n- context.TODO: 아직 컨텍스트를 결정하지 못했을 때 사용\n- WithCancel: 취소 가능한 컨텍스트와 cancel 함수 반환\n- WithTimeout: 타임아웃 후 자동 취소되는 컨텍스트\n- WithDeadline: 특정 시각에 취소되는 컨텍스트\n- WithValue: 키-값 쌍을 저장하는 컨텍스트\n\n**취소 패턴:**\n- cancel 함수: WithCancel이 반환하는 cancel 함수로 명시적 취소\n- defer cancel: 함수 반환 시 자동으로 cancel 호출하여 리소스 정리\n- Done 채널: ctx.Done() 채널이 닫히면 취소 신호\n- select: Done 채널과 작업을 select로 동시 대기\n\n**값 전달:**\n- WithValue: 요청 ID, 사용자 정보 등 요청 범위 값 저장\n- Value: 키로 값 조회, 없으면 부모 컨텍스트 검색\n- 타입 안전: 키는 비교 가능한 타입이며 충돌 방지를 위해 비공개 타입 사용 권장\n- 제한적 사용: 값 전달은 요청 범위 데이터에만 사용하고 함수 파라미터로 전달할 데이터는 명시적으로 전달\n\n**타임아웃과 데드라인:**\n- WithTimeout: 상대 시간으로 타임아웃 지정\n- WithDeadline: 절대 시각으로 데드라인 지정\n- 자동 취소: 시간 도래 시 Done 채널이 닫힘\n- 조기 취소: cancel 함수로 시간 전에도 취소 가능\n\n**모범 사례:**\n- 첫 파라미터: 함수의 첫 번째 파라미터로 Context 전달\n- 구조체 금지: Context를 구조체 필드에 저장하지 말고 파라미터로 전달\n- cancel 호출: WithCancel, WithTimeout 사용 시 반드시 defer cancel() 호출\n- 값 저장 최소화: 컨텍스트 값은 요청 범위 메타데이터에만 사용\n\n**실무 활용:**\n- HTTP 핸들러에서 데이터베이스 쿼리나 외부 API 호출에 타임아웃 적용\n- gRPC 호출 시 컨텍스트로 취소와 데드라인 전파\n- 여러 고루틴을 시작한 후 하나의 cancel로 모두 종료",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "HTTP"
      ],
      "id": "1763437633098-jnxjg2we",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 sync 패키지의 주요 기능들을 설명해주세요.",
      "answer": "**정의:**\nsync 패키지는 고루틴 간 동기화를 위한 저수준 프리미티브를 제공합니다. Mutex, RWMutex, WaitGroup, Once, Pool 등으로 공유 자원 보호, 고루틴 조율, 객체 재사용 등을 지원하며, 채널로 해결하기 어려운 문제에 사용합니다.\n\n**특징/원리:**\n- 저수준: 채널보다 저수준이지만 더 세밀한 제어 가능\n- 성능: 단순 잠금은 채널보다 빠름\n- 주의: 잘못 사용하면 데드락이나 경쟁 조건 발생\n- 채널 우선: \"공유 메모리로 통신하지 말고 통신으로 메모리를 공유\" 원칙으로 가능하면 채널 사용\n\n**Mutex:**\n- 상호 배제: 한 번에 하나의 고루틴만 임계 영역 실행\n- Lock(): 락 획득하며 다른 고루틴이 보유 중이면 대기\n- Unlock(): 락 해제하여 다른 고루틴이 획득 가능\n- defer: defer mu.Unlock()으로 자동 해제 보장\n\n**RWMutex:**\n- 읽기/쓰기 분리: 여러 읽기는 동시 가능하지만 쓰기는 배타적\n- RLock/RUnlock: 읽기 락 획득/해제\n- Lock/Unlock: 쓰기 락 획득/해제로 모든 접근 차단\n- 사용 사례: 읽기가 빈번하고 쓰기가 드문 경우 성능 향상\n\n**WaitGroup:**\n- 완료 대기: 여러 고루틴의 완료를 기다림\n- Add(n): 대기할 고루틴 개수 증가\n- Done(): 고루틴 완료 시 호출 (Add(-1)와 동일)\n- Wait(): 모든 고루틴이 Done()을 호출할 때까지 블로킹\n\n**Once:**\n- 단 한 번 실행: 여러 고루틴이 호출해도 함수를 단 한 번만 실행\n- Do(func()): 첫 호출만 함수 실행하고 이후는 무시\n- 초기화: 싱글톤 패턴이나 한 번만 수행할 초기화에 사용\n- 스레드 안전: 동시 호출에 안전\n\n**Pool:**\n- 객체 재사용: 일시적으로 사용하는 객체를 풀에서 재사용\n- Get(): 풀에서 객체 가져오거나 없으면 New 함수로 생성\n- Put(x): 객체를 풀에 반환\n- GC: 풀의 객체는 언제든 GC될 수 있음\n- 사용 사례: 버퍼나 연결 등 생성 비용이 큰 객체 재사용\n\n**실무 활용:**\n- Mutex로 카운터나 맵 같은 공유 자원 보호\n- WaitGroup으로 워커 고루틴들의 완료를 기다림\n- sync.Pool로 JSON 인코더나 버퍼를 재사용하여 GC 부담 감소",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633098-8xi7wv25",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 가비지 컬렉션 방식을 설명해주세요.",
      "answer": "**정의:**\nGo는 동시성 마크-스윕 가비지 컬렉터를 사용하여 사용하지 않는 메모리를 자동으로 회수합니다. 저지연을 목표로 하며 애플리케이션과 병렬로 실행되어 정지 시간을 최소화합니다.\n\n**특징/원리:**\n- 동시성: GC가 애플리케이션 고루틴과 동시에 실행\n- 마크-스윕: 도달 가능한 객체를 마크하고 나머지를 회수\n- 세대별 없음: Go는 세대별 GC를 사용하지 않고 모든 객체를 동일하게 처리\n- 삼색 마킹: 흰색(미방문), 회색(방문 중), 검은색(완료)으로 객체 추적\n\n**GC 단계:**\n- 마크 설정: GC 시작을 알리고 쓰기 장벽 활성화\n- 마크: 루트에서 시작하여 도달 가능한 모든 객체 마크\n- 마크 종료: 남은 회색 객체 마크 완료\n- 스윕: 마크되지 않은 객체의 메모리 회수\n\n**정지 시간:**\n- STW: Stop-The-World 정지는 매우 짧음 (수백 마이크로초)\n- 동시 마킹: 대부분의 마킹 작업은 애플리케이션과 동시 실행\n- 쓰기 장벽: 포인터 쓰기 시 약간의 오버헤드\n- 목표: GC 정지 시간을 수백 마이크로초로 유지\n\n**GC 튜닝:**\n- GOGC: 환경 변수로 GC 빈도 조절 (기본 100)\n- runtime.GC(): 명시적으로 GC 실행 (일반적으로 권장되지 않음)\n- runtime.SetFinalizer: 객체 회수 전 정리 함수 실행\n- debug.SetGCPercent: 프로그램 내에서 GOGC 값 변경\n\n**메모리 관리:**\n- 힙 할당: 포인터를 반환하거나 인터페이스에 할당되면 힙에 할당\n- 스택 할당: 함수 내에서만 사용되는 작은 객체는 스택에 할당\n- 탈출 분석: 컴파일러가 객체의 수명을 분석하여 스택/힙 결정\n- 메모리 풀: sync.Pool로 객체 재사용하여 GC 부담 감소\n\n**실무 활용:**\n- 대부분의 경우 기본 GC 설정이 적합하며 튜닝 불필요\n- 지연 시간이 중요한 애플리케이션은 GOGC 조정하여 GC 빈도 제어\n- 메모리 프로파일링으로 불필요한 할당 찾아 최적화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "메모리"
      ],
      "id": "1763437633098-bc9mm01s",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go의 빌드와 컴파일 과정을 설명해주세요.",
      "answer": "**정의:**\nGo는 정적 타입 컴파일 언어로, go build 명령으로 소스 코드를 기계어 실행 파일로 컴파일합니다. 빠른 컴파일 속도와 단일 바이너리 생성이 특징이며, 크로스 컴파일을 쉽게 수행할 수 있습니다.\n\n**특징/원리:**\n- 빠른 컴파일: 대규모 프로젝트도 초 단위로 컴파일 완료\n- 정적 링크: 모든 의존성이 바이너리에 포함되어 단일 파일로 배포\n- 크로스 컴파일: 다른 OS/아키텍처용 바이너리를 쉽게 생성\n- 의존성 관리: Go Modules로 의존성 자동 다운로드 및 관리\n\n**주요 명령어:**\n- go build: 현재 패키지를 컴파일하여 실행 파일 생성\n- go run: 소스를 컴파일하고 즉시 실행\n- go install: 패키지를 컴파일하고 $GOPATH/bin이나 $GOBIN에 설치\n- go test: 테스트 코드 컴파일 및 실행\n- go get: 원격 패키지 다운로드 및 설치\n\n**컴파일 과정:**\n- 파싱: 소스 코드를 AST(Abstract Syntax Tree)로 변환\n- 타입 체크: 정적 타입 검사 수행하여 오류 검출\n- 컴파일: AST를 중간 표현으로 변환하고 최적화\n- 코드 생성: 타겟 아키텍처의 기계어 생성\n- 링킹: 모든 패키지와 라이브러리를 하나의 실행 파일로 링크\n\n**빌드 옵션:**\n- -o: 출력 파일명 지정\n- -ldflags: 링커 플래그 전달 (버전 정보 임베딩 등)\n- -tags: 빌드 태그로 조건부 컴파일\n- -race: 경쟁 조건 검출기 포함\n- -trimpath: 바이너리에서 파일 경로 제거\n- -gcflags: 컴파일러 플래그 전달\n\n**크로스 컴파일:**\n- GOOS: 타겟 운영체제 지정 (linux, windows, darwin 등)\n- GOARCH: 타겟 아키텍처 지정 (amd64, arm64 등)\n- CGO_ENABLED: C 코드 연동 활성화 여부\n- 예시: GOOS=linux GOARCH=amd64 go build로 Linux용 바이너리 생성\n\n**실무 활용:**\n- Docker 이미지에서 Alpine Linux용 정적 바이너리를 빌드하여 최소 이미지 크기 달성\n- CI/CD 파이프라인에서 여러 플랫폼용 바이너리를 자동으로 빌드\n- ldflags로 빌드 시각이나 Git 커밋 해시를 바이너리에 임베딩",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-e5qgu092",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Go 모듈(Go Modules)과 의존성 관리에 대해 설명해주세요.",
      "answer": "**정의:**\nGo Modules는 Go 1.11에서 도입되어 1.16부터 기본이 된 공식 의존성 관리 시스템입니다. go.mod 파일로 모듈과 의존성을 선언하고, go.sum 파일로 체크섬을 검증하여 재현 가능한 빌드를 보장합니다.\n\n**특징/원리:**\n- 의존성 명시: go.mod에 모듈의 의존성과 버전 명시\n- 시맨틱 버저닝: v1.2.3 형식의 버전 태그 사용\n- 최소 버전 선택: 요구하는 최소 버전 중 가장 높은 버전 선택\n- 재현성: go.sum으로 의존성의 체크섬 검증하여 일관된 빌드\n\n**go.mod 파일:**\n- module: 모듈 경로 선언 (보통 저장소 URL)\n- go: Go 버전 명시\n- require: 직접 의존성과 버전 명시\n- replace: 의존성을 다른 모듈이나 로컬 경로로 대체\n- exclude: 특정 버전 제외\n\n**주요 명령어:**\n- go mod init: 새 모듈 초기화하고 go.mod 생성\n- go mod tidy: 사용되지 않는 의존성 제거하고 누락된 것 추가\n- go mod download: 의존성 다운로드\n- go mod vendor: 의존성을 vendor 디렉토리에 복사\n- go mod verify: go.sum으로 의존성 체크섬 검증\n\n**의존성 추가:**\n- 자동: import 문 추가 후 go build나 go mod tidy 실행\n- 수동: go get module@version으로 특정 버전 설치\n- 간접: 의존성의 의존성은 // indirect 주석과 함께 go.mod에 추가\n\n**버전 관리:**\n- 메이저 버전: v2 이상은 import 경로에 /v2 추가\n- 의사 버전: v0.0.0-20210101120000-abcdef123456 형식으로 커밋 참조\n- 최신: go get module@latest로 최신 버전 설치\n- 특정 버전: go get module@v1.2.3으로 특정 버전 설치\n\n**실무 활용:**\n- 프로젝트 시작 시 go mod init으로 모듈 초기화\n- 정기적으로 go mod tidy를 실행하여 go.mod 정리\n- go.sum을 버전 관리에 포함하여 팀원 간 동일한 의존성 보장",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-xb8m57jb",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "객체지향 프로그래밍(OOP)의 4가지 특징을 설명해주세요.",
      "answer": "**정의:**\n객체지향 프로그래밍은 데이터와 그것을 처리하는 메서드를 하나의 객체로 묶어 프로그램을 구조화하는 패러다임입니다. 캡슐화, 상속, 다형성, 추상화의 네 가지 핵심 특징으로 코드 재사용성, 유지보수성, 확장성을 향상시킵니다.\n\n**특징/원리:**\n- 객체: 상태(데이터)와 행위(메서드)를 하나로 묶은 단위\n- 클래스: 객체를 생성하기 위한 청사진이나 템플릿\n- 인스턴스: 클래스로부터 생성된 실제 객체\n- 메시지 전달: 객체 간 메서드 호출로 협력\n\n**캡슐화:**\n- 정의: 데이터와 메서드를 하나로 묶고 외부로부터 내부 구현을 숨김\n- 정보 은닉: private, protected 접근 제어자로 내부 상태 보호\n- 인터페이스: 공개 메서드로만 객체와 상호작용\n- 장점: 내부 구현 변경이 외부에 영향 주지 않아 유지보수 용이\n\n**상속:**\n- 정의: 기존 클래스의 속성과 메서드를 새 클래스가 물려받음\n- 재사용성: 공통 기능을 부모 클래스에 정의하여 중복 제거\n- IS-A 관계: 자식은 부모의 한 종류로 간주됨\n- 오버라이딩: 자식 클래스에서 부모 메서드를 재정의하여 특화된 동작 구현\n- 단점: 강한 결합으로 부모 변경 시 자식에 영향\n\n**다형성:**\n- 정의: 같은 인터페이스로 다양한 타입의 객체를 다룰 수 있는 능력\n- 메서드 오버로딩: 같은 이름의 메서드를 매개변수를 달리하여 여러 개 정의\n- 메서드 오버라이딩: 부모 클래스 메서드를 자식 클래스에서 재정의\n- 인터페이스 다형성: 인터페이스 타입으로 다양한 구현체를 동일하게 처리\n- 장점: 유연하고 확장 가능한 코드 작성\n\n**추상화:**\n- 정의: 복잡한 세부사항을 숨기고 중요한 개념만 드러냄\n- 추상 클래스: 구현이 없는 추상 메서드를 포함하여 공통 인터페이스 정의\n- 인터페이스: 순수하게 메서드 시그니처만 정의하여 계약 명시\n- 장점: 복잡도 감소하고 관심사 분리로 이해하기 쉬운 코드\n\n**실무 활용:**\n- 캡슐화로 클래스 내부 상태를 보호하고 getter/setter로 제어된 접근 제공\n- 상속보다는 컴포지션을 우선하여 유연한 설계 구현\n- 인터페이스로 다형성을 활용하여 테스트 가능하고 확장 가능한 코드 작성",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-73p5yf19",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "SOLID 원칙에 대해 설명해주세요.",
      "answer": "**정의:**\nSOLID는 객체지향 설계의 다섯 가지 기본 원칙으로, 유지보수 가능하고 확장 가능한 소프트웨어를 만들기 위한 지침입니다. Robert C. Martin이 정리했으며, 각 원칙의 첫 글자를 따서 SOLID라고 합니다.\n\n**특징/원리:**\n- 단일 책임: 클래스는 하나의 책임만 가져야 함\n- 개방-폐쇄: 확장에는 열려있고 수정에는 닫혀있어야 함\n- 리스코프 치환: 자식 클래스는 부모 클래스를 대체할 수 있어야 함\n- 인터페이스 분리: 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함\n- 의존성 역전: 구체가 아닌 추상에 의존해야 함\n\n**Single Responsibility Principle (SRP):**\n- 정의: 클래스는 단 하나의 변경 이유만 가져야 함\n- 응집도: 관련된 기능만 모아 높은 응집도 유지\n- 분리: 여러 책임을 가진 클래스는 각 책임별로 분리\n- 장점: 변경의 영향 범위가 작아 유지보수 용이\n\n**Open-Closed Principle (OCP):**\n- 정의: 소프트웨어 엔티티는 확장에는 열려있고 수정에는 닫혀있어야 함\n- 추상화: 인터페이스나 추상 클래스로 확장 포인트 제공\n- 다형성: 새로운 기능을 새 클래스로 구현하여 기존 코드 수정 최소화\n- 장점: 기존 코드 변경 없이 새 기능 추가 가능\n\n**Liskov Substitution Principle (LSP):**\n- 정의: 자식 클래스는 부모 클래스를 대체할 수 있어야 함\n- 계약 준수: 부모 클래스의 계약을 자식이 모두 만족해야 함\n- 행위 일관성: 자식 클래스가 부모와 다르게 동작하면 안 됨\n- 장점: 다형성을 안전하게 사용 가능\n\n**Interface Segregation Principle (ISP):**\n- 정의: 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 함\n- 인터페이스 분리: 큰 인터페이스를 작고 구체적인 인터페이스로 분리\n- 필요한 것만: 클라이언트는 필요한 메서드만 가진 인터페이스 사용\n- 장점: 불필요한 의존성 제거하여 결합도 낮춤\n\n**Dependency Inversion Principle (DIP):**\n- 정의: 고수준 모듈이 저수준 모듈에 의존하지 않고 둘 다 추상에 의존해야 함\n- 추상 의존: 구체 클래스가 아닌 인터페이스나 추상 클래스에 의존\n- 의존성 주입: 외부에서 의존성을 주입받아 결합도 낮춤\n- 장점: 구현 변경이 쉽고 테스트 가능\n\n**실무 활용:**\n- 클래스 설계 시 SOLID 원칙을 체크리스트로 사용하여 품질 향상\n- 리팩토링 시 SOLID 원칙을 적용하여 코드 개선\n- 코드 리뷰에서 SOLID 원칙 준수 여부 확인",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "DI"
      ],
      "id": "1763437633098-h33ryawh",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "함수형 프로그래밍의 특징과 장점은 무엇인가요?",
      "answer": "**정의:**\n함수형 프로그래밍은 순수 함수와 불변 데이터를 중심으로 프로그램을 구성하는 선언적 프로그래밍 패러다임입니다. 함수를 일급 객체로 다루고, 부수 효과를 최소화하며, 상태 변경 대신 값의 변환에 집중합니다.\n\n**특징/원리:**\n- 순수 함수: 같은 입력에 항상 같은 출력을 반환하고 부수 효과가 없음\n- 불변성: 데이터를 변경하지 않고 새로운 데이터를 생성\n- 일급 함수: 함수를 값처럼 다루어 변수에 할당하거나 인자로 전달 가능\n- 선언적: 어떻게(how)보다 무엇을(what) 계산할지 기술\n\n**순수 함수:**\n- 결정적: 입력이 같으면 출력도 항상 같음\n- 부수 효과 없음: 외부 상태를 변경하지 않고 파일, 네트워크 등 I/O 수행 안 함\n- 참조 투명성: 표현식을 그 결과값으로 대체 가능\n- 장점: 테스트가 쉽고 예측 가능하며 병렬 처리에 안전\n\n**불변성:**\n- 상태 변경 금지: 데이터를 수정하는 대신 새로운 데이터 생성\n- 공유 안전: 불변 데이터는 여러 곳에서 안전하게 공유 가능\n- 시간 여행: 이전 상태를 보존하여 되돌리기나 재생 가능\n- 장점: 동시성 문제 감소하고 디버깅 용이\n\n**고차 함수:**\n- 정의: 함수를 인자로 받거나 함수를 반환하는 함수\n- map: 각 요소를 변환하여 새 컬렉션 생성\n- filter: 조건에 맞는 요소만 선택\n- reduce: 요소들을 하나의 값으로 집계\n- 장점: 공통 패턴을 추상화하여 재사용성 향상\n\n**함수 합성:**\n- 작은 함수 조합: 단순한 함수들을 조합하여 복잡한 기능 구현\n- 파이프라인: 데이터가 함수 체인을 통과하며 변환\n- 가독성: 각 단계가 명확하여 이해하기 쉬움\n\n**장점:**\n- 테스트 용이: 순수 함수는 독립적으로 테스트 가능\n- 병렬 처리: 부수 효과가 없어 안전하게 병렬화 가능\n- 모듈화: 작은 함수들로 구성되어 재사용과 조합 용이\n- 디버깅: 불변 데이터로 상태 추적이 명확\n\n**실무 활용:**\n- React의 함수형 컴포넌트와 Hooks로 선언적 UI 구축\n- 데이터 처리 파이프라인을 map, filter, reduce로 간결하게 표현\n- Redux에서 불변성 유지하여 상태 변화 추적 및 시간 여행 디버깅",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "네트워크"
      ],
      "id": "1763437633098-nkut9i1o",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "순수 함수(Pure Function)란 무엇인가요?",
      "answer": "**정의:**\n순수 함수는 같은 입력에 대해 항상 같은 출력을 반환하고, 외부 상태를 변경하거나 의존하지 않는 함수입니다. 함수형 프로그래밍의 핵심 개념으로, 예측 가능하고 테스트하기 쉬운 코드를 작성하는 기반이 됩니다.\n\n**특징/원리:**\n- 결정적: 입력 인자만으로 출력이 완전히 결정됨\n- 부수 효과 없음: 함수 외부의 어떤 것도 변경하지 않음\n- 참조 투명성: 함수 호출을 그 결과값으로 대체해도 프로그램 동작이 같음\n- 독립성: 외부 상태나 컨텍스트에 의존하지 않음\n\n**순수 함수 조건:**\n- 동일 입력 동일 출력: 파라미터가 같으면 결과도 항상 같음\n- 외부 상태 읽기 금지: 전역 변수, 파일, 데이터베이스 등 외부 상태 참조 안 함\n- 외부 상태 변경 금지: 전역 변수 수정, 파일 쓰기, 네트워크 통신 등 부수 효과 없음\n- 예외 금지: 예외 발생도 부수 효과로 간주될 수 있음\n\n**부수 효과 종류:**\n- 변수 수정: 외부 변수나 파라미터로 받은 객체의 상태 변경\n- I/O 작업: 콘솔 출력, 파일 읽기/쓰기, 네트워크 통신\n- 예외 발생: 함수를 호출한 쪽에 예외를 던짐\n- 시간 의존: 현재 시각, 난수 등 호출 시점에 따라 결과가 달라짐\n\n**장점:**\n- 테스트 용이: 목이나 스텁 없이 입력만으로 테스트 가능\n- 병렬 처리: 스레드 안전하여 동시 실행에 안전\n- 캐싱: 메모이제이션으로 결과를 캐시하여 성능 향상\n- 디버깅: 입력과 출력만 확인하면 되어 디버깅 쉬움\n- 합성: 순수 함수끼리 자유롭게 조합 가능\n\n**비순수 함수 예시:**\n- 전역 변수 참조나 수정\n- 현재 시각 반환 (Date.now(), time.Now())\n- 난수 생성 (Math.random(), rand.Int())\n- 콘솔 출력 (console.log(), fmt.Println())\n- 데이터베이스 조회나 수정\n\n**순수 함수로 만들기:**\n- 의존성 주입: 필요한 모든 데이터를 파라미터로 전달\n- 새 객체 반환: 기존 객체를 수정하지 않고 새 객체 생성하여 반환\n- 부수 효과 분리: 순수 함수에서 계산만 하고 I/O는 호출자가 담당\n\n**실무 활용:**\n- 비즈니스 로직을 순수 함수로 작성하여 테스트와 재사용성 향상\n- reducer 함수를 순수하게 유지하여 상태 관리 예측 가능하게 구현\n- 순수 함수로 계산하고 부수 효과는 경계에서만 수행하여 코드 구조화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성",
        "네트워크"
      ],
      "id": "1763437633098-z9x7bup4",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "불변성(Immutability)의 중요성과 구현 방법은 무엇인가요?",
      "answer": "**정의:**\n불변성은 데이터를 생성 후 변경하지 않는 속성으로, 기존 데이터를 수정하는 대신 새로운 데이터를 생성합니다. 함수형 프로그래밍의 핵심 개념으로, 상태 변화를 명시적으로 만들어 예측 가능하고 안전한 코드를 작성할 수 있게 합니다.\n\n**특징/원리:**\n- 수정 불가: 데이터 생성 후 내용을 변경할 수 없음\n- 새 객체 생성: 변경이 필요하면 수정된 새 객체를 만듦\n- 공유 안전: 불변 데이터는 여러 곳에서 안전하게 공유 가능\n- 시간적 독립: 데이터가 시간에 따라 변하지 않아 추론 용이\n\n**중요성:**\n- 동시성 안전: 여러 스레드가 동시에 접근해도 경쟁 조건 없음\n- 예측 가능: 데이터가 변하지 않아 프로그램 동작 예측 쉬움\n- 디버깅: 상태 변화 추적이 명확하여 버그 찾기 쉬움\n- 시간 여행: 이전 상태를 보존하여 되돌리기나 재생 가능\n- 캐싱: 불변 데이터는 안전하게 캐시 가능\n\n**구현 방법:**\n- 원시 타입: 불변이므로 별도 조치 불필요\n- 객체 동결: Object.freeze()로 객체를 읽기 전용으로 만듦\n- 복사 후 수정: 스프레드 연산자나 Object.assign()으로 복사 후 수정\n- 불변 라이브러리: Immutable.js, Immer 등 불변 자료구조 라이브러리 사용\n- 함수형 메서드: map, filter, concat 등 새 배열을 반환하는 메서드 활용\n\n**JavaScript 구현:**\n- const: 재할당을 방지하지만 객체 내용은 변경 가능\n- Object.freeze: 얕은 동결로 1단계만 불변, 중첩 객체는 재귀적으로 동결 필요\n- 스프레드: 얕은 복사로 새 객체 생성\n- Immer: produce 함수로 불변 업데이트를 변경하는 것처럼 작성 가능\n\n**불변 자료구조:**\n- 구조적 공유: 변경되지 않은 부분은 공유하여 메모리 효율\n- 영속 자료구조: 이전 버전도 유지하면서 새 버전 생성\n- 성능: 최적화된 불변 자료구조는 가변보다 약간 느리지만 충분히 빠름\n\n**주의사항:**\n- 얕은 복사: 중첩 객체는 참조가 복사되어 진정한 불변 아님\n- 성능: 대용량 데이터를 매번 복사하면 성능 저하 가능\n- 메모리: 이전 버전을 모두 유지하면 메모리 사용량 증가\n- 균형: 성능과 안전성 사이 균형 필요\n\n**실무 활용:**\n- React에서 state를 불변으로 관리하여 변경 감지와 렌더링 최적화\n- Redux의 reducer는 불변 업데이트를 수행하여 시간 여행 디버깅 가능\n- 멀티스레드 환경에서 불변 데이터로 동기화 오버헤드 제거",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633098-3jl7ohfb",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "동시성(Concurrency)과 병렬성(Parallelism)의 차이점은 무엇인가요?",
      "answer": "**정의:**\n동시성은 여러 작업을 논리적으로 동시에 다루는 것이고, 병렬성은 물리적으로 동시에 실행하는 것입니다. 동시성은 작업 구조에 관한 것이고, 병렬성은 실행 방식에 관한 것으로, 동시성이 없어도 병렬성이 가능하고 그 반대도 가능합니다.\n\n**특징/원리:**\n- 동시성: 여러 작업을 빠르게 전환하며 처리하여 동시에 진행되는 것처럼 보임\n- 병렬성: 여러 CPU 코어에서 실제로 동시에 작업 실행\n- 독립성: 동시성과 병렬성은 독립적인 개념이며 함께 사용될 수도 있음\n- 목적: 동시성은 구조적 개선, 병렬성은 성능 향상\n\n**동시성(Concurrency):**\n- 논리적 개념: 여러 작업을 독립적으로 구성하여 동시에 다룸\n- 인터리빙: 단일 코어에서도 시간 분할로 여러 작업 처리\n- I/O 대기: I/O 작업 중 다른 작업을 수행하여 대기 시간 활용\n- 예시: 웹 서버가 여러 요청을 처리, 비동기 프로그래밍\n- 목표: 응답성과 처리량 향상\n\n**병렬성(Parallelism):**\n- 물리적 개념: 여러 작업을 실제로 동시에 실행\n- 멀티코어: 여러 CPU 코어를 활용하여 진정한 동시 실행\n- CPU 집약적: 계산 집약적 작업을 병렬 처리하여 속도 향상\n- 예시: 대용량 배열 정렬, 행렬 연산, 영상 처리\n- 목표: 처리 속도 향상\n\n**관계:**\n- 동시성 없이 병렬: 데이터 병렬성으로 동일 작업을 여러 데이터에 병렬 적용\n- 병렬 없이 동시성: 단일 코어에서 비동기나 멀티스레딩으로 동시성 구현\n- 동시성 + 병렬: 동시성 있는 프로그램을 여러 코어에서 병렬 실행\n- 선택: 문제 특성에 따라 동시성, 병렬성 또는 둘 다 선택\n\n**구현 방법:**\n- 동시성: 스레드, 코루틴, 비동기, 이벤트 루프, 액터 모델\n- 병렬성: 멀티프로세싱, 멀티스레딩 (GIL 없는 환경), GPU 연산\n- 하이브리드: 비동기 + 워커 풀, 고루틴 + 멀티코어\n\n**실무 활용:**\n- 웹 서버는 동시성으로 많은 요청을 동시에 처리\n- 데이터 분석은 병렬성으로 계산 속도 향상\n- 마이크로서비스는 동시성과 병렬성을 조합하여 높은 처리량 달성",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "동시성"
      ],
      "id": "1763437633098-bpwgn2is",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Race Condition과 Deadlock에 대해 설명해주세요.",
      "answer": "**정의:**\nRace Condition은 여러 스레드나 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상황이고, Deadlock은 두 개 이상의 작업이 서로가 점유한 자원을 기다리며 무한히 대기하는 상태입니다. 둘 다 동시성 프로그래밍의 주요 문제입니다.\n\n**특징/원리:**\n- 비결정적: 실행 타이밍에 따라 결과가 달라져 재현과 디버깅이 어려움\n- 동시성 버그: 멀티스레드나 멀티프로세스 환경에서 발생\n- 데이터 손상: 잘못된 동기화로 데이터 무결성 깨짐\n- 시스템 마비: Deadlock은 프로그램을 멈추게 할 수 있음\n\n**Race Condition:**\n- 발생 조건: 공유 자원에 대한 동시 접근과 최소 하나의 쓰기 연산\n- 예시: 카운터 증가, 계좌 잔액 업데이트, 리스트 추가\n- 증상: 예상과 다른 결과, 데이터 손실, 일관성 없는 상태\n- 검출: 어려우며 특정 타이밍에만 나타날 수 있음\n\n**Deadlock:**\n- 필요 조건 (네 가지 모두 만족):\n  - 상호 배제: 자원은 한 번에 하나의 작업만 사용 가능\n  - 점유와 대기: 자원을 점유한 채 다른 자원 대기\n  - 비선점: 자원을 강제로 빼앗을 수 없음\n  - 순환 대기: 자원 대기가 순환 구조 형성\n- 예시: 두 스레드가 서로 다른 락을 점유하고 상대방 락을 기다림\n\n**Race Condition 방지:**\n- 동기화: Mutex, Semaphore, Lock으로 임계 영역 보호\n- 원자적 연산: Atomic 변수나 CAS 연산 사용\n- 불변 데이터: 공유 데이터를 읽기 전용으로 만듦\n- 메시지 전달: 공유 메모리 대신 메시지로 통신\n- 스레드 로컬: 각 스레드가 독립적인 데이터 사용\n\n**Deadlock 방지:**\n- 락 순서: 모든 스레드가 동일한 순서로 락 획득\n- 타임아웃: 락 획득 시 타임아웃 설정하여 무한 대기 방지\n- 락 계층: 락에 순서를 부여하여 낮은 순서부터 획득\n- 자원 할당 그래프: 순환 대기를 감지하고 방지\n\n**Deadlock 탐지 및 복구:**\n- 데드락 탐지: 자원 할당 그래프에서 순환 검출\n- 복구: 프로세스 종료, 자원 선점, 체크포인트 롤백\n- 회피: Banker's 알고리즘으로 안전한 상태만 허용\n\n**실무 활용:**\n- 데이터베이스 트랜잭션의 락 순서를 일관되게 유지하여 데드락 방지\n- 멀티스레드 프로그램에서 공유 자원 접근 시 적절한 동기화 메커니즘 사용\n- 락 대신 불변 데이터나 메시지 전달로 동시성 문제 근본적으로 해결",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리",
        "동시성"
      ],
      "id": "1763437633098-h9ivmkmo",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?",
      "answer": "**정의:**\n동기는 작업을 순차적으로 실행하며 이전 작업이 완료될 때까지 기다리는 방식이고, 비동기는 작업을 시작하고 완료를 기다리지 않고 다음 작업을 진행하는 방식입니다. 각각 장단점이 있어 상황에 맞게 선택해야 합니다.\n\n**특징/원리:**\n- 동기: 호출한 함수가 결과를 반환할 때까지 대기\n- 비동기: 함수를 호출하고 즉시 다음 코드 실행, 결과는 나중에 처리\n- 블로킹: 동기는 보통 블로킹, 비동기는 논블로킹과 함께 사용\n- 제어 흐름: 동기는 순차적이고 예측 가능, 비동기는 복잡하지만 효율적\n\n**동기(Synchronous):**\n- 순차 실행: 코드가 작성된 순서대로 실행\n- 대기: 함수 호출 후 결과를 받을 때까지 다음 코드 실행 안 됨\n- 간단함: 코드 흐름이 직관적이고 이해하기 쉬움\n- 비효율: I/O 대기 중 CPU가 유휴 상태로 낭비\n- 예시: 일반 함수 호출, 파일 읽기 (동기 API)\n\n**비동기(Asynchronous):**\n- 병행 실행: 작업을 시작하고 완료를 기다리지 않고 계속 진행\n- 콜백: 작업 완료 시 콜백 함수 호출하여 결과 처리\n- 효율성: I/O 대기 중 다른 작업 수행하여 시간 절약\n- 복잡성: 콜백 지옥, 에러 처리가 복잡해질 수 있음\n- 예시: AJAX 요청, setTimeout, Promise, async/await\n\n**구현 패턴:**\n- 콜백: 작업 완료 시 실행할 함수를 인자로 전달\n- Promise: 비동기 작업의 최종 결과를 나타내는 객체\n- async/await: Promise를 동기 코드처럼 작성할 수 있는 문법\n- 이벤트: 이벤트 리스너로 비동기 결과 처리\n\n**사용 사례:**\n- 동기: 계산 집약적 작업, 순서가 중요한 작업, 간단한 스크립트\n- 비동기: 네트워크 요청, 파일 I/O, 타이머, 이벤트 처리\n- 혼합: 비동기로 데이터를 가져와 동기로 처리\n\n**장단점:**\n- 동기 장점: 코드 이해 쉬움, 디버깅 용이, 에러 처리 간단\n- 동기 단점: I/O 대기 중 블로킹, 응답성 저하\n- 비동기 장점: 효율적 자원 활용, 높은 처리량, 응답성 향상\n- 비동기 단점: 복잡한 코드, 디버깅 어려움, 에러 처리 복잡\n\n**실무 활용:**\n- 웹 프론트엔드에서 API 호출을 비동기로 처리하여 UI 블로킹 방지\n- Node.js에서 비동기 I/O로 높은 동시성 달성\n- 계산 로직은 동기로 명확하게, I/O는 비동기로 효율적으로 처리",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "네트워크"
      ],
      "id": "1763437633098-845acoea",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "블로킹(Blocking)과 논블로킹(Non-blocking)의 차이점은 무엇인가요?",
      "answer": "**정의:**\n블로킹은 함수 호출 시 제어권이 넘어가 완료될 때까지 대기하는 방식이고, 논블로킹은 함수를 호출해도 즉시 제어권이 반환되어 다른 작업을 계속할 수 있는 방식입니다. 동기/비동기와 다른 개념으로 독립적으로 조합 가능합니다.\n\n**특징/원리:**\n- 블로킹: 호출된 함수가 완료될 때까지 호출자가 대기\n- 논블로킹: 함수가 즉시 반환되어 호출자가 다른 작업 수행 가능\n- 제어권: 누가 제어권을 가지고 있는가에 관한 개념\n- 조합: 동기/비동기와 블로킹/논블로킹은 독립적으로 조합 가능\n\n**블로킹(Blocking):**\n- 대기: 함수 호출 후 결과를 받을 때까지 멈춤\n- 단순: 코드 흐름이 직선적이어서 이해하기 쉬움\n- 비효율: 대기 중 CPU를 활용하지 못함\n- 예시: 동기 파일 읽기, 일반 네트워크 소켓 읽기\n\n**논블로킹(Non-blocking):**\n- 즉시 반환: 함수가 즉시 제어권을 반환\n- 폴링: 주기적으로 완료 여부 확인 필요\n- 효율: 대기하지 않고 다른 작업 수행 가능\n- 예시: 논블로킹 소켓, 비동기 I/O\n\n**동기/비동기 vs 블로킹/논블로킹:**\n- 동기/비동기: 작업 완료를 누가 신경 쓰는가 (호출자 vs 호출된 함수)\n- 블로킹/논블로킹: 제어권을 즉시 반환하는가\n- 동기 블로킹: 일반적인 함수 호출, 완료까지 대기\n- 동기 논블로킹: 폴링 방식, 즉시 반환하지만 호출자가 완료 확인\n- 비동기 블로킹: 드물며 비효율적\n- 비동기 논블로킹: 즉시 반환하고 완료 시 콜백, 가장 효율적\n\n**I/O 모델:**\n- Blocking I/O: 읽기/쓰기가 완료될 때까지 대기\n- Non-blocking I/O: 즉시 반환하고 데이터 없으면 에러나 부분 결과 반환\n- I/O Multiplexing: select/poll/epoll로 여러 I/O를 동시 모니터링\n- Asynchronous I/O: 완료 시 시스템이 알림\n\n**실무 활용:**\n- 웹 서버에서 논블로킹 I/O로 많은 연결을 동시에 처리\n- Node.js의 논블로킹 이벤트 루프로 높은 동시성 달성\n- 게임 렌더링 루프는 논블로킹으로 입력을 처리하면서 화면 갱신",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "네트워크"
      ],
      "id": "1763437633098-42i6cyqy",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "컴파일 언어와 인터프리터 언어의 차이점은 무엇인가요?",
      "answer": "**정의:**\n컴파일 언어는 소스 코드를 실행 전에 기계어로 변환하는 언어이고, 인터프리터 언어는 소스 코드를 한 줄씩 해석하며 실행하는 언어입니다. 각각 실행 속도, 개발 편의성, 이식성 등에서 장단점이 있습니다.\n\n**특징/원리:**\n- 컴파일: 전체 소스를 한 번에 기계어로 변환 후 실행\n- 인터프리터: 소스를 한 줄씩 읽으며 즉시 실행\n- 하이브리드: Java, Python 등은 중간 표현으로 컴파일 후 VM에서 해석\n- JIT: Just-In-Time 컴파일로 두 방식의 장점 결합\n\n**컴파일 언어:**\n- 예시: C, C++, Go, Rust\n- 과정: 소스 코드 → 컴파일러 → 기계어 → 실행\n- 실행 속도: 빠름, 이미 기계어로 변환되어 있음\n- 개발 시간: 느림, 컴파일 시간 필요\n- 에러 검출: 컴파일 타임에 문법 및 타입 오류 검출\n- 이식성: 낮음, 플랫폼별로 재컴파일 필요\n- 최적화: 컴파일 타임에 다양한 최적화 수행\n\n**인터프리터 언어:**\n- 예시: Python, Ruby, JavaScript (초기)\n- 과정: 소스 코드 → 인터프리터 → 한 줄씩 실행\n- 실행 속도: 느림, 실행 중 해석 과정 필요\n- 개발 시간: 빠름, 즉시 실행하여 테스트 가능\n- 에러 검출: 런타임에 해당 줄 실행 시 검출\n- 이식성: 높음, 인터프리터만 있으면 어디서든 실행\n- REPL: 대화형 실행 환경 제공\n\n**하이브리드 방식:**\n- Java: 바이트코드로 컴파일 후 JVM에서 해석/JIT 컴파일\n- Python: 바이트코드(.pyc)로 컴파일 후 인터프리터 실행\n- C#: IL(중간 언어)로 컴파일 후 CLR에서 JIT 컴파일\n- JavaScript: 현대 엔진은 JIT 컴파일로 성능 향상\n\n**JIT 컴파일:**\n- 개념: 실행 시점에 자주 실행되는 코드를 기계어로 컴파일\n- 장점: 인터프리터의 유연성과 컴파일의 속도를 결합\n- 최적화: 런타임 정보로 더 공격적인 최적화 가능\n- 예시: HotSpot JVM, V8 JavaScript 엔진\n\n**선택 기준:**\n- 성능 중요: 컴파일 언어 선택 (C, C++, Rust, Go)\n- 개발 속도: 인터프리터 언어로 빠른 프로토타이핑 (Python, Ruby)\n- 이식성: 하이브리드 방식으로 플랫폼 독립성 (Java, C#)\n- 현대 언어: JIT 컴파일로 성능과 생산성 모두 추구\n\n**실무 활용:**\n- 시스템 프로그래밍은 C/C++/Rust로 최고 성능 추구\n- 웹 백엔드는 다양한 언어 선택 가능 (Go, Java, Python, Node.js)\n- 스크립팅이나 데이터 분석은 Python으로 빠른 개발",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "JVM"
      ],
      "id": "1763437633098-o5kxff0i",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "JIT(Just-In-Time) 컴파일러의 동작 원리를 설명해주세요.",
      "answer": "**정의:**\nJIT 컴파일러는 프로그램 실행 중에 바이트코드나 중간 표현을 기계어로 컴파일하는 기술입니다. 인터프리터의 유연성과 컴파일러의 성능을 결합하며, 런타임 정보를 활용하여 더 공격적인 최적화를 수행할 수 있습니다.\n\n**특징/원리:**\n- 런타임 컴파일: 프로그램 실행 중에 필요한 부분을 기계어로 변환\n- 핫스팟 탐지: 자주 실행되는 코드(핫스팟)를 식별하여 우선 컴파일\n- 적응적 최적화: 실행 프로파일을 기반으로 최적화 수준 조정\n- 캐싱: 컴파일된 코드를 캐시하여 재사용\n\n**동작 과정:**\n- 초기 실행: 바이트코드를 인터프리터로 실행하며 프로파일링\n- 핫스팟 탐지: 실행 빈도가 높은 메서드나 루프 식별\n- 컴파일: 핫스팟을 기계어로 컴파일하여 코드 캐시에 저장\n- 실행: 이후 호출은 컴파일된 기계어를 직접 실행\n- 재최적화: 실행 패턴 변화 시 재컴파일하여 최적화 수정\n\n**최적화 기법:**\n- 인라이닝: 자주 호출되는 작은 메서드를 호출 지점에 삽입\n- 루프 최적화: 루프 전개, 불변 코드 이동 등으로 루프 가속\n- 타입 특화: 런타임 타입 정보로 다형성 코드를 단형성으로 변환\n- 데드 코드 제거: 실제로 실행되지 않는 코드 제거\n- 탈출 분석: 객체가 메서드 외부로 탈출하지 않으면 스택 할당\n\n**티어드 컴파일:**\n- C1 컴파일러: 빠르게 컴파일하여 초기 성능 향상 (클라이언트 컴파일러)\n- C2 컴파일러: 느리지만 고도로 최적화 (서버 컴파일러)\n- 계층적 전략: C1으로 먼저 컴파일 후 핫한 코드는 C2로 재컴파일\n\n**장점:**\n- 빠른 시작: 초기에는 인터프리터로 빠르게 시작\n- 고성능: 핫스팟을 최적화하여 네이티브 코드에 근접한 성능\n- 적응성: 실행 패턴에 따라 동적으로 최적화\n- 플랫폼 독립: 중간 표현은 플랫폼 독립적이고 JIT가 타겟 기계어 생성\n\n**단점:**\n- 워밍업: 최적화 전까지 초기 성능이 낮을 수 있음\n- 메모리: 컴파일된 코드 캐시와 프로파일 데이터 저장 필요\n- 비결정적: 실행마다 최적화가 달라질 수 있음\n- 복잡성: JIT 컴파일러 구현이 매우 복잡\n\n**예시:**\n- HotSpot JVM: Java의 표준 JIT 컴파일러\n- V8: Chrome의 JavaScript 엔진\n- .NET CLR: C#의 런타임 환경\n- PyPy: Python의 JIT 구현\n\n**실무 활용:**\n- JVM 애플리케이션은 워밍업 후 네이티브 코드에 근접한 성능 달성\n- 마이크로벤치마크 시 워밍업 시간을 고려하여 정확한 측정\n- 서버 애플리케이션은 충분한 워밍업 후 안정적인 성능 유지",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "JVM",
        "메모리"
      ],
      "id": "1763437633098-q9w5vomw",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "정적 타이핑과 동적 타이핑의 장단점은 무엇인가요?",
      "answer": "**정의:**\n정적 타이핑은 변수의 타입을 컴파일 타임에 결정하고 검사하는 방식이고, 동적 타이핑은 런타임에 결정하고 검사하는 방식입니다. 각각 안전성, 유연성, 개발 속도 등에서 장단점이 있어 언어 설계와 사용 사례에 영향을 미칩니다.\n\n**특징/원리:**\n- 정적: 변수 선언 시 타입 명시하고 컴파일 타임에 검사\n- 동적: 타입 선언 없이 런타임에 값에 따라 타입 결정\n- 타입 추론: 일부 정적 언어는 타입을 자동으로 추론\n- 점진적 타이핑: 정적과 동적을 혼합하여 사용\n\n**정적 타이핑:**\n- 언어: Java, C, C++, Go, Rust, TypeScript\n- 타입 검사: 컴파일 타임에 타입 오류 검출\n- 명시적: 변수, 파라미터, 반환값의 타입을 명시\n- IDE 지원: 자동완성, 리팩토링, 타입 정보 제공\n- 최적화: 컴파일러가 타입 정보로 최적화 수행\n\n**동적 타이핑:**\n- 언어: Python, JavaScript, Ruby, PHP\n- 타입 검사: 런타임에 실제 사용 시점에 타입 검사\n- 유연성: 타입 선언 없이 자유롭게 변수 사용\n- 빠른 프로토타이핑: 타입 고민 없이 빠르게 개발\n- 덕 타이핑: 객체의 타입보다 제공하는 메서드가 중요\n\n**정적 타이핑 장점:**\n- 안전성: 타입 오류를 컴파일 타임에 조기 발견\n- 성능: 타입 정보로 최적화하여 빠른 실행 속도\n- 도구 지원: IDE의 강력한 자동완성과 리팩토링\n- 문서화: 타입 자체가 코드의 계약을 문서화\n- 대규모: 큰 프로젝트에서 타입 시스템이 안전망 역할\n\n**정적 타이핑 단점:**\n- 보일러플레이트: 타입 선언으로 코드가 길어짐\n- 유연성 부족: 타입 제약으로 표현력 제한\n- 학습 곡선: 타입 시스템 이해 필요\n- 컴파일 시간: 타입 검사로 컴파일 시간 증가\n\n**동적 타이핑 장점:**\n- 간결성: 타입 선언 없이 코드가 짧고 간결\n- 유연성: 타입에 구애받지 않고 자유로운 표현\n- 빠른 개발: 프로토타이핑과 스크립팅에 적합\n- 메타프로그래밍: 런타임에 동적으로 코드 생성 용이\n\n**동적 타이핑 단점:**\n- 런타임 에러: 타입 오류가 런타임에 발견되어 프로덕션 장애 가능\n- 성능: 런타임 타입 검사로 오버헤드 발생\n- 도구 지원: IDE의 자동완성이나 리팩토링 지원 제한적\n- 대규모 프로젝트: 타입 관련 버그가 많아지고 추적 어려움\n\n**하이브리드 접근:**\n- TypeScript: JavaScript에 정적 타입 추가\n- Python 타입 힌트: 점진적으로 타입 힌트 추가하여 정적 검사\n- mypy, flow: 동적 언어에 정적 분석 도구 제공\n\n**실무 활용:**\n- 대규모 프로젝트나 팀 협업에는 정적 타이핑으로 안전성 확보\n- 스크립트나 프로토타입은 동적 타이핑으로 빠르게 개발\n- TypeScript로 JavaScript의 유연성과 정적 타입의 안전성 결합",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-0hosm48w",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "강타입과 약타입 언어의 차이점은 무엇인가요?",
      "answer": "**정의:**\n강타입 언어는 타입 간 변환을 엄격히 제한하여 명시적 변환만 허용하고, 약타입 언어는 타입 간 자동 변환(암묵적 타입 변환)을 허용합니다. 정적/동적 타이핑과는 독립적인 개념으로 함께 조합될 수 있습니다.\n\n**특징/원리:**\n- 강타입: 타입이 엄격하게 구분되고 호환되지 않는 타입 간 연산 불가\n- 약타입: 서로 다른 타입을 자동으로 변환하여 연산 수행\n- 타입 강제: 컴파일러나 런타임이 타입을 자동 변환\n- 명시성: 강타입은 개발자의 의도를 명확히 표현하도록 강제\n\n**강타입 언어:**\n- 예시: Python, Java, Go, Rust\n- 엄격성: 타입 불일치 시 에러 발생\n- 명시적 변환: 타입 변환을 명시적으로 수행해야 함\n- 안전성: 의도하지 않은 타입 변환 방지\n- 예측 가능: 타입 관련 동작이 명확하고 일관적\n\n**약타입 언어:**\n- 예시: JavaScript, PHP, Perl, C (일부)\n- 암묵적 변환: 다른 타입 간 자동 변환(타입 강제)\n- 유연성: 타입에 관대하여 코드 작성이 편리\n- 위험성: 예상치 못한 타입 변환으로 버그 발생 가능\n- 혼란: 타입 변환 규칙이 복잡하고 이해하기 어려울 수 있음\n\n**JavaScript 예시:**\n- 약타입: \"5\" + 3은 \"53\"으로 문자열 연결\n- 타입 강제: \"5\" - 3은 2로 숫자 연산\n- 비교: \"5\" == 5는 true (암묵적 변환 후 비교)\n- 엄격 비교: \"5\" === 5는 false (타입까지 비교)\n\n**Python 예시:**\n- 강타입: \"5\" + 3은 TypeError 발생\n- 명시적: int(\"5\") + 3 또는 \"5\" + str(3)으로 명시적 변환 필요\n- 예측 가능: 타입 불일치가 즉시 에러로 드러남\n\n**정적/동적 vs 강/약:**\n- 정적 강타입: Java, C++, Rust - 가장 안전\n- 정적 약타입: C - 포인터 산술 등으로 약함\n- 동적 강타입: Python, Ruby - 유연하지만 안전\n- 동적 약타입: JavaScript, PHP - 가장 유연하지만 위험\n\n**장단점:**\n- 강타입 장점: 안전성, 예측 가능성, 조기 오류 발견\n- 강타입 단점: 명시적 변환 필요로 코드가 길어짐\n- 약타입 장점: 간결함, 유연성, 빠른 개발\n- 약타입 단점: 예상 못한 버그, 디버깅 어려움\n\n**실무 활용:**\n- JavaScript는 일치 연산자(===)로 타입 강제 회피\n- Python은 명시적 변환을 강제하여 의도를 명확히 표현\n- 타입스크립트로 JavaScript의 약타입 문제 완화",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접"
      ],
      "id": "1763437633098-2s5fhmj6",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "Call by Value와 Call by Reference의 차이점을 설명해주세요.",
      "answer": "**정의:**\nCall by Value는 함수 호출 시 인자의 값을 복사하여 전달하는 방식이고, Call by Reference는 인자의 참조(메모리 주소)를 전달하는 방식입니다. 각각 메모리 사용, 성능, 부수 효과 등에서 차이가 있습니다.\n\n**특징/원리:**\n- Call by Value: 값 복사로 함수 내부 수정이 외부에 영향 없음\n- Call by Reference: 참조 전달로 함수 내부 수정이 외부에 반영됨\n- 언어 지원: 언어마다 지원하는 방식이 다름\n- 성능: 큰 데이터는 참조 전달이 효율적\n\n**Call by Value:**\n- 복사: 인자의 값이 복사되어 함수의 매개변수에 할당\n- 독립성: 함수 내부에서 매개변수를 수정해도 원본 변수는 영향 없음\n- 안전성: 함수가 외부 상태를 변경하지 못해 부수 효과 없음\n- 메모리: 큰 데이터는 복사 비용이 클 수 있음\n- 예시: C의 기본 방식, Java의 원시 타입\n\n**Call by Reference:**\n- 참조: 변수의 메모리 주소가 전달됨\n- 공유: 함수 내부와 외부가 같은 메모리 공간을 가리킴\n- 수정 가능: 함수에서 매개변수를 수정하면 원본도 변경됨\n- 효율성: 큰 데이터도 주소만 전달하여 빠름\n- 예시: C++의 참조(&), Python의 가변 객체\n\n**언어별 동작:**\n- C: 기본은 Call by Value, 포인터로 Call by Reference 시뮬레이션\n- C++: 값과 참조(&) 모두 지원\n- Java: 원시 타입은 Call by Value, 객체는 참조의 값 전달\n- Python: 모든 것이 객체 참조 전달, 불변 객체는 값처럼 동작\n- JavaScript: 원시값은 Call by Value, 객체는 참조의 값 전달\n\n**Java의 특수성:**\n- 원시 타입: int, double 등은 Call by Value로 복사\n- 객체: 참조 자체는 Call by Value로 복사되지만 같은 객체를 가리킴\n- 재할당: 매개변수를 다른 객체로 재할당해도 원본은 영향 없음\n- 수정: 객체 내부 상태 수정은 원본에 반영됨\n\n**Python의 특수성:**\n- 불변 객체: int, str, tuple은 수정 불가하여 Call by Value처럼 동작\n- 가변 객체: list, dict는 수정 가능하여 Call by Reference처럼 동작\n- 재할당: 매개변수 재할당은 로컬 변수만 변경\n\n**실무 활용:**\n- 함수가 외부 상태를 변경하지 않게 하려면 불변 데이터나 복사본 전달\n- 큰 객체를 효율적으로 전달하려면 참조 방식 활용\n- 의도치 않은 수정을 방지하려면 불변 객체 사용하거나 방어적 복사",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "메모리"
      ],
      "id": "1763437633098-cj1ftbn5",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    },
    {
      "question": "메모리 누수(Memory Leak)가 발생하는 원인과 방지 방법은 무엇인가요?",
      "answer": "**정의:**\n메모리 누수는 프로그램이 더 이상 사용하지 않는 메모리를 해제하지 않아 가용 메모리가 점점 감소하는 현상입니다. 시간이 지남에 따라 시스템 성능 저하나 프로그램 크래시를 유발할 수 있어, 장기 실행 애플리케이션에서 특히 중요한 문제입니다.\n\n**특징/원리:**\n- 점진적 악화: 시간이 지날수록 메모리 사용량이 계속 증가\n- 자원 고갈: 결국 사용 가능한 메모리가 부족해져 프로그램이나 시스템 중단\n- 은밀함: 즉시 드러나지 않고 서서히 나타나 발견이 어려움\n- 누적: 작은 누수도 반복되면 심각한 문제가 됨\n\n**발생 원인:**\n- 참조 유지: 더 이상 필요 없는 객체에 대한 참조를 계속 보유\n- 리소스 미해제: 파일, 소켓, 데이터베이스 연결 등을 닫지 않음\n- 이벤트 리스너: 등록한 리스너를 제거하지 않아 객체가 GC되지 않음\n- 캐시: 무한정 증가하는 캐시로 메모리 소진\n- 순환 참조: 가비지 컬렉터가 처리 못하는 순환 참조 (구형 언어)\n\n**언어별 특징:**\n- C/C++: 수동 메모리 관리로 malloc/new 후 free/delete 누락 시 누수\n- Java: GC가 있지만 static 컬렉션, ThreadLocal, 리스너 등으로 누수 가능\n- JavaScript: 클로저, DOM 참조, 타이머 등으로 누수 발생\n- Python: 순환 참조나 C 확장 모듈에서 누수 가능\n- Go: defer 누락, 고루틴 누수, 큰 슬라이스 참조\n\n**일반적 패턴:**\n- 전역 컬렉션: 전역 리스트나 맵에 계속 추가만 하고 제거 안 함\n- 클로저: 클로저가 큰 객체를 캡처하여 GC 방해\n- 타이머: setInterval이나 setTimeout을 정리하지 않음\n- 이벤트: addEventListener 후 removeEventListener 안 함\n- 캐시: LRU 같은 제한 없이 캐시가 무한정 증가\n\n**탐지 방법:**\n- 메모리 프로파일링: 힙 덤프나 메모리 사용량 추이 분석\n- 도구 사용: Valgrind(C/C++), VisualVM(Java), Chrome DevTools(JavaScript)\n- 모니터링: 운영 환경에서 메모리 사용량을 지속적으로 모니터링\n- 부하 테스트: 장시간 실행하며 메모리 증가 확인\n\n**방지 방법:**\n- 명시적 정리: try-finally나 defer로 리소스 해제 보장\n- 약한 참조: WeakMap, WeakSet으로 GC를 방해하지 않는 참조\n- 크기 제한: 캐시나 컬렉션에 최대 크기 설정\n- 리스너 제거: 더 이상 필요 없는 이벤트 리스너 제거\n- 자동 관리: RAII 패턴, with 문, defer 등으로 자동 정리\n\n**언어별 방지책:**\n- Java: WeakHashMap 사용, ThreadLocal.remove() 호출, 리스너 등록 해제\n- JavaScript: WeakMap/WeakSet 사용, clearInterval/clearTimeout, removeEventListener\n- Python: 약한 참조(weakref) 사용, with 문으로 리소스 관리\n- C++: 스마트 포인터(unique_ptr, shared_ptr) 사용, RAII 패턴\n- Go: defer로 리소스 정리, 컨텍스트로 고루틴 종료\n\n**실무 활용:**\n- 웹 서버에서 요청 처리 후 반드시 데이터베이스 연결이나 파일 닫기\n- SPA에서 컴포넌트 언마운트 시 타이머와 이벤트 리스너 정리\n- 장기 실행 프로세스는 정기적으로 메모리 사용량 모니터링하고 프로파일링\n- 코드 리뷰에서 리소스 정리 누락 여부를 체크리스트로 확인",
      "type": "essay",
      "tags": [
        "프로그래밍언어",
        "CS",
        "면접",
        "GC",
        "메모리"
      ],
      "id": "1763437633098-yyem4do9",
      "createdAt": "2025-11-18T03:47:13.096733",
      "studyCount": 0
    }
  ]
}