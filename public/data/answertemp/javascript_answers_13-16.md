# JavaScript 답변 13-16

## 질문 13: 커링(Currying)과 부분 적용(Partial Application)에 대해 설명해주세요.

**정의:**
커링은 여러 개의 인수를 받는 함수를 인수 하나씩 받는 함수들의 체인으로 변환하는 기법입니다. 부분 적용은 함수의 일부 인수를 미리 고정하여 새로운 함수를 만드는 기법입니다. 둘 다 함수형 프로그래밍에서 중요한 개념입니다.

**커링의 특징:**
- n개의 인수를 받는 함수를 1개의 인수를 받는 n개의 함수로 변환합니다.
- 각 함수는 하나의 인수만 받고 다음 함수를 반환합니다.
- 모든 인수가 제공될 때까지 함수를 반환합니다.
- 마지막 인수가 제공되면 최종 결과를 계산합니다.

**부분 적용의 특징:**
- 일부 인수를 미리 고정한 새로운 함수를 생성합니다.
- 나머지 인수는 나중에 제공됩니다.
- bind 메서드나 클로저로 구현할 수 있습니다.
- 커링과 달리 여러 인수를 한 번에 고정할 수 있습니다.

**커링과 부분 적용의 차이:**
- 커링: 항상 단일 인수 함수의 연속입니다. 모든 인수를 하나씩 받습니다.
- 부분 적용: 여러 인수를 한 번에 고정할 수 있습니다. 남은 인수를 한 번에 받을 수 있습니다.
- 커링은 더 순수한 함수형 기법이고, 부분 적용은 더 실용적입니다.

**커링의 장점:**
- 함수 재사용성이 높아집니다. 공통 인수를 가진 함수를 쉽게 만들 수 있습니다.
- 함수 조합이 용이합니다. 작은 함수들을 조합하여 복잡한 로직을 구성합니다.
- 지연 실행이 가능합니다. 필요한 시점까지 실행을 미룰 수 있습니다.
- 코드 가독성이 향상됩니다. 각 인수의 의미가 명확해집니다.

**실무 활용 사례:**
- 설정 함수를 만들 때 유용합니다. 공통 설정을 먼저 제공하고 나중에 구체적인 값을 전달합니다.
- 이벤트 핸들러를 생성할 때 사용합니다. 공통 로직을 커링으로 분리합니다.
- 유효성 검사 함수를 만들 때 활용합니다. 검사 규칙을 먼저 설정하고 값은 나중에 전달합니다.
- Lodash나 Ramda 같은 함수형 라이브러리에서 널리 사용됩니다.
- React에서 HOC를 만들 때 커링 패턴을 활용합니다.
- Redux의 액션 크리에이터나 미들웨어에서 부분 적용을 사용합니다.

---

## 질문 14: IIFE(즉시 실행 함수)는 왜 사용하나요?

**정의:**
IIFE는 Immediately Invoked Function Expression의 약자로, 정의되자마자 즉시 실행되는 함수 표현식입니다. 함수를 괄호로 감싸고 바로 호출 연산자를 붙여 실행합니다.

**IIFE의 문법:**
- 함수 표현식을 괄호로 감쌉니다. 함수 선언문이 아닌 표현식으로 만듭니다.
- 즉시 호출 연산자를 붙입니다. 마지막에 괄호를 추가하여 바로 실행합니다.
- 화살표 함수로도 만들 수 있습니다.
- 인수를 전달할 수도 있습니다.

**IIFE의 주요 목적:**
- 전역 스코프 오염을 방지합니다. 변수와 함수를 지역 스코프에 격리합니다.
- 전역 네임스페이스를 보호합니다. 다른 라이브러리와의 충돌을 막습니다.
- 클로저를 활용한 데이터 은닉이 가능합니다. private 변수를 만들 수 있습니다.
- 초기화 코드를 실행합니다. 설정이나 초기 설정을 한 번만 실행합니다.

**IIFE의 장점:**
- 변수 충돌을 방지합니다. 같은 이름의 전역 변수가 있어도 영향을 받지 않습니다.
- 메모리 관리가 효율적입니다. 실행 후 내부 변수는 가비지 컬렉션 대상이 됩니다.
- 모듈 패턴의 기초가 됩니다. public API만 노출하고 내부 구현을 숨길 수 있습니다.
- 초기화 로직을 명확히 분리합니다. 일회성 코드를 구조화합니다.

**실무 활용 사례:**
- 라이브러리나 플러그인 개발 시 사용합니다. 내부 변수가 외부로 노출되지 않도록 합니다.
- 모듈 패턴을 구현합니다. 공개할 메서드만 반환하고 나머지는 private으로 유지합니다.
- 반복문에서 클로저 문제를 해결합니다. 각 반복마다 독립적인 스코프를 만듭니다.
- 초기 설정이나 환경 감지를 수행합니다. 페이지 로드 시 한 번만 실행되는 코드를 작성합니다.
- ES6 모듈이 없던 시절 모듈화를 구현했습니다. 현재는 import/export를 사용하지만 레거시 코드에서 볼 수 있습니다.

**현대적인 대안:**
- ES6 모듈 시스템이 도입되면서 IIFE의 필요성이 줄었습니다.
- let과 const의 블록 스코프로 변수 격리가 가능합니다.
- 하지만 여전히 즉시 실행이 필요한 초기화 코드에서는 유용합니다.
- 번들러나 트랜스파일러가 자동으로 IIFE로 감싸주기도 합니다.

---

## 질문 15: 프로토타입(Prototype)과 프로토타입 체인에 대해 설명해주세요.

**정의:**
프로토타입은 JavaScript 객체가 다른 객체로부터 속성과 메서드를 상속받을 수 있게 하는 메커니즘입니다. 프로토타입 체인은 객체에서 프로퍼티를 찾을 때 상위 프로토타입을 따라 올라가며 검색하는 구조입니다.

**프로토타입의 핵심 개념:**
- 모든 객체는 내부적으로 프로토타입을 참조합니다. 이를 통해 다른 객체의 속성을 사용할 수 있습니다.
- 함수는 prototype 프로퍼티를 가집니다. 생성자 함수로 만든 인스턴스의 프로토타입이 됩니다.
- 객체는 프로토타입으로부터 속성을 상속받습니다. 직접 가지지 않은 속성도 접근할 수 있습니다.

**프로토타입 체인의 동작:**
- 객체의 프로퍼티에 접근하면 먼저 객체 자신에게서 찾습니다.
- 없으면 프로토타입 객체에서 찾습니다. 내부 슬롯을 통해 프로토타입을 참조합니다.
- 프로토타입에도 없으면 프로토타입의 프로토타입에서 찾습니다. 체인을 따라 올라갑니다.
- Object.prototype까지 올라가도 없으면 undefined를 반환합니다.
- Object.prototype이 체인의 최상위입니다. 그 위의 프로토타입은 null입니다.

**프로토타입 상속의 특징:**
- 동적 상속입니다. 프로토타입이 변경되면 모든 인스턴스에 즉시 반영됩니다.
- 메모리 효율적입니다. 공통 메서드를 프로토타입에 한 번만 정의하면 모든 인스턴스가 공유합니다.
- 인스턴스마다 메서드를 복사하지 않아도 됩니다.
- 하지만 프로토타입 변경은 위험할 수 있습니다. 기존 인스턴스에 영향을 미칩니다.

**프로토타입 기반 상속의 구현:**
- 생성자 함수의 prototype에 메서드를 추가합니다. 모든 인스턴스가 공유합니다.
- Object.create로 프로토타입을 지정한 객체를 만듭니다.
- ES6 클래스 문법은 내부적으로 프로토타입을 사용합니다. 문법적 설탕일 뿐입니다.

**프로토타입 관련 메서드:**
- Object.getPrototypeOf는 객체의 프로토타입을 가져옵니다.
- Object.setPrototypeOf는 프로토타입을 변경합니다. 성능상 권장되지 않습니다.
- hasOwnProperty는 객체 자신의 프로퍼티인지 확인합니다. 프로토타입 체인을 검색하지 않습니다.
- instanceof는 프로토타입 체인에 생성자의 prototype이 있는지 확인합니다.

**실무 활용:**
- 공통 메서드는 프로토타입에 정의하여 메모리를 절약합니다.
- 프로토타입 체인을 이해하면 상속 구조를 설계할 수 있습니다.
- 네이티브 객체의 프로토타입 확장은 피해야 합니다. 다른 코드와 충돌할 수 있습니다.
- 프레임워크나 라이브러리의 상속 패턴을 이해하는 데 필수적입니다.

---

## 질문 16: __proto__와 prototype의 차이점은 무엇인가요?

**정의:**
__proto__는 모든 객체가 가지는 접근자 프로퍼티로 자신의 프로토타입을 가리킵니다. prototype은 함수 객체만 가지는 프로퍼티로, 생성자 함수로 생성될 인스턴스의 프로토타입을 가리킵니다.

**__proto__의 특징:**
- 모든 객체가 가집니다. 일반 객체, 배열, 함수 모두 가지고 있습니다.
- 객체의 프로토타입을 참조합니다. 상속받은 프로퍼티를 찾을 때 사용됩니다.
- 접근자 프로퍼티입니다. getter와 setter로 구현되어 있습니다.
- 비표준이었다가 ES6에서 표준화되었습니다. 하지만 직접 사용은 권장되지 않습니다.
- Object.getPrototypeOf와 Object.setPrototypeOf 사용이 권장됩니다.

**prototype의 특징:**
- 함수 객체만 가집니다. 일반 객체는 가지지 않습니다.
- 생성자 함수로 만들 인스턴스의 프로토타입을 가리킵니다.
- new 키워드로 객체를 생성하면 prototype이 인스턴스의 프로토타입이 됩니다.
- constructor 프로퍼티를 통해 생성자 함수를 역참조합니다.
- 화살표 함수는 prototype을 가지지 않습니다. 생성자로 사용할 수 없기 때문입니다.

**관계와 연결:**
- 생성자 함수의 prototype과 인스턴스의 __proto__는 같은 객체를 가리킵니다.
- 인스턴스에서 __proto__로 접근하는 것과 생성자.prototype은 동일합니다.
- prototype.constructor는 생성자 함수 자신을 가리킵니다. 순환 참조 구조입니다.

**사용 시 주의사항:**
- __proto__는 직접 사용하지 않는 것이 좋습니다. 성능 문제가 있고 모든 환경에서 지원되지 않습니다.
- Object.getPrototypeOf를 사용하여 프로토타입을 가져옵니다.
- Object.create를 사용하여 프로토타입을 지정한 객체를 생성합니다.
- Object.setPrototypeOf는 성능에 매우 부정적입니다. 가능하면 객체 생성 시 프로토타입을 지정합니다.

**프로토타입 체인에서의 역할:**
- __proto__가 체인을 형성합니다. 각 객체의 __proto__가 다음 프로토타입을 가리킵니다.
- prototype은 생성자 함수가 만들 객체의 프로토타입을 미리 정의합니다.
- 인스턴스 생성 시 인스턴스.__proto__에 생성자.prototype이 연결됩니다.

**실무 활용:**
- 클래스 문법을 사용하면 prototype을 직접 다룰 일이 적습니다. 내부적으로 처리됩니다.
- 하지만 프로토타입 기반 상속을 이해해야 합니다. 클래스도 프로토타입을 사용합니다.
- 객체의 프로토타입을 확인할 때는 Object.getPrototypeOf를 사용합니다.
- 디버깅 시 __proto__를 콘솔에서 확인할 수 있지만 코드에서는 사용하지 않습니다.
- instanceof 연산자는 프로토타입 체인을 검색하여 타입을 확인합니다.

---
