## 질문 53: 디바운싱(Debouncing)과 스로틀링(Throttling)의 차이와 구현 방법은 무엇인가요?

**정의:**
디바운싱과 스로틀링은 이벤트 핸들러의 실행 빈도를 제한하는 기법으로, 성능 최적화에 사용됩니다. 디바운싱은 연속된 호출을 그룹화하여 마지막 호출 후 일정 시간이 지나면 실행하고, 스로틀링은 일정 시간 간격으로 최대 한 번만 실행합니다.

**특징/원리:**
- 성능 최적화: 빈번한 이벤트 발생 시 불필요한 함수 실행을 줄여 성능 향상
- 사용자 경험: 과도한 API 호출이나 렌더링을 방지하여 부드러운 UX 제공
- 타이머 활용: setTimeout을 사용하여 지연 실행 구현
- 클로저 사용: 타이머 ID를 클로저로 유지하여 취소 가능

**디바운싱:**
- 동작 원리: 연속 호출 시 이전 타이머를 취소하고 새 타이머 설정하며, 마지막 호출 후 대기 시간이 지나면 실행
- 사용 사례: 검색창 자동완성으로 입력이 멈춘 후 API 호출, 창 크기 조절 완료 후 레이아웃 재계산
- leading/trailing: 첫 호출 시 즉시 실행할지(leading), 마지막 호출 후 실행할지(trailing) 선택 가능
- 완전한 대기: 연속 입력 중에는 절대 실행되지 않고 입력이 멈춰야 실행

**스로틀링:**
- 동작 원리: 일정 시간 간격으로 최대 한 번만 실행되도록 제한
- 사용 사례: 스크롤 이벤트 처리, 무한 스크롤 구현, 마우스 이동 추적
- 정기적 실행: 연속 호출 중에도 일정 간격마다 주기적으로 실행
- 즉시 실행: 첫 호출은 즉시 실행되고 이후 대기 시간 동안은 무시

**구현 차이:**
- 디바운싱: clearTimeout으로 이전 타이머를 계속 취소하고 새로 설정
- 스로틀링: 플래그나 타임스탬프로 실행 가능 여부를 판단
- 실행 빈도: 디바운싱은 연속 호출 시 0번, 스로틀링은 일정 간격으로 실행
- 응답성: 스로틀링이 더 즉각적인 피드백 제공

**실무 활용:**
- 검색창 자동완성은 디바운싱으로 입력 완료 후 API 호출하여 불필요한 요청 방지
- 무한 스크롤은 스로틀링으로 스크롤 중에도 일정 간격으로 데이터 로드
- Lodash 라이브러리의 debounce, throttle 함수를 사용하여 간편하게 구현

---

## 질문 54: 얕은 복사와 깊은 복사의 차이점과 구현 방법은 무엇인가요?

**정의:**
얕은 복사는 객체의 최상위 속성만 복사하여 중첩된 객체는 참조를 공유하고, 깊은 복사는 모든 레벨의 속성을 재귀적으로 복사하여 완전히 독립적인 객체를 생성합니다. JavaScript의 객체는 참조 타입이므로 복사 시 주의가 필요합니다.

**특징/원리:**
- 참조 공유: 얕은 복사는 중첩 객체의 참조를 복사하여 원본과 복사본이 같은 객체를 가리킴
- 완전 분리: 깊은 복사는 모든 객체를 새로 생성하여 원본과 완전히 독립적
- 메모리: 얕은 복사는 메모리 효율적이지만, 깊은 복사는 모든 객체를 복제하여 메모리 많이 사용
- 순환 참조: 깊은 복사 시 순환 참조가 있으면 무한 루프 발생 가능

**얕은 복사 방법:**
- 스프레드 연산자: 객체나 배열에 ...을 사용하여 최상위 레벨만 복사
- Object.assign: 첫 번째 인자 객체에 나머지 객체들의 속성을 복사
- Array.slice: 배열의 일부나 전체를 복사하지만 요소가 객체면 참조 복사
- Array.from: 유사 배열이나 이터러블을 배열로 변환하며 얕은 복사

**깊은 복사 방법:**
- JSON 방식: JSON.stringify로 문자열로 변환 후 JSON.parse로 파싱하지만 함수, undefined, Symbol 등은 손실
- 재귀 함수: 객체를 순회하며 재귀적으로 복사하되 순환 참조 처리 필요
- Lodash cloneDeep: 라이브러리 함수로 순환 참조, 함수, Symbol 등을 안전하게 처리
- structuredClone: 최신 브라우저에서 제공하는 표준 API로 깊은 복사 지원

**주의사항:**
- JSON 방식: Date는 문자열로 변환되고, 함수와 undefined는 제거되며, NaN과 Infinity는 null로 변환
- 프로토타입: 대부분의 깊은 복사 방법은 프로토타입 체인을 복사하지 않음
- 성능: 깊은 복사는 비용이 크므로 필요한 경우에만 사용
- 불변성: React나 Redux에서는 얕은 복사로 새 참조를 만들어 변경 감지

**실무 활용:**
- 상태 관리 시 스프레드 연산자로 얕은 복사하여 불변성 유지
- 중첩된 설정 객체를 수정할 때 깊은 복사하여 원본 보존
- 불필요한 깊은 복사를 피하고 필요한 부분만 복사하여 성능 최적화

---

## 질문 55: 구조 분해 할당(Destructuring)에 대해 설명해주세요.

**정의:**
구조 분해 할당은 배열이나 객체의 속성을 해체하여 개별 변수에 할당하는 문법입니다. ES6에서 도입되어 코드를 간결하게 만들고 필요한 값만 추출할 수 있어 가독성을 향상시킵니다.

**특징/원리:**
- 패턴 매칭: 좌변의 패턴과 우변의 구조를 매칭하여 값을 추출
- 기본값: 값이 undefined인 경우 사용할 기본값 지정 가능
- 나머지 패턴: rest 연산자로 나머지 요소를 배열이나 객체로 수집
- 중첩 구조: 깊게 중첩된 객체나 배열도 한 번에 분해 가능

**배열 구조 분해:**
- 기본 사용: 배열 요소를 순서대로 변수에 할당
- 요소 건너뛰기: 빈 자리를 남겨 특정 인덱스의 요소만 추출
- 기본값: 배열 길이가 짧을 때 사용할 기본값 지정
- 나머지 요소: rest 연산자로 남은 모든 요소를 배열로 수집
- 값 교환: 임시 변수 없이 두 변수의 값을 교환 가능

**객체 구조 분해:**
- 기본 사용: 속성 이름과 동일한 변수명으로 값 추출
- 다른 변수명: 콜론을 사용하여 다른 이름의 변수에 할당
- 기본값: 속성이 없을 때 사용할 기본값 지정
- 중첩 객체: 점 표기법처럼 중첩된 구조를 한 번에 분해
- 계산된 속성명: 대괄호로 동적 속성명 사용 가능

**함수 파라미터:**
- 객체 파라미터: 함수가 많은 옵션을 받을 때 객체 구조 분해로 명시적으로 표현
- 기본값 조합: 파라미터 기본값과 구조 분해 기본값을 함께 사용 가능
- 가독성: 함수 시그니처만 봐도 어떤 속성을 사용하는지 명확히 알 수 있음

**실무 활용:**
- React 컴포넌트에서 props를 구조 분해하여 간결하게 사용
- API 응답에서 필요한 필드만 추출하여 변수에 할당
- 배열의 첫 번째와 나머지 요소를 분리하여 재귀 함수 구현

---

## 질문 56: 스프레드 연산자와 레스트 파라미터의 차이점은 무엇인가요?

**정의:**
스프레드 연산자와 레스트 파라미터는 모두 점 세 개(...) 문법을 사용하지만 반대 역할을 합니다. 스프레드는 배열이나 객체를 펼쳐서 개별 요소로 분리하고, 레스트는 개별 요소들을 모아서 배열이나 객체로 수집합니다.

**특징/원리:**
- 문법 위치: 스프레드는 값이 필요한 곳에, 레스트는 변수를 선언하는 곳에 사용
- 반대 동작: 스프레드는 펼치기(spreading), 레스트는 모으기(gathering)
- 얕은 복사: 스프레드로 복사한 객체나 배열은 새로운 참조를 가지지만 중첩 객체는 참조 공유
- 불변성: 원본을 수정하지 않고 새로운 배열이나 객체 생성

**스프레드 연산자:**
- 배열 펼치기: 배열의 요소들을 개별 인자로 펼쳐서 함수에 전달하거나 다른 배열에 삽입
- 객체 펼치기: 객체의 속성들을 펼쳐서 새 객체에 복사하거나 병합
- 배열 복사: 얕은 복사로 새로운 배열 생성
- 배열 연결: 여러 배열을 하나로 합치기
- 객체 병합: 여러 객체를 하나로 합치며 나중 것이 우선순위

**레스트 파라미터:**
- 함수 파라미터: 가변 인자를 배열로 수집하여 처리
- 구조 분해: 배열이나 객체에서 일부만 추출하고 나머지를 모음
- arguments 대체: 화살표 함수에서 arguments 객체 대신 레스트 파라미터 사용
- 마지막 위치: 레스트 파라미터는 항상 마지막 파라미터여야 함

**사용 위치 구분:**
- 함수 호출: 스프레드로 배열을 개별 인자로 펼침
- 함수 정의: 레스트로 여러 인자를 배열로 모음
- 배열 리터럴: 스프레드로 배열 요소 삽입
- 구조 분해 할당: 레스트로 나머지 요소 수집
- 객체 리터럴: 스프레드로 속성 복사

**실무 활용:**
- 불변성 유지를 위해 스프레드로 배열이나 객체를 복사하여 수정
- 함수에 가변 개수의 인자를 받을 때 레스트 파라미터 사용
- Math.max 같은 함수에 배열의 요소들을 스프레드로 전달

---
