## 질문 1: JVM의 구조와 동작 원리에 대해 설명해주세요.

**정의:**
JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신으로, 플랫폼 독립성을 제공하는 자바의 핵심 구성 요소입니다. JVM은 자바 컴파일러가 생성한 .class 파일을 읽어 해당 운영체제에서 실행 가능한 형태로 변환하여 실행합니다.

**특징/원리:**
- 플랫폼 독립성: "Write Once, Run Anywhere" 철학을 구현하여 한 번 작성된 코드가 JVM이 설치된 모든 플랫폼에서 실행 가능
- 자동 메모리 관리: 가비지 컬렉션을 통해 사용하지 않는 객체를 자동으로 메모리에서 제거
- 보안성: 바이트코드 검증기를 통해 악의적인 코드 실행을 방지
- 최적화 기능: JIT 컴파일러를 통해 자주 실행되는 코드를 네이티브 코드로 컴파일하여 성능 향상

**주요 구성 요소:**
- 클래스 로더(Class Loader): .class 파일을 메모리에 로드하고 링크하는 역할 수행
- 실행 엔진(Execution Engine): 바이트코드를 해석하고 실행하며, 인터프리터와 JIT 컴파일러로 구성
- 런타임 데이터 영역(Runtime Data Area): 메모리 공간으로 Heap, Stack, Method Area, PC Register, Native Method Stack으로 구분
- 가비지 컬렉터(Garbage Collector): 더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제

**실무 활용:**
- 애플리케이션 성능 튜닝 시 JVM 옵션 설정을 통해 힙 메모리 크기, GC 알고리즘 선택 등을 최적화
- 운영 중인 시스템의 메모리 누수나 성능 문제 진단 시 JVM 모니터링 도구 활용
- 다양한 플랫폼에서 동일한 자바 애플리케이션을 배포하고 실행할 수 있어 유지보수 비용 절감

---

## 질문 2: JVM의 메모리 구조(Heap, Stack, Method Area 등)를 설명해주세요.

**정의:**
JVM의 메모리 구조는 런타임 데이터 영역으로 구성되며, 프로그램 실행에 필요한 데이터를 저장하는 공간입니다. 각 영역은 특정 목적에 따라 구분되어 있으며, 일부는 모든 스레드가 공유하고 일부는 스레드별로 독립적으로 생성됩니다.

**특징/원리:**
- 스레드 공유 여부에 따른 구분: Heap과 Method Area는 모든 스레드가 공유하며, Stack, PC Register, Native Method Stack은 스레드별로 생성
- 생명주기 차이: Method Area와 Heap은 JVM 시작 시 생성되고 종료 시 소멸되며, 스레드 전용 영역은 스레드 생성/종료 시 함께 생성/소멸
- 가비지 컬렉션 대상: Heap과 Method Area는 GC의 대상이 되지만, Stack 영역은 자동으로 메모리가 해제됨

**메모리 영역별 특징:**
- Heap: 객체 인스턴스와 배열이 저장되는 공간으로 GC의 주요 대상이며, Young Generation과 Old Generation으로 구분
- Stack: 메서드 호출 시 생성되는 지역 변수, 매개변수, 리턴 값 등을 저장하며 LIFO 구조로 동작
- Method Area: 클래스 메타데이터, static 변수, 상수 풀 등이 저장되며 Java 8부터 Metaspace로 대체
- PC Register: 현재 실행 중인 JVM 명령어 주소를 저장하는 스레드별 레지스터
- Native Method Stack: 네이티브 메서드 실행 시 사용되는 스택 영역

**실무 활용:**
- OutOfMemoryError 발생 시 어느 영역에서 발생했는지 파악하여 적절한 JVM 옵션으로 메모리 크기 조정
- 스레드 덤프 분석 시 Stack 영역 정보를 활용하여 데드락이나 무한 루프 문제 진단
- 힙 덤프 분석을 통해 메모리 누수가 발생하는 객체를 식별하고 코드 개선

---

## 질문 3: Garbage Collection의 동작 원리와 종류에 대해 설명해주세요.

**정의:**
가비지 컬렉션(GC)은 JVM의 힙 메모리에서 더 이상 사용되지 않는 객체를 자동으로 찾아 제거하는 메모리 관리 기법입니다. 개발자가 명시적으로 메모리를 해제할 필요 없이 JVM이 자동으로 메모리를 관리하여 메모리 누수를 방지합니다.

**특징/원리:**
- Stop-The-World: GC 실행 중에는 애플리케이션 스레드가 일시 중지되며, 이 시간을 최소화하는 것이 GC 성능의 핵심
- Reachability 기반: GC Root로부터 참조 체인을 따라 도달 가능한 객체는 살아있는 객체로 판단
- 세대별 관리: 대부분의 객체는 생성 후 금방 사라진다는 Weak Generational Hypothesis에 기반하여 Young과 Old 영역으로 구분
- Mark and Sweep: 살아있는 객체를 표시(Mark)하고 표시되지 않은 객체를 제거(Sweep)하는 방식으로 동작

**주요 GC 알고리즘:**
- Serial GC: 단일 스레드로 동작하며 작은 힙 크기에 적합하고 Stop-The-World 시간이 김
- Parallel GC: 여러 스레드를 사용하여 Young Generation을 병렬로 처리하며 처리량 중심 최적화
- CMS GC: 애플리케이션 스레드와 동시에 실행되어 Stop-The-World 시간을 최소화하지만 메모리 단편화 발생 가능
- G1 GC: 힙을 여러 리전으로 나누어 관리하며 예측 가능한 정지 시간 목표를 제공
- ZGC/Shenandoah GC: 매우 짧은 정지 시간을 목표로 하는 최신 GC 알고리즘

**실무 활용:**
- 애플리케이션 특성에 따라 적절한 GC 알고리즘 선택하여 응답 시간이나 처리량 최적화
- GC 로그 분석을 통해 Full GC 빈도와 정지 시간을 모니터링하고 튜닝 포인트 발견
- 메모리 누수 의심 시 힙 덤프를 분석하여 GC되지 않는 객체의 참조 체인 추적

---

## 질문 4: G1 GC와 다른 GC 알고리즘의 차이점은 무엇인가요?

**정의:**
G1(Garbage First) GC는 Java 7에서 도입되어 Java 9부터 기본 GC로 채택된 알고리즘으로, 대용량 힙 메모리에서 예측 가능한 정지 시간을 제공하는 것을 목표로 합니다. 기존 GC와 달리 힙을 고정된 크기의 리전으로 나누어 관리하는 새로운 접근 방식을 사용합니다.

**특징/원리:**
- 리전 기반 구조: 힙을 동일한 크기의 리전으로 나누고 각 리전이 Eden, Survivor, Old 역할을 동적으로 변경
- 예측 가능한 정지 시간: 사용자가 설정한 정지 시간 목표 내에서 GC를 수행하도록 최적화
- 점진적 수집: 전체 힙을 한 번에 수집하지 않고 우선순위가 높은 리전부터 점진적으로 수집
- 동시 마킹: 애플리케이션 실행과 동시에 마킹 작업을 수행하여 정지 시간 최소화

**다른 GC와의 차이점:**
- Parallel GC 대비: Parallel GC는 전체 Young/Old Generation을 한 번에 처리하지만, G1은 리전 단위로 선택적 수집
- CMS GC 대비: CMS는 메모리 단편화 문제가 있지만 G1은 컴팩션을 통해 단편화 해결하며, 더 예측 가능한 정지 시간 제공
- Serial GC 대비: Serial은 단일 스레드이지만 G1은 멀티 스레드로 병렬 처리하여 대용량 힙에 적합
- ZGC 대비: ZGC는 매우 짧은 정지 시간(10ms 미만)을 목표로 하지만, G1은 균형 잡힌 처리량과 응답성 제공

**실무 활용:**
- 4GB 이상의 대용량 힙을 사용하는 서버 애플리케이션에서 안정적인 응답 시간 보장
- MaxGCPauseMillis 옵션으로 목표 정지 시간을 설정하여 애플리케이션 요구사항에 맞는 튜닝
- 실시간성이 중요한 웹 서비스에서 일관된 응답 속도를 유지하기 위해 G1 GC 선택

---
