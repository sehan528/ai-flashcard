## 질문 65: TypeScript의 Union Type과 Intersection Type의 차이점은 무엇인가요?

**정의:**
Union Type은 여러 타입 중 하나일 수 있는 값을 표현하고, Intersection Type은 여러 타입을 모두 만족하는 값을 표현합니다. Union은 OR 논리를 사용하여 타입을 결합하고, Intersection은 AND 논리를 사용하여 타입을 결합합니다.

**특징/원리:**
- Union Type: 파이프(|) 기호로 연결하며 타입 중 하나에 속하면 유효
- Intersection Type: 앰퍼샌드(&) 기호로 연결하며 모든 타입의 속성을 가져야 유효
- 타입 좁히기: Union Type은 타입 가드로 구체적인 타입으로 좁혀서 사용
- 타입 확장: Intersection Type은 기존 타입에 새로운 속성을 추가하여 확장

**Union Type 특징:**
- 여러 가능성: 함수가 여러 타입의 값을 받거나 반환할 수 있음을 표현
- 공통 속성: Union의 모든 타입에 공통으로 존재하는 속성만 안전하게 접근 가능
- 타입 가드: typeof, instanceof, in 연산자로 타입을 좁혀서 특정 타입의 속성 접근
- 리터럴 Union: 문자열 리터럴이나 숫자 리터럴을 Union으로 열거형처럼 사용

**Intersection Type 특징:**
- 타입 결합: 여러 타입의 모든 속성과 메서드를 가진 새로운 타입 생성
- 믹스인: 여러 인터페이스나 타입을 결합하여 복합 타입 생성
- 충돌 해결: 같은 이름의 속성이 다른 타입이면 never 타입으로 결정
- 객체 타입: 주로 객체 타입을 결합하는 데 사용

**사용 사례:**
- Union Type: 함수 파라미터가 문자열이나 숫자를 받을 수 있는 경우, API 응답이 성공 또는 에러 타입인 경우
- Intersection Type: 여러 믹스인을 결합하여 풍부한 기능을 가진 타입 생성, 기존 타입에 새로운 속성 추가

**타입 가드:**
- typeof: 원시 타입 구분
- instanceof: 클래스 인스턴스 구분
- in 연산자: 속성 존재 여부로 타입 구분
- 사용자 정의 타입 가드: 반환 타입으로 타입 predicate 사용

**실무 활용:**
- API 응답을 성공과 실패 타입의 Union으로 정의하여 에러 처리 강제
- Intersection으로 여러 인터페이스를 결합하여 복잡한 도메인 모델 표현
- Union Type과 타입 가드로 다형성을 타입 안전하게 구현

---

## 질문 66: TypeScript의 타입 가드(Type Guard) 종류와 사용 방법을 설명해주세요.

**정의:**
타입 가드는 런타임에 변수의 타입을 좁혀서 TypeScript가 더 구체적인 타입으로 추론할 수 있게 하는 기법입니다. 조건문 내에서 타입을 검사하면 해당 블록 안에서는 좁혀진 타입으로 안전하게 사용할 수 있습니다.

**특징/원리:**
- 타입 좁히기: 넓은 타입에서 구체적인 타입으로 범위를 좁힘
- 컴파일러 이해: TypeScript 컴파일러가 타입 가드를 인식하여 타입 추론
- 런타임 검사: 실제 런타임에 값의 타입을 검사하는 코드 실행
- 스코프: 타입 가드가 적용되는 스코프 내에서만 타입이 좁혀짐

**typeof 타입 가드:**
- 원시 타입 검사: string, number, boolean, symbol, undefined, function 구분
- 제한: object는 객체와 null 모두 포함하여 세밀한 구분 불가
- 사용: if (typeof x === 'string') 형태로 사용

**instanceof 타입 가드:**
- 클래스 인스턴스 검사: 객체가 특정 클래스의 인스턴스인지 확인
- 프로토타입 체인: 프로토타입 체인을 따라 생성자 함수 확인
- 사용: if (x instanceof Date) 형태로 사용

**in 연산자 타입 가드:**
- 속성 존재 확인: 객체에 특정 속성이 있는지 검사
- 옵셔널 속성: 선택적 속성의 존재 여부로 타입 구분
- 사용: if ('propertyName' in obj) 형태로 사용

**사용자 정의 타입 가드:**
- 타입 predicate: 함수 반환 타입을 'parameterName is Type' 형태로 선언
- 복잡한 검사: 여러 조건을 조합하여 타입을 판별하는 로직 구현
- 재사용성: 타입 가드 함수를 정의하여 여러 곳에서 재사용
- 명확성: 타입 검사 로직에 의미 있는 이름 부여

**실무 활용:**
- Union Type을 다룰 때 타입 가드로 각 타입에 맞는 처리 분기
- API 응답의 성공/실패를 타입 가드로 구분하여 안전하게 처리
- 사용자 정의 타입 가드 함수로 복잡한 타입 판별 로직을 캡슐화

---

## 질문 67: TypeScript의 유틸리티 타입(Partial, Pick, Omit 등)에 대해 설명해주세요.

**정의:**
유틸리티 타입은 TypeScript가 제공하는 내장 제네릭 타입으로, 기존 타입을 변환하여 새로운 타입을 생성합니다. 코드 중복을 줄이고 타입 변환을 선언적으로 표현하여 타입 정의를 간결하고 유지보수하기 쉽게 만듭니다.

**특징/원리:**
- 타입 변환: 기존 타입을 기반으로 새로운 타입 자동 생성
- 제네릭 활용: 타입 파라미터를 받아 유연하게 동작
- 조건부 타입: 내부적으로 조건부 타입과 매핑된 타입 사용
- 표준 제공: TypeScript가 기본 제공하여 별도 정의 불필요

**Partial<T>:**
- 모든 속성 선택적: 모든 속성을 optional로 만들어 일부만 제공 가능
- 사용 사례: 업데이트 함수에서 변경할 필드만 받을 때
- 구현: 매핑된 타입과 옵셔널 수정자 사용

**Required<T>:**
- 모든 속성 필수: 모든 속성을 required로 만들어 반드시 제공하도록 강제
- Partial 반대: Partial의 반대 개념
- 사용 사례: 선택적 속성을 가진 타입을 모두 필수로 변환할 때

**Pick<T, K>:**
- 속성 선택: T 타입에서 K에 해당하는 속성만 선택하여 새 타입 생성
- 부분 타입: 큰 타입에서 필요한 일부만 추출
- 사용 사례: DTO에서 특정 필드만 선택하여 뷰 모델 생성

**Omit<T, K>:**
- 속성 제외: T 타입에서 K에 해당하는 속성을 제외한 나머지로 새 타입 생성
- Pick 반대: Pick과 반대로 제외할 속성 지정
- 사용 사례: 민감한 정보를 제외한 공개 타입 생성

**Record<K, T>:**
- 키-값 매핑: K를 키 타입으로, T를 값 타입으로 하는 객체 타입 생성
- 사용 사례: 문자열 키와 특정 타입 값의 딕셔너리 정의

**Readonly<T>:**
- 읽기 전용: 모든 속성을 읽기 전용으로 만들어 수정 방지
- 불변성: 불변 객체 타입 정의에 사용
- 사용 사례: 설정 객체나 상수 객체 타입 정의

**Extract<T, U>와 Exclude<T, U>:**
- Extract: T에서 U에 할당 가능한 타입만 추출
- Exclude: T에서 U에 할당 가능한 타입을 제외
- Union 타입 필터링: Union Type을 필터링하여 부분집합 생성

**ReturnType<T>:**
- 반환 타입 추출: 함수 타입 T의 반환 타입 추출
- 사용 사례: 함수의 반환 타입을 변수 타입으로 재사용

**실무 활용:**
- API 요청과 응답 타입을 Pick/Omit으로 변환하여 코드 중복 제거
- Partial로 업데이트 함수의 파라미터 타입 정의하여 선택적 업데이트 지원
- Record로 열거형 값을 키로 하는 매핑 객체 타입 정의

---

## 질문 68: TypeScript의 never 타입은 언제 사용하나요?

**정의:**
never 타입은 절대 발생하지 않는 값의 타입으로, 함수가 절대 반환하지 않거나 도달할 수 없는 코드를 표현합니다. 타입 시스템에서 불가능한 상황을 나타내며 철저한 타입 체크를 가능하게 합니다.

**특징/원리:**
- 최하위 타입: 모든 타입의 서브타입이지만 never의 서브타입은 never만 존재
- 할당 불가: 어떤 값도 never 타입에 할당할 수 없음
- 빈 Union: never는 Union Type에서 자동으로 제거됨
- 완전성 검사: 모든 경우를 다루었는지 컴파일러가 검증

**never를 반환하는 경우:**
- 예외 발생 함수: 항상 예외를 던지는 함수는 절대 정상 반환하지 않음
- 무한 루프: 무한 루프로 절대 종료되지 않는 함수
- 반환문 없음: 모든 경로에서 예외를 던지거나 무한 루프인 함수

**타입 가드에서의 활용:**
- Exhaustive check: switch 문에서 모든 케이스를 처리했는지 확인
- default 절: default에서 never 타입으로 할당하여 누락된 케이스 감지
- 컴파일 에러: 새로운 케이스가 추가되면 default 절에서 컴파일 에러 발생

**조건부 타입에서의 활용:**
- 타입 필터링: 조건부 타입에서 특정 타입을 제거할 때 never 사용
- 불가능한 타입: 조건을 만족하지 않는 경우 never로 표시

**Union Type과의 관계:**
- 자동 제거: string | never는 자동으로 string으로 단순화
- 교집합: 서로 교집합이 없는 타입의 Intersection은 never
- 유효성: never가 결과로 나오면 타입 정의에 문제가 있음을 시사

**실무 활용:**
- switch 문의 exhaustive check로 모든 Union Type 케이스를 처리했는지 컴파일 타임에 검증
- 에러 처리 유틸리티 함수의 반환 타입을 never로 지정하여 의도 명확화
- 조건부 타입에서 특정 타입을 필터링할 때 never 사용

---
