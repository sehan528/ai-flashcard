# Network 답변 5-8

## 질문 5: HTTP의 특성인 Stateless에 대해 설명해 주세요.

Stateless는 HTTP 프로토콜의 핵심 특성으로, 서버가 클라이언트의 이전 요청에 대한 상태나 정보를 유지하지 않는다는 것을 의미합니다.

각 HTTP 요청은 완전히 독립적으로 처리됩니다. 서버는 요청을 받으면 그 요청에 필요한 모든 정보를 요청 자체에서 얻어야 하며, 이전에 같은 클라이언트로부터 어떤 요청을 받았는지 기억하지 않습니다. 클라이언트가 첫 번째 요청을 보내든 백 번째 요청을 보내든, 서버는 각 요청을 처음 보는 것처럼 처리합니다.

**Stateless의 장점:**

확장성이 뛰어납니다. 서버가 클라이언트 상태를 저장하지 않기 때문에, 요청을 어떤 서버로 보내도 동일하게 처리할 수 있습니다. 로드밸런서를 통해 여러 서버로 트래픽을 분산할 때 특정 클라이언트를 특정 서버로 고정할 필요가 없습니다.

서버의 메모리 부담이 줄어듭니다. 수많은 클라이언트의 상태 정보를 저장하고 관리할 필요가 없어 서버 리소스를 효율적으로 사용할 수 있습니다.

장애 복구가 간단합니다. 서버가 다운되어도 클라이언트는 다른 서버로 요청을 보내면 됩니다. 잃어버린 상태 정보가 없기 때문입니다.

**Stateless의 단점:**

매 요청마다 인증 정보 등 필요한 모든 정보를 전송해야 합니다. 이는 네트워크 오버헤드를 증가시킬 수 있습니다.

연속적인 사용자 경험을 제공하기 어렵습니다. 로그인 상태 유지, 장바구니 관리 등 상태가 필요한 기능을 구현하려면 별도의 메커니즘이 필요합니다.

**실무에서의 대응:**

실제로는 쿠키, 세션, 토큰 등을 사용하여 상태를 관리합니다. 하지만 이는 HTTP 프로토콜 자체가 아닌 애플리케이션 레벨에서 구현되는 것입니다. 쿠키나 JWT 토큰을 매 요청에 포함시켜 서버가 사용자를 식별할 수 있게 합니다.

Stateless는 웹의 성장과 확장에 필수적인 특성이었으며, 분산 시스템과 마이크로서비스 아키텍처의 기반이 됩니다.

## 질문 6: Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

맞습니다. 세션 기반 인증은 엄격한 의미에서 HTTP의 Stateless 원칙에 위배됩니다.

세션 방식은 서버가 사용자의 로그인 상태를 메모리나 데이터베이스에 저장합니다. 클라이언트는 세션 ID만 쿠키로 가지고 있고, 실제 사용자 정보는 서버에 저장됩니다. 이는 서버가 클라이언트의 상태를 유지한다는 점에서 Stateful한 방식입니다.

**세션 방식의 문제점:**

서버 확장이 복잡합니다. 여러 서버가 있을 때 세션 정보를 공유해야 하는데, 이를 위해 세션 클러스터링이나 중앙 세션 저장소(Redis 등)가 필요합니다. 특정 사용자를 항상 같은 서버로 라우팅하는 Sticky Session을 사용할 수도 있지만, 이는 로드밸런싱의 효율성을 떨어뜨립니다.

메모리 부담이 있습니다. 동시 접속자가 많아지면 모든 세션 정보를 저장하기 위한 메모리가 상당히 필요합니다.

서버 재시작 시 세션이 유실될 수 있습니다. 별도의 영속성 메커니즘 없이는 서버가 재시작되면 모든 사용자가 로그아웃됩니다.

**그럼에도 세션이 사용되는 이유:**

보안성이 높습니다. 중요한 정보가 클라이언트에 노출되지 않고 서버에만 저장됩니다. 클라이언트는 의미 없는 세션 ID만 가지고 있어 탈취되어도 서버에서 해당 세션을 무효화할 수 있습니다.

세션 관리가 용이합니다. 서버에서 언제든 세션을 무효화하거나 수정할 수 있어 강제 로그아웃이나 권한 변경이 즉시 반영됩니다.

구현이 간단하고 검증되었습니다. 대부분의 웹 프레임워크가 세션 관리 기능을 기본 제공하며, 오랜 기간 사용되어 안정성이 입증되었습니다.

**현대적 대안:**

JWT(JSON Web Token) 같은 토큰 기반 인증은 더 Stateless에 가깝습니다. 토큰 자체에 사용자 정보가 포함되어 있어 서버가 상태를 저장할 필요가 없습니다. 하지만 토큰 무효화가 어렵고 토큰 크기가 크다는 단점이 있습니다.

실무에서는 서비스의 요구사항에 따라 세션, 토큰, 또는 하이브리드 방식을 선택합니다. 완벽한 Stateless보다는 실용성과 보안성, 확장성 사이의 균형을 찾는 것이 중요합니다.

## 질문 7: 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

서버가 여러 대로 확장되면 세션 관리가 복잡해집니다. 사용자가 첫 번째 요청은 서버 A로, 두 번째 요청은 서버 B로 보낼 때 세션 정보가 없어 로그인이 풀리는 문제가 발생할 수 있습니다. 이를 해결하는 주요 방법들은 다음과 같습니다.

**Sticky Session (Session Affinity):**

로드밸런서가 특정 사용자의 모든 요청을 항상 같은 서버로 전달하는 방식입니다. 일반적으로 사용자의 IP 주소나 세션 ID를 해싱하여 서버를 결정합니다.

장점은 구현이 간단하고 추가 인프라가 필요 없다는 것입니다. 각 서버가 독립적으로 세션을 관리하면 됩니다.

단점은 로드밸런싱이 불균등해질 수 있다는 것입니다. 특정 서버에 트래픽이 몰릴 수 있고, 해당 서버가 다운되면 그 서버의 모든 세션이 유실됩니다. 서버 증설 시 기존 사용자들의 세션이 깨질 수 있습니다.

**Session Clustering:**

여러 서버의 세션을 동기화하여 모든 서버가 같은 세션 정보를 공유하는 방식입니다. WAS(Web Application Server)들이 클러스터를 구성하고 세션 복제를 수행합니다.

장점은 고가용성을 제공한다는 것입니다. 한 서버가 다운되어도 다른 서버에 세션 정보가 있어 서비스가 계속됩니다.

단점은 서버 간 세션 복제 오버헤드가 크다는 것입니다. 네트워크 트래픽이 증가하고, 서버 수가 많아질수록 복제 비용이 기하급수적으로 늘어납니다. 세션 데이터가 크면 성능 저하가 심각할 수 있습니다.

**중앙 세션 저장소:**

가장 일반적이고 권장되는 방식으로, Redis나 Memcached 같은 인메모리 데이터베이스를 중앙 세션 저장소로 사용합니다. 모든 서버가 이 저장소에서 세션을 읽고 씁니다.

장점은 확장성이 뛰어나다는 것입니다. 서버를 추가하거나 제거해도 세션에 영향이 없습니다. 로드밸런싱이 자유롭고, 서버가 다운되어도 세션이 유지됩니다. Redis는 영속성 옵션을 제공하여 Redis 자체가 재시작되어도 세션을 보존할 수 있습니다.

단점은 추가 인프라가 필요하고, 중앙 저장소가 단일 장애점(SPOF)이 될 수 있다는 것입니다. 하지만 Redis Cluster나 Sentinel을 사용하면 고가용성을 확보할 수 있습니다. 네트워크 지연이 약간 추가됩니다.

**토큰 기반 인증으로 전환:**

JWT 같은 토큰을 사용하면 서버가 세션을 저장할 필요가 없습니다. 토큰 자체에 필요한 정보가 들어있어 완전히 Stateless하게 동작합니다.

장점은 서버 확장이 매우 쉽고, 세션 관리 인프라가 필요 없다는 것입니다. 마이크로서비스 환경에 적합합니다.

단점은 토큰 무효화가 어렵다는 것입니다. 토큰이 탈취되면 만료 전까지 막을 방법이 없습니다. 토큰 갱신 전략이 복잡하고, 토큰 크기가 세션 ID보다 훨씬 커서 매 요청마다 오버헤드가 있습니다.

**실무 권장사항:**

대부분의 현대 웹 애플리케이션은 Redis 같은 중앙 세션 저장소를 사용합니다. 구현이 비교적 간단하고, 확장성과 안정성이 검증되었기 때문입니다. Spring Session, Express Session 같은 라이브러리들이 Redis 통합을 기본 지원하여 구현이 쉽습니다.

## 질문 8: HTTP 응답코드에 대해 설명해 주세요.

HTTP 응답코드는 서버가 클라이언트의 요청을 어떻게 처리했는지를 나타내는 세 자리 숫자입니다. 응답코드는 다섯 가지 클래스로 분류됩니다.

**1xx (Informational - 정보 응답):**

요청을 받았으며 프로세스를 계속 진행한다는 의미입니다. 실무에서는 거의 사용되지 않습니다.

100 Continue는 클라이언트가 요청을 계속 전송해도 된다는 의미입니다. 대용량 파일 업로드 시 헤더를 먼저 보내고 100을 받은 후 본문을 전송하는 방식으로 사용됩니다.

101 Switching Protocols는 프로토콜을 전환한다는 의미로, WebSocket 연결 시 HTTP에서 WebSocket으로 업그레이드할 때 사용됩니다.

**2xx (Success - 성공):**

요청이 성공적으로 처리되었음을 나타냅니다.

200 OK는 가장 일반적인 성공 응답으로, 요청이 성공했다는 의미입니다. GET 요청에 대한 리소스 반환, POST 요청의 처리 완료 등에 사용됩니다.

201 Created는 요청이 성공했고 새로운 리소스가 생성되었음을 나타냅니다. POST 요청으로 새 데이터를 생성했을 때 사용하며, Location 헤더로 생성된 리소스의 URI를 전달하는 것이 일반적입니다.

204 No Content는 요청은 성공했지만 응답 본문이 없다는 의미입니다. DELETE 요청이나 업데이트 후 반환할 내용이 없을 때 사용됩니다.

**3xx (Redirection - 리다이렉션):**

클라이언트가 요청을 완료하기 위해 추가 동작이 필요함을 나타냅니다.

301 Moved Permanently는 리소스가 영구적으로 이동했다는 의미입니다. 검색엔진이 새 URL을 색인하고, 브라우저는 새 URL을 북마크합니다.

302 Found는 리소스가 일시적으로 다른 위치에 있다는 의미입니다. 원래 URL로 계속 요청해야 합니다.

304 Not Modified는 캐시된 버전을 사용해도 된다는 의미입니다. 조건부 GET 요청에서 리소스가 변경되지 않았을 때 사용하여 대역폭을 절약합니다.

**4xx (Client Error - 클라이언트 오류):**

클라이언트의 요청에 오류가 있음을 나타냅니다.

400 Bad Request는 잘못된 문법으로 서버가 요청을 이해할 수 없다는 의미입니다. 필수 파라미터 누락, 잘못된 JSON 형식 등에 사용됩니다.

401 Unauthorized는 인증이 필요하다는 의미입니다. 로그인이 필요하거나 인증 토큰이 유효하지 않을 때 사용됩니다.

403 Forbidden은 서버가 요청을 이해했지만 권한이 없어 거부한다는 의미입니다. 인증은 되었지만 해당 리소스에 접근할 권한이 없을 때 사용됩니다.

404 Not Found는 요청한 리소스를 찾을 수 없다는 의미입니다. 존재하지 않는 URL이나 삭제된 리소스에 접근할 때 사용됩니다.

**5xx (Server Error - 서버 오류):**

서버가 유효한 요청을 처리하지 못했음을 나타냅니다.

500 Internal Server Error는 서버에 오류가 발생했다는 일반적인 메시지입니다. 예상치 못한 예외, 데이터베이스 연결 실패 등에 사용됩니다.

502 Bad Gateway는 게이트웨이나 프록시 서버가 업스트림 서버로부터 잘못된 응답을 받았다는 의미입니다. 리버스 프록시 뒤의 애플리케이션 서버가 다운되었을 때 발생합니다.

503 Service Unavailable은 서버가 일시적으로 요청을 처리할 수 없다는 의미입니다. 과부하, 유지보수 등의 상황에서 사용하며, Retry-After 헤더로 재시도 시점을 안내할 수 있습니다.

**적절한 응답코드 선택의 중요성:**

명확한 응답코드는 API 사용자가 오류를 빠르게 이해하고 대응할 수 있게 합니다. 또한 모니터링 시스템이 문제를 정확히 감지하고 분류할 수 있게 하며, RESTful API 설계 원칙을 준수하는 데 필수적입니다.
