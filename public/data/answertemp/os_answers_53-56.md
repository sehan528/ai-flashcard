# OS 답변 53-56

## 53. 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?

**기본 개념**

데드락의 네 가지 필요조건은 모두 동시에 만족되어야 데드락이 발생합니다. 네 가지 조건은 AND 관계이므로, 하나라도 성립하지 않으면 데드락은 절대 발생하지 않습니다.

**상호 배제가 없는 경우**

자원을 여러 프로세스가 동시에 공유할 수 있다면, 대기할 필요가 없으므로 데드락이 발생하지 않습니다. 읽기 전용 파일이나 공유 메모리의 읽기 작업은 여러 프로세스가 동시에 접근할 수 있어서 데드락 위험이 없습니다. 하지만 대부분의 자원은 배타적 사용이 필요하므로 이 조건을 제거하기는 어렵습니다.

**점유와 대기가 없는 경우**

프로세스가 필요한 모든 자원을 한꺼번에 요청하거나, 자원을 보유하지 않은 상태에서만 요청한다면 데드락이 발생하지 않습니다. 예를 들어, 프로세스가 실행 시작 시 모든 필요 자원을 할당받고 시작하거나, 새로운 자원이 필요하면 기존 자원을 모두 해제한 후 요청하는 방식입니다. 하지만 이는 자원 활용률을 낮추고 기아 상태를 유발할 수 있습니다.

**비선점이 없는 경우**

프로세스가 보유한 자원을 강제로 회수할 수 있다면, 순환 대기 상태에서도 시스템이 자원을 재할당하여 데드락을 해결할 수 있습니다. CPU나 메모리는 선점이 가능하지만, 프린터나 데이터베이스 레코드 같은 자원은 선점이 어렵습니다. 선점 시 작업 손실이나 일관성 문제가 발생할 수 있습니다.

**순환 대기가 없는 경우**

자원에 순서를 부여하고 모든 프로세스가 오름차순으로만 자원을 요청하도록 하면, 순환 구조가 형성되지 않아 데드락이 발생하지 않습니다. 예를 들어, 자원 A, B, C에 각각 1, 2, 3의 번호를 부여하고, 프로세스는 항상 낮은 번호부터 높은 번호 순서로만 요청하도록 규칙을 정하면 순환 대기를 방지할 수 있습니다.

**실무 활용**

데이터베이스 시스템은 락 순서를 정의하여 순환 대기를 방지합니다. 멀티스레드 프로그래밍에서는 전역적인 락 순서 규칙을 정하여 데드락을 예방합니다. Java의 tryLock 메서드는 타임아웃을 통해 점유와 대기 조건을 회피합니다. 각 조건을 제거하는 방법마다 trade-off가 있으므로, 시스템 특성에 맞는 전략을 선택해야 합니다.

**효율성 고려**

순환 대기 조건을 제거하는 것이 가장 실용적입니다. 자원 순서 지정은 구현이 간단하고 성능 오버헤드가 적습니다. 상호 배제는 시스템의 기본 요구사항이므로 제거하기 어렵고, 점유와 대기 제거는 자원 낭비를 초래하며, 비선점은 구현 복잡도가 높고 데이터 일관성 문제를 야기합니다.

---

## 54. 어떤 방식으로 예방할 수 있을까요?

**기본 개념**

데드락 예방은 데드락의 네 가지 필요조건 중 최소 하나를 원천적으로 차단하여 데드락이 발생하지 않도록 하는 방법입니다. 시스템 설계 단계에서 적용되는 정적인 접근 방식입니다.

**상호 배제 부정**

자원을 공유 가능하게 만들어 상호 배제를 제거합니다. 읽기 전용 파일은 여러 프로세스가 동시에 접근할 수 있도록 하고, 스풀링 기법을 사용하여 프린터 같은 자원을 가상화합니다. 하지만 본질적으로 배타적 사용이 필요한 자원에는 적용하기 어렵습니다. 쓰기 작업이나 하드웨어 자원은 상호 배제가 필수적이므로 이 방법의 적용 범위는 제한적입니다.

**점유와 대기 부정**

프로세스가 실행 전에 필요한 모든 자원을 한꺼번에 요청하도록 합니다. 모든 자원을 할당받았을 때만 실행을 시작하고, 하나라도 할당받지 못하면 대기합니다. 또는 프로세스가 새로운 자원을 요청할 때 기존에 보유한 모든 자원을 먼저 해제하도록 합니다. 이 방법은 자원 활용률을 낮추고, 필요한 자원을 미리 예측하기 어려우며, 기아 상태를 유발할 수 있습니다.

**비선점 부정**

프로세스가 요청한 자원을 즉시 할당받지 못하면, 현재 보유한 모든 자원을 해제하도록 합니다. 또는 시스템이 우선순위에 따라 자원을 강제로 회수하여 재할당합니다. CPU나 메모리처럼 상태를 저장하고 복원할 수 있는 자원에는 적용 가능하지만, 프린터나 테이프 드라이브처럼 중간 상태를 저장하기 어려운 자원에는 부적합합니다.

**순환 대기 부정**

모든 자원에 고유한 번호를 부여하고, 프로세스는 오름차순으로만 자원을 요청하도록 규칙을 정합니다. 이미 더 높은 번호의 자원을 보유했다면, 낮은 번호의 자원을 요청할 수 없습니다. 이 방법은 구현이 비교적 간단하고 효과적이지만, 자원 사용 순서를 미리 결정해야 하고, 프로그래머가 순서 규칙을 따라야 하는 부담이 있습니다.

**실무 활용**

데이터베이스 시스템은 락 순서 규칙을 정의하여 순환 대기를 방지합니다. 모든 트랜잭션이 테이블 A, B, C 순서로 락을 획득하도록 강제합니다. 운영체제 커널 개발 시 스핀락 획득 순서를 문서화하고 정적 분석 도구로 검증합니다. 멀티스레드 애플리케이션에서는 락 계층 구조를 정의하여 항상 외부 락부터 내부 락 순서로 획득합니다.

**예방의 한계**

데드락 예방은 안전하지만 자원 활용률과 시스템 처리량을 감소시킵니다. 제약이 너무 엄격하여 실용성이 떨어지는 경우가 많습니다. 따라서 현대 시스템은 예방보다는 회피나 탐지 방법을 선호하거나, 데드락을 무시하는 정책을 채택합니다.

---

## 55. 왜 현대 OS는 Deadlock을 처리하지 않을까요?

**기본 개념**

대부분의 현대 운영체제는 데드락을 처리하지 않는 타조 알고리즘을 채택합니다. 데드락이 발생하지 않는 것처럼 가정하고, 발생하면 사용자가 직접 해결하도록 합니다.

**처리 비용 대비 효과**

데드락 예방, 회피, 탐지 모든 방법은 상당한 성능 오버헤드를 발생시킵니다. 예방은 자원 활용률을 크게 낮추고, 회피는 매 자원 요청마다 안전성 검사를 수행해야 하며, 탐지는 주기적으로 자원 할당 그래프를 검사해야 합니다. 하지만 실제로 데드락은 매우 드물게 발생하므로, 거의 발생하지 않는 문제를 위해 시스템 전체 성능을 희생하는 것은 비효율적입니다.

**복잡성과 구현 어려움**

현대 시스템은 매우 복잡하고 다양한 자원이 존재합니다. 파일, 소켓, 세마포어, 뮤텍스, 데이터베이스 연결 등 모든 자원에 대해 데드락을 관리하는 것은 구현이 매우 어렵습니다. 또한 분산 시스템이나 멀티스레드 환경에서 전역적인 데드락 탐지는 거의 불가능에 가깝습니다.

**애플리케이션 레벨 책임**

현대 운영체제는 데드락 처리를 애플리케이션 개발자의 책임으로 위임합니다. 데이터베이스, 웹 서버, 미들웨어 등 각 애플리케이션이 자신의 도메인에 맞는 데드락 처리 전략을 구현하는 것이 더 효과적입니다. 운영체제는 기본적인 동기화 도구만 제공하고, 올바른 사용은 프로그래머의 책임입니다.

**타임아웃과 재시작**

데드락이 발생하면 사용자가 프로세스를 강제 종료하거나 시스템을 재시작합니다. 프로세스 모니터링 도구나 워치독 타이머를 사용하여 무응답 상태를 감지하고 자동으로 재시작하는 방식도 사용됩니다. 이는 완벽한 해결책은 아니지만, 구현이 간단하고 대부분의 경우 충분히 동작합니다.

**특정 도메인의 별도 처리**

데이터베이스 시스템은 트랜잭션 레벨에서 데드락을 탐지하고 롤백합니다. 이는 데이터베이스 자체가 자원과 트랜잭션을 완벽히 제어할 수 있기 때문입니다. Java 같은 고수준 언어는 타임아웃 기반 락 획득을 지원하여 데드락을 회피합니다. 각 도메인이 자체적으로 데드락을 처리하는 것이 운영체제 레벨 처리보다 효율적입니다.

**실무 관점**

리눅스, 윈도우, macOS 모두 데드락 처리 메커니즘을 제공하지 않습니다. 대신 개발자가 락 순서 규칙, 타임아웃, tryLock 같은 기법을 사용하여 데드락을 방지하도록 권장합니다. 시스템 전체의 성능과 단순성을 유지하는 것이 드문 데드락을 처리하는 것보다 중요하다고 판단한 결과입니다.

---

## 56. Wait Free와 Lock Free를 비교해 주세요.

**기본 개념**

Wait Free와 Lock Free는 락을 사용하지 않고도 동기화를 달성하는 비블로킹 알고리즘입니다. 두 방식 모두 전통적인 락 기반 동기화의 문제점을 해결하지만, 보장하는 진행 조건이 다릅니다.

**Lock Free의 정의**

Lock Free 알고리즘은 시스템 전체적으로 항상 어떤 스레드는 진행을 한다는 것을 보장합니다. 일부 스레드가 지연되더라도, 적어도 하나의 스레드는 유한한 시간 내에 작업을 완료합니다. CAS 같은 원자적 연산을 사용하여 구현되며, 재시도 루프를 통해 경쟁 상황을 처리합니다. 개별 스레드는 기아 상태에 빠질 수 있지만, 시스템 전체는 항상 진행됩니다.

**Wait Free의 정의**

Wait Free 알고리즘은 모든 스레드가 유한한 시간 내에 작업을 완료하는 것을 보장합니다. 어떤 스레드도 무한정 대기하지 않으며, 각 스레드는 독립적으로 진행할 수 있습니다. 모든 연산이 정해진 단계 내에 완료되며, 다른 스레드의 상태와 무관합니다. Lock Free보다 더 강한 보장을 제공하지만 구현이 훨씬 어렵습니다.

**성능과 공정성**

Lock Free는 구현이 비교적 간단하고 성능이 우수하지만, 스레드 간 공정성을 보장하지 않습니다. 경쟁이 심한 상황에서 일부 스레드가 계속 재시도하여 기아 상태에 빠질 수 있습니다. Wait Free는 모든 스레드에 공정성을 보장하므로 예측 가능한 성능을 제공하지만, 복잡한 알고리즘으로 인해 평균 성능은 Lock Free보다 낮을 수 있습니다.

**구현 복잡도**

Lock Free 자료구조는 CAS 연산과 재시도 루프를 사용하여 구현할 수 있습니다. 예를 들어, Lock Free 스택이나 큐는 비교적 간단하게 구현 가능합니다. Wait Free 알고리즘은 모든 스레드의 진행을 보장하기 위해 복잡한 협력 메커니즘이 필요하며, 헬퍼 메커니즘이나 복잡한 상태 관리가 필요합니다. 많은 경우 Wait Free 구현은 이론적으로만 존재하고 실용적이지 않습니다.

**실무 활용**

Java의 ConcurrentLinkedQueue는 Lock Free로 구현되어 있으며, CAS 연산을 활용합니다. AtomicInteger나 AtomicReference 같은 원자적 변수는 Wait Free 연산을 제공합니다. C++의 atomic 라이브러리도 Wait Free 연산을 지원합니다. 고성능 시스템에서는 Lock Free 자료구조를 사용하여 락 경쟁을 제거하고 확장성을 향상시킵니다.

**선택 기준**

대부분의 실무 시스템은 Lock Free 알고리즘을 선호합니다. Wait Free의 강한 보장이 필요한 경우는 드물며, 구현 복잡도와 성능 trade-off를 고려하면 Lock Free가 더 실용적입니다. 실시간 시스템이나 최악의 경우 지연 시간이 중요한 경우에만 Wait Free를 고려합니다. 대부분의 애플리케이션은 전통적인 락 기반 동기화만으로도 충분합니다.
