## 질문 69: TypeScript의 컴파일 과정과 설정 옵션을 설명해주세요.

**정의:**
TypeScript 컴파일러(tsc)는 TypeScript 코드를 JavaScript로 변환하는 과정을 수행하며, tsconfig.json 파일로 컴파일 옵션을 설정합니다. 컴파일 과정에서 타입 검사를 수행하고, 최신 JavaScript 문법을 구 버전으로 변환하며, 모듈 시스템을 처리합니다.

**특징/원리:**
- 타입 제거: 컴파일 결과물에는 타입 정보가 포함되지 않고 순수 JavaScript만 출력
- 다운레벨링: 최신 ES 문법을 구버전 JavaScript로 변환하여 호환성 확보
- 타입 검사: 컴파일 시 타입 오류를 검출하여 런타임 전에 문제 발견
- 증분 컴파일: 변경된 파일만 다시 컴파일하여 빌드 시간 단축

**컴파일 과정:**
- 파싱: TypeScript 파일을 읽어 AST(Abstract Syntax Tree) 생성
- 타입 검사: AST를 분석하여 타입 오류 검출 및 타입 추론 수행
- 변환: AST를 JavaScript AST로 변환하고 타입 정보 제거
- 생성: JavaScript AST로부터 JavaScript 코드와 선언 파일 생성
- 방출: 컴파일 결과물을 파일로 출력

**주요 컴파일러 옵션:**
- target: 출력 JavaScript 버전 지정 (ES5, ES6, ES2020 등)
- module: 모듈 시스템 지정 (CommonJS, ES2015, ESNext 등)
- lib: 컴파일에 포함할 라이브러리 파일 지정
- outDir: 출력 파일이 생성될 디렉토리 지정
- rootDir: 입력 파일의 루트 디렉토리 지정
- sourceMap: 디버깅을 위한 소스맵 파일 생성 여부

**엄격성 옵션:**
- strict: 모든 엄격한 타입 검사 옵션 활성화
- noImplicitAny: 암묵적 any 타입 사용 시 오류 발생
- strictNullChecks: null과 undefined를 명시적으로 처리하도록 강제
- strictFunctionTypes: 함수 타입의 매개변수를 더 엄격하게 검사
- noUnusedLocals: 사용하지 않는 지역 변수 시 오류
- noUnusedParameters: 사용하지 않는 매개변수 시 오류

**모듈 해석 옵션:**
- moduleResolution: 모듈 해석 전략 (node, classic)
- baseUrl: 비상대적 모듈 이름을 해석할 기준 디렉토리
- paths: 모듈 이름을 경로로 매핑하는 패턴
- esModuleInterop: CommonJS 모듈을 ES 모듈처럼 import 가능하게 함

**실무 활용:**
- strict 모드를 활성화하여 타입 안전성 최대화
- 프로젝트 루트에 tsconfig.json을 배치하여 팀 전체가 일관된 설정 사용
- incremental 옵션으로 증분 컴파일 활성화하여 빌드 속도 향상

---

## 질문 70: TypeScript의 데코레이터(Decorator)에 대해 설명해주세요.

**정의:**
데코레이터는 클래스, 메서드, 프로퍼티, 매개변수에 메타데이터를 추가하거나 동작을 수정하는 특수한 선언입니다. @ 기호로 시작하며, 실험적 기능으로 tsconfig.json에서 experimentalDecorators를 활성화해야 사용할 수 있습니다.

**특징/원리:**
- 선언적 메타프로그래밍: 코드에 메타데이터를 선언적으로 추가
- 관심사 분리: 핵심 로직과 부가 기능을 분리하여 코드 간결화
- 재사용성: 공통 패턴을 데코레이터로 추출하여 여러 곳에서 재사용
- 실행 시점: 클래스 정의 시점에 실행되며 런타임 동작 수정

**데코레이터 종류:**
- 클래스 데코레이터: 클래스 전체에 적용되며 생성자 함수를 인자로 받음
- 메서드 데코레이터: 메서드에 적용되며 메서드의 프로퍼티 디스크립터 수정 가능
- 프로퍼티 데코레이터: 프로퍼티에 적용되며 메타데이터 추가
- 매개변수 데코레이터: 메서드 매개변수에 적용되며 주로 메타데이터 기록
- 접근자 데코레이터: getter/setter에 적용되며 프로퍼티 디스크립터 수정

**데코레이터 팩토리:**
- 함수 반환: 데코레이터 팩토리는 데코레이터 함수를 반환하는 함수
- 매개변수화: 팩토리에 인자를 전달하여 동작을 커스터마이징
- 유연성: 같은 데코레이터를 다른 설정으로 재사용 가능

**적용 순서:**
- 인스턴스 멤버: 프로퍼티 → 접근자 → 매개변수 → 메서드
- 정적 멤버: 프로퍼티 → 접근자 → 매개변수 → 메서드
- 생성자: 매개변수 → 클래스
- 여러 데코레이터: 아래에서 위로 평가하고 위에서 아래로 실행

**주요 사용 사례:**
- 로깅: 메서드 실행 전후로 로그 기록
- 검증: 메서드 매개변수 유효성 검사
- 권한: 메서드 실행 전 권한 확인
- 캐싱: 메서드 결과를 캐시하여 재사용
- 의존성 주입: 클래스에 의존성 자동 주입

**실무 활용:**
- NestJS에서 @Controller, @Get, @Post 등의 데코레이터로 라우팅 정의
- Angular에서 @Component, @Injectable 등으로 의존성 주입 설정
- TypeORM에서 @Entity, @Column 등으로 데이터베이스 매핑 선언

---

## 질문 71: Python의 메모리 관리 방식을 설명해주세요.

**정의:**
Python은 자동 메모리 관리를 제공하며, 참조 카운팅과 가비지 컬렉션을 결합하여 메모리를 관리합니다. 모든 객체는 힙에 할당되고, 참조 카운트가 0이 되면 즉시 메모리가 해제되며, 순환 참조는 가비지 컬렉터가 처리합니다.

**특징/원리:**
- 동적 할당: 모든 객체가 힙 메모리에 동적으로 할당됨
- 자동 관리: 개발자가 명시적으로 메모리를 할당하거나 해제할 필요 없음
- 참조 카운팅: 각 객체는 자신을 참조하는 개수를 추적
- 가비지 컬렉션: 순환 참조를 감지하고 제거하는 GC 제공

**참조 카운팅:**
- 카운트 증가: 변수에 할당, 리스트에 추가, 함수 인자로 전달 시 증가
- 카운트 감소: 변수가 스코프를 벗어남, del로 삭제, 컨테이너에서 제거 시 감소
- 즉시 해제: 참조 카운트가 0이 되면 즉시 메모리 해제
- 오버헤드: 모든 참조 변경 시 카운트 업데이트 필요

**가비지 컬렉션:**
- 순환 참조 처리: 참조 카운팅으로 처리 못하는 순환 참조 객체 수집
- 세대별 수집: 객체를 0세대, 1세대, 2세대로 분류하여 효율적으로 수집
- 임계값: 각 세대마다 GC를 트리거하는 임계값 존재
- gc 모듈: 가비지 컬렉션을 수동으로 제어하거나 통계 확인 가능

**메모리 할당 전략:**
- 작은 객체: 전용 메모리 풀(arena)에서 빠르게 할당
- 큰 객체: 시스템의 malloc을 직접 호출하여 할당
- 객체 재사용: 작은 정수, 빈 튜플 등 자주 사용되는 객체는 캐싱하여 재사용
- 메모리 단편화: 메모리 풀 방식으로 단편화 최소화

**인터닝과 캐싱:**
- 문자열 인터닝: 동일한 문자열 리터럴은 하나의 객체로 공유
- 작은 정수: -5부터 256까지 정수는 미리 생성되어 재사용
- 싱글톤: None, True, False는 싱글톤 객체

**실무 활용:**
- 순환 참조를 피하기 위해 weakref 모듈 사용
- 메모리 누수 의심 시 gc 모듈로 수집되지 않는 객체 추적
- 대용량 데이터 처리 시 제너레이터로 메모리 사용량 최소화

---

## 질문 72: Python의 GIL(Global Interpreter Lock)이란 무엇인가요?

**정의:**
GIL은 CPython 인터프리터에서 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있도록 하는 뮤텍스 잠금입니다. 멀티스레드 프로그램에서 여러 스레드가 있어도 실제로는 동시에 하나의 스레드만 실행되어 CPU-bound 작업에서는 병렬 처리 효과가 없습니다.

**특징/원리:**
- 뮤텍스 잠금: 전역적인 하나의 락으로 Python 객체 접근 보호
- 단일 실행: 여러 스레드가 있어도 한 시점에 하나만 바이트코드 실행 가능
- 메모리 안전성: 참조 카운팅 기반 메모리 관리를 스레드 안전하게 보호
- CPython 특징: Jython, IronPython 등 다른 구현체는 GIL이 없음

**GIL의 장점:**
- 구현 단순성: C 확장 모듈 작성과 인터프리터 구현이 단순해짐
- 빠른 단일 스레드: 단일 스레드 프로그램은 락 오버헤드가 적어 빠름
- 참조 카운팅 보호: 복잡한 동기화 없이 메모리 관리를 스레드 안전하게 유지
- C 라이브러리 통합: 스레드 안전하지 않은 C 라이브러리도 안전하게 사용

**GIL의 단점:**
- CPU-bound 제약: CPU 집약적 작업은 멀티스레딩으로 성능 향상 불가
- 멀티코어 미활용: 여러 CPU 코어가 있어도 하나만 사용
- 경쟁 조건: 스레드 전환 시 GIL을 획득하려는 경쟁으로 성능 저하 가능
- 병렬 처리 제한: 진정한 병렬 실행이 필요하면 다른 방법 필요

**GIL 우회 방법:**
- Multiprocessing: 별도 프로세스로 실행하여 각각 독립적인 GIL 보유
- C 확장: NumPy, Pandas 등 C로 작성된 라이브러리는 GIL을 해제하고 병렬 실행
- 비동기 IO: asyncio로 I/O-bound 작업을 동시에 처리
- Jython, IronPython: GIL이 없는 다른 Python 구현체 사용

**I/O-bound vs CPU-bound:**
- I/O-bound: 네트워크, 파일 I/O 등은 GIL을 해제하므로 멀티스레딩 효과적
- CPU-bound: 계산 집약적 작업은 multiprocessing 사용 필요
- 혼합 작업: I/O와 CPU 작업이 섞인 경우 적절한 방법 선택 필요

**실무 활용:**
- 웹 크롤링이나 API 호출 등 I/O-bound 작업은 멀티스레딩으로 처리
- 데이터 분석이나 머신러닝 같은 CPU-bound 작업은 multiprocessing 또는 NumPy 활용
- 비동기 웹 서버는 asyncio로 많은 동시 연결 처리

---
