# JavaScript 답변 45-48

## 질문 45: Iterator와 Iterable의 차이점은 무엇인가요?

**정의:**
Iterable은 순회 가능한 객체를 의미하며 Symbol.iterator 메서드를 가집니다. Iterator는 실제 순회를 수행하는 객체로 next 메서드를 가집니다.

**Iterable의 특징:**
- Symbol.iterator 메서드를 구현합니다. 이 메서드는 Iterator를 반환합니다.
- for-of 루프에서 사용할 수 있습니다.
- 스프레드 연산자와 구조 분해 할당이 가능합니다.
- Array, String, Map, Set 등이 기본적으로 iterable입니다.

**Iterator의 특징:**
- next 메서드를 가집니다. 이 메서드는 value와 done을 가진 객체를 반환합니다.
- value는 현재 값입니다.
- done은 순회 완료 여부를 나타내는 불리언입니다.
- 순회 상태를 내부적으로 관리합니다.

**동작 방식:**
- Iterable 객체의 Symbol.iterator를 호출하면 Iterator를 얻습니다.
- Iterator의 next를 반복 호출하여 값을 가져옵니다.
- done이 true가 될 때까지 반복합니다.
- for-of는 이 과정을 자동화합니다.

**커스텀 Iterable 구현:**
- 객체에 Symbol.iterator 메서드를 추가합니다.
- 이 메서드는 next 메서드를 가진 객체를 반환해야 합니다.
- next는 value와 done을 반환해야 합니다.
- 이를 통해 커스텀 순회 로직을 만들 수 있습니다.

**Iterable 프로토콜의 이점:**
- 통일된 인터페이스로 다양한 컬렉션을 다룰 수 있습니다.
- for-of, 스프레드, 구조 분해 등 다양한 문법을 사용할 수 있습니다.
- 지연 평가가 가능합니다. Generator와 결합하여 효율적입니다.
- 무한 시퀀스도 표현할 수 있습니다.

**Iterator와 Generator:**
- Generator 함수는 자동으로 Iterator를 생성합니다.
- yield로 간단히 Iterator를 구현할 수 있습니다.
- 수동으로 next를 구현하는 것보다 편리합니다.

**실무 활용:**
- 커스텀 컬렉션 클래스를 만들 때 Iterable을 구현합니다.
- 데이터 스트림을 표현할 때 활용합니다.
- 페이지네이션 API 결과를 순회 가능하게 만듭니다.
- 복잡한 데이터 구조를 for-of로 순회할 수 있게 합니다.
- Generator로 간단히 Iterable을 만들어 사용합니다.

---

## 질문 46: WeakMap과 WeakSet은 언제 사용하나요?

**정의:**
WeakMap과 WeakSet은 약한 참조를 사용하는 특수한 컬렉션입니다. 키로 사용된 객체가 다른 곳에서 참조되지 않으면 자동으로 가비지 컬렉션됩니다.

**WeakMap의 특징:**
- 키는 반드시 객체여야 합니다. 원시 값은 사용할 수 없습니다.
- 약한 참조를 사용합니다. 키 객체가 GC 대상이 되면 엔트리도 제거됩니다.
- 열거할 수 없습니다. keys, values, entries 메서드가 없습니다.
- 크기를 알 수 없습니다. size 프로퍼티가 없습니다.
- get, set, has, delete 메서드만 제공합니다.

**WeakSet의 특징:**
- 값은 반드시 객체여야 합니다.
- 약한 참조를 사용합니다.
- 열거할 수 없습니다.
- add, has, delete 메서드만 제공합니다.
- 중복을 허용하지 않습니다.

**약한 참조의 의미:**
- 일반 참조는 객체가 GC되는 것을 방지합니다.
- 약한 참조는 GC를 방해하지 않습니다.
- 다른 참조가 없으면 객체가 메모리에서 제거됩니다.
- WeakMap/WeakSet의 엔트리도 함께 사라집니다.

**메모리 누수 방지:**
- DOM 노드를 키로 사용할 때 유용합니다. 노드가 제거되면 자동으로 정리됩니다.
- 이벤트 리스너나 데이터를 저장할 때 메모리 누수를 방지합니다.
- 순환 참조 문제를 해결할 수 있습니다.

**WeakMap 사용 사례:**
- private 데이터 저장: 객체의 private 속성을 외부에 저장합니다.
- 메타데이터 연결: 객체에 추가 정보를 붙입니다. 원본 객체를 변경하지 않습니다.
- 캐싱: 객체를 키로 하는 캐시를 만듭니다. 객체가 제거되면 캐시도 자동 정리됩니다.
- DOM 노드 데이터: 노드와 연관된 데이터를 저장합니다.

**WeakSet 사용 사례:**
- 객체 추적: 특정 객체들의 집합을 유지합니다.
- 이미 처리한 객체 표시: 중복 처리를 방지합니다.
- 메서드 호출 제한: 특정 객체에서만 메서드를 호출할 수 있게 합니다.

**Map/Set과의 선택:**
- 키나 값이 원시 값이면 Map/Set을 사용합니다.
- 열거가 필요하면 Map/Set을 사용합니다.
- 자동 정리가 필요하고 객체만 다루면 WeakMap/WeakSet을 사용합니다.
- 메모리 관리가 중요하면 WeakMap/WeakSet을 고려합니다.

**실무 활용:**
- React에서 컴포넌트 인스턴스와 데이터를 연결할 때 사용합니다.
- 캐시 시스템에서 메모리 누수를 방지합니다.
- DOM 조작 라이브러리에서 요소와 데이터를 매핑합니다.
- 객체 풀이나 플라이웨이트 패턴을 구현합니다.
- 디버깅이 어려울 수 있으므로 신중하게 사용합니다.

---

## 질문 47: 원시 타입(Primitive Type)과 참조 타입(Reference Type)의 차이점은 무엇인가요?

**정의:**
원시 타입은 불변의 기본 데이터 타입으로 값 자체가 저장됩니다. 참조 타입은 객체로 메모리 주소가 저장되며 가변적입니다.

**원시 타입의 특징:**
- 값이 직접 저장됩니다. 변수에 실제 값이 담깁니다.
- 불변입니다. 값 자체를 변경할 수 없습니다.
- 스택 메모리에 저장됩니다. 접근이 빠릅니다.
- 복사 시 값이 복사됩니다. 독립적인 값이 생성됩니다.
- Number, String, Boolean, null, undefined, Symbol, BigInt가 있습니다.

**참조 타입의 특징:**
- 메모리 주소가 저장됩니다. 변수는 실제 데이터의 위치를 가리킵니다.
- 가변입니다. 내부 속성을 변경할 수 있습니다.
- 힙 메모리에 저장됩니다. 스택에는 참조만 저장됩니다.
- 복사 시 참조가 복사됩니다. 같은 객체를 가리킵니다.
- Object, Array, Function, Date, RegExp 등이 있습니다.

**값 비교의 차이:**
- 원시 타입: 값 자체를 비교합니다. 같은 값이면 true입니다.
- 참조 타입: 참조를 비교합니다. 같은 객체를 가리켜야 true입니다.
- 내용이 같아도 참조가 다르면 false입니다.

**복사 동작의 차이:**
- 원시 타입: 값이 복사되어 독립적입니다. 한쪽을 변경해도 다른 쪽에 영향이 없습니다.
- 참조 타입: 참조가 복사되어 같은 객체를 가리킵니다. 한쪽에서 변경하면 다른 쪽도 변경됩니다.
- 참조 타입의 독립적인 복사는 명시적으로 해야 합니다.

**함수 인수 전달:**
- 원시 타입: 값이 전달됩니다. 함수 내부에서 변경해도 원본에 영향이 없습니다.
- 참조 타입: 참조가 전달됩니다. 함수 내부에서 변경하면 원본도 변경됩니다.
- JavaScript는 항상 값으로 전달하지만 참조 타입은 참조 값이 전달됩니다.

**메모리 관리:**
- 원시 타입: 스택에서 자동 관리됩니다. 스코프를 벗어나면 즉시 제거됩니다.
- 참조 타입: 힙에 저장되고 가비지 컬렉션으로 관리됩니다. 참조가 없어질 때 제거됩니다.
- 참조 타입은 메모리 누수의 원인이 될 수 있습니다.

**래퍼 객체:**
- 원시 타입도 메서드를 호출할 수 있습니다. 임시로 래퍼 객체가 생성됩니다.
- String, Number, Boolean 생성자가 래퍼 역할을 합니다.
- 메서드 호출 후 래퍼 객체는 제거됩니다.
- new로 생성하면 참조 타입 래퍼 객체가 됩니다.

**실무에서의 이해:**
- 상태 관리 시 원시 타입과 참조 타입을 구분해야 합니다.
- React의 state 업데이트에서 중요합니다. 참조가 바뀌어야 리렌더링됩니다.
- 깊은 비교와 얕은 비교의 차이를 이해해야 합니다.
- 함수에 객체를 전달할 때 원본 변경 여부를 고려해야 합니다.
- 성능 최적화 시 메모리 특성을 활용할 수 있습니다.

---

## 질문 48: 타입 변환(Type Coercion)과 명시적 변환의 차이점은 무엇인가요?

**정의:**
타입 변환은 값을 다른 타입으로 바꾸는 과정입니다. 암묵적 변환은 JavaScript가 자동으로 수행하고, 명시적 변환은 개발자가 의도적으로 수행합니다.

**암묵적 타입 변환:**
- 자동으로 발생합니다. 연산자나 컨텍스트에 따라 변환됩니다.
- 예측하기 어려울 수 있습니다. 의도하지 않은 결과를 낳을 수 있습니다.
- 문자열 연결, 산술 연산, 불리언 컨텍스트 등에서 발생합니다.
- 코드가 간결해지지만 명확성이 떨어집니다.

**명시적 타입 변환:**
- 개발자가 명시적으로 변환합니다. 의도가 명확합니다.
- 변환 함수나 생성자를 사용합니다. Number, String, Boolean 등입니다.
- 예측 가능하고 안전합니다.
- 코드 가독성이 향상됩니다.

**문자열 변환:**
- 암묵적: 더하기 연산자로 자동 변환됩니다. 숫자와 문자열을 더하면 문자열이 됩니다.
- 명시적: String 함수나 toString 메서드를 사용합니다.
- 템플릿 리터럴도 명시적 변환입니다.

**숫자 변환:**
- 암묵적: 산술 연산자가 숫자로 변환합니다. 더하기 제외한 연산자는 숫자로 변환합니다.
- 명시적: Number 함수나 parseInt, parseFloat을 사용합니다.
- 단항 플러스 연산자도 숫자로 변환하지만 명시적이지 않아 권장되지 않습니다.

**불리언 변환:**
- 암묵적: 조건문이나 논리 연산자가 불리언으로 변환합니다.
- 명시적: Boolean 함수나 이중 부정 연산자를 사용합니다.
- Falsy 값은 false로, 나머지는 true로 변환됩니다.

**Falsy 값:**
- false, 0, 음수 0, 빈 문자열, null, undefined, NaN이 falsy입니다.
- 이외의 모든 값은 truthy입니다.
- 빈 객체와 빈 배열도 truthy입니다.

**동등 연산자의 타입 변환:**
- 이중 등호는 타입을 변환한 후 비교합니다. 예측하기 어렵습니다.
- 삼중 등호는 타입 변환 없이 비교합니다. 항상 사용이 권장됩니다.
- 이중 등호의 변환 규칙은 복잡하고 일관성이 없습니다.

**parseInt와 Number의 차이:**
- parseInt는 문자열을 파싱합니다. 숫자로 시작하면 그 부분까지만 변환합니다.
- Number는 전체를 변환합니다. 일부만 숫자면 NaN을 반환합니다.
- parseInt는 진법을 지정할 수 있습니다.

**실무 권장사항:**
- 항상 명시적 변환을 사용합니다. 의도를 명확히 합니다.
- 암묵적 변환에 의존하지 않습니다. 예상치 못한 버그를 방지합니다.
- 삼중 등호를 기본으로 사용합니다.
- TypeScript로 타입 안전성을 강화할 수 있습니다.
- ESLint 규칙으로 암묵적 변환을 경고할 수 있습니다.

---
