## 질문 85: Python의 다중 상속과 MRO(Method Resolution Order)에 대해 설명해주세요.

**정의:**
Python은 다중 상속을 지원하여 클래스가 여러 부모 클래스를 상속받을 수 있습니다. MRO는 메서드를 찾을 때 클래스 계층을 탐색하는 순서를 정의하며, C3 Linearization 알고리즘을 사용하여 일관성 있고 예측 가능한 순서를 보장합니다.

**특징/원리:**
- 다이아몬드 문제: 여러 경로로 같은 부모를 상속받을 때 발생하는 문제
- C3 알고리즘: Python 3의 MRO는 C3 Linearization으로 계산되어 일관성 보장
- 왼쪽 우선: 상속 목록에서 왼쪽 클래스가 오른쪽보다 우선순위 높음
- 깊이 우선: 부모 클래스보다 자식 클래스가 우선순위 높음

**MRO 규칙:**
- 자식 우선: 메서드는 자식 클래스에서 먼저 찾음
- 왼쪽에서 오른쪽: 상속 목록 순서대로 탐색
- 일관성: 부모의 MRO 순서를 위반하지 않음
- object: 모든 클래스의 최상위 부모인 object가 마지막

**MRO 확인:**
- Class.__mro__: 튜플 형태로 MRO 순서 반환
- Class.mro(): 리스트 형태로 MRO 순서 반환
- super(): MRO 순서에 따라 다음 클래스의 메서드 호출

**super() 함수:**
- 동작: MRO에서 현재 클래스 다음 클래스의 메서드 호출
- 협력적 다중 상속: 모든 부모의 __init__()을 호출하기 위해 super() 사용
- 매개변수 전달: super().__init__()으로 부모 생성자에 인자 전달

**다이아몬드 문제 해결:**
- C3 알고리즘: 일관된 순서로 탐색하여 같은 부모를 한 번만 방문
- 명시적 호출: super() 대신 부모 클래스를 명시적으로 호출하면 여러 번 호출 가능
- 설계: 가능하면 다이아몬드 상속 구조를 피하고 단순하게 설계

**실무 활용:**
- 믹스인 클래스로 기능을 조합하여 다양한 클래스 생성
- super()를 사용하여 모든 부모 클래스의 초기화 메서드를 올바르게 호출
- __mro__를 확인하여 다중 상속 구조를 디버깅하고 이해

---

## 질문 86: Python의 추상 클래스(ABC)와 인터페이스 구현 방법은 무엇인가요?

**정의:**
추상 클래스는 인스턴스를 직접 생성할 수 없고 서브클래스에서 추상 메서드를 구현하도록 강제하는 클래스입니다. abc 모듈의 ABC 클래스와 @abstractmethod 데코레이터를 사용하여 정의하며, 인터페이스와 유사한 역할을 합니다.

**특징/원리:**
- 인스턴스 생성 불가: 추상 메서드가 있는 클래스는 직접 인스턴스화 불가
- 강제 구현: 서브클래스가 모든 추상 메서드를 구현해야 인스턴스 생성 가능
- 부분 구현: 추상 클래스는 일반 메서드와 추상 메서드를 모두 가질 수 있음
- 타입 체크: isinstance()와 issubclass()로 추상 클래스 확인 가능

**abc 모듈:**
- ABC: 추상 클래스의 기반 클래스
- ABCMeta: 추상 클래스의 메타클래스
- @abstractmethod: 추상 메서드를 정의하는 데코레이터
- @abstractproperty: 추상 프로퍼티 정의 (deprecated, @property와 @abstractmethod 조합 사용)

**추상 메서드:**
- 선언: @abstractmethod 데코레이터로 메서드 선언
- 구현 없음: 메서드 본문은 pass나 NotImplementedError
- 다중 데코레이터: @classmethod, @staticmethod와 함께 사용 가능하며 @abstractmethod가 가장 안쪽
- 구현 강제: 서브클래스에서 반드시 구현해야 인스턴스 생성 가능

**인터페이스 패턴:**
- 순수 인터페이스: 모든 메서드가 추상 메서드인 추상 클래스
- 프로토콜: typing 모듈의 Protocol로 구조적 서브타이핑 구현
- 덕 타이핑: 명시적 상속 없이도 같은 인터페이스를 구현하면 호환

**가상 서브클래스:**
- register(): ABC.register()로 클래스를 가상 서브클래스로 등록
- isinstance 통과: 등록된 클래스는 isinstance 검사를 통과하지만 메서드 구현 강제 안 됨
- 덕 타이핑 지원: 실제 상속 없이도 타입 호환성 표현

**실무 활용:**
- 플러그인 시스템에서 추상 기반 클래스로 인터페이스 정의
- 템플릿 메서드 패턴으로 알고리즘 구조를 정의하고 세부 단계는 서브클래스에서 구현
- 타입 힌트와 함께 사용하여 명확한 계약 정의하고 정적 분석 도구 활용

---

## 질문 87: Python의 Duck Typing이란 무엇인가요?

**정의:**
Duck Typing은 객체의 타입보다는 객체가 특정 메서드나 속성을 가지고 있는지로 판단하는 동적 타이핑 방식입니다. "오리처럼 걷고 오리처럼 울면 오리다"라는 철학으로, 명시적 타입이나 상속 관계보다 실제 동작을 중시합니다.

**특징/원리:**
- 인터페이스 기반: 객체가 어떤 클래스인지보다 어떤 메서드를 제공하는지가 중요
- 런타임 검사: 컴파일 타임이 아닌 실행 시점에 메서드 존재 여부 확인
- 유연성: 명시적 상속 없이도 같은 인터페이스를 구현하면 호환 가능
- EAFP: "허락보다 용서가 쉽다" 원칙으로 일단 시도하고 예외 처리

**장점:**
- 느슨한 결합: 구체적인 타입에 의존하지 않아 결합도 낮음
- 재사용성: 다양한 타입의 객체를 동일하게 처리 가능
- 간결성: 타입 체크나 변환 코드가 필요 없어 코드가 간결
- 프로토타입 기반: 프로토타이핑과 빠른 개발에 유리

**단점:**
- 런타임 에러: 타입 불일치가 런타임에 발견되어 디버깅 어려움
- 문서 필요: 어떤 메서드가 필요한지 명시적이지 않아 문서화 중요
- IDE 지원: 정적 타입이 아니라 자동완성이나 리팩토링 지원 제한적
- 예측 어려움: 코드만 보고 어떤 타입이 전달될지 예측 어려움

**Duck Typing vs Static Typing:**
- Duck Typing: 유연하고 간결하지만 런타임 에러 가능
- Static Typing: 안전하고 예측 가능하지만 보일러플레이트 증가
- 타입 힌트: Python 3.5+에서 타입 힌트로 두 방식의 장점 결합 가능

**EAFP vs LBYL:**
- EAFP: Easier to Ask for Forgiveness than Permission, 일단 시도하고 예외 처리
- LBYL: Look Before You Leap, 미리 조건 확인 후 실행
- Pythonic: EAFP가 더 Pythonic한 스타일로 권장됨

**실무 활용:**
- 파일 유사 객체를 받는 함수에서 실제 파일인지 StringIO인지 구분하지 않고 read() 메서드만 호출
- 이터러블을 기대하는 함수에 리스트, 튜플, 제너레이터 등 다양한 타입 전달 가능
- 타입 힌트와 Protocol을 사용하여 Duck Typing의 유연성과 정적 분석의 안전성 결합

---

## 질문 88: Python의 타입 힌팅(Type Hinting)과 정적 타입 체커(mypy)에 대해 설명해주세요.

**정의:**
타입 힌팅은 Python 3.5+에서 도입된 기능으로 변수, 함수 파라미터, 반환값의 타입을 주석으로 표시합니다. mypy는 타입 힌트를 분석하여 컴파일 타임에 타입 오류를 검출하는 정적 타입 체커로, 런타임 전에 타입 관련 버그를 발견합니다.

**특징/원리:**
- 선택적: 타입 힌트는 선택 사항이며 런타임 동작에 영향 없음
- 점진적 타이핑: 기존 코드에 점진적으로 타입 힌트 추가 가능
- 정적 분석: mypy 같은 도구로 타입 검사를 수행하여 오류 사전 발견
- 문서화: 타입 힌트 자체가 함수의 인터페이스를 명확히 문서화

**기본 타입 힌트:**
- 변수: x: int = 5 형태로 변수의 타입 명시
- 함수 파라미터: def func(name: str, age: int) 형태로 파라미터 타입 명시
- 반환값: def func() -> str 형태로 반환 타입 명시
- 내장 타입: int, str, float, bool, list, dict, tuple 등 사용

**typing 모듈:**
- List, Dict, Tuple: 제네릭 타입으로 요소의 타입까지 명시
- Optional: None이 될 수 있는 타입, Optional[int]는 int | None과 동일
- Union: 여러 타입 중 하나, Union[int, str]은 int 또는 str
- Callable: 함수 타입, Callable[[int, str], bool]은 int와 str를 받아 bool 반환
- TypeVar: 제네릭 타입 변수 정의
- Protocol: 구조적 서브타이핑 지원

**mypy:**
- 설치: pip install mypy로 설치
- 실행: mypy script.py로 타입 검사 수행
- 설정: mypy.ini나 pyproject.toml로 검사 옵션 설정
- 점진적: --ignore-missing-imports로 타입 힌트 없는 라이브러리 무시

**고급 타입:**
- Generic: 제네릭 클래스나 함수 정의
- Literal: 특정 값으로 제한된 타입
- Final: 재할당 불가능한 상수 표시
- TypedDict: 딕셔너리의 키와 값 타입을 명시
- Annotated: 타입에 메타데이터 추가

**실무 활용:**
- 대규모 프로젝트에서 타입 힌트로 인터페이스를 명확히 하고 리팩토링 안전성 향상
- mypy를 CI/CD 파이프라인에 통합하여 타입 오류를 자동으로 검출
- IDE의 자동완성과 타입 체크 기능을 활용하여 개발 생산성 향상

---
