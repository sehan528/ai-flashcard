# OS 답변 117-120

## 117. I-Node가 무엇인가요?

**기본 개념**

I-Node는 Index Node의 약자로, 유닉스 계열 파일 시스템에서 파일의 메타데이터를 저장하는 자료구조입니다. 파일 내용을 제외한 파일에 관한 모든 정보를 담고 있습니다.

**I-Node의 구성 요소**

파일 유형과 권한 정보를 저장합니다. 일반 파일, 디렉토리, 심볼릭 링크, 디바이스 파일 등을 구분합니다. 소유자 UID와 그룹 GID를 기록합니다. 파일 크기를 바이트 단위로 저장합니다. 접근 시간, 수정 시간, 상태 변경 시간의 타임스탬프를 포함합니다. 하드 링크 카운트로 파일을 가리키는 디렉토리 엔트리 수를 추적합니다.

**블록 포인터**

I-Node는 파일 데이터가 저장된 블록을 가리키는 포인터를 가집니다. 직접 포인터는 데이터 블록을 직접 가리킵니다. 일반적으로 12개의 직접 포인터가 있어서 작은 파일을 효율적으로 저장합니다. 간접 포인터는 포인터들의 블록을 가리킵니다. 이중 간접과 삼중 간접 포인터로 매우 큰 파일도 지원합니다. 이 계층 구조로 다양한 파일 크기를 효율적으로 관리합니다.

**I-Node 번호**

각 I-Node는 고유한 번호로 식별됩니다. 파일 시스템 내에서 I-Node 번호는 유일하며, 파일의 실제 식별자입니다. 디렉토리는 파일 이름과 I-Node 번호의 매핑을 저장합니다. ls -i 명령으로 파일의 I-Node 번호를 확인할 수 있습니다. 같은 I-Node를 가진 파일은 하드 링크로 연결된 같은 파일입니다.

**I-Node와 파일 이름의 분리**

I-Node는 파일 이름을 저장하지 않습니다. 이름은 디렉토리 엔트리에만 존재합니다. 이 분리로 하드 링크가 가능합니다. 여러 디렉토리 엔트리가 같은 I-Node를 가리킬 수 있습니다. 파일 이름 변경은 디렉토리 엔트리만 수정하고, I-Node는 변경하지 않습니다. 이는 효율적이고 빠른 rename을 가능하게 합니다.

**I-Node 할당**

파일 생성 시 빈 I-Node를 할당받습니다. I-Node 테이블에서 사용 가능한 엔트리를 찾아 초기화합니다. 비트맵이나 리스트로 빈 I-Node를 추적합니다. I-Node 수는 파일 시스템 생성 시 결정되며, 이후 변경할 수 없습니다. I-Node가 고갈되면 디스크 공간이 남아도 새 파일을 만들 수 없습니다.

**확장 속성과 ACL**

현대 파일 시스템은 I-Node를 확장하여 추가 정보를 저장합니다. 확장 속성으로 임의의 키-값 쌍을 파일에 연결할 수 있습니다. ACL로 세밀한 권한 제어를 제공합니다. SELinux 레이블 같은 보안 컨텍스트도 저장됩니다. 확장 정보는 I-Node 내부 또는 별도 블록에 저장됩니다.

**I-Node 캐시**

자주 접근되는 I-Node는 메모리에 캐시됩니다. 디스크 읽기를 줄여 성능을 향상시킵니다. 열린 파일의 I-Node는 항상 캐시에 유지됩니다. LRU 정책으로 캐시를 관리하며, 메모리 압력 시 오래된 것을 제거합니다. Dirty I-Node는 주기적으로 또는 sync 시 디스크에 기록됩니다.

**실무 활용**

stat 시스템 콜로 I-Node 정보를 조회할 수 있습니다. find 명령은 -inum 옵션으로 I-Node 번호로 파일을 찾습니다. 백업 도구는 I-Node를 비교하여 하드 링크를 감지합니다. 파일 시스템 복구 도구는 I-Node 테이블을 스캔하여 손상을 복구합니다. I-Node는 유닉스 파일 시스템의 핵심 개념이며, 파일 관리의 기초입니다.

---

## 118. 프로그래밍 언어 상에서 제공하는 파일 관련 함수는, 파일을 어떤 방식으로 읽어들이나요?

**기본 개념**

프로그래밍 언어의 파일 함수는 운영체제의 시스템 콜을 래핑하여 버퍼링과 편의 기능을 추가합니다. 내부적으로 파일 디스크립터를 사용하며, 효율성을 위해 버퍼를 관리합니다.

**시스템 콜 래핑**

Python의 open, Java의 FileReader, C의 fopen은 모두 내부적으로 운영체제의 open 시스템 콜을 호출합니다. 파일 디스크립터를 받아 파일 객체나 스트림으로 래핑합니다. read/write 함수는 시스템 콜 read/write를 호출하여 실제 I/O를 수행합니다. 언어 라이브러리는 추상화 계층을 제공하여 플랫폼 차이를 숨깁니다.

**버퍼링**

직접 시스템 콜을 호출하면 작은 I/O마다 커널 전환 오버헤드가 발생합니다. 언어 라이브러리는 사용자 공간 버퍼를 유지하여 I/O를 모읍니다. 읽기 시 큰 블록을 한 번에 읽어 버퍼에 저장하고, 작은 요청은 버퍼에서 충족합니다. 쓰기도 버퍼에 모았다가 가득 차거나 flush 시 한 번에 씁니다. 이는 시스템 콜 횟수를 크게 줄여 성능을 향상시킵니다.

**버퍼 크기와 정책**

기본 버퍼 크기는 일반적으로 4KB나 8KB입니다. 사용자가 setvbuf로 버퍼 크기와 모드를 변경할 수 있습니다. 전체 버퍼링은 버퍼가 가득 찰 때 플러시합니다. 라인 버퍼링은 개행 문자마다 플러시하며, 터미널 I/O에 적합합니다. 무버퍼링은 즉시 시스템 콜을 호출하여 지연 없이 I/O합니다.

**텍스트 vs 바이너리 모드**

텍스트 모드는 플랫폼별 개행 문자를 자동 변환합니다. 윈도우의 CRLF를 LF로, 또는 그 반대로 변환합니다. 인코딩 변환도 수행하여 유니코드를 처리합니다. 바이너리 모드는 변환 없이 그대로 읽고 씁니다. 이미지, 실행 파일, 압축 파일은 바이너리 모드로 열어야 합니다.

**고급 기능**

언어 라이브러리는 readline, readlines 같은 편의 함수를 제공합니다. with 문이나 try-with-resources로 자동 자원 관리를 지원합니다. 파일이 스코프를 벗어나면 자동으로 닫힙니다. 예외 처리와 에러 메시지를 추상화하여 사용하기 쉽게 합니다. 인코딩 지정, 줄 종결자 설정 등 다양한 옵션을 제공합니다.

**메모리 맵 파일**

큰 파일이나 랜덤 접근이 많은 경우 mmap을 사용할 수 있습니다. 파일을 메모리에 매핑하여 메모리 접근처럼 파일을 읽고 씁니다. 운영체제가 페이징으로 필요한 부분만 메모리에 적재합니다. 여러 프로세스가 같은 매핑을 공유할 수 있습니다. Python의 mmap, Java의 MappedByteBuffer가 이를 제공합니다.

**비동기 I/O**

전통적인 read/write는 블로킹 방식입니다. I/O 완료까지 스레드가 대기합니다. 비동기 I/O는 I/O를 시작하고 즉시 반환하여, 완료 통지를 나중에 받습니다. Node.js의 fs 모듈, Python의 asyncio, Java의 AsynchronousFileChannel이 지원합니다. 많은 파일을 병렬로 처리할 때 효율적입니다.

**실무 패턴**

작은 파일은 한 번에 읽어 메모리에 저장합니다. 큰 파일은 스트리밍으로 처리하여 메모리 사용을 최소화합니다. 로그 파일은 라인 단위로 읽어 처리합니다. 바이너리 프로토콜은 구조체 언팩으로 파싱합니다. 파일 I/O는 프로그래밍의 기본이며, 언어 라이브러리가 효율성과 편의성을 제공합니다.

---

## 119. 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요.

**기본 개념**

동기와 비동기는 작업 완료 통지 방식의 차이이고, 블로킹과 논블로킹은 호출 즉시 제어권 반환 여부의 차이입니다. 두 축은 독립적이며, 네 가지 조합이 가능합니다.

**동기 vs 비동기**

동기는 작업 요청 후 완료될 때까지 기다리는 방식입니다. 순차적으로 실행되며, 한 작업이 끝나야 다음이 시작됩니다. 프로그램 흐름이 단순하고 이해하기 쉽지만, 대기 시간에 자원이 낭비될 수 있습니다. 비동기는 작업 요청 후 완료를 기다리지 않고 다른 일을 합니다. 콜백, 프로미스, 퓨처로 완료 시 통지받습니다. 병렬 처리가 가능하고 효율적이지만, 프로그램 흐름이 복잡해집니다.

**블로킹 vs 논블로킹**

블로킹은 함수 호출 시 결과가 나올 때까지 제어권을 반환하지 않습니다. 호출한 스레드는 대기 상태가 됩니다. 구현이 간단하지만, 대기 중 CPU를 사용할 수 없습니다. 논블로킹은 함수 호출 시 즉시 제어권을 반환합니다. 작업이 완료되지 않았어도 진행 상황이나 에러를 반환합니다. 호출자는 다른 작업을 수행하거나 주기적으로 재시도할 수 있습니다.

**동기 + 블로킹**

가장 전통적인 방식으로, 함수를 호출하고 완료까지 대기합니다. read 시스템 콜이 데이터를 읽을 때까지 블로킹됩니다. 프로그램 흐름이 직관적이고 디버깅이 쉽습니다. 하지만 I/O 대기 시간에 스레드가 유휴 상태입니다. 멀티스레드로 보완할 수 있지만, 스레드 오버헤드가 있습니다.

**동기 + 논블로킹**

함수가 즉시 반환하지만, 완료 여부를 호출자가 확인합니다. 폴링 방식으로 반복 확인하거나, 준비될 때까지 다른 작업을 합니다. select나 poll로 여러 FD의 준비 상태를 확인합니다. CPU를 낭비하지 않지만, 구현이 복잡하고 응답성이 폴링 주기에 의존합니다.

**비동기 + 논블로킹**

작업을 요청하고 즉시 반환받으며, 완료 시 콜백이나 이벤트로 통지받습니다. 가장 효율적이고 확장성이 높은 방식입니다. Node.js의 이벤트 루프, epoll, io_uring이 이를 구현합니다. 하나의 스레드로 수천 개의 연결을 처리할 수 있습니다. 하지만 콜백 헬이나 복잡한 흐름 제어 문제가 있습니다.

**비동기 + 블로킹**

이론적으로 가능하지만 실용성이 떨어집니다. 비동기로 요청했는데 완료 통지를 블로킹으로 기다립니다. 비동기의 이점을 살리지 못하고 복잡도만 증가합니다. 일부 특수한 경우에만 의미가 있습니다. 예를 들어, 비동기 I/O를 시작하고 잠시 후 블로킹으로 결과를 기다릴 수 있습니다.

**실무 선택**

간단한 스크립트는 동기 블로킹으로 충분합니다. 고성능 서버는 비동기 논블로킹으로 구현합니다. I/O 멀티플렉싱으로 여러 연결을 효율적으로 처리합니다. async/await 문법으로 비동기 코드를 동기처럼 작성하여 가독성을 높입니다. 요구사항과 언어 특성에 맞는 모델을 선택해야 합니다.

**현대 프레임워크**

Node.js는 비동기 논블로킹 기반입니다. Python asyncio, Java NIO, .NET async/await도 지원합니다. Reactor와 Proactor 패턴으로 이벤트 기반 프로그래밍을 구조화합니다. 동기 코드의 단순성과 비동기의 효율성을 결합하려는 노력이 계속됩니다.

---

## 120. 그렇다면, 동기이면서 논블로킹이고, 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?

**기본 개념**

동기+논블로킹과 비동기+블로킹은 덜 일반적이지만, 특정 상황에서 의미와 사용 사례가 있습니다. 각각의 특성과 실용성을 이해하면 적절히 활용할 수 있습니다.

**동기 + 논블로킹의 의미**

함수가 즉시 반환하지만, 호출자가 완료 여부를 직접 확인해야 합니다. 작업이 완료되지 않았으면 진행 상태나 에러를 반환합니다. 호출자는 폴링하거나 다른 일을 하다가 재시도합니다. 제어권은 즉시 돌아오지만, 완료 통지는 명시적 확인으로만 얻습니다.

**동기 + 논블로킹의 사용 사례**

I/O 멀티플렉싱이 대표적입니다. select, poll, epoll로 여러 파일 디스크립터의 준비 상태를 확인합니다. 각 FD의 read/write는 논블로킹이지만, 준비된 것만 처리하는 동기 방식입니다. 게임 루프에서 입력을 논블로킹으로 확인하고, 없으면 렌더링을 계속합니다. 사용자 인터페이스가 블로킹되지 않고 응답성을 유지합니다.

**동기 + 논블로킹의 장점**

단일 스레드로 여러 I/O를 처리할 수 있습니다. 스레드 오버헤드와 동기화 문제를 피합니다. 제어 흐름이 비교적 단순하고 예측 가능합니다. 비동기보다 디버깅이 쉬우며, 블로킹보다 효율적입니다. CPU 집약적 작업과 I/O를 혼합할 때 유용합니다.

**비동기 + 블로킹의 의미**

작업을 비동기로 시작하지만, 완료 통지를 블로킹으로 기다립니다. 논리적으로 모순되어 보이지만, 구현 세부사항에서 발생할 수 있습니다. 비동기 API를 호출하고, 즉시 또는 짧은 시간 후 블로킹으로 결과를 기다립니다.

**비동기 + 블로킹의 사례**

비동기 I/O를 시작하고 잠시 다른 작업을 한 후, 블로킹으로 완료를 기다립니다. 타임아웃과 함께 사용하여, 일정 시간 내 완료를 보장합니다. 복잡한 레거시 코드에서 비동기와 블로킹을 혼용할 때 의도치 않게 발생합니다. select나 epoll 자체는 블로킹하지만, I/O는 비동기로 진행됩니다.

**비동기 + 블로킹의 문제점**

비동기의 장점을 살리지 못합니다. 논블로킹 특성이 없어서 대기 중 다른 작업을 할 수 없습니다. 복잡도만 증가하고 성능 이득이 적습니다. 대부분의 경우 설계 실수이거나, 더 나은 대안이 있습니다. 명시적으로 사용하기보다 프레임워크 내부에서 발생합니다.

**실용적 관점**

동기+논블로킹은 의미 있고 널리 사용됩니다. epoll 기반 서버, 게임 루프, 실시간 시스템에서 흔합니다. 비동기+블로킹은 피해야 할 패턴이지만, 특정 상황에서 불가피하게 나타납니다. 예를 들어, 비동기 작업의 최종 결과를 블로킹으로 기다리는 경우입니다.

**조합의 유연성**

네 가지 조합을 이해하면 상황에 맞는 전략을 선택할 수 있습니다. 동기+블로킹은 단순성, 비동기+논블로킹은 성능, 동기+논블로킹은 균형을 제공합니다. 비동기+블로킹은 대부분 피하지만, 완전히 무의미하지는 않습니다. 각 조합의 trade-off를 이해하고 적절히 활용하는 것이 중요합니다.

**결론**

동기+논블로킹은 실용적이고 의미 있는 패턴입니다. I/O 멀티플렉싱의 기반이며, 효율성과 단순성을 균형있게 제공합니다. 비동기+블로킹은 일반적으로 권장되지 않지만, 완전히 무의미하지는 않으며 특수 상황에서 사용될 수 있습니다. 개념을 명확히 이해하면 올바른 I/O 전략을 선택할 수 있습니다.
