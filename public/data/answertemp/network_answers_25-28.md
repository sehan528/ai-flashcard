# Network 답변 모음 (25-28)

## 25. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?

**HTTP/1.1**과 **HTTP/2**는 웹 통신 프로토콜의 서로 다른 버전으로, 성능과 효율성 면에서 큰 차이가 있습니다.

**연결 처리 방식:**
- **HTTP/1.1**: 한 번에 하나의 요청만 처리하거나, 파이프라이닝을 사용해도 응답 순서가 보장되어야 합니다
- **HTTP/2**: 멀티플렉싱으로 하나의 연결에서 여러 요청/응답을 동시에 처리합니다

**멀티플렉싱:**
- **HTTP/1.1**: 여러 리소스를 동시에 받으려면 여러 TCP 연결을 생성해야 합니다
- **HTTP/2**: 단일 TCP 연결 내에서 여러 스트림을 병렬로 처리하여 효율적입니다

**헤더 압축:**
- **HTTP/1.1**: 모든 요청마다 중복된 헤더를 텍스트 형태로 전송합니다
- **HTTP/2**: HPACK 압축을 사용하여 헤더 크기를 대폭 줄입니다. 이전에 보낸 헤더를 참조하여 변경된 부분만 전송합니다

**데이터 형식:**
- **HTTP/1.1**: 텍스트 기반 프로토콜로 사람이 읽을 수 있습니다
- **HTTP/2**: 바이너리 프레이밍으로 파싱이 빠르고 오류가 적습니다

**서버 푸시:**
- **HTTP/1.1**: 클라이언트가 요청한 리소스만 응답합니다
- **HTTP/2**: 서버가 클라이언트 요청 전에 필요할 것으로 예상되는 리소스를 미리 전송할 수 있습니다

**우선순위 지정:**
- **HTTP/1.1**: 요청 순서에 따라 처리됩니다
- **HTTP/2**: 각 스트림에 우선순위와 의존성을 부여하여 중요한 리소스를 먼저 전달합니다

**도메인 샤딩의 필요성:**
- **HTTP/1.1**: 브라우저의 동시 연결 제한을 우회하기 위해 여러 도메인 사용이 권장됩니다
- **HTTP/2**: 단일 연결로 충분하므로 도메인 샤딩이 오히려 성능을 저하시킬 수 있습니다

**리소스 인라이닝:**
- **HTTP/1.1**: 작은 CSS/JS를 HTML에 직접 포함하여 요청 수를 줄입니다
- **HTTP/2**: 멀티플렉싱으로 요청이 저렴하므로 파일을 분리하는 것이 캐싱에 유리합니다

**HOL Blocking:**
- **HTTP/1.1**: 애플리케이션 레벨에서 HOL Blocking 발생 (앞선 응답을 기다려야 함)
- **HTTP/2**: 애플리케이션 레벨 HOL Blocking은 해결했지만, TCP 레벨 HOL Blocking은 여전히 존재합니다

**성능 개선 효과:**
페이지 로딩 속도가 15-50% 향상되며, 특히 지연 시간이 큰 네트워크에서 효과가 큽니다. 헤더 압축으로 모바일 환경에서 데이터 사용량도 감소합니다.

---

## 26. HOL Blocking 에 대해 설명해 주세요.

**HOL Blocking(Head-of-Line Blocking)**은 순차적 처리가 필요한 시스템에서 앞선 작업이 지연되어 뒤따르는 모든 작업이 대기하게 되는 현상입니다.

**HTTP/1.1의 HOL Blocking:**
HTTP/1.1에서는 하나의 TCP 연결에서 요청을 순차적으로 처리합니다. 첫 번째 응답이 완료되기 전까지 두 번째 응답은 대기해야 합니다.

**파이프라이닝의 한계:**
HTTP/1.1 파이프라이닝은 여러 요청을 순차적으로 보낼 수 있지만, 응답은 요청 순서대로 받아야 합니다. 첫 번째 응답이 지연되면 이미 준비된 두 번째 응답도 대기해야 합니다.

**문제점:**
큰 이미지 파일 하나가 로딩되는 동안 작은 CSS 파일들이 모두 대기하게 되어 전체 페이지 로딩이 느려집니다.

**HTTP/1.1의 해결 방법:**
- **다중 연결**: 브라우저가 도메인당 6-8개의 병렬 연결을 생성합니다
- **도메인 샤딩**: 여러 도메인을 사용하여 더 많은 병렬 연결을 확보합니다
- **한계**: 연결 수가 많아지면 메모리와 CPU 오버헤드가 증가합니다

**HTTP/2의 개선:**
HTTP/2는 멀티플렉싱을 통해 애플리케이션 계층의 HOL Blocking을 해결했습니다. 하나의 연결에서 여러 스트림이 독립적으로 동작하여 하나의 응답 지연이 다른 응답에 영향을 주지 않습니다.

**TCP 레벨 HOL Blocking:**
HTTP/2도 TCP를 사용하므로 전송 계층의 HOL Blocking은 여전히 존재합니다. TCP는 패킷 손실 시 재전송을 기다려야 하며, 이는 모든 스트림에 영향을 줍니다.

**TCP HOL Blocking의 메커니즘:**
TCP는 순서 보장을 위해 패킷을 순차적으로 전달합니다. 중간 패킷이 손실되면 이후 도착한 패킷들이 버퍼에 쌓여 대기하게 됩니다. 이는 서로 무관한 HTTP/2 스트림에도 영향을 미칩니다.

**실제 영향:**
패킷 손실률이 2%인 네트워크에서 HTTP/2가 HTTP/1.1보다 느릴 수 있습니다. 손실된 패킷 하나가 모든 스트림을 지연시키기 때문입니다.

**HTTP/3의 해결책:**
HTTP/3는 UDP 기반의 QUIC 프로토콜을 사용하여 스트림 레벨에서 독립적인 재전송을 구현합니다. 하나의 스트림에서 패킷 손실이 발생해도 다른 스트림은 영향을 받지 않습니다.

**QUIC의 접근 방식:**
각 스트림이 독립적인 순서 보장과 재전송 메커니즘을 가지므로, 완전히 HOL Blocking을 해결합니다.

**실무적 고려사항:**
네트워크 품질이 좋은 환경에서는 HTTP/2가 충분하지만, 패킷 손실이 잦은 모바일 환경에서는 HTTP/3가 더 나은 성능을 보입니다.

---

## 27. HTTP/3.0의 주요 특징에 대해 설명해 주세요.

**HTTP/3**는 UDP 기반의 QUIC 프로토콜을 사용하는 차세대 HTTP 프로토콜입니다.

**QUIC 프로토콜 사용:**
TCP 대신 UDP 위에 구현된 QUIC을 전송 프로토콜로 사용합니다. QUIC은 TCP의 신뢰성과 UDP의 속도를 결합한 프로토콜입니다.

**HOL Blocking 완전 해결:**
스트림별 독립적인 전송으로 하나의 스트림에서 패킷 손실이 발생해도 다른 스트림은 영향을 받지 않습니다. TCP의 HOL Blocking 문제를 근본적으로 해결했습니다.

**연결 수립 속도 개선:**
- **0-RTT 재연결**: 이전에 연결했던 서버라면 핸드셰이크 없이 즉시 데이터 전송이 가능합니다
- **1-RTT 초기 연결**: 처음 연결 시에도 TLS 핸드셰이크와 전송 계층 핸드셰이크를 결합하여 1-RTT만 필요합니다
- **TCP+TLS**: 기존에는 3-RTT(TCP 핸드셰이크 + TLS 핸드셰이크)가 필요했습니다

**연결 마이그레이션:**
Connection ID를 사용하여 IP 주소나 포트가 변경되어도 연결이 유지됩니다. Wi-Fi에서 모바일 네트워크로 전환될 때도 연결이 끊어지지 않습니다.

**내장된 암호화:**
QUIC은 기본적으로 TLS 1.3 암호화를 포함하고 있어 별도의 암호화 계층이 필요 없습니다. 모든 QUIC 연결은 암호화되어 보안이 강화됩니다.

**향상된 혼잡 제어:**
QUIC은 더 정확한 RTT 측정과 ACK 피드백을 제공하여 네트워크 상태에 더 빠르게 적응합니다. 패킷 손실 감지와 회복이 더 효율적입니다.

**유연한 프로토콜 발전:**
QUIC은 사용자 공간에서 구현되어 운영체제 업데이트 없이 프로토콜을 개선할 수 있습니다. TCP는 커널에 구현되어 업데이트가 어렵습니다.

**멀티플렉싱 유지:**
HTTP/2의 멀티플렉싱 기능을 그대로 유지하면서 TCP의 한계를 극복했습니다.

**패킷 번호 공간:**
각 패킷이 고유한 번호를 가져 재전송된 패킷과 원본 패킷을 명확히 구분할 수 있습니다. 이를 통해 RTT 측정이 더 정확해집니다.

**도입 현황:**
구글, 페이스북, 클라우드플레어 등 주요 기업들이 이미 HTTP/3를 지원하고 있습니다. 크롬, 파이어폭스, 사파리 등 주요 브라우저도 지원합니다.

**장점 요약:**
빠른 연결 수립, HOL Blocking 해결, 연결 마이그레이션, 향상된 보안, 모바일 환경 최적화가 주요 장점입니다.

**과제:**
UDP 기반이라 일부 방화벽이나 미들박스에서 차단될 수 있으며, 새로운 프로토콜이라 생태계 성숙도가 아직 발전 중입니다.

---

## 28. TCP와 UDP의 차이에 대해 설명해 주세요.

**TCP(Transmission Control Protocol)**와 **UDP(User Datagram Protocol)**는 전송 계층의 대표적인 프로토콜로, 신뢰성과 성능 면에서 다른 특성을 가집니다.

**연결 방식:**
- **TCP**: 연결 지향형 프로토콜로, 통신 전에 3-way handshake로 연결을 수립합니다
- **UDP**: 비연결형 프로토콜로, 연결 수립 없이 바로 데이터를 전송합니다

**신뢰성:**
- **TCP**: 데이터 전송의 신뢰성을 보장합니다. 손실, 중복, 순서 오류를 모두 처리합니다
- **UDP**: 신뢰성을 보장하지 않습니다. 패킷이 손실되거나 순서가 바뀔 수 있습니다

**순서 보장:**
- **TCP**: 송신한 순서대로 데이터가 수신됨을 보장합니다
- **UDP**: 순서를 보장하지 않으며, 먼저 보낸 패킷이 나중에 도착할 수 있습니다

**속도와 오버헤드:**
- **TCP**: 신뢰성 보장을 위한 메커니즘으로 인해 오버헤드가 크고 상대적으로 느립니다
- **UDP**: 최소한의 오버헤드로 빠른 전송이 가능합니다

**혼잡 제어:**
- **TCP**: 네트워크 상황에 따라 전송 속도를 조절하는 혼잡 제어를 수행합니다
- **UDP**: 혼잡 제어를 하지 않아 네트워크가 혼잡해도 계속 전송합니다

**흐름 제어:**
- **TCP**: 수신자의 처리 능력에 맞춰 전송 속도를 조절합니다
- **UDP**: 흐름 제어를 하지 않습니다

**헤더 크기:**
- **TCP**: 20-60 바이트의 가변 크기 헤더를 가집니다
- **UDP**: 8 바이트의 고정 크기 헤더로 단순합니다

**전송 단위:**
- **TCP**: 바이트 스트림으로 데이터를 처리합니다. 경계가 없습니다
- **UDP**: 데이터그램 단위로 전송하며, 메시지 경계가 보존됩니다

**오류 검출:**
- **TCP**: Checksum으로 오류를 검출하고 재전송으로 복구합니다
- **UDP**: Checksum으로 오류를 검출하지만 복구하지 않습니다

**사용 사례:**
- **TCP**: 웹 브라우징(HTTP/HTTPS), 이메일(SMTP, POP3), 파일 전송(FTP), 원격 접속(SSH)
- **UDP**: 실시간 스트리밍(영상, 음성), DNS 쿼리, 온라인 게임, IoT 센서 데이터

**실시간 성능:**
- **TCP**: 재전송으로 인한 지연이 발생하여 실시간 애플리케이션에 부적합할 수 있습니다
- **UDP**: 낮은 지연 시간으로 실시간 애플리케이션에 적합합니다

**브로드캐스트/멀티캐스트:**
- **TCP**: 일대일 통신만 지원합니다
- **UDP**: 일대다, 다대다 통신을 지원합니다

**선택 기준:**
데이터의 정확성이 중요하고 손실이 허용되지 않으면 TCP를, 속도가 중요하고 일부 손실이 허용되면 UDP를 선택합니다.
