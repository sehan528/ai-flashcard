## 질문 45: this 바인딩의 종류와 동작 원리를 설명해주세요.

**정의:**
this는 함수가 호출될 때 결정되는 특수한 식별자로, 함수가 속한 객체나 실행 컨텍스트를 가리킵니다. JavaScript의 this는 함수 호출 방식에 따라 동적으로 바인딩되며, 명시적으로 바인딩을 변경할 수도 있습니다.

**특징/원리:**
- 동적 바인딩: 함수 정의 시점이 아닌 호출 시점에 this가 결정됨
- 호출 방식 의존: 어떻게 함수를 호출하느냐에 따라 this가 가리키는 대상이 달라짐
- 암묵적 소실: 메서드를 변수에 할당하거나 콜백으로 전달하면 this 바인딩이 소실될 수 있음
- 화살표 함수 예외: 화살표 함수는 this를 바인딩하지 않고 상위 스코프의 this 사용

**this 바인딩 종류:**
- 기본 바인딩: 일반 함수 호출 시 전역 객체(브라우저에서는 window)에 바인딩되며, strict mode에서는 undefined
- 암묵적 바인딩: 객체의 메서드로 호출 시 해당 객체에 바인딩
- 명시적 바인딩: call, apply, bind 메서드로 명시적으로 this를 지정
- new 바인딩: new 키워드로 생성자 함수 호출 시 새로 생성된 객체에 바인딩

**명시적 바인딩 메서드:**
- call: 첫 번째 인자로 this를 지정하고 나머지는 개별 인자로 전달하여 함수 즉시 실행
- apply: call과 유사하지만 인자를 배열로 전달
- bind: this가 고정된 새로운 함수를 반환하며 나중에 호출 가능

**바인딩 우선순위:**
- new 바인딩이 가장 높은 우선순위
- 명시적 바인딩(bind, call, apply)이 그 다음
- 암묵적 바인딩(객체 메서드)이 그 다음
- 기본 바인딩이 가장 낮은 우선순위

**실무 활용:**
- 이벤트 핸들러에서 bind로 this를 고정하여 컴포넌트 메서드를 안전하게 전달
- 배열 메서드의 두 번째 인자로 this를 전달하여 콜백 내에서 원하는 객체 참조
- 화살표 함수를 사용하여 상위 스코프의 this를 자동으로 유지

---

## 질문 46: 화살표 함수와 일반 함수의 차이점은 무엇인가요?

**정의:**
화살표 함수는 ES6에서 도입된 간결한 함수 표현식으로, function 키워드 대신 화살표(=>)를 사용합니다. 일반 함수와는 this 바인딩, arguments 객체, 생성자 사용 등에서 중요한 차이가 있습니다.

**특징/원리:**
- 간결한 문법: function 키워드와 중괄호를 생략할 수 있어 코드가 간결함
- 렉시컬 this: 자신만의 this를 생성하지 않고 상위 스코프의 this를 그대로 사용
- 비생성자: 생성자 함수로 사용할 수 없으며 new 키워드와 함께 사용 불가
- arguments 없음: arguments 객체를 갖지 않으며 rest 파라미터로 대체

**this 바인딩 차이:**
- 일반 함수: 호출 방식에 따라 this가 동적으로 결정됨
- 화살표 함수: 정의될 때 상위 스코프의 this를 캡처하여 고정
- 메서드: 객체 메서드는 일반 함수로 정의해야 객체를 this로 참조 가능
- 콜백: 콜백 함수는 화살표 함수로 정의하면 외부 this를 자연스럽게 유지

**생성자 함수 차이:**
- 일반 함수: new 키워드로 인스턴스 생성 가능하며 prototype 프로퍼티 보유
- 화살표 함수: new로 호출 시 TypeError 발생하며 prototype 프로퍼티 없음
- 메서드 정의: 클래스 메서드나 객체 메서드는 일반 함수로 정의 필요

**arguments 객체:**
- 일반 함수: 모든 인자를 담은 유사 배열 객체인 arguments 제공
- 화살표 함수: arguments가 없으며 상위 함수의 arguments 참조
- rest 파라미터: 화살표 함수에서는 ...args로 가변 인자 처리

**실무 활용:**
- 콜백 함수나 고차 함수의 인자로는 화살표 함수 사용하여 this 문제 해결
- 객체 메서드나 프로토타입 메서드는 일반 함수로 정의하여 올바른 this 바인딩
- React 컴포넌트의 이벤트 핸들러를 화살표 함수로 정의하여 자동 this 바인딩

---

## 질문 47: 프로토타입 체인과 상속에 대해 설명해주세요.

**정의:**
프로토타입 체인은 JavaScript의 상속 메커니즘으로, 객체가 자신에게 없는 프로퍼티나 메서드를 프로토타입 객체에서 찾는 과정입니다. 모든 객체는 [[Prototype]] 내부 슬롯을 가지며 이를 통해 다른 객체를 참조하여 체인을 형성합니다.

**특징/원리:**
- 프로토타입 링크: 모든 객체는 생성 시 프로토타입 객체에 대한 숨겨진 링크를 가짐
- 체인 탐색: 프로퍼티 접근 시 자신에게 없으면 프로토타입 체인을 따라 상위로 검색
- 최상위: 체인의 끝은 Object.prototype이며, 여기에도 없으면 undefined 반환
- 동적 확장: 프로토타입에 프로퍼티를 추가하면 모든 인스턴스에 즉시 반영

**프로토타입 접근:**
- __proto__: 객체의 프로토타입을 가리키는 접근자 프로퍼티이지만 비표준이며 사용 권장되지 않음
- Object.getPrototypeOf: 객체의 프로토타입을 반환하는 표준 메서드
- Object.setPrototypeOf: 객체의 프로토타입을 설정하는 메서드이지만 성능상 권장되지 않음
- prototype 프로퍼티: 생성자 함수만 가지며 new로 생성될 인스턴스의 프로토타입을 가리킴

**생성자 함수와 프로토타입:**
- 생성자 함수: 함수가 생성될 때 자동으로 prototype 프로퍼티가 생성됨
- constructor: 프로토타입 객체는 constructor 프로퍼티로 생성자 함수를 역참조
- 인스턴스 생성: new 키워드로 인스턴스 생성 시 생성자 함수의 prototype이 인스턴스의 프로토타입이 됨
- 메서드 공유: 프로토타입에 정의된 메서드는 모든 인스턴스가 공유하여 메모리 효율적

**프로토타입 상속:**
- 프로토타입 연결: 자식 생성자의 prototype을 부모 인스턴스로 설정하여 상속 구현
- Object.create: 지정한 프로토타입을 가진 새 객체를 생성하는 메서드
- 다중 상속 불가: JavaScript는 단일 프로토타입 체인만 지원하여 다중 상속 불가
- 믹스인 패턴: Object.assign으로 여러 객체의 프로퍼티를 복사하여 다중 상속 효과

**실무 활용:**
- 공통 메서드를 프로토타입에 정의하여 모든 인스턴스가 공유하도록 메모리 최적화
- Object.create로 순수한 프로토타입 상속을 구현하여 깔끔한 객체 계층 구조 생성
- instanceof 연산자로 프로토타입 체인을 검사하여 객체의 타입 확인

---

## 질문 48: ES6 Class 문법과 프로토타입 기반 상속의 차이점은 무엇인가요?

**정의:**
ES6 Class는 프로토타입 기반 상속을 클래스 기반 언어처럼 보이도록 제공하는 문법적 설탕입니다. 내부적으로는 여전히 프로토타입을 사용하지만, 더 직관적이고 명확한 문법으로 객체지향 프로그래밍을 지원합니다.

**특징/원리:**
- 문법적 설탕: 새로운 객체 생성 메커니즘이 아니라 기존 프로토타입 기반 상속의 문법적 개선
- 엄격 모드: 클래스 내부 코드는 자동으로 strict mode로 실행됨
- 호이스팅 차이: 클래스 선언은 호이스팅되지만 초기화는 되지 않아 TDZ 존재
- 명시적 구조: constructor, 메서드, static 메서드 등을 명확하게 구분

**Class 문법 특징:**
- constructor: 인스턴스 생성 및 초기화를 담당하는 특수 메서드로 클래스당 하나만 존재
- 인스턴스 메서드: 프로토타입에 자동으로 추가되며 모든 인스턴스가 공유
- static 메서드: 클래스 자체에 속하며 인스턴스 없이 호출 가능
- getter/setter: get과 set 키워드로 접근자 프로퍼티 정의

**상속 구현:**
- extends: 간단하게 부모 클래스를 상속받을 수 있음
- super: 부모 클래스의 constructor나 메서드를 호출하는 키워드
- 오버라이딩: 부모 메서드와 같은 이름의 메서드를 정의하여 재정의
- 프로토타입 체인: extends는 내부적으로 프로토타입 체인을 올바르게 설정

**프로토타입 방식과의 차이:**
- 가독성: Class 문법이 더 직관적이고 객체지향 언어에 익숙한 개발자가 이해하기 쉬움
- 간결성: 상속 구현이 프로토타입 방식보다 훨씬 간단하고 명확
- 생성자 호출: 클래스는 반드시 new와 함께 호출해야 하며 일반 함수처럼 호출 불가
- super 키워드: 프로토타입 방식에서는 부모 메서드 호출이 복잡하지만 Class는 super로 간단히 처리

**실무 활용:**
- 새로운 코드는 Class 문법을 사용하여 명확하고 유지보수하기 쉬운 코드 작성
- React 컴포넌트를 클래스형으로 작성할 때 extends Component로 상속
- 복잡한 도메인 모델을 클래스 계층 구조로 표현하여 코드 구조화

---
