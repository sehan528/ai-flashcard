## 질문 17: ArrayList와 LinkedList의 차이점과 사용 시나리오는 무엇인가요?

**정의:**
ArrayList와 LinkedList는 모두 List 인터페이스를 구현한 클래스로 순서가 있는 데이터를 저장합니다. ArrayList는 동적 배열을 기반으로 하고, LinkedList는 이중 연결 리스트 구조를 사용하여 내부 구조와 성능 특성이 다릅니다.

**특징/원리:**
- 내부 구조: ArrayList는 연속된 메모리 공간의 배열을 사용하고, LinkedList는 노드들이 포인터로 연결된 구조
- 메모리 사용: ArrayList는 배열만 필요하지만, LinkedList는 각 노드마다 이전/다음 노드 참조를 저장하여 메모리 오버헤드 존재
- 동적 크기 조정: ArrayList는 배열이 가득 차면 새로운 배열을 생성하고 복사하며, LinkedList는 노드 추가만으로 확장
- 인터페이스 구현: LinkedList는 List뿐만 아니라 Queue와 Deque 인터페이스도 구현

**성능 비교:**
- 인덱스 접근: ArrayList는 O(1)로 즉시 접근 가능하지만, LinkedList는 O(n)으로 순차 탐색 필요
- 끝 추가/삭제: 둘 다 O(1)이지만, ArrayList는 배열 확장 시 O(n) 발생 가능
- 중간 삽입/삭제: ArrayList는 O(n)으로 요소 이동 필요, LinkedList는 O(1)이지만 탐색 시간 O(n) 추가
- 메모리: ArrayList가 메모리 효율적이지만 확장 시 여유 공간 필요, LinkedList는 노드당 추가 메모리 필요

**사용 시나리오:**
- ArrayList 적합: 조회가 빈번하고 삽입/삭제가 적은 경우, 인덱스 기반 접근이 많은 경우, 메모리 효율이 중요한 경우
- LinkedList 적합: 중간 삽입/삭제가 빈번한 경우, Queue나 Deque로 사용하는 경우, 순차 접근만 필요한 경우

**실무 활용:**
- 대부분의 경우 ArrayList를 기본으로 사용하며, 특별한 이유가 있을 때만 LinkedList 선택
- 큐 구조가 필요한 경우 ArrayDeque가 LinkedList보다 일반적으로 더 나은 성능 제공
- 빈번한 수정이 필요하면서 동시성 제어가 필요한 경우 CopyOnWriteArrayList 고려

---

## 질문 18: HashMap의 동작 원리와 해시 충돌 해결 방법을 설명해주세요.

**정의:**
HashMap은 키-값 쌍을 저장하는 해시 테이블 기반의 자료구조로, 키의 해시값을 이용하여 빠른 검색, 삽입, 삭제를 제공합니다. 평균적으로 O(1)의 시간 복잡도를 가지지만, 해시 충돌 처리가 성능에 중요한 영향을 미칩니다.

**특징/원리:**
- 해시 함수: 키의 hashCode()를 호출하여 해시값을 계산하고, 이를 배열 인덱스로 변환
- 버킷 구조: 내부적으로 배열을 사용하며 각 배열 요소를 버킷이라 하고, 버킷에는 Entry 객체가 저장
- 동적 크기 조정: 요소 개수가 임계값을 초과하면 배열 크기를 2배로 확장하고 모든 요소를 재배치(rehashing)
- null 허용: 키와 값 모두 null을 허용하며, null 키는 항상 0번 버킷에 저장

**해시 충돌 해결 방법:**
- Separate Chaining: Java 7까지는 연결 리스트로 충돌 처리하여 같은 버킷의 Entry들을 리스트로 연결
- 트리화: Java 8부터는 한 버킷의 요소가 8개 이상이면 연결 리스트를 레드-블랙 트리로 변환하여 O(log n) 성능 보장
- 역트리화: 요소가 6개 이하로 감소하면 다시 연결 리스트로 변환하여 메모리 효율성 향상
- 해시 함수 개선: 상위 비트와 하위 비트를 XOR 연산하여 해시값을 더 고르게 분산

**주요 메서드 동작:**
- put(): 키의 해시값으로 버킷 찾기, 같은 키가 있으면 값 교체, 없으면 새 Entry 추가
- get(): 키의 해시값으로 버킷 찾기, 버킷 내에서 equals()로 키 비교하여 값 반환
- remove(): 키의 해시값으로 버킷 찾기, 해당 Entry 제거
- resize(): 로드 팩터(기본 0.75) 초과 시 배열 크기 확장 및 재해싱 수행

**실무 활용:**
- 빠른 검색이 필요한 캐시 구현이나 인덱싱에 HashMap 활용
- equals()와 hashCode()를 올바르게 구현한 객체를 키로 사용하여 정확한 동작 보장
- 초기 용량과 로드 팩터를 적절히 설정하여 불필요한 rehashing 방지 및 성능 최적화

---

## 질문 19: ConcurrentHashMap의 동작 원리와 HashMap과의 차이점은 무엇인가요?

**정의:**
ConcurrentHashMap은 멀티스레드 환경에서 안전하게 사용할 수 있는 동시성 컬렉션으로, HashMap과 달리 내부적으로 세그먼트 또는 버킷 단위의 잠금을 사용하여 높은 동시성을 제공합니다. Java 8에서 구조가 크게 개선되어 성능이 향상되었습니다.

**특징/원리:**
- 세그먼트 기반 잠금: Java 7까지는 여러 세그먼트로 나누어 각 세그먼트별로 독립적인 잠금 사용
- 버킷 레벨 잠금: Java 8부터는 세그먼트 없이 각 버킷에 CAS와 synchronized를 조합하여 세밀한 동시성 제어
- Non-blocking 읽기: 읽기 작업은 대부분 잠금 없이 수행되어 높은 읽기 성능 제공
- 약한 일관성: 반복자는 fail-fast가 아닌 weakly consistent 정책으로 동작

**HashMap과의 차이점:**
- 동시성 안전: HashMap은 스레드 안전하지 않아 멀티스레드 환경에서 데이터 손상 가능, ConcurrentHashMap은 안전
- null 허용: HashMap은 null 키와 값을 허용하지만, ConcurrentHashMap은 null 허용 안 함
- 성능: 단일 스레드에서는 HashMap이 더 빠르지만, 멀티스레드에서는 ConcurrentHashMap이 훨씬 효율적
- 반복자: HashMap의 반복자는 fail-fast이지만, ConcurrentHashMap은 weakly consistent

**동시성 제어 메커니즘:**
- CAS 연산: Compare-And-Swap을 사용하여 락 없이 원자적 업데이트 수행
- synchronized 블록: 해시 충돌 발생 시 해당 버킷에만 synchronized 적용하여 다른 버킷은 동시 접근 가능
- volatile 변수: 테이블과 주요 필드를 volatile로 선언하여 가시성 보장
- 분할 잠금: 서로 다른 버킷에 대한 작업은 동시에 수행 가능하여 처리량 향상

**실무 활용:**
- 멀티스레드 환경에서 공유되는 캐시나 설정 정보 저장에 ConcurrentHashMap 사용
- Collections.synchronizedMap()보다 훨씬 나은 동시성 성능 제공하므로 우선적으로 고려
- 높은 읽기 비율의 작업에서 뛰어난 성능 발휘하며, putIfAbsent() 등의 원자적 연산 제공

---

## 질문 20: Java의 동기화 방법(synchronized, volatile, Atomic 클래스 등)을 설명해주세요.

**정의:**
Java는 멀티스레드 환경에서 공유 자원에 대한 안전한 접근을 보장하기 위해 다양한 동기화 메커니즘을 제공합니다. synchronized, volatile, Atomic 클래스 등은 각각 다른 수준과 방식으로 동시성 제어를 수행합니다.

**특징/원리:**
- 가시성: 한 스레드의 변경사항이 다른 스레드에게 즉시 보이도록 보장
- 원자성: 작업이 중간에 중단되지 않고 완전히 실행되거나 전혀 실행되지 않도록 보장
- 순서성: 명령어의 재배치를 제한하여 프로그램의 의도된 순서대로 실행 보장
- 성능 트레이드오프: 동기화는 성능 오버헤드를 발생시키므로 필요한 최소 범위에만 적용

**synchronized 키워드:**
- 메서드 또는 블록 단위로 동기화를 제공하며 모니터 락을 사용하여 상호 배제 보장
- 가시성과 원자성을 모두 보장하지만 락 획득/해제로 인한 오버헤드 존재
- 암묵적 락으로 자동으로 획득/해제되어 사용이 간편하지만 유연성은 제한적
- 재진입 가능하여 같은 스레드가 이미 획득한 락을 다시 획득 가능

**volatile 키워드:**
- 변수의 읽기/쓰기를 메인 메모리에서 직접 수행하도록 강제하여 가시성 보장
- 단순 읽기/쓰기에는 원자성 보장하지만 복합 연산(증가, 감소 등)에는 원자성 미보장
- synchronized보다 가볍고 빠르지만 기능이 제한적이어서 플래그나 상태 변수에 적합
- happens-before 관계를 형성하여 메모리 일관성 보장

**Atomic 클래스:**
- AtomicInteger, AtomicLong 등은 CAS 연산을 사용하여 락 없이 원자적 업데이트 제공
- incrementAndGet(), compareAndSet() 등의 메서드로 원자적 복합 연산 지원
- volatile 변수의 가시성과 CAS의 원자성을 결합하여 높은 성능과 안전성 제공
- 경쟁이 심하지 않은 상황에서 synchronized보다 훨씬 빠른 성능

**실무 활용:**
- 단순 플래그나 상태 변수는 volatile 사용하여 가볍게 동기화
- 복합 연산이 필요한 카운터나 누적기는 Atomic 클래스로 락 없는 동시성 제어
- 여러 변수에 대한 일관성 있는 업데이트가 필요하면 synchronized 블록 사용

---
