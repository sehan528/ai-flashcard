# JavaScript 답변 01-04

## 질문 1: JavaScript의 데이터 타입에는 어떤 것들이 있나요?

**정의:**
JavaScript의 데이터 타입은 크게 원시 타입과 참조 타입으로 구분됩니다. 원시 타입은 변경 불가능한 값이며, 참조 타입은 객체를 참조하는 타입입니다.

**원시 타입의 종류:**
- Number: 정수와 실수를 포함한 모든 숫자를 표현합니다. 특수한 값으로 Infinity, NaN이 있습니다.
- String: 텍스트 데이터를 표현하며 따옴표로 감싸서 사용합니다. 불변 값입니다.
- Boolean: 참과 거짓을 나타내는 true와 false 값만 가집니다.
- Undefined: 변수가 선언되었지만 값이 할당되지 않은 상태를 나타냅니다.
- Null: 의도적으로 값이 없음을 명시적으로 나타냅니다.
- Symbol: ES6에서 추가된 타입으로 고유하고 변경 불가능한 값을 생성합니다.
- BigInt: ES2020에서 추가된 타입으로 아주 큰 정수를 안전하게 표현합니다.

**참조 타입의 특징:**
- Object: 키와 값의 쌍으로 이루어진 데이터 구조입니다. Array, Function, Date, RegExp 등이 모두 Object의 하위 타입입니다.
- Array: 순서가 있는 값의 집합으로 인덱스로 접근합니다.
- Function: 실행 가능한 코드 블록으로 일급 객체입니다.

**원시 타입과 참조 타입의 차이:**
- 저장 방식: 원시 타입은 값 자체가 저장되고, 참조 타입은 메모리 주소가 저장됩니다.
- 불변성: 원시 타입은 불변하지만 참조 타입은 가변적입니다.
- 복사 방식: 원시 타입은 값이 복사되고, 참조 타입은 참조가 복사됩니다.

**실무 활용:**
- 타입에 따라 비교 연산과 복사 방식이 달라지므로 이를 이해하고 사용해야 합니다.
- 원시 타입은 스택에 저장되어 빠르지만, 참조 타입은 힙에 저장되어 메모리 관리가 필요합니다.
- typeof 연산자로 타입을 확인할 수 있지만 null은 object로 표시되는 등 주의가 필요합니다.
- 적절한 타입 선택은 메모리 효율성과 코드 안정성에 영향을 미칩니다.

---

## 질문 2: var, let, const의 차이점과 호이스팅에 대해 설명해주세요.

**정의:**
var, let, const는 JavaScript에서 변수를 선언하는 키워드입니다. 각각 스코프, 재선언, 재할당, 호이스팅 동작이 다릅니다.

**var의 특징:**
- 함수 스코프를 가집니다. 블록 스코프를 무시하고 함수 내에서만 유효합니다.
- 재선언이 가능합니다. 같은 이름의 변수를 여러 번 선언할 수 있어 실수를 유발할 수 있습니다.
- 재할당이 가능합니다. 선언 후 값을 변경할 수 있습니다.
- 호이스팅 시 undefined로 초기화됩니다. 선언 전에 접근하면 undefined를 반환합니다.

**let의 특징:**
- 블록 스코프를 가집니다. 중괄호로 감싼 블록 내에서만 유효합니다.
- 재선언이 불가능합니다. 같은 스코프에서 중복 선언 시 에러가 발생합니다.
- 재할당이 가능합니다. 값을 변경할 수 있습니다.
- TDZ가 존재합니다. 선언 전에 접근하면 ReferenceError가 발생합니다.

**const의 특징:**
- 블록 스코프를 가집니다. let과 동일하게 블록 내에서만 유효합니다.
- 재선언이 불가능합니다. 중복 선언 시 에러가 발생합니다.
- 재할당이 불가능합니다. 선언 시 반드시 초기화해야 하며 이후 변경할 수 없습니다.
- 객체나 배열의 경우 참조는 변경할 수 없지만 내부 프로퍼티는 변경 가능합니다.

**호이스팅의 동작:**
- 모든 선언은 해당 스코프의 최상단으로 끌어올려집니다.
- var는 선언과 동시에 undefined로 초기화되어 접근 가능합니다.
- let과 const는 선언만 호이스팅되고 초기화는 실제 선언문에서 이루어져 TDZ가 발생합니다.
- 함수 선언문은 전체가 호이스팅되어 선언 전에도 호출 가능합니다.

**실무 활용:**
- 기본적으로 const를 사용하고 재할당이 필요한 경우에만 let을 사용합니다.
- var는 사용하지 않는 것이 권장됩니다. 예측 불가능한 동작을 방지할 수 있습니다.
- 블록 스코프를 활용하여 변수의 유효 범위를 최소화하면 코드 안정성이 높아집니다.
- 호이스팅을 이해하면 예상치 못한 버그를 방지할 수 있습니다.

---

## 질문 3: 실행 컨텍스트(Execution Context)란 무엇인가요?

**정의:**
실행 컨텍스트는 JavaScript 코드가 실행되는 환경을 의미합니다. 코드 실행에 필요한 모든 정보를 담고 있으며, 변수, 함수, this 등이 어떻게 결정되는지를 정의합니다.

**실행 컨텍스트의 구성 요소:**
- Variable Environment: 변수와 함수 선언을 저장합니다. 초기 상태의 Lexical Environment를 스냅샷으로 가집니다.
- Lexical Environment: 식별자와 참조를 기록합니다. Environment Record와 외부 렉시컬 환경 참조를 포함합니다.
- This Binding: this 값이 결정됩니다. 함수 호출 방식에 따라 달라집니다.

**실행 컨텍스트의 종류:**
- Global Execution Context: 가장 기본이 되는 컨텍스트로 전역 객체와 연결됩니다. 브라우저에서는 window 객체가 됩니다.
- Function Execution Context: 함수가 호출될 때마다 생성됩니다. 각 함수는 자신만의 실행 컨텍스트를 가집니다.
- Eval Execution Context: eval 함수 내부의 코드를 위한 컨텍스트입니다. 보안상 사용이 권장되지 않습니다.

**실행 컨텍스트의 생성 과정:**
- Creation Phase: 컨텍스트를 생성하고 초기화합니다. 변수와 함수 선언이 메모리에 저장되며 호이스팅이 발생합니다. this 바인딩이 결정됩니다.
- Execution Phase: 코드를 한 줄씩 실행합니다. 변수에 실제 값이 할당되고 함수가 호출됩니다.

**실행 컨텍스트 스택:**
- Call Stack에 쌓이며 LIFO 방식으로 관리됩니다.
- 함수 호출 시 새 컨텍스트가 스택에 push되고, 함수 종료 시 pop됩니다.
- 스택의 최상단에 있는 컨텍스트가 현재 실행 중인 컨텍스트입니다.

**실무 활용:**
- 실행 컨텍스트를 이해하면 스코프와 클로저의 동작 원리를 파악할 수 있습니다.
- 디버깅 시 Call Stack을 분석하여 함수 호출 흐름을 추적할 수 있습니다.
- 변수 접근과 this 바인딩 문제를 해결하는 데 도움이 됩니다.
- 메모리 누수를 방지하고 성능을 최적화하는 데 활용됩니다.

---

## 질문 4: 스코프(Scope)와 스코프 체인에 대해 설명해주세요.

**정의:**
스코프는 변수에 접근할 수 있는 유효한 범위를 의미합니다. JavaScript는 렉시컬 스코프를 따르며, 함수가 선언된 위치에 따라 스코프가 결정됩니다. 스코프 체인은 내부 스코프에서 외부 스코프로 변수를 찾아가는 연결 구조입니다.

**스코프의 종류:**
- Global Scope: 코드 전체에서 접근 가능한 최상위 스코프입니다. 전역 변수는 어디서든 참조할 수 있습니다.
- Function Scope: 함수 내부에서만 접근 가능한 스코프입니다. var 키워드가 함수 스코프를 따릅니다.
- Block Scope: 블록 내부에서만 접근 가능한 스코프입니다. let과 const가 블록 스코프를 따릅니다.

**스코프 체인의 동작 원리:**
- 변수를 참조할 때 현재 스코프에서 먼저 찾습니다.
- 현재 스코프에 없으면 외부 스코프로 이동하여 찾습니다.
- 전역 스코프까지 찾아도 없으면 ReferenceError가 발생합니다.
- 이 과정은 외부 렉시컬 환경 참조를 통해 이루어집니다.

**렉시컬 스코프의 특징:**
- 함수가 호출된 위치가 아닌 선언된 위치에 따라 스코프가 결정됩니다.
- 정적 스코프라고도 하며 코드 작성 시점에 스코프가 확정됩니다.
- 클로저의 기반이 되는 중요한 개념입니다.

**스코프와 관련된 개념:**
- Shadowing: 내부 스코프의 변수가 외부 스코프의 같은 이름 변수를 가리는 현상입니다.
- Closure: 함수가 선언될 때의 렉시컬 환경을 기억하여 외부 변수에 접근할 수 있는 현상입니다.
- Hoisting: 선언이 스코프 최상단으로 끌어올려지는 동작입니다.

**실무 활용:**
- 변수의 스코프를 최소화하여 네임스페이스 충돌을 방지합니다.
- 전역 변수 사용을 줄이고 모듈 패턴이나 IIFE로 스코프를 격리합니다.
- 블록 스코프를 활용하여 변수의 생명주기를 명확히 관리합니다.
- 스코프 체인을 이해하면 변수 접근 성능을 최적화할 수 있습니다. 지역 변수 사용이 전역 변수보다 빠릅니다.

---
