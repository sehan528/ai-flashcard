# JavaScript 답변 21-24

## 질문 21: 동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?

**정의:**
동기는 코드가 순차적으로 실행되어 이전 작업이 완료될 때까지 다음 작업이 대기하는 방식입니다. 비동기는 작업이 완료되기를 기다리지 않고 다음 코드를 실행하며, 작업 완료 시 콜백이나 프로미스로 결과를 처리하는 방식입니다.

**동기 처리의 특징:**
- 코드가 작성된 순서대로 실행됩니다. 한 줄씩 차례로 처리됩니다.
- 이전 작업이 완료될 때까지 블로킹됩니다. 다음 코드는 대기 상태가 됩니다.
- 실행 흐름을 예측하기 쉽습니다. 코드를 읽는 순서대로 동작합니다.
- 간단하고 이해하기 쉽습니다. 디버깅이 직관적입니다.

**비동기 처리의 특징:**
- 작업을 시작하고 완료를 기다리지 않습니다. 논블로킹 방식입니다.
- 백그라운드에서 작업이 실행됩니다. 메인 스레드는 다른 작업을 계속합니다.
- 작업 완료 시 콜백, Promise, async/await로 결과를 받습니다.
- 동시에 여러 작업을 처리할 수 있습니다. 효율성이 높습니다.

**JavaScript에서 비동기가 필요한 이유:**
- 단일 스레드 언어입니다. 동기 작업만 사용하면 UI가 멈춥니다.
- I/O 작업이 오래 걸립니다. 네트워크 요청, 파일 읽기 등을 기다리면 비효율적입니다.
- 사용자 경험을 해치지 않습니다. 응답성을 유지할 수 있습니다.

**비동기 처리 방식:**
- 콜백 함수: 가장 기본적인 방식입니다. 중첩되면 콜백 지옥이 발생합니다.
- Promise: 체이닝으로 가독성을 높입니다. 에러 처리가 명확합니다.
- async/await: 동기 코드처럼 작성할 수 있습니다. 가장 현대적이고 직관적입니다.

**실무 활용:**
- API 호출은 항상 비동기로 처리합니다. 서버 응답을 기다리는 동안 UI를 유지합니다.
- 파일 처리와 데이터베이스 쿼리는 비동기가 적합합니다.
- 타이머 함수는 비동기입니다. setTimeout, setInterval을 사용합니다.
- 이벤트 리스너도 비동기적으로 동작합니다.
- 적절한 비동기 처리로 애플리케이션 성능을 크게 향상시킬 수 있습니다.

---

## 질문 22: 콜백 함수(Callback)와 콜백 지옥(Callback Hell)에 대해 설명해주세요.

**정의:**
콜백 함수는 다른 함수의 인수로 전달되어 나중에 실행되는 함수입니다. 콜백 지옥은 콜백 함수가 중첩되어 코드의 가독성과 유지보수성이 떨어지는 현상입니다.

**콜백 함수의 특징:**
- 비동기 작업의 결과를 처리하는 데 사용됩니다. 작업 완료 시 호출됩니다.
- 고차 함수의 인수로 전달됩니다. 함수를 값처럼 다룰 수 있습니다.
- 이벤트 핸들러로도 사용됩니다. 사용자 액션에 반응합니다.
- 동기와 비동기 모두에서 사용됩니다. map, filter 같은 배열 메서드도 콜백을 받습니다.

**콜백 지옥의 문제점:**
- 가독성이 크게 떨어집니다. 코드가 오른쪽으로 계속 들여쓰기됩니다.
- 유지보수가 어렵습니다. 중간에 로직을 추가하거나 수정하기 힘듭니다.
- 에러 처리가 복잡합니다. 각 단계마다 에러를 처리해야 합니다.
- 디버깅이 어렵습니다. 실행 흐름을 추적하기 힘듭니다.

**콜백 지옥이 발생하는 경우:**
- 순차적인 비동기 작업이 많을 때 발생합니다. 각 작업이 이전 작업의 결과에 의존합니다.
- 조건부 분기가 많을 때 더 복잡해집니다.
- 에러 처리를 모든 단계에서 해야 할 때 심화됩니다.

**콜백 지옥의 해결 방법:**
- Promise를 사용합니다. 체이닝으로 평탄한 구조를 만들 수 있습니다.
- async/await를 사용합니다. 동기 코드처럼 작성하여 가독성을 높입니다.
- 함수를 분리합니다. 각 콜백을 별도의 named 함수로 정의합니다.
- 제어 흐름 라이브러리를 사용합니다. async.js 같은 도구를 활용합니다.

**콜백 패턴의 장점:**
- 간단한 비동기 처리에 적합합니다. 단일 작업에서는 직관적입니다.
- 추가 라이브러리가 필요 없습니다. 기본 JavaScript 기능만으로 구현됩니다.
- 성능 오버헤드가 없습니다. Promise보다 가볍습니다.

**실무에서의 대처:**
- 현대적인 코드에서는 Promise나 async/await를 우선 사용합니다.
- 레거시 코드를 리팩토링할 때 콜백을 Promise로 변환합니다.
- Node.js의 util.promisify로 콜백 기반 함수를 Promise로 변환할 수 있습니다.
- 에러 처리는 try-catch나 Promise의 catch를 일관되게 사용합니다.
- 코드 리뷰에서 콜백 중첩을 경계하고 리팩토링을 권장합니다.

---

## 질문 23: Promise의 동작 원리와 세 가지 상태에 대해 설명해주세요.

**정의:**
Promise는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체입니다. 콜백 지옥을 해결하고 비동기 코드를 더 읽기 쉽게 만듭니다.

**Promise의 세 가지 상태:**
- Pending: 초기 상태로 아직 완료되지도 실패하지도 않은 상태입니다. 비동기 작업이 진행 중입니다.
- Fulfilled: 작업이 성공적으로 완료된 상태입니다. resolve가 호출되어 결과값을 가집니다.
- Rejected: 작업이 실패한 상태입니다. reject가 호출되어 에러 정보를 가집니다.
- 상태는 한 번 변경되면 다시 바뀌지 않습니다. settled 상태라고 하며 불변입니다.

**Promise의 생성과 사용:**
- new Promise로 생성하며 executor 함수를 전달합니다.
- executor는 resolve와 reject 함수를 인수로 받습니다.
- 비동기 작업 성공 시 resolve를 호출합니다. 결과값을 전달합니다.
- 실패 시 reject를 호출합니다. 에러 객체를 전달합니다.

**Promise 체이닝:**
- then 메서드로 성공 시 처리를 연결합니다. 새로운 Promise를 반환합니다.
- catch 메서드로 에러를 처리합니다. 체인 중 어디서든 발생한 에러를 잡습니다.
- finally 메서드로 성공 실패 관계없이 실행될 코드를 작성합니다.
- 평탄한 구조로 순차적 비동기 작업을 표현할 수 있습니다.

**Promise의 장점:**
- 콜백 지옥을 해결합니다. 체이닝으로 가독성이 향상됩니다.
- 에러 처리가 명확합니다. catch 하나로 모든 에러를 처리할 수 있습니다.
- 합성이 쉽습니다. Promise.all, Promise.race 등으로 조합할 수 있습니다.
- 표준화된 인터페이스입니다. 다양한 라이브러리와 호환됩니다.

**Promise 정적 메서드:**
- Promise.all은 모든 Promise가 완료될 때까지 기다립니다. 하나라도 실패하면 전체가 실패합니다.
- Promise.race는 가장 먼저 완료되는 Promise의 결과를 반환합니다.
- Promise.allSettled는 모든 Promise의 결과를 기다립니다. 성공 실패 관계없이 모두 반환합니다.
- Promise.any는 가장 먼저 성공하는 Promise를 반환합니다.

**실무 활용:**
- API 호출을 Promise로 감싸서 처리합니다. fetch API가 Promise를 반환합니다.
- 여러 비동기 작업을 병렬로 처리할 때 Promise.all을 사용합니다.
- 타임아웃 구현 시 Promise.race를 활용합니다.
- 에러 처리를 일관되게 catch로 통합합니다.
- async/await와 함께 사용하여 더욱 직관적인 코드를 작성합니다.

---

## 질문 24: Promise 체이닝과 에러 핸들링 방법은 무엇인가요?

**정의:**
Promise 체이닝은 여러 비동기 작업을 순차적으로 연결하는 패턴입니다. 각 then은 새로운 Promise를 반환하여 다음 then으로 값을 전달할 수 있습니다.

**체이닝의 동작 원리:**
- then은 항상 새로운 Promise를 반환합니다. 값을 반환하면 자동으로 Promise로 감싸집니다.
- 반환된 값이 다음 then의 인수가 됩니다. 데이터가 체인을 따라 흐릅니다.
- Promise를 반환하면 해당 Promise가 완료될 때까지 기다립니다. 중첩 없이 순차 처리가 가능합니다.
- 각 단계는 이전 단계의 결과에 의존합니다.

**값 전달과 변환:**
- then에서 값을 반환하면 다음 then으로 전달됩니다.
- 값을 변환하여 파이프라인을 구성할 수 있습니다.
- undefined를 반환하면 다음 then도 undefined를 받습니다.
- Promise를 반환하면 자동으로 unwrap됩니다.

**에러 핸들링 방법:**
- catch 메서드로 에러를 잡습니다. 체인 어디서든 발생한 에러를 처리합니다.
- then의 두 번째 인수로도 에러를 처리할 수 있습니다. 하지만 catch 사용이 권장됩니다.
- catch 이후에도 체이닝을 계속할 수 있습니다. 에러에서 복구할 수 있습니다.
- catch에서 에러를 다시 throw하면 다음 catch로 전파됩니다.

**에러 전파:**
- Promise 체인 중 하나라도 reject되면 다음 catch로 이동합니다.
- 중간의 then들은 건너뛰어집니다.
- catch에서 에러를 처리하지 않으면 계속 전파됩니다.
- finally는 에러 여부와 관계없이 실행됩니다.

**finally 메서드:**
- 성공이든 실패든 항상 실행됩니다. 정리 작업에 적합합니다.
- 인수를 받지 않습니다. 성공/실패를 구분하지 않기 때문입니다.
- 이전 Promise의 값을 그대로 전달합니다. 값을 변경하지 않습니다.
- 로딩 상태 해제, 리소스 정리 등에 사용합니다.

**체이닝 시 주의사항:**
- then에서 Promise를 반환하지 않으면 다음 then이 즉시 실행됩니다.
- return을 빼먹으면 다음 then이 undefined를 받습니다.
- catch 후에도 체인이 계속되므로 적절한 위치에 배치해야 합니다.
- 각 then은 새로운 Promise이므로 원본 Promise는 변경되지 않습니다.

**실무 활용 패턴:**
- API 호출 후 데이터 변환, 저장, UI 업데이트를 순차적으로 체이닝합니다.
- 에러 처리는 체인 마지막에 catch 하나로 통합합니다.
- 공통 정리 작업은 finally에서 처리합니다. 로딩 스피너 숨기기 등입니다.
- 조건부 분기가 필요하면 then 내부에서 Promise.resolve나 Promise.reject를 반환합니다.
- 병렬 작업은 Promise.all로, 순차 작업은 체이닝으로 구분하여 사용합니다.
- async/await로 전환하면 더 읽기 쉬운 코드가 됩니다.

---
