# React 답변 17-20

## 질문 17: Props와 State의 차이점은 무엇인가요?

**정의:**
Props와 State는 React 컴포넌트에서 데이터를 다루는 두 가지 방법입니다. Props는 부모로부터 받는 읽기 전용 데이터이고, State는 컴포넌트 내부에서 관리하는 변경 가능한 데이터입니다.

**Props의 특징:**
- 부모 컴포넌트가 자식에게 전달하는 데이터입니다.
- 읽기 전용입니다. 자식이 직접 수정할 수 없습니다.
- 함수 매개변수처럼 전달됩니다.
- 컴포넌트 외부에서 제어됩니다.
- 같은 props면 같은 결과를 렌더링합니다.

**State의 특징:**
- 컴포넌트 내부에서 관리하는 데이터입니다.
- 변경 가능합니다. setState나 useState로 업데이트합니다.
- 변경되면 컴포넌트가 리렌더링됩니다.
- 컴포넌트가 소유하고 제어합니다.
- 사용자 인터랙션이나 시간에 따라 변합니다.

**주요 차이점:**
- Props는 불변입니다. State는 가변입니다.
- Props는 부모가 설정합니다. State는 컴포넌트가 설정합니다.
- Props는 자식이 받기만 합니다. State는 컴포넌트가 직접 관리합니다.
- Props 변경은 부모가 합니다. State 변경은 자신이 합니다.
- Props는 설정값입니다. State는 상태입니다.

**Props 사용 패턴:**
- 컴포넌트를 커스터마이징합니다. 재사용 가능하게 만듭니다.
- 데이터를 하위로 전달합니다. 단방향 흐름을 따릅니다.
- 콜백 함수를 전달합니다. 자식이 부모에게 이벤트를 알립니다.
- children prop으로 컴포넌트를 조합합니다.
- 기본값을 설정할 수 있습니다.

**State 사용 패턴:**
- 사용자 입력을 저장합니다. 폼 데이터 관리에 활용합니다.
- UI 상태를 관리합니다. 모달 열림 닫힘 등입니다.
- 서버에서 받은 데이터를 저장합니다.
- 컴포넌트의 현재 상태를 추적합니다.
- 타이머나 애니메이션 상태를 관리합니다.

**Props를 State로 초기화:**
- Props를 State의 초기값으로 사용할 수 있습니다.
- 이후 State는 독립적으로 관리됩니다.
- Props가 변경되어도 State는 자동으로 업데이트되지 않습니다.
- 의도가 명확하지 않으면 혼란을 줄 수 있습니다.
- useEffect로 Props 변경을 감지하여 State를 업데이트할 수 있습니다.

**언제 무엇을 사용할까:**
- 부모로부터 받은 데이터는 Props로 사용합니다.
- 시간에 따라 변하는 데이터는 State로 관리합니다.
- 렌더링에 영향을 주는 데이터는 State입니다.
- 단순히 전달만 하는 데이터는 Props입니다.
- 컴포넌트가 제어해야 하는 데이터는 State입니다.

**실무 활용:**
- Presentational 컴포넌트는 주로 Props를 사용합니다.
- Container 컴포넌트는 State를 관리하고 Props로 전달합니다.
- 최소한의 State를 유지합니다. 계산 가능한 값은 State로 두지 않습니다.
- Props와 State를 적절히 조합하여 컴포넌트를 설계합니다.
- TypeScript로 Props와 State의 타입을 명확히 정의합니다.

---

## 질문 18: State 끌어올리기(Lifting State Up)란 무엇이고 왜 필요한가요?

**정의:**
State 끌어올리기는 여러 컴포넌트가 같은 데이터를 공유해야 할 때, 그 데이터를 공통 조상 컴포넌트로 이동시키는 패턴입니다. 단일 진실 공급원 원칙을 따르는 React의 권장 방법입니다.

**필요한 상황:**
- 두 개 이상의 컴포넌트가 같은 데이터를 표시해야 할 때입니다.
- 한 컴포넌트의 변경이 다른 컴포넌트에 영향을 줘야 할 때입니다.
- 형제 컴포넌트 간 데이터를 공유해야 할 때입니다.
- 데이터의 동기화가 필요할 때입니다.
- 단일 진실 공급원을 만들고 싶을 때입니다.

**끌어올리기 과정:**
- 공유할 State를 찾습니다. 여러 곳에서 사용하는 데이터입니다.
- 공통 조상 컴포넌트를 찾습니다. 모든 자식을 포함하는 부모입니다.
- State를 공통 조상으로 이동합니다.
- Props로 자식들에게 전달합니다.
- 업데이트 함수도 Props로 전달합니다.

**단일 진실 공급원:**
- 모든 데이터는 하나의 출처만 가져야 합니다.
- 같은 데이터를 여러 곳에 중복 저장하면 동기화 문제가 생깁니다.
- State를 끌어올려서 하나의 곳에서만 관리합니다.
- Props로 전달하여 읽기만 하게 합니다.
- 데이터 일관성이 보장됩니다.

**장점:**
- 데이터가 동기화됩니다. 한 곳에서만 관리하므로 일관성이 유지됩니다.
- 버그가 줄어듭니다. 진실 공급원이 명확합니다.
- 디버깅이 쉬워집니다. 데이터 흐름을 추적하기 쉽습니다.
- 예측 가능성이 높아집니다. 단방향 데이터 흐름을 따릅니다.

**단점과 한계:**
- Props drilling이 발생할 수 있습니다. 깊이 중첩된 구조에서 문제가 됩니다.
- 보일러플레이트가 증가합니다. Props 전달 코드가 많아집니다.
- 성능에 영향을 줄 수 있습니다. 부모 리렌더링 시 모든 자식이 리렌더링됩니다.
- 너무 높이 끌어올리면 관리가 어려워집니다.

**Props Drilling 해결:**
- Context API를 사용합니다. 중간 컴포넌트를 거치지 않고 전달합니다.
- 상태 관리 라이브러리를 사용합니다. Redux, Zustand 등입니다.
- Composition 패턴을 활용합니다. children props를 사용합니다.
- 컴포넌트 구조를 재설계합니다.

**적절한 수준 찾기:**
- 필요한 만큼만 끌어올립니다. 최소 공통 조상으로만 올립니다.
- 전역 상태로 만들 필요는 없습니다.
- 로컬에서 해결 가능하면 로컬에 둡니다.
- 과도한 끌어올리기는 복잡도를 높입니다.

**실무 활용:**
- 폼에서 여러 입력 필드의 유효성을 검사할 때 사용합니다.
- 탭 컴포넌트에서 활성 탭 상태를 관리합니다.
- 필터와 목록 컴포넌트 간 데이터를 공유합니다.
- 장바구니와 상품 목록을 동기화합니다.
- 먼저 로컬 State로 시작하고 필요할 때 끌어올립니다.

---

## 질문 19: 전역 상태 관리는 왜 필요하고 어떤 방법들이 있나요?

**정의:**
전역 상태 관리는 애플리케이션 전체에서 공유되는 데이터를 효율적으로 관리하는 방법입니다. 깊은 컴포넌트 트리에서 Props drilling 없이 데이터를 공유할 수 있게 해줍니다.

**전역 상태 관리가 필요한 이유:**
- Props drilling을 해결합니다. 중간 컴포넌트를 거치지 않아도 됩니다.
- 여러 곳에서 같은 데이터를 사용합니다. 사용자 정보, 테마 등입니다.
- 컴포넌트 간 통신이 필요합니다. 형제나 먼 컴포넌트 간에도 가능합니다.
- 상태 로직을 중앙화합니다. 일관된 방식으로 관리합니다.
- 디버깅과 테스팅이 쉬워집니다. 상태 변화를 추적할 수 있습니다.

**Context API:**
- React 내장 기능입니다. 별도 라이브러리가 필요 없습니다.
- 간단한 전역 상태에 적합합니다.
- Provider와 Consumer 패턴을 사용합니다.
- useContext Hook으로 쉽게 접근합니다.
- 작은 규모 앱이나 테마 언어 설정에 좋습니다.

**Redux:**
- 가장 널리 사용되는 상태 관리 라이브러리입니다.
- 단일 스토어에 모든 상태를 저장합니다.
- Action과 Reducer 패턴을 사용합니다.
- 미들웨어로 확장 가능합니다. 비동기 처리에 유용합니다.
- DevTools로 강력한 디버깅을 지원합니다.
- 보일러플레이트가 많지만 예측 가능합니다.

**Redux Toolkit:**
- Redux의 공식 권장 방법입니다.
- 보일러플레이트를 크게 줄입니다.
- Immer가 내장되어 불변성 관리가 쉽습니다.
- createSlice로 간편하게 리듀서를 만듭니다.
- RTK Query로 데이터 페칭도 처리합니다.

**Zustand:**
- 매우 간단하고 가벼운 라이브러리입니다.
- Hooks 기반 API를 제공합니다.
- 보일러플레이트가 거의 없습니다.
- Provider가 필요 없습니다.
- 중소 규모 프로젝트에 적합합니다.

**Recoil:**
- Facebook이 만든 상태 관리 라이브러리입니다.
- Atom과 Selector 개념을 사용합니다.
- React처럼 사용할 수 있습니다.
- 파생 상태를 쉽게 만듭니다.
- 아직 실험적이지만 강력합니다.

**Jotai:**
- Recoil과 유사한 원자 기반 접근입니다.
- 매우 작고 TypeScript 친화적입니다.
- 간단한 API를 제공합니다.
- 필요한 만큼만 사용할 수 있습니다.

**선택 기준:**
- 앱 규모: 작으면 Context나 Zustand, 크면 Redux입니다.
- 복잡도: 간단하면 Context, 복잡하면 Redux Toolkit입니다.
- 팀 경험: 팀이 익숙한 도구를 선택합니다.
- 요구사항: 디버깅이 중요하면 Redux, 간결함이 중요하면 Zustand입니다.
- 생태계: Redux는 미들웨어와 도구가 풍부합니다.

**실무 활용:**
- 사용자 인증 상태를 전역으로 관리합니다.
- 쇼핑몰의 장바구니 데이터를 공유합니다.
- 알림이나 토스트 메시지를 전역에서 제어합니다.
- 다크 모드나 언어 설정을 관리합니다.
- 필요한 곳에만 상태 관리 라이브러리를 도입합니다. 과도한 사용을 피합니다.

---

## 질문 20: Props Drilling 문제와 해결 방법은 무엇인가요?

**정의:**
Props Drilling은 상위 컴포넌트의 데이터를 깊이 중첩된 하위 컴포넌트로 전달하기 위해 중간의 모든 컴포넌트를 거쳐야 하는 문제입니다. 코드가 복잡해지고 유지보수가 어려워집니다.

**Props Drilling의 문제점:**
- 중간 컴포넌트가 불필요한 Props를 받습니다. 실제로 사용하지 않는 데이터입니다.
- 코드가 장황해집니다. Props 전달 코드가 많아집니다.
- 리팩토링이 어렵습니다. 구조를 바꾸면 여러 곳을 수정해야 합니다.
- 가독성이 떨어집니다. 데이터 흐름을 파악하기 힘듭니다.
- 실수하기 쉽습니다. Props 이름을 잘못 쓰거나 누락할 수 있습니다.

**해결 방법 1: Context API:**
- React 내장 기능으로 해결합니다.
- Provider로 상위에서 값을 제공합니다.
- useContext로 하위에서 직접 접근합니다.
- 중간 컴포넌트는 신경 쓰지 않아도 됩니다.
- 간단한 경우에 가장 적합합니다.

**해결 방법 2: 상태 관리 라이브러리:**
- Redux, Zustand, Recoil 등을 사용합니다.
- 전역 스토어에서 직접 데이터를 가져옵니다.
- Props 전달이 필요 없습니다.
- 복잡한 상태 로직에 적합합니다.
- 디버깅 도구가 풍부합니다.

**해결 방법 3: Component Composition:**
- children props를 활용합니다.
- 컴포넌트를 조합하는 방식으로 구조를 변경합니다.
- 데이터가 필요한 컴포넌트를 상위에서 만들어 전달합니다.
- Props drilling 없이 데이터를 사용할 수 있습니다.
- 유연하고 재사용 가능한 구조를 만듭니다.

**해결 방법 4: Render Props:**
- 함수를 Props로 전달합니다.
- 함수가 컴포넌트를 렌더링합니다.
- 데이터를 함수 인자로 전달합니다.
- HOC의 대안으로 사용됩니다.
- Hooks 등장 이후 덜 사용됩니다.

**해결 방법 5: 컴포넌트 구조 재설계:**
- 데이터가 필요한 곳 가까이에 State를 둡니다.
- 불필요하게 끌어올린 State를 다시 내립니다.
- 컴포넌트 분리를 재고합니다.
- 로직과 UI를 분리합니다.

**언제 어떤 방법을 사용할까:**
- 2-3 레벨 정도는 Props로 전달해도 괜찮습니다.
- 테마나 로케일 같은 전역 설정은 Context를 사용합니다.
- 복잡한 상태 관리는 Redux 같은 라이브러리를 사용합니다.
- 레이아웃 컴포넌트는 Composition 패턴을 사용합니다.
- 상황에 맞는 방법을 선택합니다.

**주의사항:**
- Context를 과도하게 사용하면 성능 문제가 생깁니다.
- 모든 것을 전역 상태로 만들 필요는 없습니다.
- 간단한 Props 전달은 문제가 아닙니다.
- 도구가 아닌 문제 해결에 집중합니다.

**실무 활용:**
- 사용자 정보는 Context로 전역 관리합니다.
- UI 레이아웃은 Composition 패턴을 사용합니다.
- 비즈니스 로직이 복잡하면 상태 관리 라이브러리를 도입합니다.
- 먼저 Props로 시작하고 문제가 생기면 리팩토링합니다.
- 각 방법의 장단점을 이해하고 적절히 선택합니다.

---
