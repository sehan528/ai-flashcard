# Spring 답변 25-28

## 질문 25: Java Stream에 대해 설명해 주세요.

Java Stream은 Java 8에서 도입된 데이터 처리 API로, 컬렉션이나 배열의 요소를 함수형 스타일로 처리할 수 있게 합니다.

**기본 개념:**

Stream은 데이터의 흐름을 나타내는 추상화입니다. 컬렉션과 달리 데이터를 저장하지 않고, 원본 데이터 소스를 변경하지 않으며, 지연 연산(lazy evaluation)을 수행합니다.

Stream은 일회용입니다. 한 번 사용하면 다시 사용할 수 없으며, 재사용하려면 새로운 스트림을 생성해야 합니다.

**Stream의 구조:**

Stream 연산은 중간 연산(intermediate operation)과 최종 연산(terminal operation)으로 나뉩니다.

중간 연산은 Stream을 반환하여 체이닝할 수 있습니다. filter, map, flatMap, distinct, sorted, limit, skip 등이 있습니다. 지연 평가되어 최종 연산이 호출되기 전까지 실행되지 않습니다.

최종 연산은 Stream을 소비하고 결과를 반환합니다. forEach, collect, reduce, count, anyMatch, allMatch, findFirst, findAny 등이 있습니다. 최종 연산이 호출되면 Stream 파이프라인이 실행됩니다.

**주요 특징:**

선언적 프로그래밍이 가능합니다. 무엇을 할지 표현하며 어떻게 할지는 내부 구현에 맡깁니다. 코드가 간결하고 가독성이 높아집니다.

지연 연산으로 효율적입니다. 중간 연산들은 파이프라인을 구성만 하고, 최종 연산 시 한 번에 처리됩니다. 불필요한 계산을 피하고 최적화할 수 있습니다.

내부 반복을 사용합니다. for 루프의 외부 반복과 달리 Stream이 반복을 제어하여 병렬화가 쉽습니다.

불변성을 유지합니다. 원본 데이터를 변경하지 않고 새로운 Stream을 생성합니다.

**생성 방법:**

컬렉션에서 stream 메서드로 생성합니다. 배열에서 Arrays.stream으로 생성합니다. Stream.of, Stream.generate, Stream.iterate 등의 정적 메서드를 사용합니다. 파일 I/O에서 Files.lines로 스트림을 얻을 수 있습니다.

**주요 연산:**

filter는 조건에 맞는 요소만 선택합니다. map은 요소를 다른 형태로 변환합니다. flatMap은 각 요소를 스트림으로 변환하고 평탄화합니다. reduce는 모든 요소를 하나의 결과로 축약합니다. collect는 스트림 요소를 컬렉션이나 다른 형태로 수집합니다.

**장점:**

코드가 간결하고 읽기 쉽습니다. 함수형 프로그래밍 스타일을 지원합니다. 병렬 처리가 쉽습니다. 복잡한 데이터 변환을 파이프라인으로 표현할 수 있습니다.

**단점:**

디버깅이 어렵습니다. 성능이 항상 더 좋은 것은 아닙니다. 간단한 경우 오히려 오버헤드가 있을 수 있습니다. 학습 곡선이 있습니다.

## 질문 26: Stream과 for ~ loop의 성능 차이를 비교해 주세요.

Stream과 for loop의 성능은 상황에 따라 다르며, 일률적으로 어느 쪽이 더 빠르다고 말할 수 없습니다.

**for loop가 더 빠른 경우:**

간단한 반복 작업에서는 전통적인 for loop가 더 빠릅니다. 추가 객체 생성이 없고, 메서드 호출 오버헤드가 없으며, JVM이 고도로 최적화합니다.

적은 양의 데이터를 처리할 때는 Stream의 초기화 비용이 상대적으로 큽니다. Stream 객체 생성, 람다 객체 생성, 파이프라인 구성 등의 오버헤드가 있습니다.

원시 타입을 다룰 때는 박싱/언박싱 비용이 발생할 수 있습니다. IntStream 같은 특화된 Stream을 사용하지 않으면 성능이 저하됩니다.

조기 종료(break)가 필요한 경우 for loop가 더 효율적입니다. Stream은 쇼트서킷 연산을 지원하지만 완전히 동일하지 않습니다.

**Stream이 더 빠르거나 유사한 경우:**

복잡한 데이터 변환과 필터링에서는 Stream이 최적화될 수 있습니다. 지연 평가로 불필요한 중간 객체 생성을 피합니다. 퓨전(fusion) 최적화로 여러 연산을 하나로 합칠 수 있습니다.

병렬 처리에서는 Stream이 훨씬 간편하고 효율적입니다. parallelStream으로 쉽게 병렬화할 수 있습니다. 대용량 데이터 처리 시 멀티코어를 활용하여 성능이 크게 향상됩니다.

데이터가 충분히 많을 때는 Stream의 오버헤드가 상대적으로 작아집니다. 수만 개 이상의 요소를 처리하면 차이가 줄어듭니다.

**성능 차이의 원인:**

Stream은 추가적인 추상화 계층을 가집니다. 람다식이 내부적으로 객체로 변환됩니다. 함수형 인터페이스 호출 비용이 있습니다. 스플리터레이터(Spliterator)와 같은 내부 구조를 사용합니다.

JIT 컴파일러의 최적화 능력이 다릅니다. for loop는 오랜 시간 최적화되어 왔습니다. Stream은 상대적으로 새로워 최적화가 덜 성숙할 수 있습니다.

**측정 결과:**

일반적으로 간단한 순회와 집계는 for loop가 10-30% 더 빠릅니다. 복잡한 변환과 필터링은 성능 차이가 거의 없습니다. 병렬 처리 가능한 대용량 데이터는 parallelStream이 훨씬 빠릅니다.

**권장 사항:**

성능이 크리티컬한 핫스팟에서는 측정 후 결정합니다. 일반적인 비즈니스 로직에서는 가독성과 유지보수성을 우선합니다. Stream은 코드를 더 명확하게 만들어 버그를 줄입니다.

원시 타입 처리 시 IntStream, LongStream, DoubleStream을 사용합니다. 병렬 처리가 필요하면 parallelStream을 우선 고려합니다. 단, 순서가 중요하거나 상태를 공유하면 주의가 필요합니다.

마이크로벤치마킹은 JMH 같은 도구를 사용하여 정확히 측정합니다. 실제 애플리케이션 성능을 프로파일링하여 병목을 찾습니다.

## 질문 27: Stream은 병렬처리 할 수 있나요?

네, Stream은 병렬 처리를 쉽게 할 수 있는 강력한 기능을 제공합니다.

**병렬 Stream 생성:**

기존 Stream에서 parallel 메서드를 호출하면 병렬 스트림으로 전환됩니다. 컬렉션에서 parallelStream 메서드로 직접 병렬 스트림을 생성할 수 있습니다. Arrays.stream의 parallel 버전도 사용할 수 있습니다.

반대로 sequential 메서드로 순차 스트림으로 되돌릴 수 있습니다.

**동작 원리:**

병렬 Stream은 내부적으로 Fork/Join 프레임워크를 사용합니다. 공통 Fork/Join Pool(ForkJoinPool.commonPool())을 사용하여 작업을 분할하고 병렬로 처리합니다.

데이터를 여러 청크(chunk)로 나누고, 각 청크를 별도의 스레드에서 처리한 후 결과를 병합합니다. Spliterator가 데이터를 분할하는 역할을 합니다.

기본적으로 사용 가능한 프로세서 수만큼의 스레드를 사용합니다. Runtime.getRuntime().availableProcessors()로 결정됩니다.

**장점:**

사용이 매우 간단합니다. sequential을 parallel로 바꾸기만 하면 됩니다. 멀티코어 CPU를 활용하여 성능을 크게 향상시킬 수 있습니다. 복잡한 스레드 관리를 직접 할 필요가 없습니다.

**주의사항:**

모든 경우에 빠른 것은 아닙니다. 데이터가 충분히 많아야 병렬 처리 오버헤드를 상쇄할 수 있습니다. 일반적으로 수천 개 이상의 요소가 있어야 효과적입니다.

스레드 안전해야 합니다. 람다식 내에서 공유 상태를 변경하면 안 됩니다. 외부 변수를 수정하거나 동기화되지 않은 컬렉션에 접근하면 경합과 예측 불가능한 결과가 발생합니다.

순서가 중요한 경우 주의가 필요합니다. forEachOrdered를 사용하면 순서를 보장하지만 성능이 저하됩니다. 순서가 중요하지 않으면 forEach를 사용하는 것이 더 빠릅니다.

데이터 소스의 분할 효율성이 중요합니다. ArrayList나 배열은 분할이 쉽고 효율적입니다. LinkedList는 분할이 어렵고 비효율적입니다. HashSet이나 TreeSet은 중간 정도입니다.

작업의 특성을 고려해야 합니다. CPU 집약적 작업은 병렬 처리에 적합합니다. I/O 작업은 블로킹되어 효과가 적을 수 있습니다. 작업이 너무 간단하면 오버헤드가 이득보다 클 수 있습니다.

**성능 측정:**

항상 측정 후 결정합니다. 병렬이 항상 빠르지 않으므로 벤치마킹이 필수입니다. JMH 같은 도구로 정확한 성능을 측정합니다.

**Thread Pool 커스터마이징:**

기본 공통 풀의 스레드 수는 시스템 프로퍼티로 변경할 수 있습니다. 커스텀 ForkJoinPool을 사용하여 특정 작업에 전용 풀을 할당할 수 있습니다.

**언제 사용하면 좋은가:**

대용량 데이터 처리, CPU 집약적 연산, 각 요소 처리가 독립적인 경우, 데이터 소스가 효율적으로 분할 가능한 경우에 적합합니다.

반대로 소량 데이터, I/O 작업, 순서가 중요한 작업, 상태를 공유하는 작업에는 적합하지 않습니다.

## 질문 28: Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.

Stream API는 java.util.function 패키지의 다양한 함수형 인터페이스를 활용합니다. 함수형 인터페이스는 단 하나의 추상 메서드를 가진 인터페이스로, 람다식으로 표현할 수 있습니다.

**주요 함수형 인터페이스:**

**1. Predicate<T>:**

하나의 인자를 받아서 boolean을 반환합니다. test 메서드를 가지며, 조건을 검사하는 데 사용됩니다.

filter 연산에서 사용됩니다. 특정 조건을 만족하는 요소만 선택할 때 활용됩니다.

and, or, negate 같은 디폴트 메서드로 조건을 조합할 수 있습니다.

**2. Function<T, R>:**

하나의 인자를 받아서 결과를 반환합니다. apply 메서드를 가지며, 값을 변환하는 데 사용됩니다.

map 연산에서 사용됩니다. 요소를 다른 타입이나 값으로 변환할 때 활용됩니다.

andThen, compose로 함수를 연결할 수 있습니다. 함수 합성이 가능합니다.

**3. Consumer<T>:**

하나의 인자를 받아서 아무것도 반환하지 않습니다. accept 메서드를 가지며, 값을 소비하는 동작을 수행합니다.

forEach 연산에서 사용됩니다. 각 요소에 대해 어떤 동작을 수행할 때 활용됩니다.

출력, 로깅, 상태 변경 등의 부수 효과를 일으킬 때 사용됩니다.

**4. Supplier<T>:**

인자 없이 값을 생성하여 반환합니다. get 메서드를 가지며, 값을 공급하는 데 사용됩니다.

Stream.generate에서 사용됩니다. 지연 평가가 필요한 상황이나 Optional의 orElseGet에서 활용됩니다.

**5. UnaryOperator<T>:**

Function<T, T>의 특수 케이스로, 같은 타입을 받아 같은 타입을 반환합니다.

map에서 같은 타입으로 변환할 때 사용됩니다. iterate에서 다음 값을 생성할 때 활용됩니다.

**6. BinaryOperator<T>:**

BiFunction<T, T, T>의 특수 케이스로, 같은 타입 두 개를 받아 같은 타입을 반환합니다.

reduce 연산에서 사용됩니다. 두 요소를 하나로 결합하는 누적 연산에 활용됩니다.

max, min 같은 정적 메서드를 제공합니다.

**7. BiFunction<T, U, R>:**

두 개의 인자를 받아서 결과를 반환합니다. apply 메서드를 가집니다.

두 스트림을 결합하거나 키-값 쌍을 처리할 때 사용됩니다.

**8. BiPredicate<T, U>:**

두 개의 인자를 받아서 boolean을 반환합니다. test 메서드를 가집니다.

두 값을 비교하거나 관계를 검사할 때 사용됩니다.

**9. BiConsumer<T, U>:**

두 개의 인자를 받아서 동작을 수행합니다. accept 메서드를 가집니다.

Map의 forEach에서 키와 값을 함께 처리할 때 사용됩니다.

**원시 타입 특화 인터페이스:**

박싱/언박싱 오버헤드를 피하기 위한 특화된 버전들이 있습니다.

IntPredicate, LongPredicate, DoublePredicate는 원시 타입을 받습니다. IntFunction, LongFunction, DoubleFunction은 원시 타입을 받아 객체를 반환합니다. ToIntFunction, ToLongFunction, ToDoubleFunction은 객체를 받아 원시 타입을 반환합니다. IntConsumer, LongConsumer, DoubleConsumer는 원시 타입을 소비합니다. IntSupplier, LongSupplier, DoubleSupplier는 원시 타입을 생성합니다. IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator는 원시 타입을 변환합니다. IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator는 원시 타입을 결합합니다.

**메서드 참조:**

람다식 대신 메서드 참조를 사용할 수 있습니다. 정적 메서드 참조, 인스턴스 메서드 참조, 생성자 참조가 가능합니다. 코드가 더 간결하고 읽기 쉬워집니다.

**커스텀 함수형 인터페이스:**

@FunctionalInterface 어노테이션을 사용하여 직접 정의할 수 있습니다. 도메인 특화 동작을 표현하거나 더 명확한 이름을 제공할 때 유용합니다.

함수형 인터페이스는 Stream API의 핵심이며, 함수형 프로그래밍 스타일을 자바에 도입하여 코드를 더 선언적이고 간결하게 만듭니다.
