# Network 답변 모음 (57-60)

## 57. 각각의 Header의 Packing Order에 대해 설명해 주세요.

**헤더 패킹 순서(Packing Order)**는 데이터가 송신될 때 각 계층의 헤더가 추가되는 순서를 의미하며, **캡슐화(Encapsulation)** 과정을 통해 이루어집니다.

**송신 측 캡슐화 순서:**

**1단계 - 애플리케이션 계층:**
사용자 데이터 또는 애플리케이션 메시지가 생성됩니다. 예를 들어 HTTP 요청, 이메일 본문, 파일 데이터 등이 있습니다. 애플리케이션 프로토콜의 헤더가 추가됩니다(HTTP 헤더, SMTP 명령 등).

**2단계 - 전송 계층:**
애플리케이션 데이터 앞에 전송 계층 헤더가 추가됩니다. TCP 헤더(20-60 바이트) 또는 UDP 헤더(8 바이트)가 붙습니다. 포함 정보: 송신/수신 포트 번호, 순서 번호(TCP), 체크섬 등. 이 시점에서 세그먼트(TCP) 또는 데이터그램(UDP)이 됩니다.

**3단계 - 네트워크 계층:**
전송 계층 세그먼트 앞에 IP 헤더가 추가됩니다. IPv4 헤더(20-60 바이트) 또는 IPv6 헤더(40 바이트)가 붙습니다. 포함 정보: 송신/수신 IP 주소, TTL, 프로토콜 타입, 체크섬(IPv4) 등. 이 시점에서 IP 패킷 또는 데이터그램이 됩니다.

**4단계 - 데이터링크 계층:**
IP 패킷 앞에 데이터링크 헤더가, 뒤에 트레일러가 추가됩니다. 이더넷 헤더(14 바이트): 송신/수신 MAC 주소, 이더타입. 이더넷 트레일러(4 바이트): FCS(Frame Check Sequence)로 오류 검출. 이 시점에서 프레임이 됩니다.

**5단계 - 물리 계층:**
프레임이 비트 스트림으로 변환되어 물리적 매체(케이블, 전파)를 통해 전송됩니다. 프리앰블과 SFD(Start Frame Delimiter)가 추가될 수 있습니다.

**실제 패킷 구조 (안쪽에서 바깥쪽으로):**
[이더넷 헤더 | IP 헤더 | TCP/UDP 헤더 | 애플리케이션 데이터 | 이더넷 트레일러]

**구체적 예시 (HTTP 요청):**
1. HTTP 요청 메시지: "GET /index.html HTTP/1.1..."
2. + TCP 헤더: 포트 80, 순서 번호 등
3. + IP 헤더: 송신/수신 IP 주소
4. + 이더넷 헤더 + 트레일러: MAC 주소, FCS

**수신 측 역캡슐화 순서:**

**1단계 - 물리 계층:**
비트 스트림을 받아 프레임으로 재구성합니다.

**2단계 - 데이터링크 계층:**
이더넷 헤더와 트레일러를 제거합니다. FCS로 오류를 검사하고, 목적지 MAC 주소가 자신인지 확인합니다. 이더타입 필드를 보고 상위 프로토콜(IP)을 식별합니다. IP 패킷을 네트워크 계층으로 전달합니다.

**3단계 - 네트워크 계층:**
IP 헤더를 제거하고 검증합니다. 목적지 IP 주소가 자신인지 확인합니다. 프로토콜 필드를 보고 상위 프로토콜(TCP/UDP)을 식별합니다. 세그먼트를 전송 계층으로 전달합니다.

**4단계 - 전송 계층:**
TCP/UDP 헤더를 제거하고 검증합니다. 포트 번호로 해당 애플리케이션을 찾습니다. TCP의 경우 순서 확인, 재조립, ACK 전송 등을 수행합니다. 데이터를 애플리케이션 계층으로 전달합니다.

**5단계 - 애플리케이션 계층:**
최종 애플리케이션 데이터를 받아 처리합니다. HTTP 응답 파싱, 이메일 표시, 파일 저장 등을 수행합니다.

**헤더 크기 총합:**
최소한의 헤더만 사용할 때:
- 이더넷: 14 바이트 헤더 + 4 바이트 트레일러 = 18 바이트
- IP(v4): 20 바이트
- TCP: 20 바이트
- 총 오버헤드: 58 바이트

실제 데이터가 100 바이트라면 총 158 바이트가 전송되며, 약 37%가 오버헤드입니다.

**MTU와의 관계:**
이더넷의 MTU(Maximum Transmission Unit)는 일반적으로 1500 바이트입니다. IP 패킷(헤더 + 데이터)이 1500 바이트를 초과하면 단편화가 발생합니다. 효율적인 전송을 위해 TCP MSS(Maximum Segment Size)를 조정합니다.

**VLAN 태그:**
VLAN을 사용하는 경우 이더넷 헤더에 4 바이트 태그가 추가됩니다. 이 경우 이더넷 헤더는 18 바이트가 됩니다.

**터널링의 경우:**
VPN이나 터널링 사용 시 추가 헤더가 중첩됩니다. 예: [외부 이더넷 | 외부 IP | 터널 프로토콜 | 내부 IP | TCP | 데이터 | 외부 이더넷 트레일러]

**실무적 중요성:**
패킷 캡처 도구(Wireshark)로 분석 시 이 순서를 이해해야 정확한 진단이 가능합니다. 네트워크 성능 최적화를 위해 오버헤드를 계산하고 관리해야 합니다.

---

## 58. ARP에 대해 설명해 주세요.

**ARP(Address Resolution Protocol)**는 IP 주소를 MAC 주소로 변환하는 프로토콜입니다.

**필요성:**
네트워크 통신을 위해서는 논리 주소(IP)와 물리 주소(MAC)가 모두 필요합니다. 상위 계층은 IP 주소만 알고 있지만, 실제 프레임 전송을 위해서는 목적지의 MAC 주소가 필요합니다. ARP는 이 두 주소를 연결하는 다리 역할을 합니다.

**동작 과정:**

**1. ARP Request (요청):**
호스트 A가 호스트 B(IP: 192.168.1.100)와 통신하려 하지만 MAC 주소를 모릅니다. 호스트 A는 ARP Request를 브로드캐스트로 전송합니다. 메시지 내용: "IP 주소 192.168.1.100을 가진 사람의 MAC 주소는 무엇인가?" 목적지 MAC 주소는 FF:FF:FF:FF:FF:FF(브로드캐스트)입니다. 같은 네트워크의 모든 장치가 이 메시지를 받습니다.

**2. ARP Reply (응답):**
해당 IP를 가진 호스트 B만 응답합니다. 호스트 B는 자신의 MAC 주소를 포함한 ARP Reply를 유니캐스트로 보냅니다. 메시지 내용: "192.168.1.100은 내 IP이고, 내 MAC 주소는 AA:BB:CC:DD:EE:FF입니다." 호스트 A는 이 정보를 받아 통신을 시작합니다.

**ARP 캐시(ARP Table):**
매번 ARP 요청을 보내면 비효율적이므로, 학습한 IP-MAC 매핑을 캐시에 저장합니다. 일정 시간(일반적으로 몇 분) 동안 유효하며, 타임아웃 후 삭제됩니다. 윈도우에서는 "arp -a" 명령으로, 리눅스에서는 "ip neigh" 명령으로 확인할 수 있습니다.

**동적 ARP vs 정적 ARP:**
- **동적 ARP**: 자동으로 학습하고 타임아웃 후 삭제됩니다
- **정적 ARP**: 관리자가 수동으로 설정하며 영구적입니다. 보안이 중요한 장치에 사용됩니다

**Gratuitous ARP:**
자신의 IP에 대한 ARP를 보내는 특수한 경우입니다. 목적: IP 주소 충돌 감지, 네트워크의 다른 장치들이 ARP 캐시를 업데이트하도록 함, 장비가 부팅되거나 IP가 변경될 때 사용됩니다.

**Proxy ARP:**
라우터가 다른 네트워크의 호스트를 대신하여 ARP 응답을 보냅니다. 서브넷 마스크 설정이 잘못된 호스트들이 통신할 수 있게 합니다. 보안 문제가 있어 권장되지 않습니다.

**Reverse ARP(RARP):**
MAC 주소를 알고 있을 때 IP 주소를 찾는 역방향 프로토콜입니다. 디스크 없는 워크스테이션이 부팅 시 사용했습니다. 현재는 DHCP, BOOTP로 대체되었습니다.

**ARP 스푸핑(ARP Spoofing):**
공격자가 거짓 ARP 응답을 보내 피해자의 ARP 캐시를 오염시킵니다. 중간자 공격(MITM)을 가능하게 하여 트래픽을 가로챌 수 있습니다. 대응: 정적 ARP 엔트리, DAI(Dynamic ARP Inspection), 암호화된 통신 사용합니다.

**IPv6의 경우:**
IPv6에서는 ARP 대신 NDP(Neighbor Discovery Protocol)를 사용합니다. ICMPv6 기반으로 더 많은 기능을 제공합니다. Neighbor Solicitation과 Neighbor Advertisement 메시지로 주소를 해석합니다.

**동작 범위:**
ARP는 브로드캐스트를 사용하므로 같은 네트워크(브로드캐스트 도메인) 내에서만 동작합니다. 라우터를 넘어가는 통신에서는 게이트웨이의 MAC 주소를 찾습니다.

**게이트웨이 통신 시:**
호스트 A가 다른 네트워크의 호스트 C와 통신할 때, 목적지 IP는 C의 IP이지만, 목적지 MAC은 게이트웨이(라우터)의 MAC입니다. 라우터는 패킷을 받아 다음 홉으로 전달하며, MAC 주소는 홉마다 변경됩니다.

**ARP 패킷 구조:**
Hardware Type, Protocol Type, Hardware/Protocol Length, Operation(Request/Reply), Sender MAC/IP, Target MAC/IP 필드를 포함합니다.

**실무적 중요성:**
네트워크 연결 문제 시 ARP 캐시를 확인하고 정리하는 것이 기본 해결 방법입니다. "arp -d" 명령으로 캐시를 삭제할 수 있습니다.

---

## 59. 3-Way Handshake에 대해 설명해 주세요.

**3-Way Handshake**는 TCP 연결을 수립하는 과정으로, 양쪽이 통신 준비가 되었음을 확인합니다.

**목적:**
신뢰성 있는 양방향 연결을 설정합니다. 초기 순서 번호(ISN, Initial Sequence Number)를 교환합니다. 양쪽의 수신 능력을 확인합니다. 윈도우 크기, MSS 등의 연결 파라미터를 협상합니다.

**3단계 과정:**

**1단계 - SYN (클라이언트 → 서버):**
클라이언트가 서버에 연결을 요청합니다. SYN(Synchronize) 플래그를 1로 설정합니다. 클라이언트의 초기 순서 번호(ISN_C)를 포함합니다. 예: Seq = 1000, SYN = 1. 클라이언트는 SYN_SENT 상태가 됩니다.

**2단계 - SYN-ACK (서버 → 클라이언트):**
서버가 연결 요청을 수락합니다. SYN 플래그와 ACK(Acknowledgment) 플래그를 모두 1로 설정합니다. 서버의 초기 순서 번호(ISN_S)를 포함합니다. ACK 번호는 클라이언트 ISN + 1입니다. 예: Seq = 2000, Ack = 1001, SYN = 1, ACK = 1. 서버는 SYN_RECEIVED 상태가 됩니다.

**3단계 - ACK (클라이언트 → 서버):**
클라이언트가 서버의 응답을 확인합니다. ACK 플래그를 1로 설정합니다(SYN은 0). ACK 번호는 서버 ISN + 1입니다. 예: Seq = 1001, Ack = 2001, ACK = 1. 이 시점에서 데이터 전송이 가능합니다. 양쪽 모두 ESTABLISHED 상태가 됩니다.

**초기 순서 번호(ISN):**
무작위로 생성되어 보안을 강화합니다. 시간과 연결 정보를 기반으로 계산됩니다. 예측 가능한 ISN은 시퀀스 예측 공격에 취약합니다.

**옵션 협상:**
3-Way Handshake 중에 TCP 옵션을 교환합니다:
- **MSS(Maximum Segment Size)**: 수신할 수 있는 최대 세그먼트 크기
- **윈도우 스케일**: 큰 윈도우 크기 지원
- **SACK 허용**: 선택적 확인 응답 사용 여부
- **타임스탬프**: RTT 측정과 PAWS 지원

**상태 전이:**
- 클라이언트: CLOSED → SYN_SENT → ESTABLISHED
- 서버: CLOSED → LISTEN → SYN_RECEIVED → ESTABLISHED

**왜 3단계가 필요한가:**
2단계만으로는 양방향 통신을 보장할 수 없습니다. 서버도 클라이언트에게 데이터를 보낼 수 있어야 하므로 서버의 ISN도 확인받아야 합니다. 3단계를 통해 양쪽 모두의 송신/수신 능력을 확인합니다.

**오래된 연결 요청 문제:**
네트워크 지연으로 오래된 SYN이 늦게 도착할 수 있습니다. 2-Way만 사용하면 잘못된 연결이 수립될 수 있습니다. 3-Way Handshake는 순서 번호 확인으로 이를 방지합니다.

**타임아웃:**
각 단계에서 응답을 받지 못하면 재전송합니다. 여러 번 시도 후 실패하면 연결 수립을 포기합니다. 일반적으로 SYN은 몇 번 재전송한 후(수십 초) 타임아웃됩니다.

**SYN Flooding 공격:**
공격자가 대량의 SYN 패킷을 보내 서버의 자원을 고갈시킵니다. 서버는 SYN_RECEIVED 상태의 연결을 대기하며 메모리를 소비합니다. 대응: SYN 쿠키, SYN 프록시, 백로그 큐 크기 조정합니다.

**동시 개방(Simultaneous Open):**
양쪽이 동시에 SYN을 보내는 경우도 가능합니다. 4-Way Handshake가 발생하지만 최종적으로 연결이 수립됩니다.

**Fast Open (TCP Fast Open):**
TFO는 3-Way Handshake를 최적화합니다. 첫 SYN에 데이터를 포함하여 전송할 수 있습니다. 재연결 시 1-RTT로 단축됩니다.

**실무 예시:**
웹 브라우저가 서버에 접속할 때, 눈에 보이지 않지만 3-Way Handshake가 먼저 수행됩니다. 이후 HTTP 요청이 전송됩니다. 패킷 캡처 시 항상 SYN, SYN-ACK, ACK 순서를 확인할 수 있습니다.

---

## 60. ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?

**ACK, SYN 같은 제어 정보는 TCP 헤더의 플래그 비트(Control Flags)**를 통해 전달됩니다.

**TCP 헤더 구조:**
TCP 헤더는 최소 20 바이트이며, 여러 필드로 구성됩니다. 13-14번째 바이트에 제어 플래그가 위치합니다. 각 플래그는 1비트로 표현되어 0(비활성) 또는 1(활성) 값을 가집니다.

**주요 제어 플래그:**

**URG(Urgent):**
긴급 데이터가 포함되어 있음을 나타냅니다. 긴급 포인터 필드와 함께 사용됩니다. 현재는 거의 사용되지 않습니다.

**ACK(Acknowledgment):**
확인 응답 번호 필드가 유효함을 나타냅니다. 연결 수립 후 전송되는 모든 세그먼트에 설정됩니다. 수신한 데이터를 확인하는 용도입니다.

**PSH(Push):**
수신 측에서 버퍼에 쌓지 말고 즉시 애플리케이션에 전달하라는 요청입니다. 대화형 애플리케이션(텔넷, SSH)에서 사용됩니다.

**RST(Reset):**
연결을 강제로 종료하거나 잘못된 연결을 거부합니다. 비정상 종료 시 사용됩니다. 존재하지 않는 포트로 연결 시도 시 서버가 RST를 보냅니다.

**SYN(Synchronize):**
연결 수립을 요청하고 초기 순서 번호를 동기화합니다. 3-Way Handshake의 첫 두 단계에서 사용됩니다.

**FIN(Finish):**
연결 종료를 요청합니다. 더 이상 보낼 데이터가 없음을 알립니다. 4-Way Handshake에서 사용됩니다.

**플래그 조합:**
여러 플래그를 동시에 설정할 수 있습니다:
- **SYN**: 연결 요청 (3-Way 1단계)
- **SYN + ACK**: 연결 수락 (3-Way 2단계)
- **ACK**: 확인 응답 (3-Way 3단계 및 데이터 전송)
- **FIN + ACK**: 연결 종료 요청과 데이터 확인
- **RST + ACK**: 연결 리셋과 확인

**실제 전송 과정:**
1. 송신자가 세그먼트를 생성하며 적절한 플래그 비트를 설정합니다
2. TCP 헤더가 완성되어 IP 패킷에 캡슐화됩니다
3. 수신자가 TCP 헤더의 플래그 비트를 확인합니다
4. 플래그에 따라 적절한 동작을 수행합니다(상태 변경, ACK 전송 등)

**TCP 헤더의 다른 중요 필드:**

**순서 번호(Sequence Number):**
전송하는 데이터의 첫 바이트 번호입니다. 순서 보장과 재조립에 사용됩니다.

**확인 응답 번호(Acknowledgment Number):**
다음에 받기를 기대하는 바이트 번호입니다. ACK 플래그가 1일 때만 유효합니다.

**데이터 오프셋(Header Length):**
TCP 헤더의 길이를 나타냅니다(4비트, 32비트 워드 단위). 옵션 필드 때문에 가변 길이입니다.

**윈도우 크기(Window Size):**
수신 가능한 버퍼 크기를 알립니다. 흐름 제어에 사용됩니다.

**체크섬(Checksum):**
헤더와 데이터의 무결성을 검증합니다.

**긴급 포인터(Urgent Pointer):**
URG 플래그가 1일 때 긴급 데이터의 끝을 가리킵니다.

**옵션(Options):**
MSS, 윈도우 스케일, SACK, 타임스탬프 등 추가 정보를 전달합니다. 가변 길이로 0-40 바이트입니다.

**비트 레벨 표현:**
플래그는 실제로는 연속된 비트들입니다. 예: 00011000은 PSH와 ACK가 설정된 것입니다. 네트워크 도구는 이를 읽기 쉽게 표시합니다(예: Flags: [.A....], Flags: [S.], Flags: [S.A...]).

**Wireshark에서의 표시:**
Wireshark는 플래그를 약어로 표시합니다:
- [S] = SYN
- [.] = ACK만 (다른 플래그 없음)
- [S.] = SYN + ACK
- [F.] = FIN + ACK
- [P.] = PSH + ACK
- [R.] = RST

**프로그래밍 관점:**
소켓 프로그래밍에서 개발자는 이러한 플래그를 직접 설정하지 않습니다. connect(), send(), close() 같은 함수를 호출하면 운영체제가 자동으로 적절한 플래그를 설정합니다. 하지만 로우 소켓(Raw Socket)을 사용하면 직접 제어할 수 있습니다.

**보안 스캐닝:**
포트 스캐닝 도구는 다양한 플래그 조합을 보내 서버의 응답을 분석합니다:
- **SYN 스캔**: SYN만 보내고 SYN-ACK 응답 확인
- **FIN 스캔**: FIN을 보내 RST 응답 확인
- **NULL 스캔**: 모든 플래그 0으로 설정
- **Xmas 스캔**: FIN, URG, PSH 동시 설정

**실무적 중요성:**
패킷 분석 시 플래그를 확인하면 연결 상태와 문제를 정확히 파악할 수 있습니다. 비정상적인 플래그 조합은 공격이나 오작동을 의미할 수 있습니다.
