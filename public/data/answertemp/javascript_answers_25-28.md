# JavaScript 답변 25-28

## 질문 25: async/await의 동작 원리와 Promise와의 차이점은 무엇인가요?

**정의:**
async/await는 Promise 기반 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법입니다. async 함수는 항상 Promise를 반환하고, await는 Promise가 완료될 때까지 실행을 일시 중지합니다.

**async 함수의 특징:**
- async 키워드로 선언된 함수는 자동으로 Promise를 반환합니다. 반환값이 Promise로 감싸집니다.
- 일반 값을 반환해도 Promise.resolve로 자동 변환됩니다.
- 에러를 throw하면 거부된 Promise를 반환합니다.
- 함수 내부에서 await를 사용할 수 있습니다.

**await의 동작 원리:**
- await는 Promise가 settled 될 때까지 함수 실행을 일시 중지합니다.
- Promise가 fulfilled되면 결과값을 반환합니다.
- Promise가 rejected되면 에러를 throw합니다.
- await는 async 함수 내부에서만 사용할 수 있습니다. 최상위 레벨에서는 사용 불가합니다.

**Promise와의 차이점:**
- 가독성: async/await는 동기 코드처럼 읽힙니다. Promise 체이닝보다 직관적입니다.
- 에러 처리: try-catch로 통일됩니다. Promise의 catch보다 익숙한 패턴입니다.
- 디버깅: 스택 트레이스가 명확합니다. 중단점을 설정하기 쉽습니다.
- 조건 분기: if-else를 자연스럽게 사용할 수 있습니다. Promise는 중첩이 필요합니다.

**async/await의 장점:**
- 코드 흐름이 명확합니다. 순차적 실행이 한눈에 보입니다.
- 중간 변수를 쉽게 사용할 수 있습니다. 체이닝처럼 클로저가 필요 없습니다.
- 에러 처리가 간단합니다. try-catch 하나로 여러 await를 감쌀 수 있습니다.
- 반복문과 조건문을 자연스럽게 사용합니다.

**병렬 처리 주의사항:**
- 순차적으로 await하면 직렬 실행됩니다. 불필요하게 시간이 오래 걸립니다.
- 병렬 실행이 필요하면 Promise.all을 사용합니다.
- await를 변수 선언과 분리하여 동시 실행을 유도할 수 있습니다.
- 독립적인 작업은 병렬로, 의존적인 작업은 순차로 처리합니다.

**실무 활용:**
- API 호출을 동기 코드처럼 작성합니다. 가독성이 크게 향상됩니다.
- try-catch로 일관된 에러 처리를 구현합니다.
- 순차적 비동기 작업에 최적입니다. 각 단계가 이전 결과에 의존할 때 유용합니다.
- Promise.all과 조합하여 병렬 처리도 가능합니다.
- React에서 데이터 fetching, Node.js에서 파일 처리 등에 널리 사용됩니다.
- 최신 JavaScript의 표준적인 비동기 처리 방식입니다.

---

## 질문 26: 이벤트 루프(Event Loop)의 동작 원리를 설명해주세요.

**정의:**
이벤트 루프는 JavaScript의 비동기 처리를 가능하게 하는 메커니즘입니다. 단일 스레드 환경에서 비블로킹 작업을 수행하며, 콜 스택과 태스크 큐를 관리하여 코드 실행 순서를 제어합니다.

**JavaScript 런타임 구조:**
- Call Stack: 실행 중인 함수를 추적하는 스택입니다. 함수 호출 시 push, 종료 시 pop됩니다.
- Web APIs: 브라우저가 제공하는 비동기 API입니다. setTimeout, fetch, DOM 이벤트 등이 포함됩니다.
- Task Queue: 실행 대기 중인 콜백 함수들이 저장됩니다. 매크로태스크 큐라고도 합니다.
- Microtask Queue: Promise 콜백과 MutationObserver가 저장됩니다. 우선순위가 더 높습니다.

**이벤트 루프의 동작 과정:**
- 콜 스택이 비어있는지 확인합니다. 실행 중인 코드가 없어야 합니다.
- 마이크로태스크 큐를 먼저 확인합니다. 모든 마이크로태스크를 실행합니다.
- 마이크로태스크가 없으면 태스크 큐를 확인합니다. 하나의 태스크를 꺼내 실행합니다.
- 다시 마이크로태스크 큐를 확인합니다. 새로 추가된 마이크로태스크를 모두 실행합니다.
- 이 과정을 반복합니다.

**실행 순서:**
- 동기 코드가 가장 먼저 실행됩니다. 콜 스택에서 바로 처리됩니다.
- 마이크로태스크가 그다음입니다. Promise then, catch, finally가 해당됩니다.
- 매크로태스크가 마지막입니다. setTimeout, setInterval, I/O 작업이 해당됩니다.
- 마이크로태스크는 매크로태스크보다 항상 먼저 실행됩니다.

**논블로킹의 원리:**
- 비동기 작업은 Web API로 위임됩니다. 콜 스택을 차단하지 않습니다.
- 작업 완료 시 콜백이 큐에 추가됩니다.
- 콜 스택이 비면 이벤트 루프가 큐에서 콜백을 가져옵니다.
- 이를 통해 단일 스레드에서도 동시성을 구현합니다.

**setTimeout의 동작:**
- setTimeout은 타이머를 설정하고 즉시 반환됩니다.
- 지정된 시간 후 콜백이 태스크 큐에 추가됩니다.
- 콜 스택이 비고 앞선 태스크들이 처리된 후 실행됩니다.
- 따라서 정확한 시간 보장이 없습니다. 최소 지연 시간일 뿐입니다.

**실무에서의 이해:**
- 무거운 동기 작업은 UI를 멈추게 합니다. 이벤트 루프가 블로킹됩니다.
- 비동기 작업으로 분할하면 응답성을 유지할 수 있습니다.
- Promise 체인보다 마이크로태스크가 먼저 실행됨을 이해해야 합니다.
- 무한 마이크로태스크 생성은 매크로태스크를 영원히 차단할 수 있습니다.
- 이벤트 루프를 이해하면 비동기 코드의 실행 순서를 예측할 수 있습니다.

---

## 질문 27: 마이크로태스크(Microtask)와 매크로태스크(Macrotask)의 차이점은 무엇인가요?

**정의:**
마이크로태스크와 매크로태스크는 이벤트 루프에서 관리하는 두 가지 태스크 큐입니다. 실행 우선순위와 처리 방식이 다르며, 비동기 작업의 실행 순서를 결정합니다.

**마이크로태스크의 특징:**
- Promise의 then, catch, finally 핸들러가 해당됩니다.
- queueMicrotask로 직접 추가할 수도 있습니다.
- MutationObserver 콜백도 마이크로태스크입니다.
- 우선순위가 더 높습니다. 매크로태스크보다 먼저 실행됩니다.
- 큐가 완전히 비워질 때까지 연속 실행됩니다.

**매크로태스크의 특징:**
- setTimeout, setInterval 콜백이 해당됩니다.
- setImmediate는 Node.js의 매크로태스크입니다.
- I/O 작업과 UI 렌더링도 포함됩니다.
- 한 번에 하나씩만 실행됩니다.
- 실행 후 마이크로태스크 큐를 확인합니다.

**실행 우선순위:**
- 동기 코드가 가장 먼저 실행됩니다.
- 모든 마이크로태스크가 다음입니다. 큐가 빌 때까지 계속 실행됩니다.
- 하나의 매크로태스크가 실행됩니다.
- 다시 모든 마이크로태스크를 실행합니다.
- 이 사이클이 반복됩니다.

**이벤트 루프 사이클:**
- 콜 스택을 실행합니다. 동기 코드가 완료될 때까지 진행합니다.
- 마이크로태스크 큐를 모두 비웁니다. 새로 추가되는 것도 즉시 실행합니다.
- 필요시 렌더링을 수행합니다. 브라우저가 화면을 업데이트합니다.
- 하나의 매크로태스크를 실행합니다.
- 다시 마이크로태스크 큐를 확인합니다.

**마이크로태스크의 위험성:**
- 무한 루프를 만들 수 있습니다. 계속 새로운 마이크로태스크를 생성하면 매크로태스크가 실행되지 않습니다.
- UI 렌더링이 차단될 수 있습니다. 마이크로태스크가 끝나야 렌더링이 시작됩니다.
- 타이머가 지연될 수 있습니다. setTimeout 콜백보다 Promise가 먼저 실행됩니다.

**실무에서의 활용:**
- 우선순위가 높은 작업은 마이크로태스크로 처리합니다. Promise를 활용합니다.
- 즉시 실행이 필요하지 않은 작업은 매크로태스크로 처리합니다.
- 상태 업데이트 후 DOM 변경은 마이크로태스크에서 처리하면 한 번에 렌더링됩니다.
- 무거운 계산은 여러 매크로태스크로 분할하여 UI를 유지합니다.
- 실행 순서를 정확히 이해하면 버그를 예방할 수 있습니다.

---

## 질문 28: Promise.all(), Promise.race(), Promise.allSettled()의 차이점은 무엇인가요?

**정의:**
이들은 여러 Promise를 다루는 정적 메서드들입니다. 각각 다른 방식으로 Promise 배열을 처리하며, 병렬 비동기 작업에 활용됩니다.

**Promise.all의 특징:**
- 모든 Promise가 fulfilled될 때까지 기다립니다.
- 모든 결과를 배열로 반환합니다. 입력 순서대로 결과가 정렬됩니다.
- 하나라도 rejected되면 즉시 전체가 실패합니다. 첫 번째 에러를 반환합니다.
- 나머지 Promise는 계속 실행되지만 결과는 무시됩니다.
- 모든 작업이 성공해야 하는 경우에 사용합니다.

**Promise.race의 특징:**
- 가장 먼저 settled되는 Promise의 결과를 반환합니다.
- 성공이든 실패든 상관없이 첫 번째 결과를 사용합니다.
- 나머지 Promise는 계속 실행되지만 결과는 무시됩니다.
- 타임아웃 구현에 유용합니다. Promise와 타이머를 경쟁시킵니다.
- 여러 소스 중 가장 빠른 응답을 사용할 때 적합합니다.

**Promise.allSettled의 특징:**
- 모든 Promise가 settled될 때까지 기다립니다. 성공 실패 관계없이 모두 대기합니다.
- 각 Promise의 상태와 값/에러를 모두 반환합니다.
- 절대 rejected되지 않습니다. 항상 fulfilled됩니다.
- 각 결과는 status와 value 또는 reason을 포함합니다.
- 일부 실패해도 다른 결과를 확인해야 할 때 사용합니다.

**Promise.any의 특징:**
- 가장 먼저 fulfilled되는 Promise의 결과를 반환합니다.
- 실패한 Promise는 무시하고 성공만 기다립니다.
- 모두 rejected되면 AggregateError를 발생시킵니다.
- 여러 대안 중 하나만 성공하면 되는 경우에 사용합니다.

**사용 사례 비교:**
- Promise.all: 여러 API를 병렬 호출하고 모든 결과가 필요할 때 사용합니다. 페이지 초기화 시 여러 데이터를 동시에 로드합니다.
- Promise.race: 타임아웃을 구현하거나 가장 빠른 서버를 선택할 때 사용합니다.
- Promise.allSettled: 여러 작업의 성공 실패를 모두 확인해야 할 때 사용합니다. 배치 처리 결과를 로깅합니다.
- Promise.any: 여러 미러 서버 중 하나만 응답하면 되는 경우에 사용합니다.

**실무 활용:**
- 병렬 API 호출로 성능을 개선합니다. 순차 호출보다 빠릅니다.
- Promise.all과 async/await를 조합하여 효율적인 코드를 작성합니다.
- 에러 처리 전략에 따라 적절한 메서드를 선택합니다.
- Promise.allSettled로 부분 실패를 허용하는 견고한 시스템을 만듭니다.
- 타임아웃이 필요한 네트워크 요청은 Promise.race로 구현합니다.

---
