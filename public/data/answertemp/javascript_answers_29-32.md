# JavaScript 답변 29-32

## 질문 29: 구조 분해 할당(Destructuring)에 대해 설명해주세요.

**정의:**
구조 분해 할당은 배열이나 객체의 속성을 해체하여 개별 변수에 할당하는 JavaScript 표현식입니다. 코드를 간결하게 만들고 필요한 값만 추출할 수 있습니다.

**배열 구조 분해:**
- 배열의 요소를 순서대로 변수에 할당합니다. 인덱스 순서를 따릅니다.
- 일부 요소를 건너뛸 수 있습니다. 빈 칸을 두면 해당 요소는 무시됩니다.
- 기본값을 설정할 수 있습니다. undefined인 경우 기본값이 사용됩니다.
- 나머지 요소를 배열로 수집할 수 있습니다. rest 연산자를 사용합니다.
- 변수 교환을 간단히 할 수 있습니다. 임시 변수 없이 가능합니다.

**객체 구조 분해:**
- 속성 이름과 일치하는 변수에 값을 할당합니다. 순서는 상관없습니다.
- 다른 변수명을 사용할 수 있습니다. 콜론으로 새 이름을 지정합니다.
- 중첩된 객체도 분해할 수 있습니다. 깊은 속성에 접근합니다.
- 기본값을 설정할 수 있습니다. 속성이 없거나 undefined일 때 사용됩니다.
- 나머지 속성을 객체로 수집할 수 있습니다.

**함수 매개변수 구조 분해:**
- 객체를 매개변수로 받아 즉시 분해합니다.
- 필요한 속성만 추출하여 사용합니다.
- 기본값을 설정하여 옵션 매개변수를 구현합니다.
- 가독성이 높아지고 순서에 구애받지 않습니다.

**구조 분해의 장점:**
- 코드가 간결해집니다. 반복적인 점 표기법을 줄입니다.
- 가독성이 향상됩니다. 사용할 변수를 명확히 보여줍니다.
- 필요한 값만 추출합니다. 불필요한 데이터를 무시할 수 있습니다.
- 함수 반환값을 쉽게 처리합니다. 여러 값을 배열이나 객체로 반환받습니다.

**실무 활용 사례:**
- React에서 props와 state를 구조 분해합니다. 컴포넌트 코드가 깔끔해집니다.
- API 응답에서 필요한 필드만 추출합니다.
- 설정 객체에서 옵션을 꺼냅니다. 기본값과 함께 사용합니다.
- 배열의 첫 번째 요소와 나머지를 분리합니다.
- import 문에서 필요한 모듈만 가져옵니다.
- 함수가 여러 값을 반환할 때 받는 쪽에서 분해합니다.

---

## 질문 30: 스프레드 연산자(Spread Operator)와 레스트 파라미터(Rest Parameter)의 차이점은 무엇인가요?

**정의:**
스프레드 연산자와 레스트 파라미터는 모두 세 개의 점 문법을 사용하지만 반대 방향으로 동작합니다. 스프레드는 배열이나 객체를 펼치고, 레스트는 여러 요소를 하나로 모읍니다.

**스프레드 연산자의 특징:**
- 배열이나 객체를 개별 요소로 펼칩니다. 전개한다고 표현합니다.
- 배열 복사와 병합에 사용됩니다. 얕은 복사가 수행됩니다.
- 객체 복사와 병합에도 사용됩니다. 속성을 펼쳐서 새 객체를 만듭니다.
- 함수 호출 시 배열을 인수로 펼칩니다.
- 이터러블한 모든 객체에 사용할 수 있습니다.

**레스트 파라미터의 특징:**
- 여러 개의 인수를 배열로 수집합니다. 묶는다고 표현합니다.
- 함수 매개변수에서 가변 인수를 받습니다. 개수가 정해지지 않은 인수를 처리합니다.
- 구조 분해 할당에서 나머지 요소를 수집합니다.
- 항상 마지막 위치에 와야 합니다. 그 이후에 다른 매개변수가 올 수 없습니다.
- 실제 배열입니다. arguments 객체와 달리 배열 메서드를 바로 사용할 수 있습니다.

**사용 위치에 따른 구분:**
- 값을 펼치는 위치에서는 스프레드입니다. 배열 리터럴, 객체 리터럴, 함수 호출에서 사용합니다.
- 값을 수집하는 위치에서는 레스트입니다. 함수 매개변수, 구조 분해 할당에서 사용합니다.
- 문맥에 따라 같은 문법이 다르게 동작합니다.

**스프레드 연산자 활용:**
- 배열 복사: 얕은 복사로 새 배열을 만듭니다. 원본이 보호됩니다.
- 배열 병합: 여러 배열을 하나로 합칩니다. concat보다 간결합니다.
- 배열 요소 추가: 특정 위치에 요소를 삽입할 수 있습니다.
- 함수 인수 전달: 배열을 개별 인수로 펼쳐 전달합니다.
- 객체 복사와 병합: 불변성을 유지하며 객체를 업데이트합니다.

**레스트 파라미터 활용:**
- 가변 인수 함수: 인수 개수에 관계없이 처리합니다.
- 일부 인수 분리: 앞의 인수는 개별 변수로, 나머지는 배열로 받습니다.
- arguments 대체: 더 명확하고 배열 메서드를 바로 사용할 수 있습니다.

**실무 활용 사례:**
- React에서 props를 펼치거나 수집합니다. 불변 업데이트에 활용합니다.
- 배열과 객체를 안전하게 복사하고 수정합니다.
- 유틸리티 함수에서 유연한 인수 처리를 구현합니다.
- 고차 함수에서 인수를 전달하거나 수집합니다.
- 이전 문법보다 간결하고 읽기 쉬운 코드를 작성합니다.

---

## 질문 31: ES6 모듈(import/export)과 CommonJS(require/module.exports)의 차이점은 무엇인가요?

**정의:**
ES6 모듈과 CommonJS는 JavaScript의 두 가지 모듈 시스템입니다. ES6 모듈은 표준 JavaScript 모듈이고, CommonJS는 Node.js에서 사용되던 모듈 시스템입니다.

**ES6 모듈의 특징:**
- 정적 구조입니다. 컴파일 타임에 의존성이 결정됩니다.
- import와 export 키워드를 사용합니다. 선언적이고 명확합니다.
- 최상위 레벨에서만 사용할 수 있습니다. 조건부나 함수 내에서 사용할 수 없습니다.
- 엄격 모드가 기본입니다. 자동으로 strict mode가 적용됩니다.
- this는 undefined입니다. 전역 객체를 가리키지 않습니다.
- 트리 쉐이킹이 가능합니다. 사용하지 않는 코드를 제거할 수 있습니다.

**CommonJS의 특징:**
- 동적 구조입니다. 런타임에 모듈이 로드됩니다.
- require와 module.exports를 사용합니다. 함수처럼 호출합니다.
- 어디서든 사용할 수 있습니다. 조건부 로딩이 가능합니다.
- 동기적으로 로드됩니다. 파일을 즉시 읽어옵니다.
- this는 module.exports를 가리킵니다.
- Node.js의 기본 모듈 시스템입니다.

**로딩 방식의 차이:**
- ES6 모듈: 비동기적으로 로드됩니다. 브라우저 환경에 적합합니다. 정적 분석이 가능하여 최적화됩니다.
- CommonJS: 동기적으로 로드됩니다. 서버 환경에 적합합니다. 파일 시스템 접근이 빠르기 때문입니다.

**내보내기와 가져오기:**
- ES6 모듈: named export와 default export를 구분합니다. 여러 named export를 할 수 있습니다. 하나의 default export를 가집니다.
- CommonJS: module.exports에 할당합니다. 객체, 함수, 클래스 등 어떤 값이든 내보낼 수 있습니다.

**호환성과 변환:**
- ES6 모듈은 최신 브라우저와 Node.js에서 지원됩니다. type="module"이 필요합니다.
- Babel이나 TypeScript로 CommonJS로 변환할 수 있습니다.
- Webpack 같은 번들러가 두 시스템을 모두 처리합니다.
- Node.js에서는 .mjs 확장자나 package.json 설정으로 구분합니다.

**실무에서의 선택:**
- 새 프로젝트는 ES6 모듈을 사용합니다. 표준이며 미래 지향적입니다.
- 브라우저용 코드는 ES6 모듈이 적합합니다.
- 레거시 Node.js 프로젝트는 CommonJS를 유지할 수 있습니다.
- 라이브러리는 둘 다 지원하도록 빌드합니다.
- 트리 쉐이킹을 활용하려면 ES6 모듈을 사용해야 합니다.

---

## 질문 32: ES6 Class 문법과 프로토타입 기반 상속의 차이점은 무엇인가요?

**정의:**
ES6 Class는 프로토타입 기반 상속을 더 직관적인 문법으로 작성할 수 있게 해주는 문법적 설탕입니다. 내부적으로는 여전히 프로토타입을 사용하지만 클래스 기반 언어처럼 보입니다.

**Class 문법의 특징:**
- class 키워드로 선언합니다. 명확하고 읽기 쉽습니다.
- constructor로 인스턴스를 초기화합니다. 생성자 역할을 명시적으로 정의합니다.
- 메서드를 간결하게 정의합니다. 프로토타입에 자동으로 추가됩니다.
- extends로 상속을 선언합니다. 프로토타입 체인을 자동으로 설정합니다.
- super로 부모 클래스에 접근합니다. 부모의 생성자와 메서드를 호출합니다.

**프로토타입 방식과의 비교:**
- 문법: Class는 선언적이고 명확합니다. 프로토타입은 명시적으로 설정해야 합니다.
- 가독성: Class가 훨씬 읽기 쉽습니다. 의도가 명확히 드러납니다.
- 상속: Class는 extends 하나로 해결됩니다. 프로토타입은 여러 단계가 필요합니다.
- 동작: 내부적으로는 동일합니다. 프로토타입 체인을 사용합니다.

**Class만의 특징:**
- 호이스팅되지 않습니다. TDZ가 적용됩니다. 선언 전에 사용할 수 없습니다.
- 엄격 모드가 기본입니다. 자동으로 strict mode가 적용됩니다.
- new 없이 호출할 수 없습니다. TypeError가 발생합니다. 생성자 함수는 가능했습니다.
- 메서드는 열거되지 않습니다. enumerable이 false입니다.

**정적 메서드와 속성:**
- static 키워드로 정의합니다. 클래스 자체의 메서드와 속성입니다.
- 인스턴스가 아닌 클래스에서 호출합니다.
- 유틸리티 함수나 팩토리 메서드로 사용됩니다.
- 프로토타입에 추가되지 않습니다.

**private 필드:**
- 해시 기호로 시작합니다. 클래스 내부에서만 접근 가능합니다.
- 진정한 캡슐화를 제공합니다. 외부에서 접근할 수 없습니다.
- 비교적 최근에 추가된 기능입니다.

**실무에서의 사용:**
- 객체 지향 패턴을 구현할 때 Class를 사용합니다. 더 명확하고 유지보수하기 쉽습니다.
- React 클래스 컴포넌트에서 사용됩니다. 하지만 Hooks로 대체되는 추세입니다.
- 복잡한 상속 구조는 Class로 표현하기 쉽습니다.
- TypeScript와 잘 어울립니다. 타입 정의가 자연스럽습니다.
- 프로토타입의 동작 원리를 이해하면 Class도 더 잘 사용할 수 있습니다.
- 함수형 프로그래밍이 선호되면서 Class 사용이 줄어드는 경향도 있습니다.

---
