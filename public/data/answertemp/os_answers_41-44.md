# OS 답변 41-44

## 41. 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?

**최적 선택: 비선점형 FCFS 또는 우선순위 스케줄링**

**비선점형 스케줄링이 적합한 이유**

**중단 없는 실행 보장**
- 한번 CPU를 할당받으면 자발적으로 반납할 때까지 실행됩니다
- 타이머 인터럽트에 의한 선점이 없습니다
- 작업 완료를 보장할 수 있습니다
- 예측 가능한 실행 시간을 제공합니다

**컨텍스트 스위칭 최소화**
- 프로세스 전환이 최소화됩니다
- 오버헤드가 거의 없습니다
- CPU 효율성이 최대화됩니다

**실시간 응답 보장**
- 긴급한 작업을 중단 없이 처리할 수 있습니다
- 지터(jitter)가 없습니다
- 시간 제약이 있는 작업에 적합합니다

**권장 알고리즘**

**1. Priority Scheduling (비선점형)**

**설정 방법**
- 상시 프로세스에 최고 우선순위 부여
- 다른 프로세스보다 항상 먼저 실행
- 비선점형으로 설정하여 중단 방지

**장점**
- 중요한 프로세스를 우선 처리
- 다른 프로세스와 공존 가능
- 유연한 정책 적용

**주의사항**
- 다른 프로세스의 기아 현상 발생 가능
- 우선순위 설정을 신중히 해야 함

**2. 단독 실행 모드**

**전용 시스템**
- 해당 프로세스만 실행
- 다른 프로세스를 생성하지 않음
- 멀티태스킹 불필요

**적합한 경우**
- 임베디드 시스템
- 전용 제어 시스템
- 단일 목적 장치

**3. 실시간 스케줄링**

**Rate Monotonic (RM)**
- 주기적 작업에 적합
- 정적 우선순위
- 수학적으로 분석 가능

**특징**
- 주기가 짧을수록 높은 우선순위
- CPU 이용률 69% 이하에서 스케줄 가능성 보장
- 예측 가능한 동작

**고려사항**

**싱글 스레드 CPU의 특성**
- 한 번에 하나의 작업만 실행 가능
- 병렬성이 없음
- 스케줄링이 더욱 중요

**상시 실행의 의미**
- 정말로 100% CPU 사용이 필요한가?
- 주기적 실행인가, 연속 실행인가?
- I/O 대기는 없는가?

**다른 프로세스와의 관계**
- 완전히 독점적인가?
- 백그라운드 작업 허용 가능한가?
- 우선순위만 높으면 되는가?

**시나리오별 권장**

**100% CPU 독점 필요**
- 다른 프로세스 없이 단독 실행
- 스케줄러 불필요
- 베어메탈 또는 RTOS 고려

**주기적 실행 (예: 10ms마다)**
- Rate Monotonic 스케줄링
- 타이머 인터럽트로 깨우기
- 실행 후 sleep

**높은 우선순위 유지**
- Priority Scheduling (비선점형)
- 최고 우선순위 설정
- 백그라운드에서 다른 작업 허용

**대안: 선점형 스케줄링**

**높은 우선순위 + 선점형**
- 긴급한 경우 다른 작업 선점 가능
- 유연성 증가
- 하지만 컨텍스트 스위칭 오버헤드 존재

**Round Robin은 부적합**
- 강제로 CPU를 빼앗김
- 공정한 분배이지만 상시 실행 보장 안 됨
- 응답 시간이 예측 불가능

**실무 예시**

**임베디드 제어 시스템**
- 모터 제어 루프
- 센서 데이터 수집
- 비선점형 스케줄링 사용
- 다른 작업은 낮은 우선순위로 백그라운드 실행

**실시간 데이터 처리**
- 네트워크 패킷 처리
- 비디오 인코딩
- 높은 우선순위 + 실시간 스케줄링

**리눅스에서의 구현**

**SCHED_FIFO**
- 실시간 FIFO 스케줄링
- 비선점형 (같은 우선순위 내에서)
- 다른 일반 프로세스보다 우선

**SCHED_DEADLINE**
- 마감 시간 기반 스케줄링
- 실시간 보장
- 리눅스 3.14 이상

**nice 값 -20**
- 최고 우선순위 (일반 스케줄러 내)
- root 권한 필요
- CFS 스케줄러에서 사용

**주의사항**

**시스템 안정성**
- 다른 필수 시스템 프로세스 고려
- 커널 작업도 CPU 필요
- 완전히 독점하면 시스템 멈출 수 있음

**인터럽트 처리**
- 하드웨어 인터럽트는 여전히 발생
- 인터럽트 핸들러가 프로세스 중단 가능
- 인터럽트를 막으면 위험

**실무 활용**
산업 제어 시스템에서는 실시간 리눅스(RT-PREEMPT 패치)나 RTOS를 사용하여 엄격한 타이밍 보장을 구현합니다. 일반 리눅스에서는 SCHED_FIFO와 높은 우선순위를 조합하여 사용합니다.

---

## 42. 동시성과 병렬성의 차이에 대해 설명해 주세요.

**동시성(Concurrency)**

**정의**
- 여러 작업이 동시에 진행되는 것처럼 보이는 것입니다
- 실제로는 빠르게 전환하며 순차적으로 실행됩니다
- 논리적 개념입니다

**특징**
- 단일 코어에서도 구현 가능합니다
- 컨텍스트 스위칭을 통해 달성됩니다
- 시간을 쪼개어 여러 작업을 처리합니다
- 작업 간 빠른 전환이 핵심입니다

**구현 방법**
- 멀티태스킹: 프로세스/스레드 전환
- 시분할: Time Slicing
- 비동기 I/O: 이벤트 기반 처리
- 코루틴: 협력적 멀티태스킹

**예시**
- 싱글 코어에서 여러 프로그램 실행
- 웹 브라우저에서 탭 전환
- 운영체제의 프로세스 스케줄링
- Node.js의 이벤트 루프

**장점**
- 응답성 향상
- 자원 활용 효율화
- I/O 대기 시간 활용

**병렬성(Parallelism)**

**정의**
- 여러 작업이 실제로 동시에 실행되는 것입니다
- 물리적으로 동시 실행입니다
- 하드웨어 기반 개념입니다

**특징**
- 여러 코어 또는 프로세서가 필요합니다
- 실제로 동시에 작업을 수행합니다
- 물리적 병렬 실행 능력이 필수입니다
- 진정한 동시 실행입니다

**구현 방법**
- 멀티코어 프로세서
- 멀티프로세서 시스템
- GPU 병렬 처리
- 분산 시스템

**예시**
- 4코어 CPU에서 4개 스레드 동시 실행
- 행렬 곱셈의 GPU 병렬 처리
- 분산 데이터베이스의 쿼리 처리
- 멀티프로세싱 계산

**장점**
- 실제 성능 향상
- 처리 시간 단축
- 대용량 데이터 처리

**핵심 차이점**

**실행 방식**
- 동시성: 번갈아가며 실행 (interleaved)
- 병렬성: 동시에 실행 (simultaneous)

**하드웨어 요구사항**
- 동시성: 싱글 코어도 가능
- 병렬성: 멀티 코어/프로세서 필수

**목적**
- 동시성: 구조와 설계 (응답성, 자원 활용)
- 병렬성: 성능 (속도 향상)

**척도**
- 동시성: 얼마나 많은 작업을 다룰 수 있는가
- 병렬성: 얼마나 빠르게 처리할 수 있는가

**비유**

**동시성**
- 한 사람이 여러 작업을 번갈아가며 수행
- 요리사가 여러 요리를 동시에 만드는 것
- 빠르게 전환하며 진행

**병렬성**
- 여러 사람이 각자 작업 수행
- 여러 요리사가 각자 요리하는 것
- 실제로 동시에 진행

**관계**

**동시성 ⊃ 병렬성**
- 병렬성은 동시성의 한 형태입니다
- 동시성이 있어도 병렬성이 없을 수 있습니다
- 병렬성이 있으면 동시성도 있습니다

**조합**
- 멀티코어 시스템에서 둘 다 사용
- 코어 수보다 많은 스레드: 동시성 + 병렬성
- 스케줄링과 병렬 실행 결합

**프로그래밍 관점**

**동시성 프로그래밍**
- 여러 작업을 구조화
- 스레드, 코루틴, async/await
- 동기화와 통신에 집중
- 데드락, 레이스 컨디션 주의

**병렬 프로그래밍**
- 작업을 여러 부분으로 분할
- 데이터 병렬성, 작업 병렬성
- 부하 분산에 집중
- 통신 오버헤드 최소화

**실제 시스템**

**싱글 코어**
- 동시성: ✓
- 병렬성: ✗
- 컨텍스트 스위칭으로 동시성 구현

**멀티 코어 (4코어)**
- 최대 4개 작업 병렬 실행
- 그 이상은 동시성으로 처리
- 동시성과 병렬성 모두 활용

**언어별 지원**

**Go**
- 고루틴: 동시성
- 멀티코어 활용: 병렬성
- GOMAXPROCS로 제어

**Python**
- 스레드: 동시성 (GIL로 인해 병렬성 제한)
- 멀티프로세싱: 병렬성
- asyncio: 동시성

**Java**
- 스레드: 동시성 + 병렬성
- ExecutorService: 스레드 풀
- Fork/Join 프레임워크: 병렬 처리

**성능 고려**

**동시성의 성능**
- 전체 시간은 거의 동일하거나 증가
- 응답성과 처리량은 향상
- I/O 대기 시간 활용

**병렬성의 성능**
- 전체 시간 단축 가능
- 이상적: 1/n (n = 코어 수)
- 실제: Amdahl's Law에 의한 제한

**Amdahl's Law**
- 병렬화 가능한 부분만 속도 향상
- 순차 부분이 병목이 됨
- 완벽한 선형 가속은 어려움

**실무 선택 기준**

**동시성 사용**
- I/O 바운드 작업
- 많은 요청 처리 (웹 서버)
- 응답성이 중요한 GUI
- 비동기 이벤트 처리

**병렬성 사용**
- CPU 바운드 작업
- 과학 계산, 데이터 분석
- 이미지/비디오 처리
- 대용량 데이터 처리

**실무 활용**
웹 서버는 동시성(수천 개 연결 처리)과 병렬성(멀티코어 활용)을 모두 사용합니다. 데이터 과학에서는 병렬 처리로 분석 속도를 높이고, 동시성으로 여러 실험을 관리합니다.

---

## 43. 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?

**기존 스케줄러의 문제점**

**FCFS의 문제**
- Convoy Effect: 긴 프로세스가 짧은 프로세스를 지연시킴
- 평균 대기 시간이 길어짐
- 응답 시간 예측 불가능

**SJF의 문제**
- 실행 시간을 미리 알 수 없음
- 긴 프로세스의 기아 현상
- 비현실적임

**Priority Scheduling의 문제**
- 낮은 우선순위 프로세스의 기아 현상
- 우선순위를 어떻게 결정할 것인가?
- 정적 우선순위의 한계

**Round Robin의 문제**
- 모든 프로세스를 동등하게 취급
- 짧은 작업과 긴 작업을 구분하지 못함
- Time Quantum 설정의 어려움

**Multi-level Queue의 문제**
- 프로세스가 큐 간 이동 불가
- 초기 분류 오류 시 성능 저하
- 하위 큐의 기아 현상
- 유연성 부족

**MLFQ가 해결하는 문제들**

**1. 프로세스 특성 자동 분류**

**문제**
- CPU bound vs I/O bound를 미리 알기 어려움
- 프로세스 특성이 런타임에 변할 수 있음

**MLFQ 해결책**
- 실행 패턴을 관찰하여 자동으로 분류
- CPU 많이 사용 → 하위 큐로 이동
- I/O 위주 → 상위 큐 유지
- 적응형 우선순위 조정

**효과**
- 대화형 프로세스: 빠른 응답
- 배치 프로세스: 처리량 최적화
- 자동으로 최적의 처리 방식 적용

**2. 기아 현상 방지**

**문제**
- Priority Scheduling에서 낮은 우선순위 프로세스가 영원히 대기
- Multi-level Queue에서 하위 큐 실행 안 됨

**MLFQ 해결책**
- Aging: 오래 대기한 프로세스의 우선순위 상승
- 주기적으로 모든 프로세스를 최상위 큐로 승격
- Priority Boost 메커니즘

**효과**
- 모든 프로세스가 결국 실행됨
- 공정성 보장
- 시스템 안정성 향상

**3. 실행 시간 예측 불필요**

**문제**
- SJF는 실행 시간을 미리 알아야 함
- 현실적으로 불가능

**MLFQ 해결책**
- 과거 행동을 기반으로 미래 예측
- 실행하면서 특성 파악
- 점진적 우선순위 조정

**효과**
- 실제 시스템에서 구현 가능
- 짧은 작업은 자동으로 빨리 완료
- 긴 작업은 낮은 우선순위로 처리

**4. 응답 시간과 처리량 동시 최적화**

**문제**
- 응답 시간 vs 처리량은 트레이드오프
- RR: 응답 시간 좋음, 처리량 나쁨
- FCFS: 처리량 좋음, 응답 시간 나쁨

**MLFQ 해결책**
- 상위 큐: 짧은 Time Quantum, 빠른 응답
- 하위 큐: 긴 Time Quantum, 높은 처리량
- 프로세스 특성에 맞게 자동 배치

**효과**
- 대화형 작업: 빠른 응답
- 배치 작업: 효율적 처리
- 전체 시스템 성능 최적화

**5. 동적 우선순위 조정**

**문제**
- 정적 우선순위는 변화하는 상황에 대응 못함
- 프로세스 특성이 실행 중 변할 수 있음

**MLFQ 해결책**
- 실시간으로 우선순위 조정
- CPU 사용 패턴에 따라 큐 이동
- I/O 후 우선순위 상승

**효과**
- 프로세스 단계별 최적화
- 초기화는 빠르게, 계산은 배치로
- 유연한 적응

**6. 게임 방지 (Gaming Prevention)**

**문제**
- 프로세스가 스케줄러를 속일 수 있음
- 예: Time Quantum 만료 직전 I/O 요청

**MLFQ 해결책**
- 전체 CPU 사용 시간 추적
- I/O 후 우선순위 상승 제한
- 우선순위 부스트 주기 조정

**효과**
- 공정한 CPU 시간 배분
- 악의적 프로세스 대응
- 시스템 안정성

**MLFQ의 핵심 규칙**

**규칙 1**: Priority(A) > Priority(B) → A 실행
**규칙 2**: Priority(A) == Priority(B) → RR로 실행
**규칙 3**: 새 프로세스는 최상위 큐에 진입
**규칙 4**: Time Quantum 소진 시 하위 큐로 이동
**규칙 5**: I/O 대기 후 같은 큐 유지 (개선: 하락 방지)
**규칙 6**: 일정 시간 후 모든 프로세스를 최상위 큐로 (Aging)

**실제 구현 예시**

**리눅스 CFS 이전**
- O(1) 스케줄러가 MLFQ 개념 사용
- 140개 우선순위 레벨
- Active/Expired 배열

**Windows**
- 32단계 우선순위
- Priority Boost 메커니즘
- 동적 우선순위 조정

**FreeBSD**
- ULE 스케줄러
- 다단계 피드백 큐 사용
- 인터랙티브 점수 계산

**비교 정리**

| 알고리즘 | 응답시간 | 처리량 | 기아 | 예측필요 | 공정성 |
|---------|---------|--------|------|----------|--------|
| FCFS | 나쁨 | 중간 | ✗ | ✗ | 중간 |
| SJF | 좋음 | 좋음 | ✓ | ✓ | 나쁨 |
| RR | 좋음 | 나쁨 | ✗ | ✗ | 좋음 |
| Priority | 중간 | 중간 | ✓ | ✗ | 나쁨 |
| MLFQ | 좋음 | 좋음 | ✗ | ✗ | 좋음 |

**단점과 한계**

**복잡성**
- 구현이 복잡함
- 파라미터 튜닝 필요
- 디버깅 어려움

**오버헤드**
- 우선순위 조정 비용
- 큐 간 이동 관리
- 통계 수집

**파라미터 의존성**
- 큐 개수, Time Quantum, 부스트 주기 등
- 워크로드에 따라 최적값이 다름

**실무 활용**
MLFQ는 범용 운영체제의 기본이 되었으며, 현대 스케줄러들은 이를 기반으로 더욱 개선되었습니다. 하지만 대부분의 현대 시스템은 CFS 같은 더 공정한 스케줄러로 진화했습니다.

---

## 44. FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?

**FIFO가 유용한 이유**

**단순성과 예측 가능성**
- 구현이 매우 간단합니다
- 동작을 쉽게 이해하고 예측할 수 있습니다
- 디버깅이 용이합니다
- 오버헤드가 거의 없습니다

**공정성**
- 먼저 온 순서대로 처리합니다
- 직관적으로 공정합니다
- 특정 프로세스를 차별하지 않습니다

**적합한 시나리오**

**1. 일괄 처리 시스템 (Batch Processing)**

**특징**
- 작업들이 미리 제출됩니다
- 대화형 응답이 필요 없습니다
- 순서대로 처리하면 됩니다

**예시**
- 급여 계산 시스템
- 월말 결산 처리
- 백업 작업
- 대용량 데이터 변환

**장점**
- 간단하고 명확한 처리 순서
- 관리 용이
- 예측 가능한 완료 시간

**2. 프린터 큐**

**이유**
- 인쇄 작업은 중간에 중단할 수 없습니다
- 먼저 요청한 문서를 먼저 인쇄하는 것이 공정합니다
- 사용자가 순서를 이해하기 쉽습니다

**동작**
- FIFO 큐에 작업 추가
- 프린터가 한 번에 하나씩 처리
- 완료 후 다음 작업 진행

**3. 실시간 시스템 (특정 조건)**

**SCHED_FIFO (리눅스)**
- 실시간 FIFO 스케줄링
- 같은 우선순위 내에서 FIFO
- 비선점형 특성 활용

**사용 사례**
- 고정된 순서로 실행되어야 하는 작업
- 예측 가능한 타이밍 필요
- 중단되면 안 되는 제어 루프

**예시**
- 산업 제어 시스템
- 로봇 제어
- 데이터 수집 시스템

**4. 단순한 임베디드 시스템**

**이유**
- 리소스가 제한적입니다
- 복잡한 스케줄러의 오버헤드를 피해야 합니다
- 예측 가능한 동작이 중요합니다

**특징**
- 작업 수가 적습니다
- 워크로드가 일정합니다
- 실시간 요구사항이 덜 엄격합니다

**예시**
- 간단한 센서 모니터링
- 디스플레이 컨트롤러
- 키패드 입력 처리

**5. 작업 크기가 비슷한 경우**

**이유**
- Convoy Effect가 최소화됩니다
- 모든 작업이 비슷한 시간이 걸리면 문제없습니다
- 평균 대기 시간도 합리적입니다

**예시**
- 고정 크기 패킷 처리
- 동일한 크기의 이미지 처리
- 표준화된 트랜잭션 처리

**6. 메시지 큐 시스템**

**적용**
- 메시지는 도착 순서대로 처리됩니다
- 순서 보장이 중요한 경우
- 이벤트 순서가 의미를 가질 때

**예시**
- 주문 처리 시스템
- 로그 처리 파이프라인
- 이벤트 스트리밍

**7. 네트워크 라우터/스위치**

**기본 큐잉**
- 패킷을 FIFO 순서로 전송
- 간단하고 빠름
- QoS가 필요 없는 경우

**장점**
- 낮은 레이턴시
- 간단한 하드웨어 구현
- 예측 가능한 순서

**8. 테스트 및 벤치마킹**

**용도**
- 기준선(baseline) 성능 측정
- 다른 스케줄러와 비교
- 시스템 동작 이해

**이유**
- 단순하여 분석하기 쉬움
- 예측 가능한 결과
- 변수 최소화

**9. 공정성이 최우선인 경우**

**시나리오**
- 사용자 간 공정성이 중요
- 먼저 요청한 사람이 우선되어야 함
- 특별 대우가 없어야 함

**예시**
- 티켓팅 시스템
- 예약 시스템
- 고객 서비스 큐

**10. 짧은 수명 프로세스**

**특징**
- 모든 프로세스가 빨리 완료됨
- 스케줄링 결정을 자주 할 필요 없음
- 컨텍스트 스위칭 최소화

**성능 우위**
- 스케줄링 오버헤드 감소
- 단순성의 이점 극대화

**FIFO의 장점**

**구현 비용**
- 코드가 간단함
- 메모리 오버헤드 최소
- CPU 사이클 낭비 없음

**예측 가능성**
- 대기 시간 계산 가능
- SLA 보장 용이
- 디버깅 쉬움

**공정성**
- 차별 없음
- 투명한 정책
- 사용자 신뢰

**FIFO를 피해야 할 경우**

**대화형 시스템**
- 응답 시간이 중요
- 사용자 경험 저하
- Round Robin 등이 낫습니다

**작업 크기 편차 큼**
- Convoy Effect 발생
- 긴 작업이 짧은 작업 지연
- SJF 또는 MLFQ 권장

**우선순위 필요**
- 중요한 작업 우선 처리
- 긴급 작업 대응
- Priority Scheduling 필요

**리눅스의 SCHED_FIFO**

**특징**
- 실시간 스케줄링 정책
- 우선순위 기반 + FIFO
- 일반 프로세스보다 우선

**사용법**
- 실시간 애플리케이션
- 오디오/비디오 처리
- 제어 시스템

**주의**
- root 권한 필요
- 시스템 전체에 영향 가능
- 신중히 사용

**실무 활용**
FIFO는 간단한 시스템이나 특수 목적 애플리케이션에서 여전히 유용합니다. 복잡한 스케줄러가 필요 없는 경우, FIFO의 단순성과 예측 가능성이 오히려 장점이 됩니다.
