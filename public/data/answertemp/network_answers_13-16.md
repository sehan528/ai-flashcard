# Network 답변 13-16

## 질문 13: HTTP Method의 멱등성에 대해 설명해 주세요.

멱등성(Idempotency)은 동일한 요청을 여러 번 수행해도 결과가 동일함을 의미합니다. HTTP Method 중 일부는 멱등성을 가지며, 이는 안전한 재시도와 시스템 설계에 중요합니다.

**멱등성의 정의:**

첫째, 여러 번 호출해도 결과가 같습니다. 한 번 호출하나 열 번 호출하나 서버 상태가 동일합니다. 부작용이 반복되지 않습니다. 클라이언트 입장에서 안전하게 재시도할 수 있습니다.

둘째, 서버의 상태 변화가 중요합니다. 응답 코드나 응답 바디는 달라질 수 있습니다. 하지만 서버의 리소스 상태는 동일해야 합니다. 예를 들어 첫 DELETE는 200을 반환하고, 두 번째는 404를 반환할 수 있지만 리소스는 이미 삭제된 상태로 동일합니다.

**멱등성을 가지는 Method:**

첫째, GET입니다. 리소스를 조회만 합니다. 서버 상태를 변경하지 않습니다. 몇 번을 조회해도 같은 결과입니다. 안전(Safe)하기도 합니다.

둘째, PUT입니다. 리소스를 완전히 대체합니다. 같은 데이터로 여러 번 PUT해도 결과는 동일합니다. 첫 번째 호출에서 리소스가 생성되거나 수정됩니다. 이후 호출은 같은 상태를 유지합니다.

셋째, DELETE입니다. 리소스를 삭제합니다. 첫 번째 호출에서 삭제됩니다. 이후 호출에서도 리소스는 없는 상태입니다. 상태는 동일하므로 멱등성을 가집니다.

넷째, HEAD입니다. GET과 유사하지만 바디 없이 헤더만 반환합니다. 서버 상태를 변경하지 않습니다. 멱등성과 안전성을 모두 가집니다.

다섯째, OPTIONS입니다. 서버가 지원하는 메서드를 조회합니다. 상태를 변경하지 않습니다. 멱등성과 안전성을 가집니다.

**멱등성을 가지지 않는 Method:**

첫째, POST입니다. 새로운 리소스를 생성합니다. 매번 호출할 때마다 새 리소스가 생성됩니다. 동일한 요청을 두 번 보내면 중복 데이터가 생깁니다. 멱등하지 않습니다.

둘째, PATCH입니다. 리소스를 부분적으로 수정합니다. 구현에 따라 멱등할 수도 있고 아닐 수도 있습니다. 일반적으로는 멱등하지 않다고 간주합니다. 예를 들어 "값을 1 증가"라는 PATCH는 호출할 때마다 값이 변합니다.

**멱등성의 중요성:**

첫째, 안전한 재시도입니다. 네트워크 오류로 응답을 받지 못한 경우 재시도할 수 있습니다. 멱등한 요청은 여러 번 보내도 안전합니다. 중복 실행을 걱정하지 않아도 됩니다.

둘째, 분산 시스템의 안정성입니다. 메시지가 중복 전달될 수 있습니다. 멱등성이 보장되면 중복을 무시할 수 있습니다. 시스템이 더 견고해집니다.

셋째, 캐싱과 최적화입니다. 멱등한 요청은 캐싱하기 좋습니다. 프록시나 CDN에서 안전하게 처리할 수 있습니다.

**실무에서의 고려사항:**

GET 요청에 부작용을 넣으면 안 됩니다. 조회수 증가 같은 것도 엄밀히는 부작용입니다. 하지만 실무에서는 허용하는 경우가 많습니다.

PUT은 전체 교체를 의미합니다. 부분 수정에 PUT을 사용하면 멱등성이 깨질 수 있습니다. 명확하게 전체 데이터를 보내야 합니다.

DELETE는 이미 없는 리소스를 삭제하는 것도 허용합니다. 404를 반환할 수 있지만 멱등성은 유지됩니다.

POST는 멱등하지 않으므로 재시도에 주의해야 합니다. 중복 방지를 위해 별도의 메커니즘이 필요합니다. 멱등성 키(Idempotency Key)를 사용할 수 있습니다.

**멱등성 키 패턴:**

클라이언트가 고유한 키를 생성하여 헤더에 포함합니다. 서버는 같은 키의 요청을 중복으로 간주합니다. 첫 요청만 처리하고 이후는 같은 응답을 반환합니다. POST 같은 비멱등 요청을 멱등하게 만들 수 있습니다.

**안전성과의 차이:**

안전(Safe)한 메서드는 서버 상태를 전혀 변경하지 않습니다. GET, HEAD, OPTIONS가 해당합니다.

멱등한 메서드는 상태를 변경할 수 있지만, 여러 번 호출해도 최종 상태는 같습니다. PUT, DELETE가 해당합니다.

안전하면 항상 멱등하지만, 멱등하다고 항상 안전한 것은 아닙니다.

멱등성은 HTTP의 신뢰성과 확장성을 위한 중요한 개념입니다. RESTful API 설계 시 반드시 고려해야 합니다.

## 질문 14: GET과 POST의 차이는 무엇인가요?

GET과 POST는 가장 많이 사용되는 HTTP 메서드로, 용도와 특성에서 명확한 차이가 있습니다.

**GET의 특징:**

첫째, 리소스 조회 목적입니다. 데이터를 가져오는 데 사용합니다. 서버의 상태를 변경하지 않습니다. 읽기 전용 작업입니다.

둘째, URL에 데이터를 포함합니다. 쿼리 스트링으로 파라미터를 전달합니다. URL에 모든 정보가 노출됩니다. 북마크하거나 공유할 수 있습니다.

셋째, 길이 제한이 있습니다. URL 길이에 제한이 있습니다. 브라우저마다 다르지만 보통 2048자 정도입니다. 많은 데이터를 전송하기 어렵습니다.

넷째, 캐싱이 가능합니다. 같은 URL은 같은 결과를 반환합니다. 브라우저, 프록시, CDN에서 캐시합니다. 성능 향상에 도움이 됩니다.

다섯째, 멱등성과 안전성을 가집니다. 여러 번 호출해도 결과가 같습니다. 서버 상태를 변경하지 않습니다. 재시도해도 안전합니다.

여섯째, 브라우저 히스토리에 남습니다. 뒤로 가기 버튼으로 다시 요청할 수 있습니다. 새로고침해도 경고가 없습니다.

**POST의 특징:**

첫째, 리소스 생성 목적입니다. 새로운 데이터를 서버에 전송합니다. 서버의 상태를 변경합니다. 생성, 업데이트, 삭제 등에 사용합니다.

둘째, 바디에 데이터를 포함합니다. HTTP 메시지 바디에 데이터를 담습니다. URL에 노출되지 않습니다. 보안상 유리합니다.

셋째, 길이 제한이 거의 없습니다. 바디에 담을 수 있는 크기는 서버 설정에 따릅니다. 일반적으로 매우 큽니다. 파일 업로드 등 대용량 데이터 전송에 적합합니다.

넷째, 캐싱되지 않습니다. 기본적으로 캐시하지 않습니다. 매번 서버에 요청이 전달됩니다. 항상 최신 데이터를 처리합니다.

다섯째, 멱등하지 않습니다. 같은 요청을 여러 번 보내면 중복 생성될 수 있습니다. 재시도에 주의가 필요합니다.

여섯째, 브라우저 히스토리 처리가 다릅니다. 뒤로 가기 시 재전송 여부를 묻습니다. 새로고침 시에도 경고가 표시됩니다.

**주요 차이점 정리:**

목적이 다릅니다. GET은 조회, POST는 생성입니다.

데이터 위치가 다릅니다. GET은 URL, POST는 바디입니다.

보안성이 다릅니다. GET은 URL에 노출, POST는 바디에 숨김입니다.

캐싱 여부가 다릅니다. GET은 가능, POST는 불가능입니다.

멱등성이 다릅니다. GET은 멱등, POST는 비멱등입니다.

**보안 측면:**

GET은 URL에 데이터가 노출됩니다. 서버 로그, 브라우저 히스토리, 프록시 로그에 남습니다. 민감한 정보를 전송하면 안 됩니다. 비밀번호나 개인정보는 POST를 사용해야 합니다.

POST도 HTTPS 없이는 안전하지 않습니다. 평문으로 전송되므로 중간에서 탈취될 수 있습니다. HTTPS를 사용해야 진정한 보안이 보장됩니다.

**잘못된 사용 예:**

GET으로 데이터를 생성하거나 수정하면 안 됩니다. 검색 엔진 크롤러가 실수로 작업을 실행할 수 있습니다. 브라우저가 자동으로 재시도하면서 의도치 않은 동작이 발생합니다.

POST로 단순 조회를 하는 것도 비효율적입니다. 캐싱의 이점을 잃습니다. RESTful하지 않습니다.

**RESTful API에서의 사용:**

GET은 리소스 조회에만 사용합니다. 목록 조회, 상세 조회 등입니다.

POST는 리소스 생성에 사용합니다. 새로운 사용자 등록, 새로운 게시글 작성 등입니다.

수정은 PUT이나 PATCH를 사용하는 것이 더 적절합니다. 삭제는 DELETE를 사용합니다.

**실무 팁:**

검색 기능은 GET을 사용합니다. 검색 결과를 북마크하거나 공유할 수 있습니다. 캐싱으로 성능이 향상됩니다.

폼 제출은 POST를 사용합니다. 회원가입, 로그인, 글쓰기 등입니다. 중복 제출을 방지하는 로직이 필요합니다.

파일 업로드는 반드시 POST를 사용합니다. GET으로는 불가능합니다.

GET과 POST는 각각 명확한 목적이 있으므로, 적절히 구분하여 사용해야 합니다.

## 질문 15: POST와 PUT, PATCH의 차이는 무엇인가요?

POST, PUT, PATCH는 모두 데이터를 서버로 전송하지만, 의미와 동작 방식에서 차이가 있습니다.

**POST의 특징:**

첫째, 리소스 생성입니다. 새로운 엔티티를 만듭니다. 서버가 리소스의 URI를 결정합니다. 클라이언트는 어디에 생성될지 모릅니다.

둘째, 비멱등적입니다. 같은 요청을 여러 번 보내면 여러 리소스가 생성됩니다. 중복 실행을 조심해야 합니다.

셋째, 201 Created를 반환합니다. Location 헤더에 생성된 리소스 URI를 포함합니다.

넷째, 컬렉션에 요청합니다. 예를 들어 POST /users는 users 컬렉션에 새 사용자를 추가합니다.

다섯째, 다목적으로 사용됩니다. 생성 외에도 복잡한 연산, 컨트롤러 역할 등에 사용됩니다.

**PUT의 특징:**

첫째, 리소스 교체입니다. 기존 리소스를 완전히 대체합니다. 리소스가 없으면 생성하고, 있으면 덮어씁니다.

둘째, 멱등적입니다. 같은 요청을 여러 번 보내도 결과는 동일합니다. 안전하게 재시도할 수 있습니다.

셋째, 클라이언트가 URI를 알고 있습니다. 특정 리소스에 직접 요청합니다. 예를 들어 PUT /users/123은 ID가 123인 사용자를 대체합니다.

넷째, 전체 데이터를 전송합니다. 부분 데이터만 보내면 나머지는 null이나 기본값으로 덮어씁니다. 명시하지 않은 필드도 영향을 받습니다.

다섯째, 200 OK나 204 No Content를 반환합니다. 생성된 경우 201 Created를 반환할 수도 있습니다.

**PATCH의 특징:**

첫째, 부분 수정입니다. 리소스의 일부만 변경합니다. 명시한 필드만 수정하고 나머지는 유지합니다.

둘째, 일반적으로 비멱등적입니다. 구현에 따라 다를 수 있습니다. 절대값 설정은 멱등하지만, 증감 연산은 비멱등합니다.

셋째, 유연한 수정이 가능합니다. 하나의 필드만 바꿀 수 있습니다. 전체 데이터를 보낼 필요가 없습니다.

넷째, 200 OK나 204 No Content를 반환합니다.

다섯째, JSON Patch 같은 표준 형식이 있습니다. 작업을 명시적으로 기술할 수 있습니다.

**주요 차이점 비교:**

POST는 생성, PUT은 교체, PATCH는 부분 수정입니다.

POST는 컬렉션에, PUT과 PATCH는 특정 리소스에 요청합니다.

POST와 PATCH는 비멱등, PUT은 멱등입니다.

PUT은 전체 데이터 필요, PATCH는 변경 부분만 필요합니다.

**실제 사용 예시:**

회원가입은 POST를 사용합니다. POST /users로 새 사용자를 생성합니다. 서버가 ID를 할당합니다.

사용자 정보 전체 수정은 PUT을 사용합니다. PUT /users/123으로 모든 정보를 보냅니다. 이름, 이메일, 주소 등 전체를 포함합니다.

이메일만 변경은 PATCH를 사용합니다. PATCH /users/123으로 이메일만 보냅니다. 다른 필드는 그대로 유지됩니다.

**PUT 사용 시 주의점:**

전체 데이터를 보내야 합니다. 일부만 보내면 나머지가 삭제될 수 있습니다. 예를 들어 이름만 보내면 이메일이 null이 될 수 있습니다.

클라이언트가 리소스 URI를 알아야 합니다. 보통 GET으로 먼저 조회한 후 수정합니다.

**PATCH 사용 시 주의점:**

서버가 PATCH를 지원해야 합니다. 모든 서버가 지원하는 것은 아닙니다.

부분 수정 로직이 복잡할 수 있습니다. null과 명시하지 않음을 구분해야 합니다.

멱등성이 보장되지 않을 수 있습니다. 재시도에 주의가 필요합니다.

**POST vs PUT 생성:**

POST는 서버가 URI를 정합니다. POST /articles로 새 글을 만들면 서버가 ID를 할당합니다. /articles/456 같은 URI가 생성됩니다.

PUT도 생성할 수 있습니다. PUT /articles/999로 특정 ID의 글을 생성합니다. 클라이언트가 URI를 결정합니다. 일반적이지는 않습니다.

**멱등성의 실제 의미:**

PUT /users/123으로 같은 데이터를 10번 보내도 사용자 123은 같은 상태입니다. 첫 요청이든 열 번째 요청이든 결과는 동일합니다.

POST /users를 10번 보내면 10명의 사용자가 생성됩니다. 각각 다른 ID를 가집니다.

PATCH /users/123으로 "나이 +1"을 10번 보내면 나이가 10 증가합니다. 비멱등적입니다.

**RESTful API 설계:**

명확한 의미를 가지도록 사용해야 합니다. POST는 생성, PUT은 전체 교체, PATCH는 부분 수정입니다. 각 메서드의 의미를 존중해야 합니다.

실무에서는 POST를 과도하게 사용하는 경향이 있습니다. 모든 수정을 POST로 하는 것은 RESTful하지 않습니다. 적절한 메서드를 선택해야 합니다.

POST, PUT, PATCH를 올바르게 구분하여 사용하면 API가 직관적이고 예측 가능해집니다.

## 질문 16: HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

HTTP/1.1 명세는 기술적으로 GET 요청에 바디를 허용하지만, 실무에서는 강력히 권장되지 않습니다. 여러 실용적인 이유가 있습니다.

**명세상의 모호함:**

첫째, 의미가 불명확합니다. HTTP 명세는 GET 바디를 금지하지 않지만, 서버가 무시할 수 있다고 명시합니다. 바디가 있어도 처리하지 않을 수 있습니다. 동작이 보장되지 않습니다.

둘째, RFC 7231의 표현입니다. GET 요청에 바디를 포함하는 것은 "정의되지 않은 의미론"을 가진다고 합니다. 서버는 바디를 무시하거나 거부할 수 있습니다. 명확한 지침이 없습니다.

**인프라의 제한:**

첫째, 프록시와 게이트웨이 문제입니다. 많은 프록시 서버가 GET 바디를 지원하지 않습니다. 바디를 삭제하거나 요청을 거부할 수 있습니다. Nginx, Apache 등 일부 웹 서버도 마찬가지입니다.

둘째, 로드 밸런서 문제입니다. GET 요청을 특별하게 처리하는 경우가 많습니다. 바디가 있으면 예상치 못한 동작이 발생할 수 있습니다. 캐싱 레이어에서 문제가 생깁니다.

셋째, CDN과 캐시 문제입니다. GET은 캐싱 가능한 메서드입니다. 하지만 바디를 고려하지 않고 캐시합니다. URL만 보고 캐시 키를 만듭니다. 같은 URL에 다른 바디를 보내도 같은 결과를 반환할 수 있습니다.

**라이브러리와 도구의 제약:**

첫째, HTTP 클라이언트 라이브러리입니다. 많은 라이브러리가 GET 바디를 지원하지 않거나 복잡합니다. fetch, axios, curl 등에서 불편하거나 불가능합니다. 코드가 복잡해지고 가독성이 떨어집니다.

둘째, 브라우저의 제한입니다. 일부 브라우저는 GET 바디를 무시합니다. XMLHttpRequest나 fetch API에서도 일관되지 않습니다. 크로스 브라우저 호환성 문제가 있습니다.

셋째, 테스트 도구 문제입니다. Postman, Swagger 등 도구가 GET 바디를 잘 지원하지 않을 수 있습니다. API 문서화와 테스트가 어려워집니다.

**의미론적 문제:**

첫째, GET의 의미와 충돌합니다. GET은 안전하고 멱등한 조회 작업입니다. 바디는 서버에 데이터를 전송하는 것을 의미합니다. 의미가 상충됩니다.

둘째, RESTful 원칙 위반입니다. REST에서 GET은 리소스 식별을 URL로 합니다. 바디에 조건을 넣으면 리소스 식별이 모호해집니다. API가 직관적이지 않습니다.

셋째, 예측 가능성이 떨어집니다. 대부분의 개발자가 GET은 바디가 없다고 가정합니다. 예상을 벗어나는 API는 이해하기 어렵습니다. 유지보수가 힘들어집니다.

**캐싱 문제:**

GET은 URL 기반으로 캐싱됩니다. 바디는 캐시 키에 포함되지 않습니다. 같은 URL이지만 다른 바디를 보내면 잘못된 캐시를 받을 수 있습니다. 데이터 정합성 문제가 발생합니다.

**로깅과 모니터링:**

많은 시스템이 GET 요청은 URL만 로깅합니다. 바디를 로깅하지 않습니다. 디버깅이 어려워집니다. 문제 추적이 힘들어집니다.

**대안:**

첫째, 쿼리 파라미터를 사용합니다. GET /search?q=keyword&category=book처럼 URL에 포함합니다. 표준적이고 안정적입니다.

둘째, POST로 변경합니다. 복잡한 검색 조건은 POST로 보낼 수 있습니다. POST /search로 바디에 조건을 담습니다. 멱등하지 않지만 실용적입니다.

셋째, GraphQL을 사용합니다. POST 메서드로 쿼리를 바디에 담습니다. 복잡한 조회에 적합합니다.

**특수한 경우:**

Elasticsearch 같은 일부 시스템은 GET 바디를 사용합니다. 검색 쿼리가 복잡하고 길기 때문입니다. 하지만 이것도 논란의 여지가 있습니다. POST를 사용하는 것이 더 안전합니다.

**실무 권장사항:**

GET 바디는 사용하지 마세요. 기술적으로 가능해도 실용적이지 않습니다. 호환성, 예측 가능성, 유지보수성 모두 떨어집니다.

쿼리 파라미터가 길어지면 POST 사용을 고려하세요. RESTful 원칙과 충돌하지만 현실적인 해결책입니다.

표준을 따르세요. 대부분의 개발자가 이해하는 방식으로 API를 설계해야 합니다.

기술적 가능성과 실용성은 다릅니다. GET 바디는 피해야 할 안티패턴입니다.
