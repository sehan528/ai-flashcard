# Spring 답변 65-68

## 질문 65: @Component, @Service, @Repository의 차이점 및 사용 사례는 무엇인가요?

이 세 어노테이션은 모두 Spring의 스테레오타입 어노테이션으로, Bean을 자동으로 등록하는 역할을 합니다. 하지만 의미론적 차이와 부가 기능에서 차이가 있습니다.

**@Component:**

첫째, 가장 기본적인 스테레오타입 어노테이션입니다. 컴포넌트 스캔 시 Spring Bean으로 등록됩니다. 범용적으로 사용할 수 있는 어노테이션입니다.

둘째, 특별한 부가 기능이 없습니다. 순수하게 Bean 등록만 담당합니다. 다른 스테레오타입 어노테이션들의 부모 역할을 합니다.

셋째, 사용 사례는 일반적인 Spring 관리 컴포넌트입니다. 계층 구조가 명확하지 않은 유틸리티 클래스, 어떤 계층에도 속하지 않는 클래스, 설정이나 헬퍼 클래스 등에 사용합니다.

**@Service:**

첫째, 비즈니스 로직 계층을 나타냅니다. Service Layer의 클래스에 사용합니다. 내부적으로 @Component를 포함하고 있습니다.

둘째, 현재는 @Component와 기술적으로 동일합니다. 부가적인 특별한 기능은 없습니다. 하지만 의미론적으로 비즈니스 로직을 담당함을 명시합니다.

셋째, 미래에 추가 기능이 붙을 수 있습니다. Spring팀은 향후 서비스 계층에 특화된 기능을 추가할 가능성을 열어두고 있습니다.

넷째, 사용 사례는 비즈니스 로직 구현입니다. 여러 Repository를 조합하여 트랜잭션 단위 작업을 수행합니다. 도메인 로직을 처리합니다. 외부 API 호출을 조율합니다.

**@Repository:**

첫째, 데이터 접근 계층을 나타냅니다. Persistence Layer의 DAO나 Repository 클래스에 사용합니다. 내부적으로 @Component를 포함하고 있습니다.

둘째, 예외 변환 기능이 있습니다. 데이터 접근 기술(JDBC, JPA 등)의 예외를 Spring의 DataAccessException으로 변환합니다. 일관된 예외 처리가 가능해집니다. 기술 독립적인 코드를 작성할 수 있습니다.

셋째, PersistenceExceptionTranslationPostProcessor가 예외 변환을 담당합니다. 이 후처리기가 @Repository가 붙은 Bean의 예외를 자동으로 변환합니다. 체크 예외를 언체크 예외로 변환합니다.

넷째, 사용 사례는 데이터베이스 접근입니다. CRUD 작업을 수행합니다. 쿼리 실행을 담당합니다. 엔티티와 데이터베이스 간 매핑을 처리합니다.

**@Controller:**

추가로 @Controller도 스테레오타입 어노테이션입니다. 프레젠테이션 계층을 나타냅니다. Spring MVC의 컨트롤러 역할을 합니다. 핸들러 매핑에서 이 어노테이션을 인식합니다.

**계층별 역할 구분:**

전형적인 3계층 아키텍처에서 각 어노테이션의 역할이 명확합니다.

Controller는 프레젠테이션 계층입니다. 사용자 요청을 받고 응답을 반환합니다. HTTP 관련 처리를 담당합니다. Service를 호출합니다.

Service는 비즈니스 로직 계층입니다. 핵심 비즈니스 로직을 구현합니다. 트랜잭션 경계를 설정합니다. 여러 Repository를 조율합니다.

Repository는 데이터 접근 계층입니다. 데이터베이스와 직접 통신합니다. 데이터 CRUD를 담당합니다. 영속성 관리를 책임집니다.

**왜 구분해서 사용할까:**

첫째, 코드 가독성입니다. 어노테이션만 보고도 클래스의 역할을 알 수 있습니다. 새로운 팀원이 코드를 쉽게 이해할 수 있습니다. 계층 구조가 명확해집니다.

둘째, 유지보수성입니다. 각 계층의 책임이 분리됩니다. 변경 시 영향 범위를 예측할 수 있습니다. 단일 책임 원칙(SRP)을 따릅니다.

셋째, 테스트 용이성입니다. 계층별로 독립적인 테스트가 가능합니다. Service는 Repository를 Mock으로 대체하여 테스트할 수 있습니다. Controller는 Service를 Mock으로 대체하여 테스트할 수 있습니다.

넷째, AOP 적용입니다. 특정 계층에만 AOP를 적용할 수 있습니다. 예를 들어 Service 계층에만 트랜잭션을 적용합니다. Repository 계층에만 쿼리 로깅을 적용합니다.

다섯째, 향후 확장성입니다. Spring이 각 어노테이션에 계층별 특화 기능을 추가할 수 있습니다. 이미 @Repository는 예외 변환 기능을 가지고 있습니다.

**실무 사용 패턴:**

UserController는 HTTP 요청을 처리합니다. UserService를 주입받아 사용합니다. 요청 데이터를 검증하고 응답을 반환합니다.

UserService는 사용자 관련 비즈니스 로직을 처리합니다. UserRepository를 주입받아 사용합니다. 트랜잭션 내에서 여러 Repository 작업을 조율합니다.

UserRepository는 User 엔티티의 데이터베이스 접근을 담당합니다. JPA나 JDBC를 사용하여 쿼리를 실행합니다. 순수한 데이터 접근 로직만 포함합니다.

**주의사항:**

비즈니스 로직이 Repository에 들어가면 안 됩니다. Repository는 순수한 데이터 접근만 담당해야 합니다. 비즈니스 로직은 Service에 위치해야 합니다.

Controller에 비즈니스 로직이 들어가면 안 됩니다. Controller는 요청과 응답 처리에만 집중해야 합니다. Fat Controller 안티패턴을 피해야 합니다.

단순히 모든 클래스에 @Component를 사용하면 구조가 불명확해집니다. 적절한 스테레오타입 어노테이션을 사용하여 의도를 명확히 해야 합니다.

**커스텀 스테레오타입 어노테이션:**

필요하다면 @Component를 메타 어노테이션으로 사용하여 커스텀 스테레오타입을 만들 수 있습니다. 예를 들어 @Validator, @Facade 같은 도메인 특화 어노테이션을 정의할 수 있습니다.

결론적으로 세 어노테이션은 기술적으로는 유사하지만, 의미론적으로 계층을 구분하고 코드의 의도를 명확히 하는 데 중요한 역할을 합니다.

## 질문 66: AOP(Aspect Oriented Programming)를 활용한 공통 관심사 분리 방법에 대해 설명해주세요.

AOP는 관점 지향 프로그래밍으로, 횡단 관심사(Cross-cutting Concerns)를 비즈니스 로직에서 분리하는 프로그래밍 패러다임입니다.

**AOP가 필요한 이유:**

첫째, 코드 중복 문제입니다. 로깅, 트랜잭션, 보안, 성능 측정 같은 기능은 여러 메서드에서 반복됩니다. 모든 Service 메서드에 로깅 코드를 넣으면 중복이 심합니다. 수정이 필요할 때 모든 곳을 찾아 변경해야 합니다.

둘째, 관심사의 혼재입니다. 비즈니스 로직과 부가 기능이 섞여 있습니다. 핵심 로직이 부가 코드에 묻혀 가독성이 떨어집니다. 단일 책임 원칙(SRP)을 위반합니다.

셋째, 유지보수 어려움입니다. 로깅 방식을 변경하려면 모든 메서드를 수정해야 합니다. 산재된 코드를 찾기 어렵습니다. 실수로 누락할 가능성이 높습니다.

**AOP 주요 용어:**

첫째, Aspect(관점)입니다. 횡단 관심사를 모듈화한 것입니다. 여러 객체에 공통으로 적용되는 기능입니다. 예를 들어 로깅 Aspect, 트랜잭션 Aspect입니다.

둘째, Join Point(조인 포인트)입니다. Aspect를 적용할 수 있는 지점입니다. 메서드 실행, 객체 생성, 필드 접근 등이 될 수 있습니다. Spring AOP에서는 메서드 실행만 지원합니다.

셋째, Advice(어드바이스)입니다. Aspect에서 실제로 수행할 작업입니다. 언제 무엇을 할지를 정의합니다. Before, After, Around 등의 타입이 있습니다.

넷째, Pointcut(포인트컷)입니다. Join Point 중에서 Advice를 적용할 곳을 선별하는 표현식입니다. 특정 패턴의 메서드들을 지정합니다.

다섯째, Weaving(위빙)입니다. Aspect를 대상 객체에 적용하는 과정입니다. 컴파일 타임, 로드 타임, 런타임에 수행될 수 있습니다. Spring AOP는 런타임 위빙을 사용합니다.

**Advice 타입:**

첫째, Before Advice입니다. 메서드 실행 전에 실행됩니다. 매개변수 검증, 로깅 등에 사용합니다. 메서드 실행을 막을 수는 없습니다.

둘째, After Returning Advice입니다. 메서드가 정상적으로 반환된 후 실행됩니다. 반환값을 로깅하거나 변환할 수 있습니다. 예외가 발생하면 실행되지 않습니다.

셋째, After Throwing Advice입니다. 메서드가 예외를 던진 후 실행됩니다. 예외 로깅이나 알림 전송에 사용합니다. 정상 반환 시에는 실행되지 않습니다.

넷째, After(Finally) Advice입니다. 메서드 실행 후 항상 실행됩니다. 정상 반환과 예외 모두에서 실행됩니다. 리소스 해제 같은 정리 작업에 사용합니다.

다섯째, Around Advice입니다. 가장 강력한 Advice입니다. 메서드 실행 전후를 모두 제어할 수 있습니다. 메서드 실행 자체를 제어할 수 있습니다. proceed 메서드로 대상 메서드를 호출합니다. 호출 전후에 작업을 수행할 수 있습니다. 반환값을 변경하거나 예외를 처리할 수 있습니다.

**Pointcut 표현식:**

execution 표현식이 가장 많이 사용됩니다. 메서드 시그니처 패턴으로 적용 대상을 지정합니다.

execution 표현식의 패턴은 접근제어자, 반환타입, 패키지.클래스.메서드, 파라미터, 예외입니다. 와일드카드를 사용할 수 있습니다. 별표는 모든 것을 의미합니다. 점점은 0개 이상의 패키지를 의미합니다.

within 표현식은 특정 타입 내의 메서드에 적용합니다.

this와 target 표현식은 프록시나 대상 객체의 타입으로 지정합니다.

args 표현식은 인자 타입으로 메서드를 선별합니다.

@annotation 표현식은 특정 어노테이션이 붙은 메서드를 선택합니다.

**Spring AOP 구현 방식:**

첫째, 프록시 기반입니다. Spring AOP는 프록시 패턴을 사용합니다. 대상 객체를 감싸는 프록시 객체를 생성합니다. 클라이언트는 프록시를 통해 대상 객체에 접근합니다.

둘째, JDK Dynamic Proxy와 CGLIB입니다. 대상 객체가 인터페이스를 구현하면 JDK Dynamic Proxy를 사용합니다. 인터페이스가 없으면 CGLIB를 사용합니다. CGLIB는 클래스를 상속하여 프록시를 만듭니다.

셋째, 런타임 위빙입니다. 애플리케이션 실행 시점에 프록시가 생성됩니다. 컴파일이나 클래스 로딩 시점이 아닙니다. 별도의 컴파일러나 클래스로더가 필요 없습니다.

**실제 활용 사례:**

첫째, 로깅입니다. 메서드 실행 전후에 로그를 남깁니다. 실행 시간을 측정합니다. 매개변수와 반환값을 기록합니다.

둘째, 트랜잭션 관리입니다. @Transactional 어노테이션이 AOP로 구현됩니다. 메서드 시작 시 트랜잭션을 시작합니다. 정상 종료 시 커밋하고 예외 발생 시 롤백합니다.

셋째, 보안입니다. 메서드 실행 전에 권한을 검사합니다. 인증되지 않은 사용자의 접근을 차단합니다. Spring Security가 AOP를 활용합니다.

넷째, 캐싱입니다. 메서드 호출 전에 캐시를 확인합니다. 캐시에 있으면 메서드를 실행하지 않고 캐시 값을 반환합니다. 캐시에 없으면 실행 후 결과를 캐싱합니다.

다섯째, 예외 처리입니다. 특정 예외를 다른 예외로 변환합니다. 예외 발생 시 알림을 전송합니다. 공통 예외 처리 로직을 적용합니다.

여섯째, 성능 모니터링입니다. 메서드 실행 시간을 측정합니다. 느린 쿼리를 감지합니다. 성능 메트릭을 수집합니다.

**AOP 구현 방법:**

첫째, @Aspect 어노테이션을 사용합니다. Aspect 클래스에 @Aspect를 붙입니다. @Component도 함께 붙여 Bean으로 등록합니다.

둘째, Advice 메서드를 정의합니다. @Before, @After, @Around 등의 어노테이션을 사용합니다. Pointcut 표현식을 지정합니다.

셋째, @EnableAspectJAutoProxy를 설정합니다. Spring Boot는 자동으로 활성화됩니다. 프록시 생성 방식을 설정할 수 있습니다.

**주의사항:**

첫째, 프록시 방식의 한계입니다. 같은 클래스 내부에서의 메서드 호출은 프록시를 거치지 않습니다. self-invocation 문제가 발생합니다. AOP가 적용되지 않습니다.

둘째, 성능 오버헤드입니다. 프록시를 통한 호출은 약간의 성능 저하가 있습니다. Around Advice는 특히 주의가 필요합니다. 과도한 AOP 적용은 성능에 영향을 줄 수 있습니다.

셋째, 디버깅 어려움입니다. 스택 트레이스가 복잡해집니다. 프록시 계층이 추가되어 흐름 파악이 어려울 수 있습니다. 적절한 로깅이 필요합니다.

**장점:**

코드 중복이 제거됩니다. 비즈니스 로직이 깔끔해집니다. 관심사가 명확히 분리됩니다. 재사용성이 높아집니다. 유지보수가 쉬워집니다.

AOP는 OOP를 보완하는 강력한 도구입니다. 횡단 관심사를 효과적으로 모듈화하여 코드 품질을 높입니다.

## 질문 67: Spring에서 트랜잭션 관리와 @Transactional 어노테이션의 역할에 대해 설명해주세요.

트랜잭션은 데이터베이스의 상태를 변경하는 하나의 논리적 작업 단위입니다. Spring은 선언적 트랜잭션 관리를 통해 트랜잭션을 쉽게 처리할 수 있게 합니다.

**트랜잭션의 ACID 속성:**

첫째, Atomicity(원자성)입니다. 트랜잭션 내의 모든 작업이 완전히 수행되거나 아예 수행되지 않아야 합니다. 일부만 실행되는 것은 허용되지 않습니다. All or Nothing입니다.

둘째, Consistency(일관성)입니다. 트랜잭션 실행 전후에 데이터베이스가 일관된 상태를 유지해야 합니다. 제약 조건, 트리거 등이 위반되지 않아야 합니다. 무결성이 보장되어야 합니다.

셋째, Isolation(격리성)입니다. 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 합니다. 한 트랜잭션의 중간 상태를 다른 트랜잭션이 볼 수 없어야 합니다. 격리 수준에 따라 다르게 동작합니다.

넷째, Durability(지속성)입니다. 커밋된 트랜잭션의 결과는 영구적으로 반영되어야 합니다. 시스템 장애가 발생해도 데이터가 유지되어야 합니다. 일반적으로 로그에 기록하여 보장합니다.

**Spring 트랜잭션 관리 방식:**

첫째, 선언적 트랜잭션 관리입니다. @Transactional 어노테이션을 사용합니다. XML이나 어노테이션으로 설정합니다. AOP를 기반으로 동작합니다. 비즈니스 로직과 트랜잭션 코드가 분리됩니다.

둘째, 프로그래밍 방식 트랜잭션 관리입니다. TransactionTemplate이나 PlatformTransactionManager를 직접 사용합니다. 코드로 명시적으로 트랜잭션을 제어합니다. 세밀한 제어가 필요한 경우 사용합니다. 일반적으로는 선언적 방식을 권장합니다.

**@Transactional 어노테이션:**

첫째, 적용 위치입니다. 클래스 레벨에 적용하면 모든 public 메서드에 트랜잭션이 적용됩니다. 메서드 레벨에 적용하면 해당 메서드만 트랜잭션이 적용됩니다. 메서드 레벨이 클래스 레벨보다 우선합니다.

둘째, 동작 원리입니다. Spring AOP 프록시를 통해 동작합니다. 메서드 호출 시 프록시가 트랜잭션을 시작합니다. 메서드가 정상 종료되면 커밋합니다. 예외가 발생하면 롤백합니다.

**@Transactional 주요 속성:**

첫째, propagation(전파 속성)입니다. 트랜잭션을 어떻게 전파할지 결정합니다.

REQUIRED가 기본값입니다. 현재 트랜잭션이 있으면 참여하고 없으면 새로 시작합니다. 대부분의 경우 적합합니다.

REQUIRES_NEW는 항상 새 트랜잭션을 시작합니다. 기존 트랜잭션이 있으면 보류합니다. 독립적인 트랜잭션이 필요할 때 사용합니다.

SUPPORTS는 트랜잭션이 있으면 참여하고 없으면 없이 실행합니다. 읽기 전용 작업에 사용할 수 있습니다.

MANDATORY는 반드시 트랜잭션이 있어야 합니다. 없으면 예외를 발생시킵니다.

NOT_SUPPORTED는 트랜잭션 없이 실행합니다. 기존 트랜잭션이 있으면 보류합니다.

NEVER는 트랜잭션이 있으면 예외를 발생시킵니다.

NESTED는 중첩 트랜잭션을 생성합니다. 부분 롤백이 가능합니다.

둘째, isolation(격리 수준)입니다. 동시 트랜잭션 간의 격리 정도를 설정합니다.

DEFAULT는 데이터베이스의 기본 격리 수준을 사용합니다.

READ_UNCOMMITTED는 가장 낮은 격리 수준입니다. 커밋되지 않은 데이터를 읽을 수 있습니다. Dirty Read가 발생할 수 있습니다.

READ_COMMITTED는 커밋된 데이터만 읽을 수 있습니다. Dirty Read는 방지합니다. Non-Repeatable Read는 발생할 수 있습니다.

REPEATABLE_READ는 같은 데이터를 여러 번 읽어도 같은 값을 보장합니다. Phantom Read는 발생할 수 있습니다.

SERIALIZABLE은 가장 높은 격리 수준입니다. 모든 이상 현상을 방지합니다. 성능이 가장 낮습니다.

셋째, readOnly 속성입니다. 읽기 전용 트랜잭션으로 설정합니다. 성능 최적화에 도움이 됩니다. 데이터 변경을 시도하면 예외가 발생할 수 있습니다. Flush 모드를 변경하여 변경 감지를 스킵합니다.

넷째, timeout 속성입니다. 트랜잭션 타임아웃을 초 단위로 설정합니다. 지정된 시간 내에 완료되지 않으면 롤백됩니다. 기본값은 데이터베이스의 타임아웃입니다.

다섯째, rollbackFor와 noRollbackFor입니다. 어떤 예외에 롤백할지 지정합니다. 기본적으로 RuntimeException과 Error에만 롤백합니다. Checked Exception은 롤백하지 않습니다. rollbackFor로 Checked Exception도 롤백하도록 설정할 수 있습니다.

**트랜잭션 매니저:**

Spring은 다양한 트랜잭션 매니저를 제공합니다.

DataSourceTransactionManager는 JDBC용입니다. 단일 DataSource를 사용합니다.

JpaTransactionManager는 JPA용입니다. EntityManagerFactory를 관리합니다.

JtaTransactionManager는 분산 트랜잭션용입니다. 여러 리소스에 걸친 트랜잭션을 지원합니다.

**트랜잭션 동기화:**

Spring은 트랜잭션 동기화 메커니즘을 제공합니다. TransactionSynchronizationManager가 현재 트랜잭션 정보를 ThreadLocal에 저장합니다. 같은 스레드의 모든 데이터 접근 코드가 같은 트랜잭션을 공유합니다. Connection이나 EntityManager를 직접 관리할 필요가 없습니다.

**주의사항:**

첫째, 프록시 방식의 한계입니다. 같은 클래스 내부에서 메서드를 호출하면 @Transactional이 적용되지 않습니다. self-invocation 문제입니다. 프록시를 거치지 않기 때문입니다. 다른 Bean을 통해 호출하거나 AspectJ 모드를 사용해야 합니다.

둘째, public 메서드만 지원합니다. private, protected 메서드에는 적용되지 않습니다. 프록시가 외부 호출만 가로챌 수 있기 때문입니다.

셋째, 예외 처리입니다. Checked Exception은 기본적으로 롤백되지 않습니다. 필요하면 rollbackFor 속성을 설정해야 합니다. 예외를 잡아서 처리하면 롤백되지 않습니다. 롤백이 필요하면 예외를 다시 던져야 합니다.

넷째, 트랜잭션 범위입니다. 트랜잭션은 가능한 한 짧게 유지해야 합니다. 긴 트랜잭션은 데드락과 성능 문제를 유발합니다. 외부 API 호출은 트랜잭션 밖에서 해야 합니다.

**실무 활용 팁:**

Service 계층에 @Transactional을 적용합니다. Repository는 트랜잭션을 시작하지 않고 참여만 합니다. 읽기 전용 작업은 readOnly=true를 설정합니다. 복잡한 비즈니스 로직은 하나의 트랜잭션으로 묶습니다. 예외 발생 시 자동으로 롤백되어 데이터 일관성이 보장됩니다.

@Transactional은 Spring의 핵심 기능으로, 복잡한 트랜잭션 관리를 간단하게 만들어줍니다.

## 질문 68: Spring MVC 아키텍처의 구성 요소와 요청 처리 과정을 설명해주세요.

Spring MVC는 Model-View-Controller 패턴을 기반으로 한 웹 프레임워크입니다. 프론트 컨트롤러 패턴을 사용하여 모든 요청을 중앙에서 처리합니다.

**주요 구성 요소:**

첫째, DispatcherServlet입니다. 프론트 컨트롤러 역할을 합니다. 모든 HTTP 요청의 진입점입니다. 요청을 적절한 핸들러로 라우팅합니다. 응답 생성을 조율합니다. Spring MVC의 핵심 컴포넌트입니다.

둘째, Handler Mapping입니다. URL과 처리할 컨트롤러를 매핑합니다. 요청 URL을 분석하여 적절한 핸들러를 찾습니다. RequestMappingHandlerMapping이 가장 많이 사용됩니다. @RequestMapping 어노테이션을 기반으로 매핑합니다.

셋째, Handler Adapter입니다. 다양한 타입의 핸들러를 실행할 수 있게 합니다. 핸들러 호출 방식을 추상화합니다. RequestMappingHandlerAdapter가 @RequestMapping 메서드를 처리합니다. 매개변수를 바인딩하고 반환값을 처리합니다.

넷째, Controller(Handler)입니다. 실제 비즈니스 로직을 처리합니다. @Controller나 @RestController 어노테이션을 붙입니다. 요청 데이터를 받아 Service를 호출합니다. Model 데이터를 준비하고 뷰 이름을 반환합니다.

다섯째, ModelAndView입니다. 모델 데이터와 뷰 정보를 담는 객체입니다. 컨트롤러가 반환할 수 있습니다. 요즘은 Model 객체와 String(뷰 이름)을 따로 반환하는 것이 일반적입니다.

여섯째, ViewResolver입니다. 논리적 뷰 이름을 실제 View 객체로 변환합니다. InternalResourceViewResolver가 JSP를 처리합니다. prefix와 suffix를 붙여 실제 경로를 만듭니다. Thymeleaf, FreeMarker 등 다양한 뷰 기술을 지원합니다.

일곱째, View입니다. 실제 응답을 생성합니다. JSP, Thymeleaf, JSON 등 다양한 형태가 있습니다. Model 데이터를 사용하여 HTML을 렌더링합니다.

여덟째, HandlerInterceptor입니다. 핸들러 실행 전후에 공통 처리를 수행합니다. preHandle은 핸들러 실행 전에 호출됩니다. postHandle은 핸들러 실행 후 뷰 렌더링 전에 호출됩니다. afterCompletion은 요청 처리 완료 후 호출됩니다. 로깅, 인증, 권한 검사 등에 사용합니다.

아홉째, HandlerExceptionResolver입니다. 예외를 처리합니다. 예외를 적절한 응답으로 변환합니다. @ExceptionHandler나 @ControllerAdvice를 처리합니다.

**요청 처리 과정:**

첫째, 클라이언트 요청입니다. 사용자가 브라우저에서 URL을 입력하거나 링크를 클릭합니다. HTTP 요청이 서버로 전송됩니다.

둘째, DispatcherServlet이 요청을 받습니다. 서블릿 컨테이너가 DispatcherServlet에 요청을 전달합니다. DispatcherServlet은 모든 요청의 진입점입니다.

셋째, Handler Mapping에 핸들러를 조회합니다. DispatcherServlet이 Handler Mapping에 요청 URL을 전달합니다. Handler Mapping이 적절한 핸들러(컨트롤러)를 찾습니다. 핸들러와 인터셉터 체인을 반환합니다.

넷째, Handler Adapter를 조회합니다. DispatcherServlet이 핸들러를 처리할 수 있는 Handler Adapter를 찾습니다. 다양한 타입의 핸들러를 지원하기 위함입니다.

다섯째, 인터셉터의 preHandle을 실행합니다. 핸들러 실행 전에 인터셉터가 실행됩니다. 인증, 권한 체크, 로깅 등을 수행합니다. false를 반환하면 요청 처리가 중단됩니다.

여섯째, Handler Adapter가 핸들러를 실행합니다. 실제 컨트롤러 메서드가 호출됩니다. 요청 데이터가 메서드 매개변수로 바인딩됩니다. HttpServletRequest, @RequestParam, @PathVariable, @RequestBody 등이 자동으로 변환됩니다. 컨트롤러가 비즈니스 로직을 수행합니다. 일반적으로 Service를 호출합니다.

일곱째, 컨트롤러가 ModelAndView를 반환합니다. 모델 데이터와 뷰 이름을 담아 반환합니다. @ResponseBody가 있으면 HTTP 메시지 바디에 직접 응답을 씁니다. @RestController는 모든 메서드에 @ResponseBody가 적용됩니다.

여덟째, 인터셉터의 postHandle을 실행합니다. 핸들러 실행 후, 뷰 렌더링 전에 실행됩니다. ModelAndView를 수정할 수 있습니다. 예외가 발생하면 실행되지 않습니다.

아홉째, ViewResolver가 뷰를 해석합니다. 논리적 뷰 이름을 받아 실제 View 객체를 반환합니다. 뷰 이름에 prefix와 suffix를 붙여 실제 경로를 만듭니다.

열째, View가 렌더링됩니다. View가 Model 데이터를 사용하여 HTML을 생성합니다. JSP, Thymeleaf 등이 템플릿을 처리합니다. 최종 HTML이 HTTP 응답 바디에 작성됩니다.

열한째, 인터셉터의 afterCompletion을 실행합니다. 뷰 렌더링까지 완료된 후 실행됩니다. 예외 발생 여부와 관계없이 항상 실행됩니다. 리소스 정리, 로깅 등에 사용합니다.

열두째, 응답을 클라이언트에 반환합니다. HTTP 응답이 클라이언트로 전송됩니다. 브라우저가 HTML을 렌더링하여 사용자에게 보여줍니다.

**@RestController 처리:**

@RestController는 @ResponseBody가 모든 메서드에 적용됩니다. 반환값이 HTTP 메시지 바디에 직접 쓰입니다. ViewResolver를 사용하지 않습니다. HttpMessageConverter가 객체를 JSON이나 XML로 변환합니다. MappingJackson2HttpMessageConverter가 JSON 변환을 담당합니다.

**데이터 바인딩:**

요청 파라미터가 자동으로 메서드 매개변수에 바인딩됩니다.

@RequestParam은 쿼리 파라미터나 폼 데이터를 바인딩합니다.

@PathVariable은 URL 경로 변수를 바인딩합니다.

@RequestBody는 HTTP 바디를 객체로 변환합니다. JSON이나 XML을 자바 객체로 역직렬화합니다.

@ModelAttribute는 폼 데이터를 객체로 바인딩합니다. 타입 변환과 검증을 수행합니다.

**검증:**

Validator를 통해 데이터를 검증합니다. @Valid나 @Validated로 검증을 활성화합니다. BindingResult에 검증 오류가 담깁니다. Bean Validation(JSR-303)을 지원합니다.

**예외 처리:**

@ExceptionHandler로 컨트롤러 내 예외를 처리합니다. @ControllerAdvice로 전역 예외 처리를 구현합니다. HandlerExceptionResolver가 예외를 처리합니다. 적절한 응답 코드와 메시지를 반환합니다.

**장점:**

요청 처리 흐름이 일관됩니다. 공통 처리를 한 곳에서 할 수 있습니다. 인터셉터로 횡단 관심사를 처리합니다. 다양한 뷰 기술을 유연하게 사용할 수 있습니다. 테스트하기 쉬운 구조입니다.

Spring MVC는 잘 설계된 아키텍처로 웹 애플리케이션 개발을 체계적이고 효율적으로 만들어줍니다.
