# React 답변 13-16

## 질문 13: useReducer는 언제 useState 대신 사용하나요?

**정의:**
useReducer는 복잡한 상태 로직을 관리하는 Hook으로, Redux와 유사한 패턴을 사용합니다. reducer 함수와 초기 상태를 받아 현재 상태와 dispatch 함수를 반환합니다.

**useReducer의 구조:**
- reducer 함수는 현재 상태와 액션을 받아 새 상태를 반환합니다.
- 초기 상태를 두 번째 인자로 전달합니다.
- dispatch 함수로 액션을 전달하여 상태를 업데이트합니다.
- 모든 상태 변경 로직이 reducer에 집중됩니다.
- 순수 함수여야 합니다.

**useState 대신 useReducer를 사용하는 경우:**
- 상태 업데이트 로직이 복잡할 때: 여러 하위 값이 연관되어 있습니다.
- 다음 상태가 이전 상태에 의존할 때: 여러 단계의 계산이 필요합니다.
- 상태 전환이 많을 때: 여러 가지 액션 타입이 있습니다.
- 비즈니스 로직을 분리하고 싶을 때: 테스트하기 쉬워집니다.
- 상태 업데이트를 추적하고 디버깅하기 쉽게 하고 싶을 때입니다.

**useState vs useReducer 비교:**
- useState는 간단한 상태에 적합합니다. useReducer는 복잡한 상태에 적합합니다.
- useState는 직접 값을 설정합니다. useReducer는 액션을 디스패치합니다.
- useState는 보일러플레이트가 적습니다. useReducer는 초기 설정이 더 많습니다.
- useState는 상태가 독립적일 때 좋습니다. useReducer는 상태가 연관될 때 좋습니다.

**reducer 함수 작성 패턴:**
- switch 문으로 액션 타입을 분기합니다.
- 각 케이스에서 새 상태 객체를 반환합니다.
- 불변성을 유지합니다. 스프레드 연산자를 사용합니다.
- default 케이스에서 현재 상태를 반환하거나 에러를 던집니다.
- 순수 함수로 작성합니다. 부작용이 없어야 합니다.

**액션 설계:**
- type 필드로 액션을 식별합니다.
- payload 필드로 추가 데이터를 전달합니다.
- 명확하고 의미 있는 액션명을 사용합니다.
- 액션 생성자 함수로 일관성을 유지할 수 있습니다.
- TypeScript로 타입 안전성을 보장합니다.

**초기화 지연:**
- 세 번째 인자로 초기화 함수를 전달할 수 있습니다.
- 초기 상태 계산이 비쌀 때 유용합니다.
- localStorage에서 읽는 등의 작업에 활용합니다.
- 초기 렌더링 시에만 실행됩니다.

**실무 활용:**
- 폼 상태 관리: 여러 입력 필드와 검증 로직이 있을 때 사용합니다.
- 쇼핑 카트: 추가 삭제 수량 변경 등 다양한 액션이 있습니다.
- 다단계 위저드: 단계별 데이터와 진행 상태를 관리합니다.
- 게임 상태: 복잡한 규칙과 상태 전환이 있습니다.
- Redux 대신 로컬 상태 관리에 활용합니다.

---

## 질문 14: useContext는 어떻게 사용하나요?

**정의:**
useContext는 Context API를 함수형 컴포넌트에서 사용하기 위한 Hook입니다. Context 객체를 인자로 받아 현재 context 값을 반환하며, Provider로 감싼 가장 가까운 값을 읽습니다.

**Context API 기본 개념:**
- Context는 전역적으로 데이터를 공유하는 방법입니다.
- Props drilling 없이 깊은 컴포넌트에 데이터를 전달합니다.
- React.createContext로 Context 객체를 생성합니다.
- Provider로 값을 제공하고 Consumer나 useContext로 소비합니다.

**useContext 사용 방법:**
- createContext로 Context를 생성합니다.
- Provider로 컴포넌트 트리를 감싸고 value를 전달합니다.
- 하위 컴포넌트에서 useContext로 값을 읽습니다.
- Provider 없이 사용하면 기본값이 반환됩니다.
- 중첩된 Provider는 가장 가까운 것이 우선됩니다.

**Context 생성과 제공:**
- 별도 파일에서 Context를 생성하고 export 합니다.
- Provider 컴포넌트를 만들어 로직을 캡슐화합니다.
- value에 객체를 전달할 때는 메모이제이션을 고려합니다.
- 여러 Context를 조합하여 사용할 수 있습니다.

**Context 소비 패턴:**
- useContext Hook으로 간단하게 값을 읽습니다.
- Context.Consumer보다 간결하고 읽기 쉽습니다.
- 여러 Context를 사용할 때도 깔끔합니다.
- 조건부로 Context를 사용할 수 없습니다. Hooks 규칙을 따라야 합니다.

**적절한 사용 사례:**
- 테마 설정: 다크 모드 라이트 모드 등을 전역적으로 관리합니다.
- 사용자 인증 정보: 로그인 상태와 유저 데이터를 공유합니다.
- 언어 설정: 다국어 지원을 위한 로케일 정보입니다.
- UI 상태: 모달 토스트 같은 전역 UI 상태입니다.
- 앱 설정: 전역 설정값을 관리합니다.

**Context의 한계:**
- 모든 상태 관리를 Context로 하면 안 됩니다.
- 성능 문제가 있을 수 있습니다. 값이 바뀌면 모든 소비자가 리렌더링됩니다.
- 컴포넌트 재사용성이 떨어질 수 있습니다.
- 복잡한 상태는 Redux 같은 라이브러리가 더 적합합니다.

**성능 최적화:**
- Provider value를 메모이제이션합니다. useMemo를 사용합니다.
- Context를 여러 개로 분리합니다. 자주 변경되는 것과 그렇지 않은 것을 나눕니다.
- 필요한 컴포넌트만 구독하도록 합니다.
- React.memo로 불필요한 리렌더링을 방지합니다.

**실무 활용:**
- 전역 상태를 간단하게 관리합니다. 작은 앱에 적합합니다.
- Provider 패턴으로 의존성을 주입합니다.
- 커스텀 Hook과 조합하여 사용합니다.
- 테스트 시 Context Provider로 모의 데이터를 제공합니다.
- 라이브러리에서 설정을 전달하는 용도로 많이 사용됩니다.

---

## 질문 15: Custom Hook을 만드는 이유와 방법은 무엇인가요?

**정의:**
Custom Hook은 상태 관련 로직을 재사용 가능한 함수로 추출한 것입니다. use로 시작하는 이름을 가지며, 내부에서 다른 Hook을 사용할 수 있습니다.

**Custom Hook을 만드는 이유:**
- 중복된 로직을 제거합니다. 여러 컴포넌트에서 같은 로직을 공유합니다.
- 컴포넌트를 단순하게 유지합니다. 복잡한 로직을 분리합니다.
- 테스트하기 쉽습니다. 로직을 독립적으로 테스트할 수 있습니다.
- 코드 가독성이 향상됩니다. 의도가 명확해집니다.
- 관심사를 분리합니다. UI와 로직을 나눕니다.

**Custom Hook 작성 규칙:**
- 이름은 use로 시작해야 합니다. 컨벤션이자 ESLint 규칙입니다.
- 일반 JavaScript 함수입니다. 특별한 문법이 없습니다.
- 내부에서 다른 Hook을 호출할 수 있습니다.
- Hook 규칙을 따라야 합니다. 조건문이나 반복문 안에서 호출하면 안 됩니다.
- 상태나 함수를 반환합니다. 필요한 값과 핸들러를 돌려줍니다.

**Custom Hook 작성 패턴:**
- 관련된 상태와 로직을 하나로 묶습니다.
- 매개변수로 옵션을 받을 수 있습니다.
- 필요한 값만 반환합니다. 객체나 배열로 묶어서 반환합니다.
- 명확한 이름을 사용합니다. 무엇을 하는지 알기 쉽게 합니다.
- 문서화를 잘 합니다. JSDoc 주석을 추가합니다.

**일반적인 Custom Hook 예시:**
- useLocalStorage: localStorage와 동기화되는 상태입니다.
- useFetch: API 호출과 로딩 에러 상태를 관리합니다.
- useDebounce: 입력값을 디바운스합니다.
- useWindowSize: 윈도우 크기를 추적합니다.
- useForm: 폼 상태와 검증을 관리합니다.

**Hook 조합:**
- Custom Hook 안에서 다른 Custom Hook을 사용할 수 있습니다.
- 작은 Hook들을 조합하여 더 복잡한 Hook을 만듭니다.
- 관심사별로 분리하여 재사용성을 높입니다.
- 과도하게 추상화하지 않도록 주의합니다.

**일반 함수와의 차이:**
- Custom Hook은 Hook을 호출할 수 있습니다. 일반 함수는 불가능합니다.
- Custom Hook은 컴포넌트처럼 독립적인 상태를 가집니다.
- 같은 Hook을 여러 곳에서 사용해도 상태는 독립적입니다.
- Hook 규칙의 제약을 받습니다.

**실무 활용:**
- API 호출 로직을 Custom Hook으로 추출합니다.
- 폼 관리 로직을 재사용 가능하게 만듭니다.
- 애니메이션이나 인터랙션 로직을 분리합니다.
- 브라우저 API 접근을 추상화합니다.
- 라이브러리처럼 배포하여 여러 프로젝트에서 사용합니다.

---

## 질문 16: Hooks 사용 시 지켜야 할 규칙은 무엇인가요?

**정의:**
Hooks 규칙은 React Hook을 올바르게 사용하기 위한 두 가지 필수 규칙입니다. 이 규칙을 따라야 Hook이 예측 가능하게 동작하고 버그를 방지할 수 있습니다.

**규칙 1: 최상위에서만 Hook을 호출:**
- 반복문 조건문 중첩 함수 안에서 Hook을 호출하면 안 됩니다.
- 항상 React 함수의 최상위에서 호출해야 합니다.
- 컴포넌트가 렌더링될 때마다 같은 순서로 Hook이 호출되어야 합니다.
- 조건부로 Hook을 사용하고 싶다면 조건문을 Hook 안에 넣습니다.

**규칙 2: React 함수에서만 Hook을 호출:**
- 일반 JavaScript 함수에서 Hook을 호출하면 안 됩니다.
- React 함수형 컴포넌트에서 호출합니다.
- Custom Hook에서 호출합니다.
- 클래스 컴포넌트에서는 사용할 수 없습니다.

**규칙이 필요한 이유:**
- React는 Hook 호출 순서로 상태를 관리합니다.
- 내부적으로 배열로 Hook 상태를 저장합니다.
- 순서가 바뀌면 상태가 뒤섞입니다.
- 조건부 Hook은 순서를 불안정하게 만듭니다.
- 클로저와 순서에 의존하는 구현 방식 때문입니다.

**조건부 실행 처리:**
- Hook은 항상 호출하되 내부 로직을 조건부로 만듭니다.
- useEffect의 조건문을 effect 함수 안에 넣습니다.
- 플래그 변수로 상태를 관리합니다.
- 조기 리턴은 Hook 호출 후에 사용합니다.

**ESLint 플러그인:**
- eslint-plugin-react-hooks가 규칙 위반을 감지합니다.
- exhaustive-deps 규칙은 의존성 배열을 검증합니다.
- rules-of-hooks 규칙은 Hook 호출 위치를 검증합니다.
- Create React App에 기본 포함되어 있습니다.
- 에디터에서 실시간으로 경고를 표시합니다.

**일반적인 실수:**
- 조건문 안에서 Hook을 호출합니다.
- 반복문 안에서 Hook을 호출합니다.
- 이벤트 핸들러에서 직접 Hook을 호출합니다.
- useEffect 의존성 배열을 잘못 작성합니다.
- 일반 함수에서 Hook을 사용하려고 합니다.

**의존성 배열 규칙:**
- effect나 메모이제이션 Hook의 의존성을 모두 포함해야 합니다.
- 함수나 객체는 메모이제이션하거나 의존성에서 제외합니다.
- 의도적으로 제외하는 경우 주석으로 설명합니다.
- ESLint가 누락된 의존성을 알려줍니다.

**실무 활용:**
- ESLint 플러그인을 반드시 설치합니다.
- 경고를 무시하지 않습니다. 근본 원인을 해결합니다.
- 조건부 로직은 Hook 내부로 이동합니다.
- 팀 전체가 규칙을 이해하고 따릅니다.
- 코드 리뷰에서 Hook 규칙 위반을 체크합니다.

---
