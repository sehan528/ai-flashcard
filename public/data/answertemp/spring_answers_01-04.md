# Spring 답변 1-4

## 질문 1: JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.

JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신입니다. 주요 기능은 다음과 같습니다.

첫째, 플랫폼 독립성을 제공합니다. 자바 소스코드를 컴파일하면 바이트코드(.class 파일)가 생성되며, 이 바이트코드는 어떤 운영체제에서든 JVM만 설치되어 있으면 실행할 수 있습니다. 즉 "Write Once, Run Anywhere" 철학을 구현합니다.

둘째, 메모리 관리를 자동으로 수행합니다. JVM은 힙 메모리 영역에서 객체를 할당하고, 가비지 컬렉션(GC)을 통해 더 이상 사용하지 않는 객체를 자동으로 정리합니다. 이를 통해 개발자가 메모리 누수를 직접 관리할 필요가 줄어듭니다.

셋째, 바이트코드를 기계어로 변환합니다. JVM은 인터프리터 방식과 JIT(Just-In-Time) 컴파일러를 결합하여 바이트코드를 실행합니다. 처음에는 인터프리터로 실행하다가 자주 사용되는 코드(핫스팟)를 JIT 컴파일러가 네이티브 코드로 컴파일하여 성능을 최적화합니다.

넷째, 보안 기능을 제공합니다. 바이트코드 검증기(Bytecode Verifier)가 클래스 파일의 유효성을 검증하고, 보안 관리자(Security Manager)가 애플리케이션의 리소스 접근을 제어합니다.

다섯째, 런타임 환경을 제공합니다. 클래스 로더(Class Loader)가 필요한 클래스를 동적으로 로딩하고, 런타임 데이터 영역(힙, 스택, 메서드 영역 등)을 관리하며, 실행 엔진이 바이트코드를 실행합니다.

## 질문 2: 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?

아니요, 자바 외에도 많은 언어가 JVM 위에서 실행될 수 있습니다. JVM은 자바 바이트코드를 실행하는 가상 머신이므로, 어떤 언어든 자바 바이트코드로 컴파일될 수 있다면 JVM에서 실행 가능합니다.

대표적인 JVM 언어들은 다음과 같습니다.

Kotlin은 JetBrains에서 개발한 현대적인 프로그래밍 언어로, 자바와 100% 상호운용이 가능하며 안드로이드 개발의 공식 언어가 되었습니다. 간결한 문법과 null 안정성, 함수형 프로그래밍 지원 등의 장점이 있습니다.

Scala는 객체지향과 함수형 프로그래밍을 결합한 언어로, 강력한 타입 시스템과 고급 기능을 제공합니다. 빅데이터 처리 프레임워크인 Apache Spark가 Scala로 작성되었습니다.

Groovy는 동적 타이핑을 지원하는 스크립팅 언어로, 자바 문법과 유사하면서도 더 간결한 코드 작성이 가능합니다. Gradle 빌드 도구가 Groovy로 작성되었습니다.

Clojure는 Lisp 계열의 함수형 프로그래밍 언어로, 불변성과 동시성 프로그래밍에 강점이 있습니다.

JRuby와 Jython은 각각 Ruby와 Python을 JVM에서 실행할 수 있게 구현한 버전입니다.

이러한 언어들이 JVM에서 실행되면 여러 이점을 얻을 수 있습니다. JVM의 성숙한 생태계와 라이브러리를 활용할 수 있고, 자바와의 상호운용성을 통해 기존 자바 코드와 통합이 쉬우며, JVM의 최적화 기술과 가비지 컬렉션의 혜택을 받을 수 있습니다.

## 질문 3: 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?

네, 가능합니다. JVM 계열 언어를 네이티브 실행 파일로 컴파일하는 기술이 발전하고 있으며, 대표적으로 GraalVM의 Native Image 기술이 있습니다.

GraalVM Native Image는 자바 애플리케이션을 네이티브 실행 파일로 미리 컴파일(Ahead-of-Time, AOT)하는 기술입니다. 이 과정에서 애플리케이션 코드, 의존 라이브러리, JDK의 필요한 부분을 분석하여 하나의 독립적인 실행 파일을 생성합니다.

네이티브 컴파일의 주요 장점은 다음과 같습니다.

첫째, 시작 시간이 매우 빠릅니다. JVM을 부팅하고 클래스를 로딩하는 과정이 필요 없어 밀리초 단위로 애플리케이션이 시작됩니다. 이는 서버리스 환경이나 CLI 도구에 적합합니다.

둘째, 메모리 사용량이 적습니다. JVM 전체를 메모리에 올릴 필요가 없고, 실제로 사용하는 코드만 포함되어 메모리 풋프린트가 크게 줄어듭니다.

셋째, 독립 실행 파일로 배포가 간편합니다. JVM 설치 없이도 실행 가능한 바이너리를 배포할 수 있습니다.

하지만 몇 가지 제약사항도 있습니다.

첫째, 리플렉션, 동적 프록시, JNI 등의 동적 기능은 빌드 시점에 명시적으로 설정해야 합니다. 런타임에 클래스를 동적으로 로딩하는 것이 제한되기 때문입니다.

둘째, 빌드 시간이 깁니다. 전체 애플리케이션을 분석하고 최적화하는 과정이 오래 걸립니다.

셋째, 일부 라이브러리나 프레임워크가 완전히 지원되지 않을 수 있습니다. 특히 리플렉션을 많이 사용하는 프레임워크는 추가 설정이 필요합니다.

Spring Boot는 GraalVM Native Image를 공식 지원하며, Micronaut, Quarkus 같은 프레임워크는 네이티브 컴파일을 염두에 두고 설계되었습니다.

## 질문 4: VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.

VM(Virtual Machine)을 사용하면 다양한 장점과 단점이 있습니다.

**장점:**

첫째, 플랫폼 독립성입니다. VM을 사용하면 운영체제나 하드웨어에 관계없이 동일한 코드를 실행할 수 있습니다. 개발자는 하나의 바이트코드만 작성하면 Windows, Linux, macOS 등 다양한 환경에서 실행할 수 있어 이식성이 뛰어납니다.

둘째, 자동 메모리 관리입니다. 가비지 컬렉션을 통해 메모리를 자동으로 관리하므로 개발자가 명시적으로 메모리 할당과 해제를 관리할 필요가 없습니다. 이는 메모리 누수나 댕글링 포인터 같은 문제를 크게 줄여줍니다.

셋째, 보안성이 향상됩니다. VM은 샌드박스 환경을 제공하여 악의적인 코드나 버그가 시스템 전체에 영향을 미치는 것을 방지합니다. 바이트코드 검증과 보안 관리자를 통해 추가적인 보안 계층을 제공합니다.

넷째, 동적 최적화가 가능합니다. JIT 컴파일러는 런타임에 실행 패턴을 분석하여 자주 사용되는 코드를 최적화합니다. 이는 정적 컴파일에서는 불가능한 프로파일 기반 최적화를 가능하게 합니다.

다섯째, 언어 다양성을 지원합니다. 하나의 VM에서 여러 프로그래밍 언어를 실행할 수 있어 각 언어의 장점을 활용하면서도 상호운용성을 유지할 수 있습니다.

**단점:**

첫째, 성능 오버헤드가 있습니다. VM을 거쳐서 실행되므로 네이티브 코드에 비해 시작 시간이 느리고 초기 실행 속도가 떨어질 수 있습니다. JIT 컴파일이 워밍업되기 전까지는 성능이 낮을 수 있습니다.

둘째, 메모리 사용량이 많습니다. VM 자체가 메모리를 차지하고, 가비지 컬렉션을 위한 추가 메모리가 필요합니다. 같은 기능을 하는 네이티브 애플리케이션보다 메모리 풋프린트가 큽니다.

셋째, 가비지 컬렉션으로 인한 일시 정지(Stop-The-World)가 발생할 수 있습니다. GC가 실행되는 동안 애플리케이션이 잠시 멈출 수 있어 실시간 시스템이나 지연 시간에 민감한 애플리케이션에는 문제가 될 수 있습니다.

넷째, 저수준 하드웨어 제어가 제한됩니다. VM의 추상화 계층 때문에 직접적인 메모리 조작이나 하드웨어 제어가 어렵습니다. 시스템 프로그래밍이나 임베디드 시스템에는 적합하지 않을 수 있습니다.

다섯째, 예측 가능성이 낮을 수 있습니다. JIT 컴파일과 가비지 컬렉션의 동작 시점이 런타임에 결정되므로 성능이 예측하기 어렵고 변동성이 있을 수 있습니다.
