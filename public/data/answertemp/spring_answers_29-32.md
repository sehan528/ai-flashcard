# Spring 답변 29-32

## 질문 29: 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?

람다식이나 익명 클래스에서 외부 변수를 사용할 때 final이거나 effectively final이어야 하는 이유는 변수 캡처(variable capture) 메커니즘과 스레드 안전성 때문입니다.

**기술적 이유:**

람다식과 익명 클래스는 외부 변수의 값을 복사하여 캡처합니다. 변수 자체에 대한 참조가 아니라 값의 복사본을 가집니다. 만약 외부 변수가 변경 가능하다면, 람다 내부의 복사본과 외부의 원본이 달라져서 혼란스러운 상황이 발생합니다.

로컬 변수는 스택에 저장되는데, 람다나 익명 클래스는 그 범위를 벗어나서도 존재할 수 있습니다. 람다가 다른 스레드에서 실행될 수도 있습니다. 변수가 변경 가능하면 동기화 문제와 가시성 문제가 발생합니다.

**Java의 설계 결정:**

자바는 변수 캡처를 단순하고 안전하게 만들기 위해 불변성을 요구합니다. 이는 동시성 문제를 근본적으로 방지하고, 의도하지 않은 부수 효과를 막으며, 코드 추론을 쉽게 만듭니다.

명시적으로 final을 붙이지 않아도 effectively final이면 됩니다. effectively final은 초기화 후 값이 변경되지 않는 변수를 의미합니다. 컴파일러가 자동으로 판단합니다.

**꼭 그래야 하나요?:**

Java 8 이후로는 명시적인 final 키워드가 필수는 아닙니다. effectively final이면 충분합니다. 초기화 후 재할당하지 않으면 자동으로 인식됩니다.

하지만 변수를 변경하려고 하면 컴파일 에러가 발생합니다. 이는 잠재적 버그를 미리 방지하는 안전장치입니다.

**우회 방법:**

배열이나 객체를 사용하면 우회할 수 있습니다. 배열의 요소나 객체의 필드는 변경 가능합니다. 하지만 이는 권장되지 않습니다. 가독성이 떨어지고 스레드 안전성 문제가 생길 수 있습니다.

AtomicInteger 같은 원자적 변수를 사용할 수 있습니다. 스레드 안전하면서도 값을 변경할 수 있습니다.

**다른 언어와의 비교:**

JavaScript, Python 같은 언어는 클로저에서 변수를 자유롭게 변경할 수 있습니다. 하지만 이는 예상치 못한 동작을 일으킬 수 있습니다.

자바는 안전성과 명확성을 선택했습니다. 제약이 있지만 버그를 줄이고 동시성 문제를 방지합니다.

**함수형 프로그래밍 철학:**

불변성은 함수형 프로그래밍의 핵심 원칙입니다. 부수 효과를 없애고 순수 함수를 작성하도록 유도합니다. 코드를 더 예측 가능하고 테스트하기 쉽게 만듭니다.

**권장 사항:**

가능하면 람다에서 외부 상태를 변경하지 않습니다. 필요하면 파라미터로 받거나 결과를 반환합니다. 정말 변경이 필요하면 적절한 동시성 도구를 사용합니다.

## 질문 30: Java의 GC에 대해 설명해 주세요.

GC(Garbage Collection)는 자바의 자동 메모리 관리 시스템으로, 더 이상 사용되지 않는 객체를 찾아서 메모리를 회수합니다.

**기본 개념:**

개발자가 명시적으로 메모리를 해제할 필요가 없습니다. JVM이 자동으로 사용하지 않는 객체를 감지하고 제거합니다. 메모리 누수와 댕글링 포인터 문제를 크게 줄여줍니다.

**도달 가능성(Reachability):**

GC는 루트(GC Root)로부터 도달 가능한 객체를 살아있는 것으로 간주합니다. 루트에는 스택의 로컬 변수, static 변수, JNI 참조 등이 포함됩니다.

루트에서 시작하여 참조를 따라가며 도달할 수 있는 모든 객체를 마킹합니다. 마킹되지 않은 객체는 가비지로 간주되어 회수됩니다.

**세대별 GC (Generational GC):**

대부분의 객체는 금방 죽습니다(약한 세대 가설). 이를 기반으로 힙을 여러 세대로 나눕니다.

Young Generation은 새로 생성된 객체가 위치합니다. Eden, Survivor 0, Survivor 1 영역으로 나뉩니다. Minor GC가 자주 발생하며 빠릅니다.

Old Generation은 오래 살아남은 객체가 이동합니다. Young에서 여러 번 GC를 견딘 객체가 승격(promotion)됩니다. Major GC 또는 Full GC가 발생하며 느립니다.

Metaspace(Java 8 이후)는 클래스 메타데이터를 저장합니다. 이전의 Permanent Generation을 대체합니다.

**GC 알고리즘:**

Serial GC는 단일 스레드로 수행되며 간단하지만 느립니다. 작은 애플리케이션이나 단일 프로세서 환경에 적합합니다.

Parallel GC는 여러 스레드로 수행되어 처리량을 높입니다. Young Generation을 병렬로 처리합니다.

CMS(Concurrent Mark Sweep)는 애플리케이션과 동시에 실행되어 일시 정지 시간을 줄입니다. Old Generation에 적용되며 저지연이 중요한 경우 사용됩니다.

G1 GC(Garbage First)는 큰 힙에 적합하며 예측 가능한 일시 정지 시간을 제공합니다. 힙을 여러 영역(region)으로 나누고 가비지가 많은 영역을 우선 회수합니다. Java 9 이후 기본 GC입니다.

ZGC와 Shenandoah는 초저지연 GC로, 매우 짧은 일시 정지(10ms 이하)를 목표로 합니다. 대용량 힙에서 효과적입니다.

**GC 과정:**

Minor GC는 Eden 영역이 가득 차면 발생합니다. 살아있는 객체를 Survivor 영역으로 이동시킵니다. Survivor 간에도 객체를 옮기며 age를 증가시킵니다. 매우 빠르게 수행됩니다.

Major GC는 Old Generation이 가득 차면 발생합니다. 전체 힙을 스캔하고 정리합니다. Stop-The-World 시간이 깁니다.

Full GC는 전체 힙을 대상으로 하며 가장 비용이 큽니다.

**Stop-The-World:**

GC가 실행되는 동안 애플리케이션 스레드가 모두 멈춥니다. 객체 그래프의 일관성을 유지하기 위해 필요합니다. 일시 정지 시간이 짧을수록 애플리케이션 응답성이 좋습니다.

**GC 튜닝:**

힙 크기를 적절히 설정합니다. Young과 Old의 비율을 조정합니다. 적절한 GC 알고리즘을 선택합니다. GC 로그를 분석하여 병목을 찾습니다. 불필요한 객체 생성을 줄입니다.

**장점:**

메모리 관리를 자동화하여 개발 생산성을 높입니다. 메모리 누수를 크게 줄입니다.

**단점:**

일시 정지가 발생하여 응답 시간이 예측 불가능할 수 있습니다. GC 오버헤드가 있어 처리량이 약간 감소합니다. 완벽한 제어가 어렵습니다.

## 질문 31: finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?

finalize 메서드를 수동으로 호출하는 것은 여러 가지 심각한 문제를 일으킬 수 있으며, 실제로 finalize 자체가 Java 9부터 deprecated되었습니다.

**finalize 메서드의 설계 의도:**

finalize는 객체가 GC에 의해 회수되기 전에 자동으로 호출되는 메서드입니다. 리소스 정리나 마지막 정리 작업을 수행하도록 설계되었습니다. 수동 호출을 위한 것이 아닙니다.

**수동 호출의 문제점:**

첫째, 중복 실행 문제가 발생합니다. 수동으로 호출한 후 나중에 GC가 다시 finalize를 호출할 수 있습니다. finalize는 한 번만 실행될 것을 가정하고 작성되므로 중복 실행은 예측 불가능한 동작을 일으킵니다.

둘째, 객체 상태가 부적절할 수 있습니다. finalize는 객체가 죽어가는 시점에 호출되도록 설계되었습니다. 수동으로 일찍 호출하면 객체가 아직 사용 중일 수 있어 리소스가 잘못 해제될 수 있습니다.

셋째, 리소스 누수가 발생할 수 있습니다. 수동 호출 후 finalize가 다시 호출되지 않도록 플래그를 설정하면, 나중에 필요한 정리 작업이 수행되지 않을 수 있습니다.

넷째, 스레드 안전성 문제가 있습니다. finalize는 GC 스레드에서 호출되도록 설계되었는데, 다른 스레드에서 수동 호출하면 동기화 문제가 생길 수 있습니다.

다섯째, 예외 처리가 불명확합니다. GC가 호출할 때는 예외가 무시되지만, 수동 호출 시에는 예외가 전파되어 의도하지 않은 동작이 발생할 수 있습니다.

**finalize 자체의 문제:**

finalize는 실행 시점이 불확실합니다. 객체가 GC될 때 호출되는데, 이 시점을 예측할 수 없습니다. 메모리가 충분하면 GC가 오랫동안 발생하지 않을 수 있습니다.

성능 문제가 있습니다. finalize를 가진 객체는 GC가 즉시 회수하지 못하고 finalizer 큐에 넣습니다. Finalizer 스레드가 처리할 때까지 메모리를 차지합니다. 이는 메모리 부족을 악화시킬 수 있습니다.

객체 부활(resurrection)이 가능합니다. finalize 내에서 자신을 다시 참조 가능하게 만들 수 있어 혼란스럽습니다.

보안 문제가 있습니다. finalize를 오버라이드하여 악의적인 코드를 실행할 수 있습니다.

**대안:**

try-with-resources를 사용합니다. AutoCloseable 인터페이스를 구현하면 자동으로 close가 호출됩니다. 명시적이고 예측 가능하며 안전합니다.

명시적 close나 dispose 메서드를 제공합니다. 사용자가 직접 호출하도록 합니다. 문서에 명확히 명시합니다.

Cleaner API(Java 9 이후)를 사용합니다. finalize보다 안전하고 유연합니다. 하지만 여전히 복잡하므로 가능하면 피하는 것이 좋습니다.

**권장 사항:**

finalize를 사용하지 않습니다. 리소스는 try-with-resources로 관리합니다. 명시적 정리 메서드를 제공하고 문서화합니다. finalize를 절대 수동으로 호출하지 않습니다.

## 질문 32: 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?

네, 변수의 값이 null이 되면 그 객체는 GC의 대상이 될 가능성이 있지만, 즉시 회수되는 것은 아니며 특정 조건을 만족해야 합니다.

**GC 대상이 되는 조건:**

객체가 GC 대상이 되려면 GC Root로부터 도달 불가능(unreachable)해야 합니다. 단순히 하나의 참조가 null이 되는 것만으로는 충분하지 않습니다.

모든 참조가 사라져야 합니다. 같은 객체를 여러 변수가 참조하고 있다면, 하나만 null이 되어도 객체는 여전히 살아있습니다.

순환 참조가 있어도 외부에서 도달할 수 없으면 GC됩니다. 현대 GC는 도달 가능성을 기반으로 하므로 순환 참조만으로는 객체를 살릴 수 없습니다.

**GC 시점:**

변수를 null로 설정했다고 즉시 GC가 발생하지 않습니다. GC는 JVM이 필요하다고 판단할 때 실행됩니다. 메모리가 부족하거나, 특정 임계값에 도달하거나, 일정 시간이 지났을 때 발생합니다.

System.gc를 호출해도 즉시 실행을 보장하지 않습니다. 단지 힌트일 뿐이며 JVM이 무시할 수 있습니다.

**예시:**

객체를 하나의 변수만 참조하는 경우, 그 변수를 null로 설정하면 객체는 도달 불가능해집니다. 다음 GC 사이클에 회수될 수 있습니다.

객체를 여러 변수가 참조하는 경우, 하나만 null이 되어도 다른 참조가 남아있으면 객체는 살아있습니다.

컬렉션에 저장된 객체는 변수를 null로 해도 컬렉션에서 여전히 참조됩니다. 컬렉션에서도 제거해야 GC 대상이 됩니다.

**명시적으로 null 설정이 유용한 경우:**

긴 생명주기를 가진 메서드나 객체에서 큰 객체를 일찍 해제하고 싶을 때 유용합니다. 메서드가 아직 끝나지 않았지만 특정 객체를 더 이상 사용하지 않는 경우 null로 설정하면 GC가 회수할 수 있습니다.

static 컬렉션이나 캐시에서 항목을 제거할 때 명시적으로 null로 설정하는 것이 좋습니다. 메모리 누수를 방지합니다.

**일반적으로 불필요한 경우:**

로컬 변수는 스코프를 벗어나면 자동으로 도달 불가능해집니다. 굳이 null을 설정할 필요가 없습니다.

짧은 메서드에서는 금방 리턴되므로 null 설정이 의미 없습니다.

**WeakReference:**

객체를 약하게 참조하고 싶다면 WeakReference를 사용할 수 있습니다. 강한 참조가 없으면 GC가 회수할 수 있게 합니다. 캐시 구현에 유용합니다.

**모범 사례:**

일반적인 경우 명시적으로 null을 설정할 필요가 없습니다. 스코프를 최소화하여 변수가 빨리 사라지도록 합니다. 큰 객체를 오래 유지하는 경우에만 명시적 null 설정을 고려합니다. 메모리 누수가 의심되면 프로파일링 도구로 확인합니다.

null 설정은 객체를 GC 대상으로 만드는 방법이지만, 실제 회수는 JVM의 재량에 달려있습니다.
