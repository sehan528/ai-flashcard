## 질문 109: Go의 빌드와 컴파일 과정을 설명해주세요.

**정의:**
Go는 정적 타입 컴파일 언어로, go build 명령으로 소스 코드를 기계어 실행 파일로 컴파일합니다. 빠른 컴파일 속도와 단일 바이너리 생성이 특징이며, 크로스 컴파일을 쉽게 수행할 수 있습니다.

**특징/원리:**
- 빠른 컴파일: 대규모 프로젝트도 초 단위로 컴파일 완료
- 정적 링크: 모든 의존성이 바이너리에 포함되어 단일 파일로 배포
- 크로스 컴파일: 다른 OS/아키텍처용 바이너리를 쉽게 생성
- 의존성 관리: Go Modules로 의존성 자동 다운로드 및 관리

**주요 명령어:**
- go build: 현재 패키지를 컴파일하여 실행 파일 생성
- go run: 소스를 컴파일하고 즉시 실행
- go install: 패키지를 컴파일하고 $GOPATH/bin이나 $GOBIN에 설치
- go test: 테스트 코드 컴파일 및 실행
- go get: 원격 패키지 다운로드 및 설치

**컴파일 과정:**
- 파싱: 소스 코드를 AST(Abstract Syntax Tree)로 변환
- 타입 체크: 정적 타입 검사 수행하여 오류 검출
- 컴파일: AST를 중간 표현으로 변환하고 최적화
- 코드 생성: 타겟 아키텍처의 기계어 생성
- 링킹: 모든 패키지와 라이브러리를 하나의 실행 파일로 링크

**빌드 옵션:**
- -o: 출력 파일명 지정
- -ldflags: 링커 플래그 전달 (버전 정보 임베딩 등)
- -tags: 빌드 태그로 조건부 컴파일
- -race: 경쟁 조건 검출기 포함
- -trimpath: 바이너리에서 파일 경로 제거
- -gcflags: 컴파일러 플래그 전달

**크로스 컴파일:**
- GOOS: 타겟 운영체제 지정 (linux, windows, darwin 등)
- GOARCH: 타겟 아키텍처 지정 (amd64, arm64 등)
- CGO_ENABLED: C 코드 연동 활성화 여부
- 예시: GOOS=linux GOARCH=amd64 go build로 Linux용 바이너리 생성

**실무 활용:**
- Docker 이미지에서 Alpine Linux용 정적 바이너리를 빌드하여 최소 이미지 크기 달성
- CI/CD 파이프라인에서 여러 플랫폼용 바이너리를 자동으로 빌드
- ldflags로 빌드 시각이나 Git 커밋 해시를 바이너리에 임베딩

---

## 질문 110: Go 모듈(Go Modules)과 의존성 관리에 대해 설명해주세요.

**정의:**
Go Modules는 Go 1.11에서 도입되어 1.16부터 기본이 된 공식 의존성 관리 시스템입니다. go.mod 파일로 모듈과 의존성을 선언하고, go.sum 파일로 체크섬을 검증하여 재현 가능한 빌드를 보장합니다.

**특징/원리:**
- 의존성 명시: go.mod에 모듈의 의존성과 버전 명시
- 시맨틱 버저닝: v1.2.3 형식의 버전 태그 사용
- 최소 버전 선택: 요구하는 최소 버전 중 가장 높은 버전 선택
- 재현성: go.sum으로 의존성의 체크섬 검증하여 일관된 빌드

**go.mod 파일:**
- module: 모듈 경로 선언 (보통 저장소 URL)
- go: Go 버전 명시
- require: 직접 의존성과 버전 명시
- replace: 의존성을 다른 모듈이나 로컬 경로로 대체
- exclude: 특정 버전 제외

**주요 명령어:**
- go mod init: 새 모듈 초기화하고 go.mod 생성
- go mod tidy: 사용되지 않는 의존성 제거하고 누락된 것 추가
- go mod download: 의존성 다운로드
- go mod vendor: 의존성을 vendor 디렉토리에 복사
- go mod verify: go.sum으로 의존성 체크섬 검증

**의존성 추가:**
- 자동: import 문 추가 후 go build나 go mod tidy 실행
- 수동: go get module@version으로 특정 버전 설치
- 간접: 의존성의 의존성은 // indirect 주석과 함께 go.mod에 추가

**버전 관리:**
- 메이저 버전: v2 이상은 import 경로에 /v2 추가
- 의사 버전: v0.0.0-20210101120000-abcdef123456 형식으로 커밋 참조
- 최신: go get module@latest로 최신 버전 설치
- 특정 버전: go get module@v1.2.3으로 특정 버전 설치

**실무 활용:**
- 프로젝트 시작 시 go mod init으로 모듈 초기화
- 정기적으로 go mod tidy를 실행하여 go.mod 정리
- go.sum을 버전 관리에 포함하여 팀원 간 동일한 의존성 보장

---

## 질문 111: 객체지향 프로그래밍(OOP)의 4가지 특징을 설명해주세요.

**정의:**
객체지향 프로그래밍은 데이터와 그것을 처리하는 메서드를 하나의 객체로 묶어 프로그램을 구조화하는 패러다임입니다. 캡슐화, 상속, 다형성, 추상화의 네 가지 핵심 특징으로 코드 재사용성, 유지보수성, 확장성을 향상시킵니다.

**특징/원리:**
- 객체: 상태(데이터)와 행위(메서드)를 하나로 묶은 단위
- 클래스: 객체를 생성하기 위한 청사진이나 템플릿
- 인스턴스: 클래스로부터 생성된 실제 객체
- 메시지 전달: 객체 간 메서드 호출로 협력

**캡슐화:**
- 정의: 데이터와 메서드를 하나로 묶고 외부로부터 내부 구현을 숨김
- 정보 은닉: private, protected 접근 제어자로 내부 상태 보호
- 인터페이스: 공개 메서드로만 객체와 상호작용
- 장점: 내부 구현 변경이 외부에 영향 주지 않아 유지보수 용이

**상속:**
- 정의: 기존 클래스의 속성과 메서드를 새 클래스가 물려받음
- 재사용성: 공통 기능을 부모 클래스에 정의하여 중복 제거
- IS-A 관계: 자식은 부모의 한 종류로 간주됨
- 오버라이딩: 자식 클래스에서 부모 메서드를 재정의하여 특화된 동작 구현
- 단점: 강한 결합으로 부모 변경 시 자식에 영향

**다형성:**
- 정의: 같은 인터페이스로 다양한 타입의 객체를 다룰 수 있는 능력
- 메서드 오버로딩: 같은 이름의 메서드를 매개변수를 달리하여 여러 개 정의
- 메서드 오버라이딩: 부모 클래스 메서드를 자식 클래스에서 재정의
- 인터페이스 다형성: 인터페이스 타입으로 다양한 구현체를 동일하게 처리
- 장점: 유연하고 확장 가능한 코드 작성

**추상화:**
- 정의: 복잡한 세부사항을 숨기고 중요한 개념만 드러냄
- 추상 클래스: 구현이 없는 추상 메서드를 포함하여 공통 인터페이스 정의
- 인터페이스: 순수하게 메서드 시그니처만 정의하여 계약 명시
- 장점: 복잡도 감소하고 관심사 분리로 이해하기 쉬운 코드

**실무 활용:**
- 캡슐화로 클래스 내부 상태를 보호하고 getter/setter로 제어된 접근 제공
- 상속보다는 컴포지션을 우선하여 유연한 설계 구현
- 인터페이스로 다형성을 활용하여 테스트 가능하고 확장 가능한 코드 작성

---

## 질문 112: SOLID 원칙에 대해 설명해주세요.

**정의:**
SOLID는 객체지향 설계의 다섯 가지 기본 원칙으로, 유지보수 가능하고 확장 가능한 소프트웨어를 만들기 위한 지침입니다. Robert C. Martin이 정리했으며, 각 원칙의 첫 글자를 따서 SOLID라고 합니다.

**특징/원리:**
- 단일 책임: 클래스는 하나의 책임만 가져야 함
- 개방-폐쇄: 확장에는 열려있고 수정에는 닫혀있어야 함
- 리스코프 치환: 자식 클래스는 부모 클래스를 대체할 수 있어야 함
- 인터페이스 분리: 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함
- 의존성 역전: 구체가 아닌 추상에 의존해야 함

**Single Responsibility Principle (SRP):**
- 정의: 클래스는 단 하나의 변경 이유만 가져야 함
- 응집도: 관련된 기능만 모아 높은 응집도 유지
- 분리: 여러 책임을 가진 클래스는 각 책임별로 분리
- 장점: 변경의 영향 범위가 작아 유지보수 용이

**Open-Closed Principle (OCP):**
- 정의: 소프트웨어 엔티티는 확장에는 열려있고 수정에는 닫혀있어야 함
- 추상화: 인터페이스나 추상 클래스로 확장 포인트 제공
- 다형성: 새로운 기능을 새 클래스로 구현하여 기존 코드 수정 최소화
- 장점: 기존 코드 변경 없이 새 기능 추가 가능

**Liskov Substitution Principle (LSP):**
- 정의: 자식 클래스는 부모 클래스를 대체할 수 있어야 함
- 계약 준수: 부모 클래스의 계약을 자식이 모두 만족해야 함
- 행위 일관성: 자식 클래스가 부모와 다르게 동작하면 안 됨
- 장점: 다형성을 안전하게 사용 가능

**Interface Segregation Principle (ISP):**
- 정의: 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 함
- 인터페이스 분리: 큰 인터페이스를 작고 구체적인 인터페이스로 분리
- 필요한 것만: 클라이언트는 필요한 메서드만 가진 인터페이스 사용
- 장점: 불필요한 의존성 제거하여 결합도 낮춤

**Dependency Inversion Principle (DIP):**
- 정의: 고수준 모듈이 저수준 모듈에 의존하지 않고 둘 다 추상에 의존해야 함
- 추상 의존: 구체 클래스가 아닌 인터페이스나 추상 클래스에 의존
- 의존성 주입: 외부에서 의존성을 주입받아 결합도 낮춤
- 장점: 구현 변경이 쉽고 테스트 가능

**실무 활용:**
- 클래스 설계 시 SOLID 원칙을 체크리스트로 사용하여 품질 향상
- 리팩토링 시 SOLID 원칙을 적용하여 코드 개선
- 코드 리뷰에서 SOLID 원칙 준수 여부 확인

---
