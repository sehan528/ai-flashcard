# Network 답변 모음 (17-20)

## 17. HTTP에 대해 설명해 주세요.

**HTTP(HyperText Transfer Protocol)**는 클라이언트와 서버 간에 데이터를 주고받기 위한 애플리케이션 계층의 프로토콜입니다.

**주요 특징:**
- **무상태성(Stateless)**: 각 요청은 독립적이며, 이전 요청의 정보를 저장하지 않습니다
- **비연결성(Connectionless)**: 요청과 응답이 완료되면 연결을 끊습니다
- **텍스트 기반 프로토콜**: 사람이 읽을 수 있는 형태로 메시지를 구성합니다
- **요청-응답 구조**: 클라이언트가 요청을 보내면 서버가 응답하는 단방향 통신입니다

**구성 요소:**
- **요청 메시지**: 요청 라인(메서드, URI, 버전), 헤더, 본문으로 구성
- **응답 메시지**: 상태 라인(버전, 상태 코드, 상태 메시지), 헤더, 본문으로 구성
- **메서드**: GET, POST, PUT, DELETE 등 클라이언트의 의도를 나타냅니다
- **상태 코드**: 2xx(성공), 3xx(리다이렉션), 4xx(클라이언트 오류), 5xx(서버 오류)

**버전별 발전:**
- **HTTP/0.9**: 단순한 GET 메서드만 지원
- **HTTP/1.0**: 헤더, 메서드, 상태 코드 도입
- **HTTP/1.1**: 지속 연결, 파이프라이닝, 호스트 헤더 추가
- **HTTP/2**: 멀티플렉싱, 헤더 압축, 서버 푸시 지원
- **HTTP/3**: QUIC 프로토콜 기반, UDP 사용

**실무 활용:**
웹 브라우저와 웹 서버 간의 통신, RESTful API 설계, 웹 서비스 구축의 기반 프로토콜로 활용됩니다.

---

## 18. 공개키와 대칭키에 대해 설명해 주세요.

**대칭키(Symmetric Key) 암호화**는 암호화와 복호화에 동일한 키를 사용하는 방식입니다.

**대칭키의 특징:**
- **빠른 속도**: 알고리즘이 단순하여 암호화/복호화 속도가 빠릅니다
- **키 관리의 어려움**: 통신 상대방과 안전하게 키를 공유해야 합니다
- **키 배포 문제**: N명이 통신하려면 N(N-1)/2개의 키가 필요합니다
- **대표 알고리즘**: AES, DES, 3DES, ChaCha20

**공개키(Public Key) 암호화**는 암호화와 복호화에 서로 다른 키를 사용하는 비대칭 암호화 방식입니다.

**공개키의 구성:**
- **공개키(Public Key)**: 누구나 알 수 있으며, 암호화에 사용됩니다
- **개인키(Private Key)**: 소유자만 가지고 있으며, 복호화에 사용됩니다
- **수학적 관계**: 두 키는 수학적으로 연관되어 있지만, 공개키로 개인키를 유추할 수 없습니다

**공개키의 특징:**
- **키 배포 용이**: 공개키는 누구에게나 공개해도 안전합니다
- **느린 속도**: 복잡한 수학 연산으로 인해 대칭키보다 느립니다
- **디지털 서명**: 개인키로 암호화하여 신원을 증명할 수 있습니다
- **대표 알고리즘**: RSA, ECC, DSA

**하이브리드 방식:**
실무에서는 두 방식을 결합하여 사용합니다. 공개키로 대칭키를 안전하게 교환하고, 실제 데이터는 빠른 대칭키로 암호화합니다. HTTPS가 대표적인 예입니다.

**장단점 비교:**
- **대칭키**: 빠르지만 키 관리가 어렵습니다
- **공개키**: 키 관리가 쉽지만 느립니다
- **따라서**: 키 교환은 공개키, 데이터 암호화는 대칭키를 사용합니다

---

## 19. 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?

HTTPS Handshake에서 인증서를 사용하는 이유는 **중간자 공격(Man-in-the-Middle Attack)을 방지**하기 위함입니다.

**인증서가 없을 때의 문제점:**
공개키 암호화만 사용하면, 클라이언트는 서버가 보낸 공개키가 진짜 서버의 것인지 확인할 수 없습니다. 공격자가 중간에서 자신의 공개키를 보낼 수 있고, 이 경우 모든 통신 내용이 노출됩니다.

**인증서의 역할:**
- **서버 신원 확인**: 인증서를 통해 서버의 도메인과 공개키의 소유자를 확인합니다
- **제3자 검증**: 신뢰할 수 있는 인증 기관(CA)이 서버의 신원을 보증합니다
- **무결성 보장**: 인증서에 포함된 디지털 서명으로 위변조를 감지합니다

**인증서의 구성 요소:**
- **서버 정보**: 도메인 이름, 조직 정보
- **서버의 공개키**: 실제 암호화에 사용될 키
- **발급 기관 정보**: 어느 CA가 발급했는지
- **유효 기간**: 인증서의 시작/만료 날짜
- **디지털 서명**: CA의 개인키로 서명하여 무결성 보장

**검증 과정:**
1. 클라이언트가 서버로부터 인증서를 받습니다
2. 클라이언트는 브라우저에 내장된 CA의 공개키로 인증서의 서명을 검증합니다
3. 인증서의 도메인이 접속한 도메인과 일치하는지 확인합니다
4. 인증서의 유효 기간을 확인합니다
5. 인증서가 폐기되지 않았는지 확인합니다

**신뢰 체인:**
루트 CA가 중간 CA를 인증하고, 중간 CA가 서버 인증서를 인증하는 계층적 신뢰 구조를 형성합니다. 이를 통해 전 세계적으로 통일된 신뢰 체계를 구축합니다.

**실무적 중요성:**
인증서가 없다면 피싱 사이트와 정상 사이트를 구별할 수 없으며, 온라인 뱅킹이나 전자상거래 같은 보안이 중요한 서비스를 안전하게 제공할 수 없습니다.

---

## 20. SSL과 TLS의 차이는 무엇인가요?

**SSL(Secure Sockets Layer)**과 **TLS(Transport Layer Security)**는 모두 네트워크 통신의 보안을 제공하는 암호화 프로토콜이며, TLS는 SSL의 후속 버전입니다.

**역사적 발전 과정:**
- **SSL 1.0**: 넷스케이프에서 개발했으나 공개되지 않음
- **SSL 2.0(1995)**: 최초 공개 버전이나 심각한 보안 취약점 존재
- **SSL 3.0(1996)**: 보안 개선, 가장 널리 사용된 SSL 버전
- **TLS 1.0(1999)**: SSL 3.0 기반, IETF 표준으로 채택
- **TLS 1.1(2006)**: CBC 공격 방어 기능 추가
- **TLS 1.2(2008)**: 더 강력한 암호화 알고리즘 지원
- **TLS 1.3(2018)**: 핸드셰이크 간소화, 보안 강화

**주요 차이점:**
- **명칭과 관리**: SSL은 넷스케이프의 프로토콜, TLS는 IETF 표준
- **암호화 알고리즘**: TLS는 더 강력하고 다양한 암호화 방식 지원
- **메시지 인증**: SSL은 MAC을 사용, TLS는 HMAC을 사용하여 더 안전함
- **핸드셰이크 프로세스**: TLS 1.3은 1-RTT 또는 0-RTT로 연결 속도 개선
- **경고 메시지**: TLS는 더 세분화된 경고 코드 제공

**보안 측면의 차이:**
- **SSL 3.0 이하**: POODLE 공격 등 심각한 취약점으로 더 이상 사용 금지
- **TLS 1.0/1.1**: BEAST, CRIME 등의 취약점 존재, 점차 지원 중단
- **TLS 1.2**: 현재 가장 널리 사용되는 안전한 버전
- **TLS 1.3**: 취약한 암호화 제거, 완전 순방향 비밀성(PFS) 강제

**핸드셰이크 효율성:**
- **SSL/TLS 1.2**: 2-RTT 필요 (왕복 2회)
- **TLS 1.3**: 1-RTT로 단축, 재연결 시 0-RTT 가능

**현재 상황:**
실무에서는 "SSL 인증서"나 "SSL/TLS"라는 용어를 흔히 사용하지만, 실제로는 TLS 프로토콜을 의미합니다. SSL은 역사적 용어로만 남아있으며, 모든 현대 시스템은 TLS를 사용합니다.

**실무 권장사항:**
- 최소 TLS 1.2 이상 사용
- 가능하면 TLS 1.3 사용
- SSL 2.0, 3.0, TLS 1.0, 1.1은 비활성화
- 강력한 암호화 스위트만 허용
