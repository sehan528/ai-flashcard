# Spring 답변 21-24

## 질문 21: Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.

synchronized 키워드는 붙는 위치에 따라 사용하는 락 객체와 동기화 범위가 달라집니다.

**인스턴스 메서드에 synchronized:**

메서드 전체가 동기화됩니다. 이 경우 this 객체의 모니터 락을 사용합니다. 같은 객체의 synchronized 인스턴스 메서드들은 모두 같은 락을 공유하므로, 한 스레드가 하나의 synchronized 메서드를 실행 중이면 다른 스레드는 같은 객체의 다른 synchronized 메서드도 실행할 수 없습니다.

객체 인스턴스별로 독립적인 락을 가집니다. 서로 다른 객체 인스턴스의 synchronized 메서드는 동시에 실행될 수 있습니다.

인스턴스 변수를 보호하는 데 적합합니다. 객체의 상태를 변경하는 여러 메서드를 동기화하여 일관성을 유지할 수 있습니다.

**static 메서드에 synchronized:**

메서드 전체가 동기화되며, 클래스 객체(Class object)의 락을 사용합니다. 모든 인스턴스가 같은 클래스 락을 공유합니다.

같은 클래스의 모든 synchronized static 메서드는 하나의 락을 공유합니다. 한 스레드가 하나의 synchronized static 메서드를 실행 중이면, 다른 스레드는 같은 클래스의 다른 synchronized static 메서드도 실행할 수 없습니다.

static 변수를 보호하는 데 적합합니다. 클래스 레벨의 공유 자원을 동기화할 때 사용합니다.

인스턴스 메서드의 synchronized와는 독립적입니다. 인스턴스 락과 클래스 락은 다르므로, synchronized instance 메서드와 synchronized static 메서드는 동시에 실행될 수 있습니다.

**synchronized 블록 (this 사용):**

특정 코드 블록만 동기화합니다. this 객체의 락을 사용하므로 synchronized 인스턴스 메서드와 같은 락을 공유합니다.

동기화 범위를 최소화할 수 있어 성능이 향상됩니다. 메서드 전체가 아닌 필요한 부분만 보호할 수 있습니다.

동일한 객체에 대해 여러 synchronized(this) 블록과 synchronized 인스턴스 메서드는 서로 배타적입니다.

**synchronized 블록 (다른 객체 사용):**

명시적으로 지정한 객체의 락을 사용합니다. 락 객체를 자유롭게 선택할 수 있어 가장 유연합니다.

여러 개의 독립적인 락을 사용하여 동시성을 높일 수 있습니다. 서로 관련 없는 데이터는 다른 락으로 보호하여 경합을 줄입니다.

private final 객체를 락으로 사용하는 것이 권장됩니다. 외부에서 같은 객체로 동기화하는 것을 방지하여 데드락 위험을 줄입니다.

**synchronized 블록 (클래스 객체 사용):**

synchronized static 메서드와 같은 효과입니다. 클래스 레벨의 락을 사용하여 모든 인스턴스가 공유합니다.

static 메서드가 아니어도 클래스 락을 사용할 수 있습니다. 인스턴스 메서드 내에서 static 자원을 보호할 때 유용합니다.

**선택 기준:**

인스턴스 상태를 보호할 때는 인스턴스 락을, static 상태를 보호할 때는 클래스 락을 사용합니다. 동기화 범위를 최소화하려면 블록을 사용하고, 여러 독립적인 자원은 서로 다른 락으로 보호합니다.

## 질문 22: 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?

synchronized는 간단하고 안전하지만, 효율적인 코드 작성 관점에서는 여러 한계가 있습니다.

**synchronized의 단점:**

첫째, 성능 오버헤드가 큽니다. 락을 획득하고 해제하는 과정에서 CPU 사이클이 소비됩니다. 메모리 배리어를 설정하여 캐시를 동기화하는 비용이 발생합니다. 경합이 발생하면 대기하는 스레드들이 컨텍스트 스위칭을 일으켜 성능이 크게 저하됩니다.

둘째, 확장성이 낮습니다. 모든 스레드가 하나의 락을 놓고 경쟁하면 병목 현상이 발생합니다. 멀티코어 환경에서 코어 수를 늘려도 성능이 비례하여 향상되지 않습니다.

셋째, 읽기와 쓰기를 구분하지 않습니다. 읽기만 하는 경우에도 락이 필요하여 불필요한 경합이 발생합니다. 읽기 작업이 많은 경우 비효율적입니다.

넷째, 세밀한 제어가 불가능합니다. 락 획득 시도에 타임아웃을 설정할 수 없습니다. 공정성(fairness)을 제어할 수 없어 스레드 기아(starvation)가 발생할 수 있습니다. 인터럽트에 응답할 수 없습니다.

다섯째, 데드락 위험이 있습니다. 여러 락을 사용할 때 순서를 잘못 지키면 데드락이 발생할 수 있습니다. 디버깅이 어렵습니다.

**더 효율적인 대안:**

첫째, java.util.concurrent 패키지의 도구들을 사용합니다. Lock 인터페이스는 tryLock, lockInterruptibly 같은 고급 기능을 제공합니다. ReadWriteLock은 읽기와 쓰기를 분리하여 동시 읽기를 허용합니다.

둘째, 원자적 변수(Atomic variables)를 사용합니다. AtomicInteger, AtomicReference 등은 락 없이 CAS(Compare-And-Swap) 연산으로 동기화합니다. 경합이 적은 경우 synchronized보다 훨씬 빠릅니다.

셋째, 동시성 컬렉션을 활용합니다. ConcurrentHashMap, CopyOnWriteArrayList 등은 내부적으로 최적화된 동기화를 제공합니다. 세밀한 락 분할(lock striping)로 동시성을 높입니다.

넷째, 불변 객체를 우선 고려합니다. 상태가 변하지 않으면 동기화가 필요 없습니다. 함수형 프로그래밍 스타일로 부수 효과를 제거합니다.

다섯째, 스레드 로컬(ThreadLocal)을 사용합니다. 각 스레드가 독립적인 복사본을 가지면 공유가 없어 동기화가 불필요합니다.

**synchronized를 사용해도 좋은 경우:**

코드가 간단하고 명확해야 할 때 유용합니다. 성능이 크리티컬하지 않은 경우 가독성이 더 중요합니다. 경합이 거의 없는 경우 오버헤드가 작습니다. JVM의 최적화(biased locking, lock elision)가 효과적으로 작동합니다.

**결론:**

synchronized는 완벽하지 않지만, 간단한 동기화에는 여전히 유용합니다. 고성능이 필요하거나 복잡한 동시성 패턴을 구현해야 한다면 java.util.concurrent의 고급 도구들을 고려해야 합니다. 항상 프로파일링으로 실제 병목을 확인한 후 최적화하는 것이 중요합니다.

## 질문 23: Synchronized를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.

자바는 synchronized 외에도 다양한 동기화 기법을 제공합니다.

**1. Lock 인터페이스 (ReentrantLock):**

java.util.concurrent.locks 패키지의 Lock 인터페이스는 synchronized보다 유연한 락 메커니즘을 제공합니다. ReentrantLock이 가장 많이 사용되는 구현체입니다.

tryLock으로 락 획득을 시도하고 실패하면 즉시 반환할 수 있습니다. 타임아웃을 설정하여 일정 시간만 대기할 수 있습니다. lockInterruptibly로 대기 중 인터럽트에 응답할 수 있습니다.

공정성(fairness)을 설정할 수 있습니다. 공정 락은 대기 시간이 긴 스레드에게 우선권을 주어 기아 현상을 방지합니다.

Condition 객체로 복잡한 대기/통지 패턴을 구현할 수 있습니다. wait/notify보다 명확하고 강력합니다.

명시적으로 unlock을 호출해야 하므로 finally 블록에서 처리해야 합니다.

**2. ReadWriteLock (ReentrantReadWriteLock):**

읽기와 쓰기를 분리하여 동시성을 높입니다. 여러 스레드가 동시에 읽기 락을 획득할 수 있지만, 쓰기 락은 배타적입니다.

읽기가 많고 쓰기가 적은 경우 성능이 크게 향상됩니다. 데이터를 조회하는 작업이 대부분인 캐시나 데이터베이스에 적합합니다.

쓰기 락을 기다리는 동안 새로운 읽기를 허용할지 제어할 수 있습니다. 쓰기 기아를 방지하거나 읽기 처리량을 최대화할 수 있습니다.

**3. 원자적 변수 (Atomic Variables):**

AtomicInteger, AtomicLong, AtomicReference, AtomicBoolean 등이 있습니다. 락 없이 CAS(Compare-And-Swap) 연산으로 원자성을 보장합니다.

논블로킹(non-blocking) 알고리즘으로 대기가 없어 성능이 우수합니다. 간단한 카운터나 플래그에 매우 효율적입니다.

getAndIncrement, compareAndSet 같은 원자적 연산을 제공합니다. 락 오버헤드 없이 스레드 안전성을 확보합니다.

복잡한 연산은 루프 안에서 CAS를 반복해야 하므로 코드가 복잡해질 수 있습니다.

**4. 동시성 컬렉션:**

ConcurrentHashMap은 세밀한 락 분할(lock striping)로 높은 동시성을 제공합니다. 읽기는 대부분 락 없이 수행됩니다.

CopyOnWriteArrayList는 쓰기 시 전체를 복사하여 읽기에서 락이 필요 없습니다. 읽기가 압도적으로 많을 때 적합합니다.

BlockingQueue 구현체들(ArrayBlockingQueue, LinkedBlockingQueue)은 생산자-소비자 패턴에 최적화되어 있습니다.

ConcurrentSkipListMap, ConcurrentSkipListSet은 정렬된 동시성 컬렉션을 제공합니다.

**5. Semaphore:**

동시에 접근할 수 있는 스레드 수를 제한합니다. 리소스 풀이나 연결 제한에 유용합니다.

acquire와 release로 허가(permit)를 얻고 반환합니다. 카운팅 세마포어로 여러 허가를 관리할 수 있습니다.

**6. CountDownLatch와 CyclicBarrier:**

CountDownLatch는 하나 이상의 스레드가 다른 스레드들의 작업 완료를 기다리게 합니다. 초기화 작업이 완료될 때까지 대기하는 등의 시나리오에 사용됩니다.

CyclicBarrier는 모든 스레드가 특정 지점에 도달할 때까지 기다립니다. 재사용 가능하여 반복적인 동기화에 적합합니다.

**7. StampedLock:**

Java 8에서 도입된 고급 락입니다. 낙관적 읽기(optimistic read)를 지원하여 읽기 성능을 극대화합니다.

읽기 락, 쓰기 락, 낙관적 읽기 세 가지 모드를 제공합니다. ReentrantReadWriteLock보다 빠르지만 재진입을 지원하지 않습니다.

**8. volatile 키워드:**

변수의 가시성을 보장합니다. 한 스레드의 쓰기가 다른 스레드에서 즉시 보입니다.

원자적 연산은 보장하지 않습니다. 단순한 플래그나 상태 변수에 적합합니다.

**선택 기준:**

단순한 상호 배제는 synchronized나 ReentrantLock을 사용합니다. 읽기가 많으면 ReadWriteLock이나 StampedLock을 고려합니다. 간단한 원자적 연산은 Atomic 변수를 사용합니다. 복잡한 동시성 패턴은 고급 동기화 도구를 활용합니다.

## 질문 24: Thread Local에 대해 설명해 주세요.

ThreadLocal은 각 스레드가 독립적인 변수 복사본을 가질 수 있게 하는 메커니즘입니다. 스레드 간에 데이터를 공유하지 않으므로 동기화가 필요 없습니다.

**기본 개념:**

ThreadLocal 변수는 각 스레드마다 별도의 값을 저장합니다. 한 스레드에서 값을 설정하거나 읽으면 그 스레드만의 값에 접근합니다. 다른 스레드의 값과는 완전히 독립적입니다.

내부적으로 각 Thread 객체는 ThreadLocalMap을 가지고 있습니다. 이 맵은 ThreadLocal 객체를 키로, 스레드별 값을 밸류로 저장합니다.

**주요 메서드:**

set 메서드로 현재 스레드의 값을 설정합니다. get 메서드로 현재 스레드의 값을 가져옵니다. remove 메서드로 현재 스레드의 값을 삭제합니다. initialValue 메서드를 오버라이드하여 초기값을 설정할 수 있습니다.

Java 8부터는 withInitial 정적 팩토리 메서드로 람다식으로 초기값을 간편하게 설정할 수 있습니다.

**사용 사례:**

첫째, 사용자 컨텍스트 저장에 유용합니다. 웹 애플리케이션에서 현재 요청을 처리하는 사용자 정보나 세션 정보를 ThreadLocal에 저장하여 어디서든 접근할 수 있습니다. 메서드 파라미터로 계속 전달할 필요가 없어집니다.

둘째, 트랜잭션 컨텍스트 관리에 사용됩니다. Spring의 트랜잭션 관리자는 ThreadLocal을 사용하여 현재 트랜잭션 정보를 저장합니다. 같은 스레드 내에서 호출되는 모든 메서드가 같은 트랜잭션을 공유합니다.

셋째, 날짜 포맷터 같은 스레드 안전하지 않은 객체를 사용할 때 활용됩니다. SimpleDateFormat은 스레드 안전하지 않지만, ThreadLocal로 각 스레드마다 인스턴스를 가지면 안전하게 사용할 수 있습니다. 객체 생성 비용을 줄이면서도 동기화 오버헤드를 피할 수 있습니다.

넷째, 성능 최적화에 사용됩니다. 스레드마다 버퍼나 캐시를 가져 락 경합 없이 빠르게 접근할 수 있습니다.

**장점:**

동기화가 필요 없습니다. 각 스레드가 독립적인 값을 가지므로 경합이 없고 락 오버헤드가 없습니다.

전역 변수처럼 사용할 수 있지만 스레드 안전합니다. 코드 어디서든 접근 가능하면서도 스레드 간 간섭이 없습니다.

**단점과 주의사항:**

메모리 누수 위험이 있습니다. ThreadLocal 변수를 제거하지 않으면 스레드가 살아있는 동안 계속 메모리를 차지합니다. 특히 스레드 풀을 사용하는 환경에서 스레드가 재사용되므로 이전 요청의 데이터가 남아있을 수 있습니다.

반드시 사용 후 remove를 호출해야 합니다. try-finally 패턴으로 확실히 정리합니다. Spring의 RequestContextHolder 같은 경우 프레임워크가 자동으로 정리해줍니다.

상속 문제가 있습니다. 기본 ThreadLocal은 자식 스레드로 값이 전파되지 않습니다. InheritableThreadLocal을 사용하면 자식 스레드가 부모의 값을 상속받지만, 스레드 풀 환경에서는 예상대로 동작하지 않을 수 있습니다.

디버깅이 어렵습니다. 값이 스레드에 숨겨져 있어 추적하기 어렵고, 잘못 사용하면 예상치 못한 동작이 발생할 수 있습니다.

**모범 사례:**

항상 try-finally로 remove를 호출합니다. 가능하면 프레임워크가 제공하는 컨텍스트 관리 기능을 사용합니다. ThreadLocal은 static final로 선언하는 것이 일반적입니다. 꼭 필요한 경우에만 사용하고 남용하지 않습니다.
