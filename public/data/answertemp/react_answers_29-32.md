# React 답변 29-32

## 질문 29: useCallback은 언제 사용해야 하나요?

**정의:**
useCallback은 함수를 메모이제이션하는 Hook입니다. 의존성이 변경될 때만 새 함수를 생성하고, 그렇지 않으면 이전 함수 인스턴스를 재사용하여 불필요한 리렌더링을 방지합니다.

**동작 원리:**
- 첫 번째 인자는 메모이제이션할 함수입니다.
- 두 번째 인자는 의존성 배열입니다.
- 의존성이 변경되면 새 함수를 생성합니다.
- 변경되지 않으면 이전 함수를 반환합니다.
- useMemo의 함수 전용 버전입니다.

**사용해야 하는 경우:**
- 자식 컴포넌트에 콜백을 props로 전달할 때입니다. 자식이 React.memo로 최적화되어 있어야 효과적입니다.
- useEffect의 의존성 배열에 함수를 넣을 때입니다.
- 커스텀 Hook에서 함수를 반환할 때입니다.
- 이벤트 핸들러를 다른 Hook의 의존성으로 사용할 때입니다.

**사용하지 말아야 하는 경우:**
- 함수를 props로 전달하지 않는 경우입니다.
- 자식이 최적화되어 있지 않은 경우입니다.
- 모든 함수를 useCallback으로 감싸는 것은 과도합니다.
- 측정 없이 추측으로 최적화하는 경우입니다.

**React.memo와 조합:**
- 자식을 React.memo로 감쌉니다.
- 부모의 콜백을 useCallback으로 메모이제이션합니다.
- 자식의 props가 같으면 리렌더링을 건너뜁니다.
- 메모이제이션하지 않으면 매번 새 함수가 전달되어 효과가 없습니다.

**의존성 관리:**
- 함수 내부에서 사용하는 모든 값을 의존성에 포함합니다.
- Props, State, Context 값 등이 포함됩니다.
- ESLint exhaustive-deps 규칙을 따릅니다.
- 의존성이 자주 바뀌면 효과가 줄어듭니다.

**클로저와 최신 값:**
- 의존성에 포함하지 않으면 오래된 값을 참조합니다.
- 클로저가 생성 시점의 값을 캡처하기 때문입니다.
- 함수형 업데이트로 최신 state에 접근할 수 있습니다.
- useRef로 최신 값을 참조할 수도 있습니다.

**useCallback vs useMemo:**
- useCallback은 함수 자체를 반환합니다.
- useMemo는 함수 실행 결과를 반환합니다.
- useCallback은 useMemo의 편의 문법입니다.
- 함수 메모이제이션에는 useCallback이 더 명확합니다.

**실무 활용:**
- 목록의 각 아이템에 전달하는 핸들러를 메모이제이션합니다.
- 디바운스나 쓰로틀 함수를 메모이제이션합니다.
- useEffect 내부에서 사용할 함수를 메모이제이션합니다.
- 커스텀 Hook에서 반환하는 함수를 메모이제이션합니다.
- 항상 실제 성능 문제가 있을 때만 사용합니다.

---

## 질문 30: key prop의 역할과 중요성은 무엇인가요?

**정의:**
key는 React가 리스트의 각 항목을 고유하게 식별하는 데 사용하는 특별한 prop입니다. Virtual DOM 비교 시 어떤 항목이 변경 추가 삭제되었는지 효율적으로 판단하게 해줍니다.

**key의 역할:**
- 리스트 항목을 고유하게 식별합니다.
- Reconciliation 알고리즘이 효율적으로 동작하게 합니다.
- 변경된 항목만 업데이트하고 나머지는 재사용합니다.
- 컴포넌트 인스턴스와 DOM 노드를 유지하거나 재생성하는 기준입니다.
- 성능과 정확성에 모두 영향을 줍니다.

**key가 없을 때의 문제:**
- React는 순서대로만 비교합니다.
- 항목이 추가 삭제되면 잘못된 요소가 업데이트됩니다.
- 모든 항목을 재생성할 수 있습니다.
- 컴포넌트 state가 잘못된 위치에 유지됩니다.
- 성능이 크게 저하됩니다.

**좋은 key 선택:**
- 데이터의 고유 ID를 사용합니다. 데이터베이스 ID가 이상적입니다.
- 안정적이고 예측 가능해야 합니다. 렌더링마다 바뀌면 안 됩니다.
- 형제 간에만 고유하면 됩니다. 전역적으로 고유할 필요는 없습니다.
- 문자열이나 숫자를 사용합니다.

**나쁜 key 선택:**
- 배열 인덱스를 key로 사용하면 안 됩니다. 순서가 바뀌거나 항목이 추가 삭제될 때 문제가 생깁니다.
- Math.random이나 Date.now는 절대 사용하면 안 됩니다. 매번 새 key가 생성되어 모든 항목이 재생성됩니다.
- 불안정한 값은 버그를 유발합니다.

**인덱스를 key로 사용할 수 있는 경우:**
- 리스트가 정적이고 재정렬되지 않을 때입니다.
- 항목이 추가 삭제되지 않을 때입니다.
- 항목에 고유 ID가 없고 순서가 중요할 때입니다.
- 매우 제한적인 경우에만 허용됩니다.

**key 변경의 효과:**
- key가 바뀌면 컴포넌트가 언마운트되고 새로 마운트됩니다.
- state가 초기화됩니다.
- DOM 노드가 새로 생성됩니다.
- 의도적으로 state를 리셋하는 데 활용할 수 있습니다.

**Fragment와 key:**
- Fragment에도 key를 추가할 수 있습니다.
- 짧은 문법으로는 key를 줄 수 없습니다.
- React.Fragment를 명시적으로 사용해야 합니다.

**실무 활용:**
- API에서 받은 데이터의 ID를 key로 사용합니다.
- 고유 ID가 없으면 조합하여 만듭니다.
- 폼을 리셋하려면 key를 바꿔서 컴포넌트를 재생성합니다.
- 성능 문제가 있으면 key를 먼저 확인합니다.
- 절대 인덱스를 기본으로 사용하지 않습니다.

---

## 질문 31: 불필요한 리렌더링을 방지하는 방법은 무엇인가요?

**정의:**
불필요한 리렌더링은 실제로 화면에 변화가 없는데도 컴포넌트가 다시 렌더링되는 것입니다. 성능 저하의 주요 원인이며, 여러 최적화 기법으로 방지할 수 있습니다.

**React.memo 사용:**
- 함수형 컴포넌트를 메모이제이션합니다.
- props가 변경되지 않으면 리렌더링을 건너뜁니다.
- 얕은 비교로 props를 확인합니다.
- 부모가 리렌더링되어도 자식은 안정적입니다.

**useMemo로 값 메모이제이션:**
- 계산 비용이 큰 값을 캐싱합니다.
- 객체나 배열의 참조를 안정적으로 유지합니다.
- 의존성이 변경될 때만 재계산합니다.
- props로 전달하는 객체를 메모이제이션합니다.

**useCallback으로 함수 메모이제이션:**
- 함수의 참조를 안정적으로 유지합니다.
- 자식에게 전달하는 콜백을 메모이제이션합니다.
- 의존성이 변경될 때만 새 함수를 생성합니다.
- React.memo와 함께 사용하면 효과적입니다.

**State 구조 최적화:**
- 관련 없는 state를 분리합니다.
- 자주 바뀌는 state와 그렇지 않은 state를 나눕니다.
- state를 필요한 컴포넌트 가까이 둡니다.
- 과도하게 끌어올리지 않습니다.

**Component Composition:**
- children prop을 활용합니다.
- state를 가진 컴포넌트와 UI를 분리합니다.
- 리렌더링 범위를 최소화합니다.
- 구조를 재설계하여 최적화합니다.

**Context 최적화:**
- Context를 여러 개로 분리합니다.
- 자주 변경되는 값과 그렇지 않은 값을 나눕니다.
- Provider value를 메모이제이션합니다.
- 필요한 컴포넌트만 Context를 구독하게 합니다.

**key를 올바르게 사용:**
- 안정적인 고유 ID를 key로 사용합니다.
- 인덱스나 랜덤 값을 피합니다.
- key가 바뀌면 컴포넌트가 재생성됩니다.

**조건부 렌더링 최적화:**
- 불필요한 컴포넌트는 렌더링하지 않습니다.
- 조기 반환으로 렌더링을 건너뜁니다.
- 조건부 마운트를 활용합니다.

**측정과 검증:**
- React DevTools Profiler를 사용합니다.
- 실제로 문제가 있는지 확인합니다.
- 추측하지 말고 측정합니다.
- 최적화 전후를 비교합니다.

**실무 활용:**
- 큰 목록은 가상화 라이브러리를 사용합니다.
- 무거운 컴포넌트를 React.memo로 감쌉니다.
- props로 전달하는 값들을 메모이제이션합니다.
- state 구조를 잘 설계하여 리렌더링 범위를 줄입니다.
- 과도한 최적화는 피하고 병목만 해결합니다.

---

## 질문 32: Higher-Order Component(HOC)란 무엇이고 언제 사용하나요?

**정의:**
Higher-Order Component는 컴포넌트를 받아서 새로운 컴포넌트를 반환하는 함수입니다. 컴포넌트 로직을 재사용하는 고급 패턴으로, React의 조합적 특성을 활용합니다.

**HOC의 개념:**
- 컴포넌트를 인자로 받습니다.
- 향상된 새 컴포넌트를 반환합니다.
- 원본 컴포넌트를 수정하지 않습니다.
- 순수 함수입니다. 부작용이 없습니다.
- with 접두사를 관례적으로 사용합니다.

**HOC의 용도:**
- 공통 로직을 재사용합니다. 인증 로깅 데이터 페칭 등입니다.
- props를 조작하거나 추가합니다.
- 조건부 렌더링을 추상화합니다.
- 컴포넌트에 기능을 주입합니다.
- 횡단 관심사를 분리합니다.

**HOC 작성 패턴:**
- 함수를 반환하는 함수를 만듭니다.
- 원본 컴포넌트를 래핑합니다.
- 추가 props를 전달합니다.
- 원본 props를 모두 전달합니다.
- displayName을 설정하여 디버깅을 쉽게 합니다.

**일반적인 HOC 예시:**
- withAuth: 인증 여부를 확인하고 리다이렉트합니다.
- withLoading: 로딩 상태를 관리하고 스피너를 표시합니다.
- withErrorBoundary: 에러 처리를 추가합니다.
- withLogger: 렌더링을 로깅합니다.
- Redux의 connect: 스토어를 연결합니다.

**HOC의 장점:**
- 로직을 재사용할 수 있습니다.
- 컴포넌트를 깔끔하게 유지합니다.
- 여러 HOC를 조합할 수 있습니다.
- 원본 컴포넌트를 수정하지 않습니다.
- 횡단 관심사를 효과적으로 분리합니다.

**HOC의 단점:**
- 래퍼 지옥이 발생할 수 있습니다. 여러 HOC를 중첩하면 복잡해집니다.
- props 충돌 가능성이 있습니다.
- 정적 메서드가 복사되지 않습니다.
- ref가 전달되지 않습니다. forwardRef가 필요합니다.
- 디버깅이 어려울 수 있습니다.

**Hooks와의 비교:**
- Hooks가 등장하면서 HOC 사용이 줄었습니다.
- Custom Hook이 더 간단하고 직관적입니다.
- HOC는 컴포넌트 트리를 복잡하게 만듭니다.
- Hooks는 평평한 구조를 유지합니다.
- 새 코드는 Hooks를 권장합니다.

**여전히 HOC가 유용한 경우:**
- 컴포넌트를 조건부로 렌더링할 때입니다.
- 레거시 코드와 통합할 때입니다.
- 라이브러리에서 제공하는 HOC를 사용할 때입니다.
- 컴포넌트 래핑이 필요한 특수한 경우입니다.

**실무 활용:**
- 기존 HOC를 유지보수합니다.
- 레거시 라이브러리의 HOC를 사용합니다.
- 새로운 기능은 Hooks로 구현합니다.
- HOC를 Custom Hook으로 마이그레이션합니다.
- 팀의 코드 스타일과 일관성을 유지합니다.

---
