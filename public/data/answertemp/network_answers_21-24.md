# Network 답변 모음 (21-24)

## 21. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.

**소켓(Socket) 통신**은 네트워크 상에서 두 프로그램 간의 양방향 통신을 위한 저수준 인터페이스입니다.

**소켓 통신의 특징:**
- **TCP/UDP 기반**: 전송 계층 프로토콜을 직접 사용합니다
- **저수준 제어**: IP 주소와 포트 번호를 직접 지정하여 통신합니다
- **자유로운 프로토콜**: 애플리케이션이 원하는 형태로 데이터를 주고받을 수 있습니다
- **플랫폼 독립적**: 다양한 언어와 환경에서 사용 가능합니다

**웹소켓(WebSocket)**은 웹 브라우저와 서버 간의 실시간 양방향 통신을 위한 프로토콜입니다.

**웹소켓의 특징:**
- **HTTP 기반 시작**: HTTP 연결을 웹소켓으로 업그레이드합니다
- **지속적 연결**: 한 번 연결되면 명시적으로 끊기 전까지 유지됩니다
- **양방향 통신**: 서버와 클라이언트가 자유롭게 메시지를 주고받습니다
- **낮은 오버헤드**: HTTP 폴링보다 효율적입니다

**프로토콜 계층 차이:**
- **소켓**: 전송 계층(TCP/UDP) 위에서 동작
- **웹소켓**: 애플리케이션 계층(HTTP) 위에서 동작하며 ws:// 또는 wss:// 스킴 사용

**연결 수립 과정:**
- **소켓**: 직접 TCP 3-way handshake 수행
- **웹소켓**: HTTP 요청으로 시작하여 Upgrade 헤더를 통해 프로토콜 전환

**방화벽/프록시 통과:**
- **소켓**: 임의의 포트 사용 시 방화벽에서 차단될 수 있습니다
- **웹소켓**: HTTP(80/443 포트) 기반이라 방화벽 통과가 쉽습니다

**사용 환경:**
- **소켓**: 서버 간 통신, 데스크톱 애플리케이션, 게임 서버 등
- **웹소켓**: 웹 브라우저 기반 실시간 서비스(채팅, 알림, 주식 시세 등)

**데이터 형식:**
- **소켓**: 바이트 스트림으로 자유롭게 정의
- **웹소켓**: 텍스트(UTF-8) 또는 바이너리 프레임 구조

**실무 선택 기준:**
웹 브라우저와의 실시간 통신이 필요하면 웹소켓을, 서버 간 통신이나 네이티브 앱에서는 소켓을 사용합니다.

---

## 22. 소켓과 포트의 차이가 무엇인가요?

**포트(Port)**는 네트워크 통신에서 특정 프로세스나 서비스를 식별하기 위한 논리적인 번호입니다.

**포트의 특징:**
- **16비트 정수**: 0부터 65535까지의 번호로 표현됩니다
- **Well-Known Ports(0-1023)**: 시스템이 예약한 포트(HTTP:80, HTTPS:443)
- **Registered Ports(1024-49151)**: 특정 애플리케이션이 등록한 포트
- **Dynamic Ports(49152-65535)**: 임시로 사용하는 포트
- **주소의 일부**: IP 주소와 함께 네트워크 종단점을 식별합니다

**소켓(Socket)**은 네트워크 통신을 위한 엔드포인트로, 실제 통신을 수행하는 프로그래밍 인터페이스입니다.

**소켓의 구성:**
- **프로토콜**: TCP, UDP 등
- **로컬 IP 주소**: 호스트의 IP 주소
- **로컬 포트 번호**: 호스트의 포트 번호
- **원격 IP 주소**: 상대방의 IP 주소
- **원격 포트 번호**: 상대방의 포트 번호

**관계성:**
포트는 소켓을 구성하는 요소 중 하나입니다. 소켓은 5-tuple(프로토콜, 로컬 IP, 로컬 포트, 원격 IP, 원격 포트)로 고유하게 식별됩니다.

**비유:**
- **포트**: 건물의 문 번호
- **소켓**: 실제 통신을 위한 문과 통로
- **IP 주소**: 건물의 주소

**사용 관점:**
- **포트**: 서비스를 제공하는 애플리케이션을 찾기 위한 식별자
- **소켓**: 실제 데이터를 주고받기 위한 프로그래밍 객체

**서버 측 예시:**
웹 서버가 80번 포트에서 리스닝하고 있을 때, 각 클라이언트 연결마다 별도의 소켓이 생성됩니다. 포트는 하나(80)지만 소켓은 여러 개가 됩니다.

**클라이언트 측 예시:**
클라이언트는 임의의 포트(예: 50123)를 사용하여 서버의 80번 포트로 연결합니다. 이때 생성되는 소켓은 (TCP, 클라이언트IP, 50123, 서버IP, 80)로 식별됩니다.

**핵심 차이:**
포트는 단순한 번호이고, 소켓은 통신을 위한 실체입니다. 하나의 포트에 여러 소켓이 연결될 수 있습니다.

---

## 23. 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?

아니요, **여러 소켓이 같은 포트 번호를 공유할 수 있습니다**. 이는 서버 프로그래밍에서 매우 일반적인 상황입니다.

**소켓의 고유 식별:**
소켓은 5-tuple로 고유하게 식별됩니다:
- 프로토콜(TCP/UDP)
- 로컬 IP 주소
- 로컬 포트 번호
- 원격 IP 주소
- 원격 포트 번호

**서버에서의 포트 공유:**
웹 서버가 80번 포트에서 수백 개의 클라이언트 요청을 처리할 때, 모든 소켓이 로컬 포트 80번을 사용하지만, 각 소켓은 서로 다른 클라이언트 IP/포트와 연결되어 있어 구별됩니다.

**예시 상황:**
서버(192.168.1.100:80)에 세 클라이언트가 접속한 경우:
- 소켓1: (TCP, 192.168.1.100, 80, 1.2.3.4, 50000)
- 소켓2: (TCP, 192.168.1.100, 80, 1.2.3.5, 50001)
- 소켓3: (TCP, 192.168.1.100, 80, 1.2.3.6, 50002)

세 소켓 모두 로컬 포트 80을 사용하지만, 원격 주소가 달라 구별됩니다.

**리스닝 소켓과 연결 소켓:**
- **리스닝 소켓**: 새로운 연결을 기다리는 소켓 (하나만 존재)
- **연결 소켓**: 실제 클라이언트와 통신하는 소켓 (여러 개 존재)
- 둘 다 같은 포트 번호를 사용합니다

**클라이언트 측:**
클라이언트가 동일 서버에 여러 연결을 만들 때는 각각 다른 로컬 포트를 사용합니다. 운영체제가 사용 가능한 임시 포트를 자동으로 할당합니다.

**SO_REUSEADDR 옵션:**
이 소켓 옵션을 사용하면 TIME_WAIT 상태의 소켓이 사용하던 포트를 즉시 재사용할 수 있습니다. 서버 재시작 시 유용합니다.

**SO_REUSEPORT 옵션:**
리눅스와 일부 시스템에서는 여러 프로세스가 동일한 포트에서 리스닝할 수 있도록 하여 로드 밸런싱을 구현합니다.

**UDP의 경우:**
UDP는 연결 개념이 없어 하나의 소켓으로 여러 클라이언트와 통신할 수 있습니다. 각 데이터그램의 송신자 주소로 구별합니다.

**멀티플렉싱:**
운영체제의 전송 계층이 도착한 패킷의 5-tuple을 확인하여 올바른 소켓으로 전달하는 과정을 디멀티플렉싱이라고 합니다.

---

## 24. 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?

네, **이론적으로는 사용자 요청마다 소켓이 생성되지만**, 실무에서는 여러 최적화 기법으로 소켓 수를 제한합니다.

**전통적인 서버 모델의 문제:**
각 연결마다 소켓을 생성하면 다음과 같은 문제가 발생합니다:
- **메모리 부족**: 각 소켓은 커널 메모리를 소비합니다
- **파일 디스크립터 고갈**: 운영체제의 파일 디스크립터 제한에 도달합니다
- **컨텍스트 스위칭 오버헤드**: 스레드 기반 모델에서 스레드 수가 증가하면 성능 저하가 발생합니다
- **C10K 문제**: 1만 개 이상의 동시 연결 처리의 어려움

**HTTP/1.1의 Keep-Alive:**
- **지속 연결**: 한 소켓으로 여러 요청/응답을 처리합니다
- **연결 재사용**: 매번 새 소켓을 생성하지 않아 오버헤드 감소
- **타임아웃 설정**: 일정 시간 사용하지 않으면 연결을 종료합니다

**HTTP/2의 멀티플렉싱:**
- **단일 연결**: 하나의 TCP 연결(소켓)로 여러 요청을 동시에 처리합니다
- **스트림**: 각 요청/응답을 별도의 스트림으로 관리합니다
- **효율성**: 소켓 수를 크게 줄이면서도 높은 성능을 유지합니다

**커넥션 풀(Connection Pool):**
클라이언트 측에서는 미리 생성한 연결을 재사용하여 소켓 생성 비용을 줄입니다.

**이벤트 기반 아키텍처:**
- **Non-blocking I/O**: 하나의 스레드로 여러 소켓을 관리합니다
- **epoll/kqueue**: 효율적인 이벤트 모니터링으로 많은 연결을 처리합니다
- **Nginx, Node.js**: 이벤트 기반 모델로 적은 리소스로 많은 연결 처리

**로드 밸런서:**
여러 서버로 요청을 분산하여 개별 서버의 소켓 수를 제한합니다.

**운영체제 레벨 제한:**
- **ulimit**: 프로세스당 최대 파일 디스크립터 수 설정
- **sysctl**: 시스템 전체의 소켓 관련 파라미터 조정
- **tcp_max_syn_backlog**: SYN 큐의 크기 조정

**애플리케이션 레벨 제어:**
- **연결 수 제한**: 최대 동시 연결 수를 설정합니다
- **큐잉**: 초과 요청은 대기열에 넣습니다
- **타임아웃**: 유휴 연결을 적극적으로 종료합니다

**실무 권장사항:**
무한정 소켓을 생성하기보다는 연결 재사용, 멀티플렉싱, 이벤트 기반 모델 등을 활용하여 제한된 리소스로 많은 요청을 처리하는 것이 바람직합니다.
