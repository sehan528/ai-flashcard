# JavaScript 답변 33-36

## 질문 33: map(), filter(), reduce()의 차이점과 사용 사례는 무엇인가요?

**정의:**
map, filter, reduce는 배열을 다루는 고차 함수들입니다. 각각 변환, 필터링, 축약이라는 명확한 목적을 가지며, 함수형 프로그래밍의 핵심 도구입니다.

**map의 특징:**
- 배열의 각 요소를 변환합니다. 콜백 함수의 반환값으로 새 배열을 만듭니다.
- 원본 배열과 같은 길이의 배열을 반환합니다. 일대일 매핑입니다.
- 원본 배열을 변경하지 않습니다. 불변성을 유지합니다.
- 각 요소에 동일한 변환을 적용할 때 사용합니다.

**filter의 특징:**
- 조건에 맞는 요소만 선택합니다. 콜백이 true를 반환하는 요소만 포함합니다.
- 원본 배열보다 작거나 같은 길이의 배열을 반환합니다.
- 원본 배열을 변경하지 않습니다.
- 특정 조건을 만족하는 요소를 추출할 때 사용합니다.

**reduce의 특징:**
- 배열을 하나의 값으로 축약합니다. 누적 계산을 수행합니다.
- 콜백과 초기값을 받습니다. 누산기와 현재 값을 처리합니다.
- 배열이 아닌 단일 값을 반환합니다. 숫자, 객체, 배열 등 어떤 타입도 가능합니다.
- 합계, 평균, 최댓값, 객체 변환 등에 사용합니다.

**사용 사례 비교:**
- map: 배열의 모든 요소에 10을 곱하기, 객체 배열에서 특정 속성만 추출하기, 데이터 형식 변환하기
- filter: 특정 조건을 만족하는 항목 찾기, 중복 제거, null이나 undefined 필터링하기
- reduce: 배열 합계 구하기, 배열을 객체로 변환하기, 평탄화하기, 그룹화하기

**체이닝과 조합:**
- 여러 메서드를 연결하여 복잡한 변환을 수행합니다.
- filter로 필터링하고 map으로 변환하는 패턴이 흔합니다.
- reduce로 모든 작업을 할 수 있지만 가독성이 떨어질 수 있습니다.
- 성능을 고려하면 reduce 하나로 통합하는 것이 효율적일 수 있습니다.

**실무 활용:**
- API 응답 데이터를 UI에 필요한 형태로 변환합니다.
- 검색, 필터링 기능을 구현합니다.
- 통계 계산이나 집계 작업을 수행합니다.
- 선언적 코드로 가독성을 높입니다. for 루프보다 의도가 명확합니다.
- React에서 컴포넌트 리스트를 렌더링할 때 map을 많이 사용합니다.
- 불변성을 유지하며 상태를 업데이트할 때 활용합니다.

---

## 질문 34: forEach()와 map()의 차이점은 무엇인가요?

**정의:**
forEach와 map은 모두 배열의 각 요소를 순회하는 메서드이지만, 반환값과 사용 목적이 다릅니다. forEach는 반복 작업을, map은 변환 작업을 수행합니다.

**forEach의 특징:**
- 각 요소에 대해 콜백을 실행합니다. 단순 반복을 위한 메서드입니다.
- undefined를 반환합니다. 반환값이 없습니다.
- 부수 효과를 위해 사용합니다. 로깅, DOM 조작 등을 수행합니다.
- 중간에 종료할 수 없습니다. break나 continue를 사용할 수 없습니다.
- 체이닝이 불가능합니다. 반환값이 없기 때문입니다.

**map의 특징:**
- 각 요소를 변환하여 새 배열을 만듭니다. 데이터 변환을 위한 메서드입니다.
- 새로운 배열을 반환합니다. 원본과 같은 길이입니다.
- 순수 함수로 사용하기 좋습니다. 부수 효과 없이 값을 반환합니다.
- 체이닝이 가능합니다. 다른 배열 메서드와 연결할 수 있습니다.

**성능 비교:**
- 성능은 거의 비슷합니다. 큰 차이가 없습니다.
- map이 새 배열을 만들므로 메모리를 더 사용합니다.
- 반환값이 필요 없으면 forEach가 더 적합합니다.
- 변환이 목적이면 map을 사용해야 합니다.

**사용 시기:**
- forEach: 부수 효과가 목적일 때 사용합니다. 콘솔 출력, DOM 업데이트, 외부 변수 수정 등입니다.
- map: 데이터 변환이 목적일 때 사용합니다. 새로운 배열이 필요할 때입니다.

**for 루프와의 비교:**
- forEach와 map은 더 선언적입니다. 무엇을 할지 명확합니다.
- for 루프는 더 명령적입니다. 어떻게 할지를 명시합니다.
- forEach와 map은 스코프가 명확합니다. 콜백마다 새로운 스코프가 생깁니다.
- for 루프는 break와 continue를 사용할 수 있습니다.
- 성능은 for 루프가 약간 빠를 수 있습니다. 하지만 차이는 미미합니다.

**실무에서의 선택:**
- 변환이 목적이면 무조건 map을 사용합니다. 의도가 명확해집니다.
- 부수 효과만 필요하면 forEach를 사용합니다.
- map의 반환값을 무시하면 안 됩니다. 메모리 낭비이고 의도가 불명확합니다.
- 함수형 프로그래밍을 지향한다면 map을 선호합니다.
- 조기 종료가 필요하면 for 루프나 some/every를 고려합니다.
- 가독성과 유지보수성을 우선으로 선택합니다.

---

## 질문 35: some()과 every()의 차이점은 무엇인가요?

**정의:**
some과 every는 배열 요소가 조건을 만족하는지 검사하는 메서드입니다. some은 하나라도 만족하면 true를, every는 모두 만족해야 true를 반환합니다.

**some의 특징:**
- 하나라도 조건을 만족하면 true를 반환합니다. OR 연산과 비슷합니다.
- 조건을 만족하는 요소를 찾으면 즉시 중단합니다. 단축 평가를 수행합니다.
- 모든 요소가 조건을 만족하지 않으면 false를 반환합니다.
- 빈 배열에 대해서는 항상 false를 반환합니다.

**every의 특징:**
- 모든 요소가 조건을 만족해야 true를 반환합니다. AND 연산과 비슷합니다.
- 조건을 만족하지 않는 요소를 찾으면 즉시 중단합니다. 단축 평가를 수행합니다.
- 하나라도 조건을 만족하지 않으면 false를 반환합니다.
- 빈 배열에 대해서는 항상 true를 반환합니다. 공허한 참입니다.

**반환값:**
- 둘 다 불리언 값을 반환합니다. true 또는 false입니다.
- 배열을 반환하지 않습니다. 존재 여부만 확인합니다.
- 조건을 만족하는 요소 자체가 필요하면 find나 filter를 사용해야 합니다.

**단축 평가의 효율성:**
- some: true를 반환할 요소를 찾으면 나머지는 검사하지 않습니다.
- every: false를 반환할 요소를 찾으면 나머지는 검사하지 않습니다.
- 큰 배열에서 효율적입니다. 불필요한 연산을 줄입니다.
- 콜백 함수의 순서가 성능에 영향을 줄 수 있습니다.

**사용 사례:**
- some: 배열에 특정 값이 존재하는지 확인, 하나라도 유효한지 검사, 조건을 만족하는 항목이 있는지 확인
- every: 모든 값이 유효한지 검증, 전체 조건 충족 여부 확인, 일관성 검사

**includes와의 비교:**
- includes는 값의 존재만 확인합니다. 단순 포함 여부입니다.
- some은 조건을 검사합니다. 더 복잡한 로직을 적용할 수 있습니다.
- includes는 간단하고 명확합니다. 단순 검사에 적합합니다.

**실무 활용:**
- 폼 유효성 검사에서 every로 모든 필드가 유효한지 확인합니다.
- 권한 검사에서 some으로 필요한 권한 중 하나라도 있는지 확인합니다.
- 데이터 검증에서 every로 모든 데이터가 형식에 맞는지 확인합니다.
- 검색 기능에서 some으로 검색어와 일치하는 항목이 있는지 확인합니다.
- filter 전에 some으로 미리 확인하여 불필요한 작업을 줄일 수 있습니다.
- 조건부 렌더링에서 불리언 값이 필요할 때 사용합니다.

---

## 질문 36: find()와 findIndex()는 언제 사용하나요?

**정의:**
find는 조건을 만족하는 첫 번째 요소를 반환하고, findIndex는 그 요소의 인덱스를 반환합니다. 둘 다 조건을 만족하는 요소를 찾으면 즉시 중단합니다.

**find의 특징:**
- 조건을 만족하는 첫 번째 요소를 반환합니다. 요소 자체를 돌려줍니다.
- 찾지 못하면 undefined를 반환합니다.
- 객체 배열에서 특정 객체를 찾을 때 유용합니다.
- 단축 평가로 효율적입니다. 찾으면 즉시 종료합니다.

**findIndex의 특징:**
- 조건을 만족하는 첫 번째 요소의 인덱스를 반환합니다. 위치 정보를 제공합니다.
- 찾지 못하면 음수 1을 반환합니다.
- 배열에서 요소를 수정하거나 삭제할 때 유용합니다.
- indexOf보다 복잡한 조건을 사용할 수 있습니다.

**filter와의 차이:**
- find: 첫 번째 요소만 반환합니다. 하나만 필요할 때 효율적입니다.
- filter: 조건을 만족하는 모든 요소를 배열로 반환합니다.
- find는 단일 값, filter는 배열입니다.
- find는 찾으면 중단하지만 filter는 끝까지 검사합니다.

**indexOf와의 차이:**
- indexOf: 값의 동등성만 검사합니다. 간단한 값 찾기에 적합합니다.
- findIndex: 콜백 함수로 복잡한 조건을 검사합니다. 객체 배열에 적합합니다.
- indexOf는 원시 값 배열에, findIndex는 객체 배열에 주로 사용합니다.

**findLast와 findLastIndex:**
- 배열의 끝에서부터 검색합니다. 최근 제안된 메서드입니다.
- 역순으로 찾을 때 reverse 없이 사용할 수 있습니다.
- 브라우저 지원을 확인해야 합니다.

**실무 활용:**
- ID로 특정 아이템을 찾을 때 find를 사용합니다. 객체 배열에서 검색합니다.
- 특정 조건의 아이템 위치를 찾아 삭제할 때 findIndex를 사용합니다.
- 존재 여부만 확인하려면 some을 사용하는 것이 의도가 명확합니다.
- React에서 state 배열의 특정 요소를 업데이트할 때 findIndex로 위치를 찾습니다.
- 검색 기능 구현 시 find로 첫 번째 결과를 표시합니다.
- 중복 검사에서 find로 이미 존재하는지 확인합니다.

---
