# OS 답변 13-16

## 13. 프로세스가 무엇인가요?

**정의**
프로세스(Process)는 실행 중인 프로그램을 의미합니다. 디스크에 저장된 정적인 프로그램이 메모리에 적재되어 CPU를 할당받아 실행되는 동적인 상태를 말합니다.

**프로세스의 구성 요소**
- 코드(Text): 실행 가능한 프로그램의 명령어들
- 데이터(Data): 전역 변수와 정적 변수
- 힙(Heap): 동적으로 할당되는 메모리 영역
- 스택(Stack): 함수 호출과 지역 변수를 위한 영역
- PCB(Process Control Block): 프로세스 관리 정보

**프로세스의 특징**
- 독립적인 메모리 공간을 가집니다
- 각 프로세스는 자신만의 주소 공간을 보유합니다
- 프로세스 간에는 메모리를 직접 공유하지 않습니다
- 운영체제로부터 독립적으로 스케줄링됩니다
- 각 프로세스는 고유한 프로세스 ID(PID)를 가집니다

**프로세스의 상태**
- New: 프로세스가 생성 중인 상태
- Ready: CPU 할당을 기다리는 상태
- Running: CPU를 할당받아 실행 중인 상태
- Waiting: I/O 작업 등을 기다리는 상태
- Terminated: 실행이 완료된 상태

**프로세스의 메모리 레이아웃**
- 코드 영역: 프로그램의 명령어가 저장됩니다
- 데이터 영역: 초기화된 전역/정적 변수가 저장됩니다
- BSS 영역: 초기화되지 않은 전역/정적 변수가 저장됩니다
- 힙 영역: 동적 메모리 할당 공간으로 낮은 주소에서 높은 주소로 성장합니다
- 스택 영역: 함수 호출과 지역 변수 저장 공간으로 높은 주소에서 낮은 주소로 성장합니다

**프로세스 간 통신**
- 독립적인 메모리 공간으로 인해 직접적인 데이터 공유가 불가능합니다
- IPC 메커니즘을 통해 통신합니다
- 파이프, 메시지 큐, 공유 메모리, 소켓 등을 사용합니다

**프로세스의 생성과 종료**
- fork() 시스템 콜로 새 프로세스를 생성합니다
- exec() 시스템 콜로 다른 프로그램을 실행합니다
- exit() 시스템 콜로 프로세스를 종료합니다
- 부모 프로세스는 wait()로 자식 프로세스의 종료를 대기합니다

**실무 활용**
웹 서버는 각 클라이언트 요청을 별도의 프로세스로 처리하여 격리성과 안정성을 보장할 수 있습니다. 하지만 프로세스 생성 비용이 크기 때문에 현대적인 서버는 스레드나 비동기 I/O를 선호합니다.

---

## 14. 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

**프로그램(Program)**

**정의**
- 디스크에 저장된 실행 가능한 파일입니다
- 정적인 코드와 데이터의 집합입니다
- 실행되기 전의 수동적인 상태입니다

**특징**
- 실행 가능한 명령어와 데이터로 구성됩니다
- 파일 시스템에 저장되어 있습니다
- 실행되지 않으면 아무런 작업도 수행하지 않습니다
- 여러 프로세스가 동일한 프로그램을 실행할 수 있습니다

**프로세스(Process)**

**정의**
- 실행 중인 프로그램의 인스턴스입니다
- 능동적인 상태로 CPU와 메모리를 할당받습니다
- 독립적인 실행 단위입니다

**특징**
- 독립적인 메모리 공간을 가집니다(코드, 데이터, 힙, 스택)
- 각자의 PCB를 가지고 있습니다
- 프로세스 간 메모리는 보호되어 있습니다
- 생성과 컨텍스트 스위칭 비용이 큽니다
- 안정성과 격리성이 높습니다

**스레드(Thread)**

**정의**
- 프로세스 내에서 실행되는 경량 실행 단위입니다
- 프로세스의 자원을 공유하면서 독립적으로 실행됩니다
- CPU 스케줄링의 기본 단위입니다

**특징**
- 같은 프로세스의 스레드들은 코드, 데이터, 힙 영역을 공유합니다
- 각 스레드는 독립적인 스택과 레지스터를 가집니다
- 경량 프로세스(LWP)라고도 불립니다
- 생성과 컨텍스트 스위칭 비용이 작습니다
- 빠른 통신과 데이터 공유가 가능합니다

**비교**

**메모리 공간**
- 프로그램: 디스크에 저장
- 프로세스: 독립적인 메모리 공간
- 스레드: 프로세스 내에서 코드/데이터/힙 공유, 스택은 독립

**자원**
- 프로그램: 자원 미할당
- 프로세스: 독립적인 자원 할당
- 스레드: 프로세스의 자원 공유

**통신**
- 프로그램: 해당 없음
- 프로세스: IPC 필요(오버헤드 큼)
- 스레드: 직접 메모리 접근(오버헤드 작음)

**생성 비용**
- 프로그램: 해당 없음
- 프로세스: 높음(메모리 할당, PCB 생성 등)
- 스레드: 낮음(스택만 할당)

**안정성**
- 프로세스: 한 프로세스의 오류가 다른 프로세스에 영향 없음
- 스레드: 한 스레드의 오류가 전체 프로세스에 영향

**관계**
- 하나의 프로그램은 여러 프로세스로 실행될 수 있습니다
- 하나의 프로세스는 여러 스레드를 포함할 수 있습니다
- 프로세스는 최소 하나의 메인 스레드를 가집니다

**실무 활용**
웹 브라우저는 각 탭을 별도의 프로세스로 실행하여 한 탭의 크래시가 다른 탭에 영향을 주지 않도록 합니다. 반면 웹 서버는 각 요청을 스레드로 처리하여 빠른 응답과 효율적인 자원 사용을 달성합니다.

---

## 15. PCB가 무엇인가요?

**정의**
PCB(Process Control Block)는 운영체제가 프로세스를 관리하기 위해 필요한 정보를 저장하는 자료구조입니다. 프로세스 디스크립터(Process Descriptor)라고도 불립니다.

**PCB에 포함되는 정보**

**프로세스 식별 정보**
- 프로세스 ID(PID): 각 프로세스를 고유하게 식별하는 번호
- 부모 프로세스 ID(PPID): 이 프로세스를 생성한 부모 프로세스의 ID
- 사용자 ID(UID): 프로세스를 실행한 사용자의 ID
- 그룹 ID(GID): 프로세스가 속한 그룹의 ID

**프로세스 상태 정보**
- 프로세스 상태: New, Ready, Running, Waiting, Terminated
- 프로그램 카운터(PC): 다음에 실행할 명령어의 주소
- CPU 레지스터: 누산기, 인덱스 레지스터, 스택 포인터, 범용 레지스터 등
- CPU 스케줄링 정보: 우선순위, 스케줄링 큐 포인터, 스케줄링 매개변수

**메모리 관리 정보**
- 베이스 레지스터와 한계 레지스터 값
- 페이지 테이블 또는 세그먼트 테이블 포인터
- 코드, 데이터, 스택 영역의 시작 주소와 크기

**계정 정보**
- CPU 사용 시간
- 실제 사용 시간
- 시간 제한
- 계정 번호
- 프로세스 번호

**입출력 상태 정보**
- 할당된 I/O 장치 목록
- 열린 파일 디스크립터 테이블
- 대기 중인 I/O 요청

**PCB의 역할**

**컨텍스트 스위칭 지원**
- CPU에서 다른 프로세스로 전환할 때 현재 프로세스의 상태를 PCB에 저장합니다
- 나중에 이 프로세스가 다시 실행될 때 PCB에서 상태를 복원합니다
- 중단된 지점부터 정확히 재개할 수 있게 합니다

**프로세스 스케줄링**
- 스케줄러가 PCB의 정보를 참조하여 다음 실행할 프로세스를 선택합니다
- 우선순위, 실행 시간, 대기 시간 등을 고려합니다

**자원 관리**
- 프로세스가 사용 중인 자원을 추적합니다
- 프로세스 종료 시 자원을 회수하는 데 사용합니다

**PCB의 저장 위치**
- 운영체제 커널의 메모리 영역에 저장됩니다
- 각 프로세스마다 하나의 PCB가 생성됩니다
- 프로세스가 종료되면 PCB도 제거됩니다
- 보호된 메모리 영역에 있어 사용자 프로세스가 직접 접근할 수 없습니다

**PCB의 구조**
- 운영체제마다 구조가 다를 수 있습니다
- 리눅스에서는 task_struct 구조체로 구현됩니다
- 연결 리스트나 트리 구조로 관리됩니다

**실무 활용**
시스템 모니터링 도구들은 PCB의 정보를 읽어 프로세스 목록, CPU 사용률, 메모리 사용량 등을 표시합니다. ps, top, htop 같은 명령어가 이를 활용합니다.

---

## 16. 그렇다면, 스레드는 PCB를 갖고 있을까요?

**결론**
스레드는 완전한 PCB를 갖고 있지 않고, 대신 TCB(Thread Control Block)라는 더 작은 자료구조를 가집니다.

**TCB(Thread Control Block)**

**정의**
- 스레드를 관리하기 위한 정보를 저장하는 자료구조입니다
- PCB보다 크기가 작고 포함하는 정보가 적습니다

**TCB에 포함되는 정보**
- 스레드 ID
- 프로그램 카운터(PC)
- 레지스터 세트
- 스택 포인터
- 스레드 상태(실행, 준비, 대기 등)
- 스레드 우선순위
- 부모 프로세스의 PCB에 대한 포인터

**TCB에 포함되지 않는 정보**
- 메모리 관리 정보(프로세스가 공유)
- 열린 파일 목록(프로세스가 공유)
- I/O 자원 정보(프로세스가 공유)
- 프로세스 ID(프로세스 레벨 정보)

**프로세스 PCB와의 관계**

**계층 구조**
- 각 프로세스는 하나의 PCB를 가집니다
- 프로세스 내의 각 스레드는 자신의 TCB를 가집니다
- TCB는 부모 프로세스의 PCB를 참조합니다

**정보 공유**
- 모든 스레드는 동일한 프로세스의 PCB를 공유합니다
- 메모리 맵, 파일 디스크립터, 시그널 핸들러 등은 PCB에 저장되어 공유됩니다
- 각 스레드의 독립적인 실행 컨텍스트는 TCB에 저장됩니다

**운영체제별 구현**

**리눅스**
- 리눅스는 프로세스와 스레드를 동일하게 task_struct로 관리합니다
- 스레드는 clone() 시스템 콜로 생성되며 일부 자원을 공유하는 특별한 프로세스로 취급됩니다
- CLONE_VM, CLONE_FS, CLONE_FILES 등의 플래그로 공유 자원을 지정합니다

**Windows**
- 프로세스는 EPROCESS 구조체로 관리됩니다
- 스레드는 ETHREAD 구조체로 관리됩니다
- 명확히 프로세스와 스레드를 구분합니다

**컨텍스트 스위칭 비용**

**프로세스 간 전환**
- 전체 PCB 저장 및 복원
- 메모리 맵 전환(TLB 플러시)
- 캐시 무효화
- 비용이 큼

**스레드 간 전환(같은 프로세스 내)**
- TCB 저장 및 복원만 필요
- 메모리 맵 유지
- 캐시 대부분 유효
- 비용이 작음

**스레드 간 전환(다른 프로세스)**
- TCB와 PCB 모두 전환 필요
- 프로세스 간 전환과 비슷한 비용

**장점**
- TCB가 PCB보다 작아 메모리 사용량이 적습니다
- 컨텍스트 스위칭이 빠릅니다
- 스레드 생성과 종료가 빠릅니다
- 자원 공유로 인한 효율성이 높습니다

**실무 활용**
멀티스레드 서버 애플리케이션에서 각 스레드는 독립적으로 스케줄링되지만 메모리와 파일 핸들을 공유하여 효율성을 높입니다. 이는 TCB/PCB 구조 덕분에 가능합니다.
