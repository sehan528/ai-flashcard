# Network 답변 9-12

## 질문 9: 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?

401과 403은 모두 접근이 거부되는 상황이지만, 그 이유와 해결 방법이 다릅니다.

**401 Unauthorized - 인증 필요:**

사용자가 누구인지 확인되지 않았다는 의미입니다. 즉, 신원을 증명하지 않았거나 잘못된 인증 정보를 제공한 상황입니다.

이 응답은 "당신이 누구인지 모르겠으니 로그인하세요"라는 메시지와 같습니다. WWW-Authenticate 헤더를 포함하여 어떤 인증 방법을 사용해야 하는지 알려줍니다.

일반적인 사례는 로그인하지 않은 상태에서 보호된 페이지에 접근할 때, 인증 토큰이 만료되었을 때, 잘못된 비밀번호를 입력했을 때 등입니다.

해결 방법은 올바른 인증 정보(아이디, 비밀번호, 토큰 등)를 제공하는 것입니다. 인증에 성공하면 같은 요청을 다시 보낼 수 있습니다.

**403 Forbidden - 권한 부족:**

사용자의 신원은 확인되었지만, 해당 리소스에 접근할 권한이 없다는 의미입니다. 즉, 서버가 당신이 누구인지는 알지만, 당신은 이 작업을 할 수 없다는 것입니다.

이 응답은 "당신이 누군지는 알지만, 이 리소스는 접근할 수 없습니다"라는 메시지와 같습니다.

일반적인 사례는 일반 사용자가 관리자 페이지에 접근할 때, 다른 사용자의 개인 정보를 조회하려 할 때, 읽기 권한만 있는 사용자가 삭제를 시도할 때 등입니다.

해결 방법은 인증 정보를 다시 제공해도 소용없습니다. 권한 자체가 없기 때문에 관리자에게 권한을 요청하거나, 접근 가능한 다른 리소스를 이용해야 합니다.

**실무에서의 구분:**

RESTful API 설계 시 이 둘을 명확히 구분하는 것이 중요합니다. 클라이언트가 적절한 대응을 할 수 있기 때문입니다.

401을 받으면 클라이언트는 로그인 페이지로 리다이렉트하거나 토큰을 갱신해야 합니다. 자동으로 재인증을 시도할 수 있습니다.

403을 받으면 클라이언트는 사용자에게 "권한이 없습니다" 메시지를 보여주고, 재시도하지 않아야 합니다. 같은 요청을 반복해도 결과는 같기 때문입니다.

**보안 고려사항:**

때로는 보안을 위해 403 대신 404를 반환하기도 합니다. 예를 들어, 사용자에게 특정 리소스의 존재 여부조차 알리고 싶지 않을 때입니다. 403을 반환하면 "이 리소스는 존재하지만 당신은 볼 수 없다"는 정보를 주는 셈이므로, 존재하지 않는 것처럼 404를 반환하는 것입니다.

**이름의 모순:**

흥미롭게도 401의 이름은 "Unauthorized"이지만 실제로는 "Unauthenticated"가 더 정확한 표현입니다. 역사적인 이유로 이렇게 명명되었으나, 실무에서는 인증 실패를 의미한다는 것을 이해하고 사용해야 합니다.

## 질문 10: 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

200과 201은 모두 성공을 나타내지만, 요청의 결과가 무엇인지에 따라 구분됩니다.

**200 OK - 일반적인 성공:**

요청이 성공적으로 처리되었다는 가장 일반적인 응답입니다. 다양한 HTTP 메서드에 사용할 수 있습니다.

GET 요청에서는 요청한 리소스를 응답 본문에 담아 반환합니다. 예를 들어 사용자 정보를 조회하면 200과 함께 사용자 데이터를 받습니다.

POST 요청에서는 작업이 완료되었고 그 결과를 응답 본문에 담아 반환합니다. 새 리소스를 생성하지 않는 POST 요청, 예를 들어 계산이나 검색 같은 작업에 적합합니다.

PUT 요청에서는 기존 리소스가 업데이트되었음을 나타냅니다.

DELETE 요청에서는 삭제가 성공했음을 나타내며, 삭제된 리소스 정보를 응답 본문에 포함할 수 있습니다.

**201 Created - 리소스 생성 성공:**

요청이 성공했고 그 결과로 새로운 리소스가 생성되었음을 나타냅니다. 주로 POST 요청과 함께 사용됩니다.

Location 헤더에 생성된 리소스의 URI를 포함하는 것이 관례입니다. 클라이언트가 생성된 리소스에 바로 접근할 수 있도록 합니다.

응답 본문에는 생성된 리소스의 표현을 포함할 수 있습니다. 서버가 생성 시 자동으로 부여한 ID나 타임스탬프 등의 정보를 클라이언트에게 전달합니다.

**실무에서의 사용:**

RESTful API 설계 시 명확한 의미 전달을 위해 구분합니다.

POST로 새 사용자를 등록하면 201을 반환하고, Location 헤더에 새 사용자의 URI를 포함합니다. 본문에는 생성된 사용자 정보와 자동 생성된 ID를 담습니다.

POST로 로그인 처리를 하면 200을 반환합니다. 새 리소스가 생성되는 것이 아니라 인증 토큰을 발급하는 작업이기 때문입니다.

PUT으로 기존 리소스를 업데이트하면 200을 반환합니다. 이미 존재하는 리소스를 수정한 것이므로 새로 생성한 것이 아닙니다.

**의미론적 중요성:**

HTTP 응답코드는 단순한 숫자가 아니라 API의 의미를 전달하는 중요한 수단입니다. 201을 사용하면 클라이언트는 "새 리소스가 생성되었구나"를 명확히 알 수 있고, Location 헤더를 확인하여 생성된 리소스에 접근할 수 있습니다.

모니터링 관점에서도 201 응답을 추적하면 시스템에서 얼마나 많은 리소스가 생성되는지 파악할 수 있습니다.

**캐싱 동작:**

200 응답은 조건에 따라 캐싱될 수 있습니다. GET 요청의 200 응답은 캐시 헤더에 따라 브라우저나 프록시에 캐싱됩니다.

201 응답은 일반적으로 캐싱되지 않습니다. 새 리소스 생성은 매번 고유한 작업이므로 캐싱이 적절하지 않습니다.

**클라이언트 동작:**

200을 받으면 클라이언트는 응답 본문의 데이터를 사용합니다.

201을 받으면 클라이언트는 Location 헤더를 확인하여 생성된 리소스의 위치를 파악하고, 필요시 해당 URI로 GET 요청을 보내 최신 상태를 확인할 수 있습니다. 많은 프레임워크가 201 응답 시 자동으로 리다이렉트하는 기능을 제공합니다.

## 질문 11: 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.

기술적으로는 가능하지만, 실무에서는 절대 권장되지 않습니다.

**기술적 가능성:**

HTTP는 프로토콜 수준에서 세 자리 숫자면 어떤 값이든 응답코드로 사용할 수 있습니다. 서버가 285를 반환하고 클라이언트가 이를 받아 처리할 수 있습니다.

첫 자리 숫자는 응답의 클래스를 나타냅니다. 2xx는 성공, 3xx는 리다이렉션, 4xx는 클라이언트 오류, 5xx는 서버 오류입니다. 만약 285를 사용한다면 클라이언트는 이를 "2xx이므로 성공"으로 분류할 것입니다.

**실무에서 사용하면 안 되는 이유:**

표준을 위반하면 호환성 문제가 발생합니다. HTTP 프록시, 로드밸런서, 캐시, 브라우저, 모니터링 도구 등 중간 계층들이 표준 응답코드를 가정하고 동작합니다. 비표준 코드를 사용하면 예상치 못한 동작이나 오류가 발생할 수 있습니다.

클라이언트 라이브러리가 혼란스러워집니다. Axios, Fetch API, HttpClient 같은 HTTP 클라이언트 라이브러리들은 표준 응답코드에 대한 처리 로직을 가지고 있습니다. 비표준 코드는 의도대로 처리되지 않을 수 있습니다.

개발자가 혼란스러워집니다. 팀원이나 API 사용자가 285가 무엇을 의미하는지 알 수 없습니다. 표준 코드는 모두가 알고 있는 공통 언어이지만, 커스텀 코드는 별도 문서가 필요하고 학습 비용이 발생합니다.

디버깅이 어려워집니다. 로그나 모니터링 도구에서 비표준 응답코드를 보면 무엇이 잘못되었는지 즉시 파악하기 어렵습니다.

**표준 코드만으로 충분합니다:**

HTTP 표준은 이미 매우 다양한 상황을 커버하는 응답코드를 제공합니다. 대부분의 경우 적절한 표준 코드가 존재합니다.

세밀한 정보가 필요하다면 응답 본문에 포함하면 됩니다. 응답코드는 넓은 범주를 나타내고, 구체적인 정보는 JSON 본문의 error code나 message 필드로 전달하는 것이 일반적입니다.

예를 들어 비밀번호가 틀렸을 때와 계정이 잠겼을 때를 구분하고 싶다면, 둘 다 401을 사용하되 응답 본문에 errorCode를 다르게 주면 됩니다.

**비표준 코드의 역사적 사례:**

일부 대형 서비스들이 비표준 코드를 사용한 적이 있지만, 대부분 표준 코드로 마이그레이션했습니다. 호환성과 유지보수의 어려움이 커스텀 코드의 이점을 넘어섰기 때문입니다.

**올바른 접근 방법:**

표준 응답코드를 사용하고, 응답 본문에 상세 정보를 포함합니다. 예를 들어 400 Bad Request와 함께 본문에 어떤 필드가 잘못되었는지 명시합니다.

커스텀 헤더를 사용할 수 있습니다. 표준 응답코드는 유지하되, X-Custom-Error-Code 같은 헤더로 추가 정보를 전달할 수 있습니다.

API 문서에 어떤 응답코드가 언제 반환되는지 명확히 기술합니다. 이것만으로도 대부분의 경우 충분합니다.

따라서 커스텀 응답코드는 기술적으로 가능하지만, 표준 준수와 호환성을 위해 절대 사용하지 말아야 합니다.

## 질문 12: HTTP Method 에 대해 설명해 주세요.

HTTP Method는 클라이언트가 서버에 요청할 때 어떤 작업을 원하는지 나타내는 동사입니다. 각 메서드는 특정한 의미와 특성을 가지고 있습니다.

**GET - 리소스 조회:**

서버로부터 리소스를 조회할 때 사용합니다. 데이터를 요청만 하고 변경하지 않는 읽기 전용 작업입니다.

요청 파라미터는 URL의 쿼리 스트링으로 전달됩니다. 브라우저 히스토리에 남고, 북마크가 가능하며, 캐싱될 수 있습니다.

안전(Safe)하고 멱등(Idempotent)한 메서드입니다. 여러 번 호출해도 결과가 같고 서버 상태를 변경하지 않습니다.

**POST - 리소스 생성 및 데이터 처리:**

새로운 리소스를 생성하거나 데이터를 처리할 때 사용합니다. 가장 유연한 메서드로 다양한 용도로 활용됩니다.

요청 데이터는 본문(body)에 포함되어 전송됩니다. URL에 노출되지 않아 민감한 데이터 전송에 적합합니다.

안전하지도 멱등하지도 않습니다. 같은 요청을 여러 번 보내면 여러 개의 리소스가 생성될 수 있습니다.

회원가입, 로그인, 파일 업로드, 주문 생성 등에 사용됩니다.

**PUT - 리소스 전체 업데이트:**

리소스를 완전히 대체할 때 사용합니다. 기존 리소스가 있으면 덮어쓰고, 없으면 생성할 수 있습니다.

클라이언트가 리소스의 정확한 URI를 알고 있어야 합니다. 리소스의 모든 필드를 포함한 완전한 데이터를 전송해야 합니다.

멱등성을 가집니다. 같은 요청을 여러 번 보내도 결과는 동일합니다.

**PATCH - 리소스 부분 업데이트:**

리소스의 일부만 수정할 때 사용합니다. 변경하고자 하는 필드만 전송하면 됩니다.

PUT보다 효율적입니다. 전체 데이터가 아닌 변경 사항만 전송하므로 네트워크 대역폭을 절약할 수 있습니다.

멱등성은 구현에 따라 다를 수 있습니다. 일반적으로 멱등하게 구현하는 것이 권장됩니다.

**DELETE - 리소스 삭제:**

지정한 리소스를 삭제할 때 사용합니다.

멱등성을 가집니다. 같은 리소스를 여러 번 삭제 요청해도 결과는 같습니다. 두 번째 요청부터는 404를 반환할 수 있지만, 서버 상태는 동일합니다.

**HEAD - 메타데이터 조회:**

GET과 동일하지만 응답 본문 없이 헤더만 받습니다. 리소스의 존재 여부 확인, 파일 크기 확인, 최종 수정 시간 확인 등에 사용됩니다.

대역폭을 절약할 수 있고, 링크 유효성 검사나 캐시 검증에 유용합니다.

**OPTIONS - 통신 옵션 확인:**

서버가 지원하는 메서드를 확인할 때 사용합니다. CORS preflight 요청에서 주로 사용됩니다.

Allow 헤더에 허용된 메서드 목록을 반환합니다.

**TRACE - 경로 추적:**

요청이 프록시를 거쳐 서버까지 도달하는 경로를 확인합니다. 디버깅 용도이며, 보안상 이유로 대부분의 서버에서 비활성화되어 있습니다.

**CONNECT - 터널링:**

프록시를 통한 SSL 터널을 설정할 때 사용합니다. 주로 HTTPS 연결에서 프록시가 사용하며, 일반 애플리케이션 개발에서는 거의 사용하지 않습니다.

**RESTful API에서의 활용:**

올바른 HTTP 메서드 사용은 RESTful API 설계의 핵심입니다. 각 메서드의 의미론을 존중하면 API가 직관적이고 예측 가능해집니다.

GET /users - 사용자 목록 조회
GET /users/123 - 특정 사용자 조회
POST /users - 새 사용자 생성
PUT /users/123 - 사용자 123 전체 정보 업데이트
PATCH /users/123 - 사용자 123 일부 정보 업데이트
DELETE /users/123 - 사용자 123 삭제

이러한 일관된 패턴은 API 사용자가 직관적으로 이해하고 사용할 수 있게 합니다.
