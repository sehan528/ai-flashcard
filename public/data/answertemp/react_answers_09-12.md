# React 답변 09-12

## 질문 9: useEffect의 동작 원리와 의존성 배열의 역할은 무엇인가요?

**정의:**
useEffect는 함수형 컴포넌트에서 부작용을 처리하는 Hook입니다. 데이터 가져오기, 구독 설정, DOM 수동 조작 등 렌더링 외부의 작업을 수행할 때 사용합니다.

**동작 원리:**
- 컴포넌트가 렌더링된 후에 실행됩니다. 화면 업데이트를 블로킹하지 않습니다.
- 브라우저가 페인트를 완료한 후 비동기적으로 실행됩니다.
- 매 렌더링마다 새로운 effect 함수가 생성됩니다.
- 이전 effect의 클린업을 실행한 후 새 effect를 실행합니다.
- 의존성 배열의 값이 변경되었는지 체크합니다.

**의존성 배열의 역할:**
- 언제 effect를 다시 실행할지 결정합니다.
- 배열 내 값이 변경되면 effect가 재실행됩니다.
- 빈 배열이면 마운트 시에만 실행됩니다.
- 배열을 생략하면 매 렌더링마다 실행됩니다.
- React는 Object.is로 이전 값과 비교합니다.

**의존성 배열 사용 패턴:**
- 특정 값 변경 시 실행: 의존성 배열에 해당 값들을 넣습니다.
- 마운트/언마운트 시에만: 빈 배열을 사용합니다.
- 매 렌더링마다: 의존성 배열을 생략합니다. 거의 사용하지 않습니다.
- 모든 의존성을 포함해야 합니다. ESLint 규칙이 도와줍니다.

**effect 실행 타이밍:**
- 초기 렌더링 후 첫 effect가 실행됩니다.
- 의존성이 변경된 렌더링 후 effect가 실행됩니다.
- useLayoutEffect는 페인트 전에 동기적으로 실행됩니다.
- effect는 렌더링을 블로킹하지 않아 성능이 좋습니다.

**의존성 누락 문제:**
- effect 내에서 사용하는 모든 값을 의존성에 포함해야 합니다.
- 누락하면 오래된 값을 참조하는 버그가 발생합니다.
- ESLint exhaustive-deps 규칙을 사용합니다.
- 함수는 useCallback으로 메모이제이션합니다.
- 객체는 useMemo로 메모이제이션합니다.

**무한 루프 방지:**
- 의존성에 객체나 배열을 직접 넣으면 위험합니다.
- 매 렌더링마다 새 참조가 생성되어 무한 루프가 됩니다.
- 원시값만 의존성에 넣거나 메모이제이션을 사용합니다.
- effect 내에서 상태를 업데이트할 때 주의합니다.

**실무 활용:**
- API 호출과 데이터 페칭에 사용합니다.
- 이벤트 리스너를 등록하고 클린업에서 제거합니다.
- 타이머를 설정하고 클린업에서 정리합니다.
- 외부 라이브러리를 초기화합니다.
- 브라우저 API와 상호작용합니다. localStorage, WebSocket 등입니다.

---

## 질문 10: useEffect의 클린업 함수는 언제 사용하나요?

**정의:**
클린업 함수는 useEffect에서 반환하는 함수로, effect가 다시 실행되기 전이나 컴포넌트가 언마운트될 때 실행됩니다. 리소스 정리와 메모리 누수 방지에 사용됩니다.

**클린업 함수의 실행 시점:**
- 컴포넌트가 언마운트될 때 실행됩니다.
- 다음 effect가 실행되기 전에 이전 effect를 정리합니다.
- 의존성이 변경되어 effect가 재실행될 때마다 이전 것을 정리합니다.
- 렌더링마다 새로운 클린업 함수가 생성됩니다.

**클린업이 필요한 경우:**
- 이벤트 리스너 등록: 메모리 누수를 방지하려면 제거해야 합니다.
- 타이머 설정: setInterval, setTimeout을 정리해야 합니다.
- 구독 설정: WebSocket, 외부 스토어 구독을 해제해야 합니다.
- 네트워크 요청 취소: 컴포넌트가 사라진 후 응답이 와도 안전합니다.
- 외부 라이브러리 정리: 인스턴스를 파괴하거나 연결을 끊습니다.

**이벤트 리스너 정리:**
- addEventListener로 등록한 리스너를 removeEventListener로 제거합니다.
- 같은 함수 참조를 사용해야 제거가 됩니다.
- 윈도우나 document 이벤트는 반드시 정리해야 합니다.
- 정리하지 않으면 컴포넌트가 사라져도 리스너는 남아 있습니다.

**타이머 정리:**
- setInterval은 clearInterval로 정리합니다.
- setTimeout은 clearTimeout으로 정리합니다.
- 타이머가 계속 실행되면 메모리 누수와 예상치 못한 동작이 발생합니다.
- 타이머 ID를 저장했다가 클린업에서 사용합니다.

**구독과 연결 정리:**
- WebSocket 연결을 닫습니다.
- 외부 상태 관리 라이브러리의 구독을 해제합니다.
- 데이터베이스나 실시간 리스너를 정리합니다.
- RxJS 같은 스트림의 구독을 해제합니다.

**비동기 작업 정리:**
- fetch 요청을 AbortController로 취소합니다.
- 컴포넌트가 언마운트된 후 setState를 방지합니다.
- 플래그 변수로 마운트 상태를 추적할 수 있습니다.
- 최신 React에서는 자동 배치로 일부 문제가 완화됩니다.

**클린업 함수 작성 패턴:**
- effect 함수 안에서 클린업 함수를 반환합니다.
- 설정한 것과 정확히 대응되게 정리합니다.
- 클린업은 effect의 역순으로 생각하면 됩니다.
- 멱등성을 보장하여 여러 번 호출되어도 안전하게 합니다.

**실무 활용:**
- 스크롤 이벤트 리스너를 등록하고 정리합니다.
- 실시간 채팅 구독을 설정하고 해제합니다.
- 인터벌 타이머로 주기적 업데이트를 하고 정리합니다.
- API 호출을 취소하여 메모리 누수를 방지합니다.
- 외부 차트 라이브러리 인스턴스를 생성하고 파괴합니다.

---

## 질문 11: useRef는 언제 사용하고 useState와 어떻게 다른가요?

**정의:**
useRef는 렌더링과 무관하게 값을 저장하거나 DOM 요소에 접근할 수 있는 Hook입니다. 변경 가능한 객체를 반환하며, 값이 바뀌어도 리렌더링을 유발하지 않습니다.

**useRef의 특징:**
- 변경해도 리렌더링되지 않습니다. 렌더링 사이에 값을 유지합니다.
- current 프로퍼티로 값에 접근합니다.
- 컴포넌트 생애 주기 동안 같은 객체를 유지합니다.
- 동기적으로 즉시 업데이트됩니다.
- 모든 렌더링에서 같은 ref 객체를 받습니다.

**useState와의 차이점:**
- useState는 변경 시 리렌더링을 유발합니다. useRef는 유발하지 않습니다.
- useState는 비동기 업데이트입니다. useRef는 동기 업데이트입니다.
- useState는 불변성을 지켜야 합니다. useRef는 직접 변경 가능합니다.
- useState는 화면에 보이는 데이터용입니다. useRef는 렌더링에 영향 없는 데이터용입니다.

**useRef 사용 경우:**
- DOM 요소에 접근할 때: focus 설정, 스크롤 제어, 크기 측정 등입니다.
- 이전 값을 저장할 때: 이전 state나 props를 기억합니다.
- 타이머 ID 저장: setInterval, setTimeout의 반환값을 보관합니다.
- 인스턴스 변수 대체: 클래스의 인스턴스 변수처럼 사용합니다.
- 렌더링과 무관한 값 저장: 변경해도 UI에 영향이 없는 값입니다.

**DOM 접근 패턴:**
- ref 속성에 ref 객체를 전달합니다.
- 렌더링 후 ref.current에 DOM 노드가 할당됩니다.
- useEffect에서 ref.current를 사용합니다.
- input에 포커스를 주거나 스크롤 위치를 제어합니다.
- 애니메이션 라이브러리와 통합할 때 유용합니다.

**이전 값 추적:**
- useEffect와 조합하여 이전 값을 저장합니다.
- 현재 값과 이전 값을 비교할 수 있습니다.
- 값의 변화를 감지하는 커스텀 훅을 만들 수 있습니다.
- 디버깅이나 조건부 로직에 활용합니다.

**주의사항:**
- 렌더링 중에 ref.current를 읽거나 쓰면 안 됩니다. 순수성을 해칩니다.
- 이벤트 핸들러나 useEffect에서 사용합니다.
- ref 변경으로 리렌더링을 유발하고 싶다면 useState를 사용해야 합니다.
- DOM 조작은 최소화합니다. React의 선언적 방식을 우선합니다.

**실무 활용:**
- 폼 제출 시 첫 번째 에러 필드로 포커스를 이동합니다.
- 스크롤 위치를 저장하고 복원합니다.
- 비디오나 오디오 재생을 제어합니다.
- 차트 라이브러리의 인스턴스를 저장합니다.
- 디바운스나 쓰로틀 타이머를 관리합니다.

---

## 질문 12: useMemo와 useCallback의 차이점은 무엇인가요?

**정의:**
useMemo와 useCallback은 성능 최적화를 위한 메모이제이션 Hook입니다. useMemo는 계산된 값을 메모이제이션하고, useCallback은 함수 자체를 메모이제이션합니다.

**useMemo의 특징:**
- 계산 비용이 큰 연산 결과를 캐싱합니다.
- 의존성이 변경될 때만 재계산합니다.
- 첫 번째 인자는 값을 반환하는 함수입니다.
- 두 번째 인자는 의존성 배열입니다.
- 렌더링 중에 실행됩니다.

**useCallback의 특징:**
- 함수 인스턴스를 메모이제이션합니다.
- 의존성이 변경될 때만 새 함수를 생성합니다.
- 자식 컴포넌트에 콜백을 전달할 때 유용합니다.
- 함수 자체를 반환합니다.
- useCallback은 useMemo의 특수 케이스입니다.

**useMemo 사용 경우:**
- 복잡한 계산이나 필터링 결과를 캐싱합니다.
- 큰 배열이나 객체를 변환할 때 사용합니다.
- 렌더링마다 같은 계산을 반복하는 것을 방지합니다.
- 참조 동등성이 중요한 객체나 배열을 생성할 때 사용합니다.

**useCallback 사용 경우:**
- 자식 컴포넌트에 props로 전달하는 함수를 메모이제이션합니다.
- 자식이 React.memo로 최적화되어 있을 때 효과적입니다.
- useEffect의 의존성으로 사용되는 함수를 메모이제이션합니다.
- 이벤트 핸들러를 메모이제이션하여 불필요한 리렌더링을 방지합니다.

**차이점 비교:**
- useMemo는 값을 반환합니다. useCallback은 함수를 반환합니다.
- useMemo는 함수를 실행한 결과를 캐싱합니다. useCallback은 함수 자체를 캐싱합니다.
- useCallback은 함수용 useMemo의 문법적 설탕입니다.
- 용도가 다르지만 내부 구현은 유사합니다.

**참조 동등성 문제:**
- 객체와 배열은 렌더링마다 새로 생성되어 참조가 달라집니다.
- React.memo나 의존성 배열은 참조로 비교합니다.
- useMemo로 같은 참조를 유지하면 불필요한 연산을 방지합니다.
- 함수도 매번 새로 생성되므로 useCallback이 필요합니다.

**최적화 시기:**
- 성능 문제가 실제로 있을 때만 사용합니다.
- 프로파일링으로 병목을 확인합니다.
- 모든 곳에 사용하면 오히려 성능이 나빠질 수 있습니다.
- 메모이제이션 자체도 비용이 듭니다.
- 단순한 연산은 메모이제이션하지 않는 것이 더 빠릅니다.

**실무 활용:**
- 큰 테이블 데이터를 필터링하거나 정렬할 때 useMemo를 사용합니다.
- 복잡한 차트 데이터 변환 결과를 캐싱합니다.
- 자식 컴포넌트의 불필요한 리렌더링을 useCallback으로 방지합니다.
- Context value를 useMemo로 메모이제이션하여 성능을 개선합니다.
- 항상 측정 후 최적화합니다. 추측하지 않습니다.

---
