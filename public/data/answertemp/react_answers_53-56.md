# React 답변 53-56

## 질문 53: React 컴포넌트 테스트는 어떻게 작성하나요?

**정의:**
React 컴포넌트 테스트는 컴포넌트가 예상대로 렌더링되고 동작하는지 확인하는 자동화된 테스트입니다. React Testing Library가 가장 권장되는 도구이며, 사용자 관점에서 테스트하는 것을 강조합니다.

**테스트의 중요성:**
- 버그를 조기에 발견합니다.
- 리팩토링 시 안전성을 보장합니다.
- 코드 품질을 향상시킵니다.
- 문서 역할을 합니다. 컴포넌트 사용법을 보여줍니다.
- 자신감을 가지고 배포할 수 있습니다.

**React Testing Library 철학:**
- 구현이 아닌 동작을 테스트합니다.
- 사용자가 보고 하는 것을 테스트합니다.
- 내부 state나 props를 직접 테스트하지 않습니다.
- 실제 DOM을 사용합니다.
- 접근성을 고려한 쿼리를 권장합니다.

**기본 테스트 구조:**
- render로 컴포넌트를 렌더링합니다.
- screen으로 렌더링된 요소를 찾습니다.
- 쿼리 메서드로 요소를 선택합니다.
- expect로 단언을 작성합니다.
- userEvent로 사용자 인터랙션을 시뮬레이션합니다.

**쿼리 메서드:**
- getBy: 요소를 찾습니다. 없으면 에러입니다.
- queryBy: 요소를 찾습니다. 없으면 null입니다.
- findBy: 비동기로 요소를 찾습니다. Promise를 반환합니다.
- AllBy 변형: 여러 요소를 배열로 반환합니다.
- 역할 이름 텍스트 등으로 찾습니다.

**쿼리 우선순위:**
- getByRole: 가장 권장됩니다. 접근성을 고려합니다.
- getByLabelText: 폼 요소에 적합합니다.
- getByPlaceholderText: 대안적 방법입니다.
- getByText: 텍스트 콘텐츠로 찾습니다.
- getByTestId: 최후의 수단입니다.

**사용자 인터랙션 테스트:**
- userEvent를 사용합니다. fireEvent보다 권장됩니다.
- 클릭 타이핑 호버 등을 시뮬레이션합니다.
- 실제 사용자 동작과 유사하게 작동합니다.
- 여러 이벤트를 순차적으로 발생시킬 수 있습니다.

**비동기 테스트:**
- findBy 쿼리를 사용합니다. Promise를 반환합니다.
- waitFor로 조건이 만족될 때까지 기다립니다.
- async/await를 사용합니다.
- 타임아웃을 설정할 수 있습니다.
- API 호출이나 지연 렌더링을 테스트합니다.

**모킹:**
- API 호출을 모킹합니다. MSW를 권장합니다.
- 외부 의존성을 제어합니다.
- Jest의 jest.fn과 jest.mock을 사용합니다.
- 일관되고 빠른 테스트를 만듭니다.

**스냅샷 테스트:**
- 렌더링 결과를 저장하고 비교합니다.
- 의도치 않은 변경을 감지합니다.
- 과도하게 사용하지 않습니다.
- 중요한 부분만 스냅샷을 찍습니다.

**실무 활용:**
- 주요 사용자 플로우를 테스트합니다.
- 버튼 클릭 폼 제출 등을 검증합니다.
- 조건부 렌더링을 테스트합니다.
- 에러 상태와 로딩 상태를 확인합니다.
- 테스트 커버리지보다 의미 있는 테스트에 집중합니다.

---

## 질문 54: React Testing Library와 Enzyme의 차이점은 무엇인가요?

**정의:**
React Testing Library와 Enzyme은 모두 React 컴포넌트 테스트 도구이지만, 근본적으로 다른 철학을 가지고 있습니다. React Testing Library는 사용자 관점의 테스트를, Enzyme은 구현 세부사항 테스트를 강조합니다.

**React Testing Library 철학:**
- 사용자가 보는 것을 테스트합니다.
- 구현 세부사항을 피합니다.
- 접근성을 중요하게 생각합니다.
- 실제 DOM을 사용합니다.
- 리팩토링에 강합니다.

**Enzyme 철학:**
- 컴포넌트 내부를 테스트합니다.
- state와 props에 직접 접근합니다.
- 라이프사이클 메서드를 테스트합니다.
- 얕은 렌더링을 지원합니다.
- 구현에 의존적입니다.

**테스트 접근 방식:**
- RTL: 사용자처럼 텍스트나 역할로 요소를 찾습니다.
- Enzyme: 클래스명이나 컴포넌트 타입으로 찾습니다.
- RTL: 실제 동작을 검증합니다.
- Enzyme: state 변경이나 props 전달을 확인합니다.

**렌더링 방식:**
- RTL: 전체 렌더링만 지원합니다. 실제와 동일합니다.
- Enzyme: 얕은 렌더링 전체 렌더링 정적 렌더링을 제공합니다.
- RTL: JSDOM을 사용합니다.
- Enzyme: 다양한 렌더러를 지원합니다.

**장단점 비교:**
- RTL 장점: 리팩토링에 강함, 접근성 고려, 실제와 유사, React 팀 권장입니다.
- RTL 단점: 구현 테스트 어려움, 러닝 커브, 내부 상태 접근 불가입니다.
- Enzyme 장점: 세밀한 제어, 얕은 렌더링, 익숙함, 많은 API입니다.
- Enzyme 단점: 구현 의존적, Hooks 지원 약함, 유지보수 문제, 더 이상 권장되지 않습니다.

**커뮤니티와 지원:**
- RTL: React 팀이 공식 권장합니다. 활발한 개발이 이루어집니다.
- Enzyme: 업데이트가 느립니다. React 18 지원이 불확실합니다.
- RTL: 문서가 잘 되어 있습니다.
- Enzyme: 레거시로 간주됩니다.

**Hooks 지원:**
- RTL: Hooks를 완벽하게 지원합니다. 자연스럽게 테스트됩니다.
- Enzyme: Hooks 테스트가 어렵습니다. 어댑터가 필요합니다.
- RTL: 최신 React 기능을 즉시 지원합니다.
- Enzyme: 업데이트가 지연됩니다.

**마이그레이션:**
- Enzyme에서 RTL로 전환이 권장됩니다.
- 테스트 방식의 패러다임 전환이 필요합니다.
- 구현이 아닌 동작을 테스트하도록 변경합니다.
- 점진적 마이그레이션이 가능합니다.

**선택 기준:**
- 새 프로젝트: React Testing Library를 선택합니다.
- 레거시 프로젝트: 유지하거나 점진적 마이그레이션을 고려합니다.
- 팀 역량: RTL의 철학을 이해하고 따를 수 있어야 합니다.
- React 버전: 최신 버전은 RTL이 필수적입니다.

**실무 활용:**
- 모든 새 테스트는 RTL로 작성합니다.
- 기존 Enzyme 테스트를 점진적으로 전환합니다.
- 사용자 시나리오 중심으로 테스트합니다.
- 구현 세부사항에 의존하지 않습니다.
- 접근성을 고려한 쿼리를 사용합니다.

---

## 질문 55: Error Boundary란 무엇이고 어떻게 구현하나요?

**정의:**
Error Boundary는 하위 컴포넌트 트리에서 발생한 JavaScript 에러를 잡아내고 대체 UI를 보여주는 React 컴포넌트입니다. 에러가 전체 앱을 중단시키지 않도록 방어합니다.

**Error Boundary의 필요성:**
- 하위 컴포넌트의 에러가 전체 앱을 망가뜨리는 것을 방지합니다.
- 사용자에게 우아한 에러 메시지를 보여줍니다.
- 에러를 로깅하여 모니터링할 수 있습니다.
- 프로덕션 환경의 안정성을 높입니다.
- 일부 기능 실패가 전체에 영향을 주지 않습니다.

**구현 방법:**
- 클래스 컴포넌트로만 구현 가능합니다.
- getDerivedStateFromError 정적 메서드를 정의합니다. 에러 발생 시 state를 업데이트합니다.
- componentDidCatch 메서드를 정의합니다. 에러 정보를 로깅합니다.
- state에 따라 에러 UI나 children을 렌더링합니다.

**getDerivedStateFromError:**
- 에러가 발생하면 호출됩니다.
- 에러를 인자로 받습니다.
- 새 state를 반환하여 UI를 업데이트합니다.
- 렌더 단계에서 호출되므로 부작용이 없어야 합니다.
- 대체 UI를 표시하는 데 사용합니다.

**componentDidCatch:**
- 에러와 에러 정보를 인자로 받습니다.
- 커밋 단계에서 호출되므로 부작용을 허용합니다.
- 에러 로깅 서비스로 전송합니다.
- Sentry나 LogRocket 같은 도구와 연동합니다.
- 에러 스택 추적 정보를 받을 수 있습니다.

**Error Boundary 배치:**
- 최상위에 하나를 두어 전체 앱을 보호합니다.
- 각 주요 섹션에 배치하여 격리합니다.
- 중요한 컴포넌트를 개별적으로 감쌉니다.
- 세밀도는 앱 구조에 따라 결정합니다.

**잡을 수 있는 에러:**
- 렌더링 중 발생하는 에러입니다.
- 라이프사이클 메서드의 에러입니다.
- 생성자의 에러입니다.
- 하위 트리 전체의 에러입니다.

**잡을 수 없는 에러:**
- 이벤트 핸들러의 에러입니다. try-catch를 사용해야 합니다.
- 비동기 코드의 에러입니다. setTimeout이나 Promise 등입니다.
- 서버 사이드 렌더링의 에러입니다.
- Error Boundary 자신의 에러입니다.

**대체 UI 설계:**
- 사용자에게 친절한 메시지를 보여줍니다.
- 재시도 버튼을 제공합니다.
- 홈으로 돌아가는 링크를 제공합니다.
- 에러 상세 정보는 개발 모드에서만 표시합니다.

**함수형 컴포넌트 대안:**
- react-error-boundary 라이브러리를 사용합니다.
- ErrorBoundary 컴포넌트를 제공합니다.
- FallbackComponent prop으로 UI를 지정합니다.
- onError 콜백으로 에러를 처리합니다.
- 선언적이고 사용하기 쉽습니다.

**실무 활용:**
- 프로덕션 앱에 반드시 구현합니다.
- 에러 모니터링 도구와 연동합니다.
- 각 라우트를 Error Boundary로 감쌉니다.
- 써드파티 위젯을 격리합니다.
- 우아한 저하를 구현하여 사용자 경험을 보호합니다.

---

## 질문 56: Error Boundary의 한계점은 무엇인가요?

**정의:**
Error Boundary는 강력한 에러 처리 메커니즘이지만 모든 에러를 잡을 수 없는 한계가 있습니다. 특정 상황에서는 다른 에러 처리 방법을 함께 사용해야 합니다.

**이벤트 핸들러 에러:**
- Error Boundary가 잡지 못합니다.
- 렌더링 중이 아니라 이벤트 응답 중 발생하기 때문입니다.
- try-catch로 직접 처리해야 합니다.
- 에러 상태를 state로 관리합니다.
- 사용자에게 피드백을 제공합니다.

**비동기 코드 에러:**
- setTimeout, Promise, async/await의 에러를 잡지 못합니다.
- 렌더링 사이클 밖에서 발생하기 때문입니다.
- try-catch나 .catch로 처리합니다.
- 비동기 에러도 state로 관리합니다.
- useEffect에서 발생한 에러도 마찬가지입니다.

**서버 사이드 렌더링 에러:**
- SSR 중 에러는 Error Boundary로 잡히지 않습니다.
- 서버 측 에러 처리 메커니즘이 필요합니다.
- Next.js의 getServerSideProps에서 처리합니다.
- 클라이언트 hydration 에러는 다릅니다.

**Error Boundary 자신의 에러:**
- Error Boundary 컴포넌트 내부의 에러는 잡을 수 없습니다.
- 무한 루프를 방지하기 위함입니다.
- 상위 Error Boundary가 필요합니다.
- 최상위에 안전망을 두어야 합니다.

**함수형 컴포넌트 제한:**
- Error Boundary를 함수형으로 만들 수 없습니다.
- getDerivedStateFromError와 componentDidCatch가 클래스 전용입니다.
- Hooks에 대응하는 API가 없습니다.
- 라이브러리를 사용하거나 클래스로 구현해야 합니다.

**세밀한 제어 어려움:**
- 어떤 에러인지 구분하기 어렵습니다.
- 에러 타입별로 다르게 처리하기 복잡합니다.
- 재시도 로직 구현이 번거롭습니다.
- 복잡한 에러 복구 시나리오에는 부족합니다.

**개발 환경에서의 혼란:**
- React는 에러를 다시 던집니다. 개발 모드에서만입니다.
- 콘솔에 빨간 화면이 나타납니다.
- Error Boundary가 작동했는지 확인하기 어렵습니다.
- 프로덕션에서는 정상 작동합니다.

**보완 방법:**
- 이벤트 핸들러에 try-catch를 추가합니다.
- 전역 에러 핸들러를 설정합니다. window.onerror입니다.
- 비동기 코드에 에러 처리를 추가합니다.
- React Query 같은 라이브러리가 에러를 잘 처리합니다.
- Sentry 같은 모니터링 도구를 사용합니다.

**대안과 보완책:**
- react-error-boundary 라이브러리를 사용합니다.
- 각 에러 타입별로 처리 전략을 세웁니다.
- 로깅과 모니터링을 철저히 합니다.
- 사용자에게 명확한 피드백을 제공합니다.
- 여러 방어선을 구축합니다.

**실무 활용:**
- Error Boundary와 try-catch를 조합합니다.
- 중요한 이벤트 핸들러에 에러 처리를 추가합니다.
- 비동기 작업의 에러를 별도로 관리합니다.
- 전역 에러 핸들러로 예상치 못한 에러를 잡습니다.
- 포괄적인 에러 처리 전략을 수립합니다.

---
