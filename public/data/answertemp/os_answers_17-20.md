# OS 답변 17-20

## 17. 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

**프로세스 생성**

**fork() 시스템 콜**
- 부모 프로세스의 복사본을 생성합니다
- 자식 프로세스는 부모와 동일한 코드, 데이터, 스택을 가집니다
- 부모와 자식은 서로 다른 주소 공간을 가집니다
- 부모는 자식의 PID를 반환받고, 자식은 0을 반환받습니다

**동작 과정**
1. 새로운 PCB를 생성합니다
2. 부모 프로세스의 메모리를 복사합니다(Copy-on-Write 최적화 사용)
3. 새로운 프로세스 ID를 할당합니다
4. 파일 디스크립터 테이블을 복사합니다
5. 자식 프로세스를 준비 큐에 추가합니다

**exec() 시스템 콜**
- 현재 프로세스의 메모리를 새로운 프로그램으로 교체합니다
- 프로세스 ID는 변경되지 않습니다
- 일반적으로 fork() 후에 exec()를 호출합니다
- execl(), execv(), execve() 등 여러 변형이 있습니다

**fork() + exec() 패턴**
- 새로운 프로그램을 실행하는 일반적인 방법입니다
- 셸이 명령어를 실행할 때 사용하는 방식입니다
- fork()로 복사하고 exec()로 다른 프로그램을 로드합니다

**Copy-on-Write(COW) 최적화**
- fork() 직후에는 실제로 메모리를 복사하지 않습니다
- 부모와 자식이 동일한 물리 메모리를 공유합니다
- 메모리 페이지가 수정될 때만 실제 복사가 발생합니다
- 메모리 사용량과 fork() 속도를 크게 개선합니다

**스레드 생성**

**pthread_create() 함수**
- POSIX 스레드 라이브러리를 사용합니다
- 같은 프로세스 내에 새로운 실행 흐름을 생성합니다
- 코드, 데이터, 힙을 공유하고 스택만 독립적으로 생성됩니다

**clone() 시스템 콜**
- 리눅스의 저수준 시스템 콜입니다
- pthread_create()가 내부적으로 호출합니다
- 플래그를 통해 공유할 자원을 지정할 수 있습니다

**clone() 플래그**
- CLONE_VM: 메모리 공간 공유
- CLONE_FS: 파일 시스템 정보 공유
- CLONE_FILES: 파일 디스크립터 테이블 공유
- CLONE_SIGHAND: 시그널 핸들러 공유
- CLONE_THREAD: 같은 스레드 그룹에 속함
- CLONE_PARENT: 부모를 동일하게 설정

**동작 과정**
1. 새로운 task_struct를 생성합니다
2. 스레드용 스택 메모리를 할당합니다
3. 지정된 플래그에 따라 자원을 공유하도록 설정합니다
4. 새로운 스레드 ID를 할당합니다
5. 스레드를 준비 큐에 추가합니다

**프로세스와 스레드 생성 비교**

**리눅스의 통합 모델**
- 리눅스는 프로세스와 스레드를 구분하지 않고 모두 task로 관리합니다
- fork()는 clone(SIGCHLD, 0)과 동등합니다
- pthread_create()는 clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD)와 유사합니다

**생성 비용**
- 프로세스: 새로운 주소 공간 생성(COW 사용)
- 스레드: 스택만 할당하므로 훨씬 빠름

**메모리 공유**
- 프로세스: 독립적인 주소 공간
- 스레드: 코드, 데이터, 힙 공유

**실무 활용**
웹 서버에서 각 클라이언트 요청을 처리할 때, Apache는 fork()를 사용하는 prefork 모드와 스레드를 사용하는 worker 모드를 제공합니다. Nginx는 비동기 이벤트 기반으로 더 효율적인 처리를 구현합니다.

---

## 18. 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

**좀비 프로세스(Zombie Process)**

**발생 상황**
- 자식 프로세스가 종료되었지만 부모 프로세스가 wait()를 호출하지 않은 경우
- 자식 프로세스의 실행은 완료되었으나 PCB는 메모리에 남아있는 상태

**특징**
- 프로세스 상태가 Z(zombie) 또는 defunct로 표시됩니다
- CPU나 메모리를 거의 사용하지 않지만 PCB는 유지됩니다
- 프로세스 테이블의 슬롯을 차지하여 시스템 자원을 낭비합니다
- 종료 코드와 실행 통계 정보를 보관하고 있습니다

**문제점**
- 프로세스 테이블이 가득 차면 새 프로세스를 생성할 수 없습니다
- 시스템 자원 낭비로 이어질 수 있습니다
- PID 고갈의 원인이 될 수 있습니다

**해결 방법**
- 부모 프로세스가 wait() 또는 waitpid()를 호출하여 자식의 종료 상태를 회수합니다
- SIGCHLD 시그널을 처리하여 자동으로 wait()를 호출합니다
- 부모 프로세스를 종료하면 init 프로세스가 자식을 입양하여 정리합니다

**예방**
- 자식 프로세스를 생성하면 반드시 wait()로 종료를 처리합니다
- SIGCHLD 핸들러를 등록하여 비동기적으로 처리합니다
- double fork 기법을 사용하여 즉시 정리되도록 합니다

**고아 프로세스(Orphan Process)**

**발생 상황**
- 부모 프로세스가 자식 프로세스보다 먼저 종료된 경우
- 자식 프로세스는 아직 실행 중이지만 부모가 없는 상태

**처리 방법**
- init 프로세스(PID 1) 또는 systemd가 자동으로 부모가 됩니다
- 재부모화(reparenting) 과정을 통해 PPID가 1로 변경됩니다
- init 프로세스는 주기적으로 wait()를 호출하여 고아 프로세스를 정리합니다

**특징**
- 정상적으로 실행을 계속합니다
- 시스템에 의해 자동으로 관리되므로 큰 문제가 되지 않습니다
- 종료 시 init이 회수하므로 좀비가 되지 않습니다

**의도적 고아 프로세스**
- 데몬 프로세스를 만들 때 의도적으로 고아 프로세스를 생성합니다
- 부모 프로세스를 종료시켜 터미널과의 연결을 끊습니다
- 백그라운드에서 독립적으로 실행되는 서비스를 구현합니다

**리눅스에서의 처리**

**init/systemd의 역할**
- 모든 고아 프로세스의 새로운 부모가 됩니다
- 주기적으로 SIGCHLD를 받아 종료된 자식을 회수합니다
- 시스템이 정상적으로 동작하도록 보장합니다

**프로세스 트리 유지**
- 리눅스는 프로세스를 트리 구조로 관리합니다
- 모든 프로세스는 init의 자손입니다
- 부모가 없는 프로세스는 존재할 수 없습니다

**시그널 처리**

**SIGCHLD**
- 자식 프로세스가 종료될 때 부모에게 전송됩니다
- 부모는 이 시그널을 받아 wait()를 호출해야 합니다
- 기본 동작은 무시지만, 핸들러를 등록하여 처리할 수 있습니다

**실무 활용**
장기 실행 서버 프로그램에서는 SIGCHLD 핸들러를 구현하여 좀비 프로세스를 방지합니다. 또한 서비스 관리자(systemd 등)가 프로세스 생명주기를 관리하여 이런 문제를 자동으로 처리합니다.

---

## 19. 리눅스에서, 데몬프로세스에 대해 설명해 주세요.

**정의**
데몬(Daemon)은 백그라운드에서 실행되는 프로세스로, 사용자와 직접 상호작용하지 않고 시스템 서비스를 제공합니다.

**특징**
- 부모 프로세스 없이 독립적으로 실행됩니다(부모는 init/systemd)
- 터미널과 연결되어 있지 않습니다
- 시스템 부팅 시 시작되어 종료 시까지 실행됩니다
- 백그라운드에서 특정 서비스를 제공합니다
- 일반적으로 루트 권한으로 실행됩니다

**데몬 프로세스의 예**
- sshd: SSH 서버 데몬
- httpd/nginx: 웹 서버 데몬
- cron: 작업 스케줄러 데몬
- syslogd: 시스템 로그 데몬
- mysqld: MySQL 데이터베이스 데몬

**데몬 프로세스 생성 방법**

**1단계: fork()로 자식 프로세스 생성**
- 부모 프로세스는 종료하고 자식만 계속 실행합니다
- 자식은 고아 프로세스가 되어 init의 자식이 됩니다

**2단계: setsid()로 새 세션 생성**
- 새로운 세션과 프로세스 그룹의 리더가 됩니다
- 터미널로부터 완전히 분리됩니다
- 제어 터미널이 없는 상태가 됩니다

**3단계: 작업 디렉토리 변경**
- chdir("/")로 루트 디렉토리로 이동합니다
- 파일 시스템 마운트 해제를 방해하지 않기 위함입니다

**4단계: 파일 디스크립터 정리**
- 불필요한 파일 디스크립터를 닫습니다
- 표준 입력, 출력, 에러를 /dev/null로 리다이렉트합니다
- 터미널 입출력을 차단합니다

**5단계: umask 설정**
- umask(0)를 호출하여 파일 생성 권한을 완전히 제어합니다
- 부모로부터 상속받은 umask의 영향을 받지 않습니다

**6단계: 시그널 핸들러 설정**
- SIGHUP: 설정 파일 재로드
- SIGTERM: 정상 종료
- SIGCHLD: 자식 프로세스 처리

**데몬 프로세스 관리**

**전통적인 방법**
- /etc/init.d/ 디렉토리의 스크립트로 관리
- service 명령어로 시작, 중지, 재시작
- PID 파일을 사용하여 프로세스 추적

**현대적인 방법(systemd)**
- systemd 유닛 파일로 관리
- systemctl 명령어 사용
- 자동 재시작, 의존성 관리 등 고급 기능 제공
- 로그는 journalctl로 확인

**데몬의 로깅**
- syslog 시스템을 사용하여 로그 기록
- /var/log/ 디렉토리에 로그 파일 저장
- 로그 레벨을 통해 중요도 구분
- 로그 로테이션으로 디스크 공간 관리

**데몬과 일반 프로세스의 차이**
- 터미널 연결: 데몬은 없음, 일반 프로세스는 있음
- 부모 프로세스: 데몬은 init, 일반은 사용자 셸
- 실행 방식: 데몬은 백그라운드, 일반은 포그라운드
- 생명주기: 데몬은 시스템과 함께, 일반은 사용자 세션과 함께

**세션과 프로세스 그룹**
- 세션: 하나 이상의 프로세스 그룹으로 구성
- 프로세스 그룹: 관련된 프로세스들의 집합
- setsid()로 새 세션 생성 시 터미널과 분리됨
- 세션 리더는 제어 터미널을 가질 수 있음

**실무 활용**
웹 서버, 데이터베이스, 메시지 큐 등 대부분의 서버 소프트웨어는 데몬으로 실행됩니다. systemd는 데몬 생성 과정을 단순화하여 서비스 파일만으로 데몬화를 처리할 수 있게 합니다.

---

## 20. 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

**init 프로세스 (전통적인 시스템)**

**정의**
- 리눅스 시스템에서 가장 먼저 시작되는 프로세스입니다
- PID 1을 가지는 특별한 프로세스입니다
- 모든 프로세스의 조상입니다

**특징**
- 커널이 부팅 과정에서 직접 실행합니다
- 시스템이 종료될 때까지 계속 실행됩니다
- 절대 종료되지 않아야 하는 필수 프로세스입니다
- 부모 프로세스가 없는 유일한 프로세스입니다

**주요 역할**

**시스템 초기화**
- 시스템 부팅 시 각종 시스템 서비스를 시작합니다
- 파일 시스템을 마운트합니다
- 네트워크를 설정합니다
- 데몬 프로세스들을 시작합니다

**고아 프로세스 입양**
- 부모가 먼저 죽은 프로세스의 새로운 부모가 됩니다
- 재부모화(reparenting)를 통해 PPID를 1로 변경합니다
- 고아 프로세스가 종료되면 wait()를 호출하여 정리합니다

**좀비 프로세스 회수**
- 종료된 자식 프로세스의 자원을 회수합니다
- SIGCHLD 시그널을 처리하여 좀비 상태를 해제합니다
- 프로세스 테이블의 항목을 제거합니다

**런레벨 관리**
- 시스템의 실행 레벨을 관리합니다
- 0: 시스템 종료
- 1: 싱글 유저 모드
- 3: 멀티 유저 텍스트 모드
- 5: 멀티 유저 그래픽 모드
- 6: 재부팅

**systemd (현대적인 시스템)**

**정의**
- 대부분의 현대 리눅스 배포판에서 사용하는 init 시스템입니다
- PID 1을 가지며 전통적인 init을 대체합니다
- 시스템 및 서비스 관리자로 동작합니다

**특징**
- 병렬 서비스 시작으로 부팅 속도 향상
- 의존성 기반 서비스 관리
- on-demand 서비스 시작
- 스냅샷과 시스템 상태 복원
- 리소스 관리 및 제한

**주요 개념**

**유닛(Unit)**
- 시스템 리소스의 기본 단위입니다
- service: 시스템 서비스
- socket: IPC 소켓
- device: 디바이스 파일
- mount: 파일 시스템 마운트 포인트
- target: 유닛 그룹

**타겟(Target)**
- 런레벨을 대체하는 개념입니다
- poweroff.target: 시스템 종료
- rescue.target: 복구 모드
- multi-user.target: 멀티 유저 텍스트 모드
- graphical.target: 그래픽 환경

**의존성 관리**
- Requires: 필수 의존성
- Wants: 선택적 의존성
- Before/After: 시작 순서 지정
- 자동으로 의존성 해결

**장점**
- 빠른 부팅 속도
- 강력한 로깅 시스템(journald)
- 통합된 서비스 관리
- 자동 재시작 및 복구
- 리소스 제어(cgroup 통합)

**systemctl 명령어**
- systemctl start: 서비스 시작
- systemctl stop: 서비스 중지
- systemctl restart: 서비스 재시작
- systemctl enable: 부팅 시 자동 시작 설정
- systemctl status: 서비스 상태 확인

**비교**

**전통적인 init**
- 순차적 실행으로 느린 부팅
- 쉘 스크립트 기반
- 간단하고 이해하기 쉬움
- 제한적인 기능

**systemd**
- 병렬 실행으로 빠른 부팅
- 바이너리 기반
- 복잡하지만 강력한 기능
- 표준화된 관리 방식

**프로세스 트리 확인**
- pstree 명령어로 전체 프로세스 트리를 시각화
- ps -ef로 모든 프로세스와 부모 관계 확인
- systemd-cgls로 cgroup 계층 구조 확인

**실무 활용**
서버 관리 시 systemd를 통해 서비스를 관리하며, 서비스 간 의존성, 자동 재시작, 리소스 제한 등을 설정합니다. PID 1이 죽으면 시스템 전체가 멈추므로, 커널 패닉이 발생합니다.
