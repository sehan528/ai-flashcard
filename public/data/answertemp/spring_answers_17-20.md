# Spring 답변 17-20

## 질문 17: 예외처리를 하는 세 방법에 대해 설명해 주세요.

자바에서 예외를 처리하는 세 가지 주요 방법은 try-catch, throws, 그리고 사용자 정의 예외입니다.

**1. try-catch-finally 블록:**

try 블록에 예외가 발생할 수 있는 코드를 작성합니다. 예외가 발생하면 해당 예외 타입과 일치하는 catch 블록으로 제어가 이동합니다.

catch 블록은 여러 개 사용할 수 있으며, 예외 타입별로 다르게 처리할 수 있습니다. 구체적인 예외부터 일반적인 예외 순서로 배치해야 합니다. Java 7부터는 multi-catch로 여러 예외를 한 번에 처리할 수 있습니다.

finally 블록은 예외 발생 여부와 관계없이 항상 실행됩니다. 리소스 정리, 연결 해제, 파일 닫기 등 반드시 실행되어야 하는 코드를 작성합니다. try나 catch에서 return문이 있어도 finally는 실행됩니다.

이 방법은 예외를 직접 처리하고 복구할 수 있을 때 사용합니다. 사용자에게 적절한 메시지를 보여주거나, 대체 로직을 실행하거나, 로깅 후 계속 진행할 수 있습니다.

**2. throws를 사용한 예외 전파:**

메서드 시그니처에 throws 키워드를 사용하여 예외를 호출자에게 전달합니다. 메서드 내에서 예외를 처리하지 않고 상위 호출 스택으로 던집니다.

Checked Exception의 경우 반드시 throws를 명시해야 합니다. Unchecked Exception은 명시하지 않아도 되지만 문서화 목적으로 작성할 수 있습니다.

여러 예외를 쉼표로 구분하여 선언할 수 있습니다. 이 방법은 현재 메서드에서 예외를 처리할 적절한 방법이 없거나, 더 높은 레벨에서 처리하는 것이 적합할 때 사용합니다.

예외를 전파하면서 다른 타입으로 감쌀 수도 있습니다. 저수준 예외를 고수준 예외로 변환하여 추상화 레벨을 유지할 수 있습니다.

**3. try-with-resources:**

Java 7에서 도입된 방법으로, AutoCloseable 인터페이스를 구현한 리소스를 자동으로 닫아줍니다. try 괄호 안에 리소스를 선언하면 try 블록이 끝날 때 자동으로 close가 호출됩니다.

여러 리소스를 세미콜론으로 구분하여 선언할 수 있으며, 선언의 역순으로 닫힙니다. finally 블록이 필요 없어 코드가 간결해지고, 리소스 누수를 방지할 수 있습니다.

close 메서드에서 예외가 발생해도 원래 예외가 보존되며, close의 예외는 suppressed exception으로 추가됩니다.

**추가적인 방법들:**

사용자 정의 예외를 만들어 도메인 특화 예외를 표현할 수 있습니다. Exception이나 RuntimeException을 상속받아 비즈니스 로직에 맞는 예외를 정의합니다.

예외 체이닝으로 원인 예외를 포함시켜 디버깅을 용이하게 할 수 있습니다. 생성자나 initCause 메서드로 원인을 설정합니다.

**선택 기준:**

예외를 복구할 수 있으면 try-catch를 사용합니다. 현재 레벨에서 처리할 수 없으면 throws로 전파합니다. 리소스를 사용하면 try-with-resources를 우선 고려합니다.

## 질문 18: CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.

Checked Exception과 Unchecked Exception은 자바 예외 처리의 두 가지 주요 범주로, 처리 방식과 사용 목적이 다릅니다.

**Checked Exception:**

Exception 클래스를 직접 상속하는 예외들입니다. RuntimeException을 제외한 모든 Exception 하위 클래스가 해당합니다. IOException, SQLException, ClassNotFoundException 등이 대표적입니다.

컴파일러가 예외 처리를 강제합니다. 메서드가 Checked Exception을 던질 수 있으면 반드시 throws로 선언해야 하고, 호출하는 쪽에서는 try-catch로 처리하거나 다시 throws해야 합니다. 처리하지 않으면 컴파일 에러가 발생합니다.

복구 가능한 예외 상황에 사용됩니다. 파일을 찾을 수 없으면 다른 경로를 시도하거나, 네트워크 연결이 실패하면 재시도하는 등 애플리케이션이 적절히 대응할 수 있는 상황입니다.

호출자가 예외를 인지하고 처리하도록 강제하여 안정성을 높입니다. API 설계에서 명시적으로 어떤 문제가 발생할 수 있는지 알려줍니다.

**Unchecked Exception:**

RuntimeException과 그 하위 클래스들입니다. NullPointerException, IllegalArgumentException, ArrayIndexOutOfBoundsException, ArithmeticException 등이 있습니다.

컴파일러가 처리를 강제하지 않습니다. throws 선언이 필요 없고, 처리하지 않아도 컴파일됩니다. 선택적으로 처리할 수 있습니다.

주로 프로그래밍 오류를 나타냅니다. null 체크 누락, 배열 인덱스 초과, 잘못된 인자 전달 등 개발자의 실수로 발생하는 문제입니다. 코드를 수정하여 예방할 수 있습니다.

런타임에 발생하며, 보통 복구하기 어렵습니다. 프로그램의 논리적 오류이므로 버그를 수정하는 것이 올바른 대응입니다.

**설계 철학의 차이:**

Checked Exception은 "예상 가능한 예외 상황"을 위한 것입니다. 정상적인 프로그램 흐름의 일부로 간주되며, 비즈니스 로직에서 처리해야 하는 경우입니다.

Unchecked Exception은 "프로그래밍 오류"를 위한 것입니다. 발생하지 않아야 하는 상황이며, 발생하면 버그로 간주됩니다.

**장단점:**

Checked Exception의 장점은 예외를 명시적으로 처리하게 하여 견고성을 높이고, API 문서 역할을 한다는 것입니다. 단점은 보일러플레이트 코드가 많아지고, 적절히 처리할 수 없는 경우에도 강제로 처리해야 하며, 함수형 프로그래밍과 잘 맞지 않습니다.

Unchecked Exception의 장점은 코드가 간결해지고, 처리할 수 없는 예외를 강제하지 않으며, 유연성이 높다는 것입니다. 단점은 예외가 문서화되지 않으면 발생 가능한 예외를 알기 어렵고, 예외를 놓치기 쉬우며, 런타임에만 발견됩니다.

**현대적 관점:**

많은 현대 프레임워크와 언어는 Checked Exception을 선호하지 않습니다. Spring은 대부분의 예외를 Unchecked로 래핑하며, Kotlin은 Checked Exception을 지원하지 않습니다.

일반적으로 복구 가능한 비즈니스 예외는 Checked로, 프로그래밍 오류는 Unchecked로 사용하는 것이 권장되지만, 프로젝트 컨텍스트에 따라 판단해야 합니다.

## 질문 19: 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?

네, 예외 처리는 성능에 상당한 영향을 미칠 수 있습니다.

**예외 처리의 성능 비용:**

첫째, 스택 트레이스 생성 비용이 큽니다. 예외 객체가 생성될 때 현재 호출 스택의 모든 프레임 정보를 캡처합니다. 호출 스택이 깊을수록 비용이 증가하며, 이는 일반적인 객체 생성보다 수십에서 수백 배 느립니다.

둘째, 예외 throw와 catch 과정의 오버헤드가 있습니다. 정상적인 제어 흐름을 벗어나 예외 핸들러를 찾고 스택을 되감는 과정이 필요합니다. JVM은 예외 테이블을 탐색하고 적절한 catch 블록으로 점프해야 합니다.

셋째, JIT 컴파일 최적화가 방해받습니다. 예외가 자주 발생하는 코드는 핫스팟으로 인식되기 어렵고, 인라이닝 같은 최적화가 제한됩니다.

넷째, 예외 객체 자체의 메모리 할당과 GC 압력이 있습니다. 예외를 많이 생성하면 힙 메모리를 소비하고 가비지 컬렉션 빈도가 증가합니다.

**성능 영향 정도:**

정상 흐름과 비교하면 예외 throw는 수백에서 수천 배 느릴 수 있습니다. 하지만 예외가 정말 예외적인 상황에만 발생한다면 전체 성능에 큰 영향은 없습니다.

문제는 제어 흐름에 예외를 사용하는 경우입니다. 반복문 안에서 예외를 던지거나, 정상적인 비즈니스 로직에 예외를 사용하면 심각한 성능 저하가 발생합니다.

**부하를 줄이는 방법:**

첫째, 제어 흐름에 예외를 사용하지 않습니다. 예상 가능한 상황은 if문이나 Optional로 처리합니다. 예외는 정말 예외적인 상황에만 사용합니다.

둘째, 검증을 먼저 수행합니다. 예외가 발생하기 전에 조건을 체크하여 예외 발생 자체를 방지합니다. null 체크, 범위 검증, 전제 조건 확인 등을 먼저 합니다.

셋째, 캐싱과 재사용을 고려합니다. 자주 던지는 예외는 싱글톤으로 만들어 재사용할 수 있습니다. 단, 스택 트레이스가 의미 없어질 수 있으므로 주의해야 합니다.

넷째, 스택 트레이스를 비활성화합니다. 성능이 매우 중요하고 스택 트레이스가 필요 없는 경우, fillInStackTrace를 오버라이드하여 비용을 줄일 수 있습니다. 하지만 디버깅이 어려워지므로 신중히 결정해야 합니다.

다섯째, 경량 대안을 사용합니다. Optional, Either 같은 함수형 데이터 타입으로 오류를 표현하면 예외보다 성능이 좋습니다. Result 패턴으로 성공/실패를 명시적으로 반환할 수 있습니다.

여섯째, 예외 범위를 최소화합니다. try 블록을 최소한으로 유지하여 JVM이 더 효율적으로 최적화할 수 있게 합니다.

일곱째, 로깅을 최적화합니다. 예외를 로깅할 때 스택 트레이스 전체를 출력하면 I/O 비용이 큽니다. 필요한 정보만 로깅하거나, 로그 레벨을 적절히 설정합니다.

여덟째, 프로파일링으로 핫스팟을 찾습니다. 실제로 어디서 예외가 많이 발생하는지 측정하여 최적화 대상을 정확히 파악합니다.

**권장 사항:**

예외는 예외적인 상황에만 사용합니다. 성능이 중요한 경로에서는 예외를 피하고 대안을 고려합니다. 하지만 가독성과 유지보수성을 해치면서까지 최적화할 필요는 없습니다. 측정 후에 최적화합니다.

## 질문 20: Synchronized 키워드에 대해 설명해 주세요.

synchronized는 자바에서 스레드 동기화를 제공하는 키워드로, 멀티스레드 환경에서 공유 자원에 대한 동시 접근을 제어합니다.

**기본 개념:**

synchronized는 상호 배제(mutual exclusion)를 구현합니다. 한 번에 하나의 스레드만 synchronized 블록이나 메서드를 실행할 수 있습니다. 다른 스레드들은 락을 획득할 때까지 대기합니다.

모든 자바 객체는 내부적으로 모니터 락(intrinsic lock 또는 monitor lock)을 가지고 있습니다. synchronized는 이 락을 사용하여 동기화를 수행합니다.

**동작 원리:**

스레드가 synchronized 블록에 진입하려면 먼저 해당 객체의 락을 획득해야 합니다. 락을 획득하면 블록을 실행하고, 블록을 나가면 락을 자동으로 해제합니다.

락을 획득하지 못한 스레드는 BLOCKED 상태로 대기합니다. 락을 가진 스레드가 블록을 나가면 대기 중인 스레드 중 하나가 락을 획득하고 진행합니다.

**메모리 가시성:**

synchronized는 단순히 동시 접근을 막는 것 이상의 기능을 제공합니다. Java Memory Model에 의해 메모리 가시성도 보장합니다.

synchronized 블록에 진입하기 전에 메인 메모리에서 최신 값을 읽어오고, 블록을 나갈 때 변경사항을 메인 메모리에 반영합니다. 이는 CPU 캐시와 메인 메모리 간의 동기화를 보장합니다.

happens-before 관계를 형성하여, 한 스레드의 synchronized 블록 내 작업이 다음 스레드에서 보이도록 보장합니다.

**두 가지 사용 형태:**

synchronized 메서드는 메서드 전체를 동기화합니다. 인스턴스 메서드는 this 객체의 락을 사용하고, static 메서드는 Class 객체의 락을 사용합니다.

synchronized 블록은 특정 코드 영역만 동기화합니다. 어떤 객체의 락을 사용할지 명시적으로 지정할 수 있습니다. 더 세밀한 제어가 가능하고, 락 범위를 최소화할 수 있습니다.

**장점:**

사용이 간단하고 직관적입니다. 자동으로 락을 획득하고 해제하므로 데드락 방지에 도움이 됩니다. 예외가 발생해도 락이 자동으로 해제됩니다.

JVM이 최적화를 수행합니다. 락 엘리젼(lock elision), 락 조악화(lock coarsening), 바이어스드 락(biased locking) 등의 기법으로 성능을 개선합니다.

**단점:**

락을 획득할 때까지 무한정 대기합니다. 타임아웃이나 인터럽트를 처리할 수 없습니다.

읽기와 쓰기를 구분하지 않습니다. 모든 접근을 동일하게 동기화하여 읽기 전용 작업도 블로킹됩니다.

유연성이 부족합니다. 락의 공정성(fairness)를 제어할 수 없고, 조건별 대기(condition variable)를 사용할 수 없습니다.

성능 오버헤드가 있습니다. 락 획득과 해제, 컨텍스트 스위칭, 경합으로 인한 대기 시간이 발생합니다.

**주의사항:**

데드락에 주의해야 합니다. 여러 락을 사용할 때 항상 같은 순서로 획득해야 합니다.

동기화 범위를 최소화합니다. 필요한 부분만 동기화하여 성능 저하를 줄입니다.

불변 객체를 우선 고려합니다. 상태가 변하지 않으면 동기화가 불필요합니다.

고수준 동시성 유틸리티를 검토합니다. java.util.concurrent 패키지의 도구들이 더 효율적이고 강력할 수 있습니다.
