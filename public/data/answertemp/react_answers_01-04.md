# React 답변 01-04

## 질문 1: React는 무엇이고 왜 사용하나요?

**정의:**
React는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다. Facebook에서 개발했으며 컴포넌트 기반의 선언적 프로그래밍 방식으로 효율적이고 유지보수하기 쉬운 UI를 만들 수 있게 해줍니다.

**React의 핵심 개념:**
- 컴포넌트 기반: UI를 재사용 가능한 독립적인 조각으로 나눕니다. 각 컴포넌트는 자체 로직과 표현을 가집니다.
- 선언적: 원하는 UI 상태를 선언하면 React가 알아서 DOM을 업데이트합니다. 명령형보다 직관적입니다.
- 단방향 데이터 흐름: 데이터가 부모에서 자식으로만 흐릅니다. 예측 가능하고 디버깅이 쉽습니다.
- Virtual DOM: 실제 DOM 조작을 최소화하여 성능을 최적화합니다.

**React를 사용하는 이유:**
- 재사용성이 높습니다. 컴포넌트를 여러 곳에서 재사용할 수 있습니다.
- 개발 생산성이 향상됩니다. 선언적 코드로 빠르게 개발할 수 있습니다.
- 큰 커뮤니티와 생태계를 가집니다. 수많은 라이브러리와 도구가 있습니다.
- 성능이 우수합니다. Virtual DOM과 최적화 기법으로 빠릅니다.
- 학습하기 쉽습니다. JavaScript 지식만 있으면 시작할 수 있습니다.

**React의 장점:**
- 유지보수가 쉽습니다. 컴포넌트 단위로 관리하여 복잡도를 낮춥니다.
- 테스트가 용이합니다. 순수 함수처럼 동작하는 컴포넌트는 테스트하기 쉽습니다.
- SEO 최적화가 가능합니다. Next.js 같은 프레임워크로 SSR을 구현할 수 있습니다.
- 모바일 앱 개발도 가능합니다. React Native로 네이티브 앱을 만듭니다.

**실무 활용:**
- 싱글 페이지 애플리케이션 개발에 최적입니다. 빠르고 부드러운 사용자 경험을 제공합니다.
- 대규모 프로젝트에 적합합니다. 컴포넌트 구조로 확장성이 좋습니다.
- 팀 협업이 원활합니다. 컴포넌트 단위로 작업을 나눌 수 있습니다.
- 다양한 플랫폼을 지원합니다. 웹, 모바일, 데스크톱 애플리케이션을 만들 수 있습니다.
- 전 세계적으로 널리 사용됩니다. Facebook, Instagram, Netflix 등이 사용합니다.

---

## 질문 2: 컴포넌트(Component)란 무엇이고 어떤 종류가 있나요?

**정의:**
컴포넌트는 UI의 독립적이고 재사용 가능한 조각입니다. 자체 로직과 렌더링을 담당하며, props를 입력받아 React 엘리먼트를 반환합니다.

**함수형 컴포넌트:**
- 함수로 정의됩니다. JavaScript 함수 그 자체입니다.
- props를 매개변수로 받습니다. 구조 분해로 쉽게 사용할 수 있습니다.
- JSX를 반환합니다. UI를 표현하는 엘리먼트를 돌려줍니다.
- Hooks를 사용할 수 있습니다. useState, useEffect 등으로 상태와 생명주기를 관리합니다.
- 간결하고 테스트하기 쉽습니다. 순수 함수에 가깝습니다.

**클래스 컴포넌트:**
- ES6 클래스로 정의됩니다. React.Component를 상속받습니다.
- render 메서드를 구현해야 합니다. 이 메서드가 JSX를 반환합니다.
- this.props로 props에 접근합니다.
- this.state와 this.setState로 상태를 관리합니다.
- 생명주기 메서드를 사용합니다. componentDidMount 등입니다.
- 레거시 코드에서 많이 볼 수 있습니다.

**함수형과 클래스형의 차이:**
- 함수형이 더 간결합니다. 보일러플레이트가 적습니다.
- 함수형은 Hooks로 강력해졌습니다. 거의 모든 기능을 구현할 수 있습니다.
- 클래스형은 this 바인딩이 필요합니다. 복잡하고 혼란스러울 수 있습니다.
- React 팀은 함수형을 권장합니다. 새 프로젝트는 함수형으로 시작하는 것이 좋습니다.

**컴포넌트의 종류:**
- Presentational Component: UI 표현만 담당합니다. 로직이 거의 없습니다. props를 받아 렌더링합니다.
- Container Component: 로직을 담당합니다. 데이터를 가져오고 상태를 관리합니다. Presentational에 props를 전달합니다.
- 하지만 Hooks 등장 이후 이 구분이 흐려졌습니다. 함수형 컴포넌트가 모든 역할을 할 수 있습니다.

**컴포넌트 구성 원칙:**
- 단일 책임 원칙을 따릅니다. 하나의 컴포넌트는 하나의 역할만 합니다.
- 재사용 가능하게 만듭니다. 특정 맥락에 종속되지 않도록 합니다.
- 작게 유지합니다. 너무 크면 분리를 고려합니다.
- Props로 커스터마이징합니다. 유연하게 사용할 수 있도록 합니다.

**실무 활용:**
- UI를 컴포넌트 단위로 설계합니다. 재사용성을 고려합니다.
- 디자인 시스템을 컴포넌트로 구현합니다. 버튼, 인풋 등 기본 요소를 만듭니다.
- 페이지를 여러 컴포넌트로 나눕니다. Header, Footer, Sidebar 등입니다.
- Storybook으로 컴포넌트를 독립적으로 개발하고 문서화합니다.
- 함수형 컴포넌트와 Hooks를 기본으로 사용합니다.

---

## 질문 3: JSX란 무엇이고 왜 사용하나요?

**정의:**
JSX는 JavaScript XML의 약자로, JavaScript 안에서 HTML과 유사한 문법으로 UI를 표현할 수 있게 해주는 문법 확장입니다. React 엘리먼트를 생성하는 간편한 방법입니다.

**JSX의 특징:**
- HTML처럼 보이지만 JavaScript입니다. 표현식을 중괄호로 삽입할 수 있습니다.
- Babel이 일반 JavaScript로 변환합니다. React.createElement 호출로 컴파일됩니다.
- XML 규칙을 따릅니다. 모든 태그는 닫혀야 합니다.
- camelCase 속성명을 사용합니다. className, onClick 등입니다.

**JSX를 사용하는 이유:**
- 가독성이 높습니다. UI 구조가 한눈에 들어옵니다.
- 직관적입니다. HTML을 아는 사람이라면 쉽게 이해할 수 있습니다.
- 컴파일 타임 에러를 잡을 수 있습니다. 문법 오류를 미리 발견합니다.
- JavaScript의 모든 기능을 사용할 수 있습니다. 조건부 렌더링, 반복 등이 쉽습니다.

**JSX 문법 규칙:**
- 하나의 루트 요소만 반환해야 합니다. Fragment로 감싸거나 배열을 사용합니다.
- JavaScript 표현식은 중괄호 안에 씁니다. 변수, 함수 호출, 연산 등이 가능합니다.
- 주석은 중괄호와 다중 라인 주석을 사용합니다.
- 스타일은 객체로 전달합니다. 카멜케이스 속성명을 사용합니다.
- className으로 CSS 클래스를 지정합니다. class는 예약어입니다.

**JSX vs createElement:**
- JSX는 간결하고 읽기 쉽습니다.
- createElement는 장황하지만 JSX 없이도 React를 사용할 수 있습니다.
- 내부적으로는 동일합니다. JSX가 createElement로 변환됩니다.
- JSX를 사용하는 것이 압도적으로 일반적입니다.

**조건부 렌더링:**
- 삼항 연산자를 많이 사용합니다. 간결한 조건부 표현입니다.
- 논리 AND 연산자로 조건부 렌더링을 합니다.
- if 문은 JSX 밖에서 사용합니다.
- 즉시 실행 함수로 복잡한 로직을 처리할 수 있습니다.

**리스트 렌더링:**
- map 메서드로 배열을 JSX로 변환합니다.
- key prop이 필요합니다. 각 항목을 고유하게 식별합니다.
- key는 안정적이고 예측 가능해야 합니다. 인덱스 사용은 피합니다.

**실무 활용:**
- 컴포넌트의 UI를 JSX로 표현합니다. 선언적이고 명확합니다.
- 조건부와 반복 렌더링을 JavaScript 문법으로 처리합니다.
- props와 state를 JSX에 삽입합니다. 동적인 UI를 만듭니다.
- Fragment로 불필요한 DOM 노드를 줄입니다.
- TypeScript와 함께 사용하면 타입 안전성을 얻습니다.

---

## 질문 4: Virtual DOM의 동작 원리와 장점은 무엇인가요?

**정의:**
Virtual DOM은 실제 DOM의 가벼운 복사본으로, 메모리에 존재하는 JavaScript 객체입니다. React는 Virtual DOM을 사용하여 실제 DOM 조작을 최소화하고 성능을 최적화합니다.

**Virtual DOM의 동작 원리:**
- 상태가 변경되면 새로운 Virtual DOM 트리를 생성합니다. 전체 UI를 다시 렌더링합니다.
- 이전 Virtual DOM과 새 Virtual DOM을 비교합니다. Diffing 알고리즘을 사용합니다.
- 변경된 부분만 찾아냅니다. 최소한의 변경사항을 계산합니다.
- 실제 DOM에 한 번에 적용합니다. Reconciliation 과정을 거칩니다.
- 배치 업데이트로 효율성을 높입니다.

**Diffing 알고리즘:**
- 트리를 레벨별로 비교합니다. 같은 레벨의 요소들만 비교합니다.
- 타입이 다르면 전체를 교체합니다. 세부 비교를 하지 않습니다.
- 같은 타입이면 속성만 업데이트합니다.
- key를 사용하여 리스트 항목을 식별합니다. 순서가 바뀌어도 재사용합니다.
- 휴리스틱 알고리즘으로 효율성과 성능의 균형을 맞춥니다.

**Virtual DOM의 장점:**
- 성능이 향상됩니다. 실제 DOM 조작을 최소화합니다. DOM 조작은 비용이 큽니다.
- 배치 업데이트로 리플로우와 리페인트를 줄입니다.
- 선언적 프로그래밍이 가능합니다. 개발자는 최종 상태만 선언하면 됩니다.
- 크로스 플랫폼 렌더링이 가능합니다. React Native가 이를 활용합니다.

**실제 DOM과의 차이:**
- 실제 DOM은 무겁고 느립니다. 브라우저 API와 연결되어 있습니다.
- Virtual DOM은 가볍고 빠릅니다. 단순한 JavaScript 객체입니다.
- 실제 DOM 조작은 리플로우를 유발합니다.
- Virtual DOM은 메모리에서만 동작합니다.

**Reconciliation 과정:**
- Render Phase: Virtual DOM을 생성하고 비교합니다. 변경사항을 계산합니다.
- Commit Phase: 실제 DOM에 변경사항을 적용합니다. 한 번에 반영합니다.
- Fiber 아키텍처로 작업을 분할합니다. 우선순위를 관리하고 중단할 수 있습니다.

**한계와 오해:**
- 항상 빠른 것은 아닙니다. 간단한 업데이트는 직접 DOM 조작이 더 빠를 수 있습니다.
- Virtual DOM이 React의 전부는 아닙니다. 컴포넌트 모델이 더 중요합니다.
- 메모리를 사용합니다. Virtual DOM도 공간을 차지합니다.
- 하지만 대부분의 경우 장점이 단점을 상회합니다.

**실무 활용:**
- 복잡한 UI에서 성능 이점이 큽니다. 많은 요소가 자주 변경될 때 유용합니다.
- key prop을 올바르게 사용하여 최적화합니다.
- 불필요한 리렌더링을 방지합니다. React.memo, useMemo 등을 활용합니다.
- 개발자는 Virtual DOM을 직접 다루지 않습니다. React가 내부적으로 처리합니다.
- 성능 프로파일링으로 병목을 찾고 최적화합니다.

---
