## 질문 81: Python의 클로저(Closure)와 nonlocal 키워드에 대해 설명해주세요.

**정의:**
클로저는 외부 함수의 변수를 내부 함수가 기억하고 접근할 수 있는 기능입니다. nonlocal 키워드는 중첩 함수에서 외부 함수의 변수를 수정할 수 있게 하며, 변수가 전역이 아닌 가장 가까운 외부 스코프에 있음을 나타냅니다.

**특징/원리:**
- 렉시컬 스코프: 함수가 정의된 위치의 스코프를 기억
- 변수 캡처: 외부 함수 종료 후에도 외부 변수에 접근 가능
- 데이터 은닉: 외부에서 직접 접근할 수 없는 private 변수 구현
- 상태 유지: 함수 호출 간에 상태를 보존

**클로저 동작:**
- 외부 함수 실행: 외부 함수가 호출되어 지역 변수 생성
- 내부 함수 정의: 내부 함수가 외부 변수를 참조
- 함수 반환: 외부 함수가 내부 함수를 반환
- 변수 접근: 반환된 함수가 외부 변수에 계속 접근 가능

**nonlocal 키워드:**
- 변수 바인딩: 가장 가까운 외부 스코프의 변수를 참조
- 수정 가능: nonlocal 선언 후 외부 변수를 수정 가능
- 전역 제외: global 변수는 대상이 아니며 중첩 스코프만 해당
- 선언 필수: nonlocal 없이 할당하면 새로운 지역 변수 생성

**global vs nonlocal:**
- global: 전역 스코프의 변수를 수정
- nonlocal: 외부 함수의 변수를 수정
- 범위: global은 모듈 레벨, nonlocal은 중첩 함수 레벨
- 사용: 전역 변수 수정은 지양하고 nonlocal로 캡슐화 유지

**활용 패턴:**
- 팩토리 함수: 매개변수로 설정을 받아 특화된 함수 생성
- 콜백 함수: 이벤트 핸들러에서 외부 컨텍스트 참조
- 데코레이터: 외부 함수의 설정을 내부 래퍼가 사용
- 카운터: 호출 횟수를 추적하는 함수 구현

**실무 활용:**
- 설정 값을 클로저로 캡처하여 설정에 따라 다르게 동작하는 함수 생성
- 이벤트 핸들러에서 외부 컨텍스트 정보를 클로저로 기억
- nonlocal로 카운터나 누적기 같은 상태를 유지하는 함수 구현

---

## 질문 82: Python의 클래스 변수와 인스턴스 변수의 차이점은 무엇인가요?

**정의:**
클래스 변수는 클래스 자체에 속하며 모든 인스턴스가 공유하는 변수이고, 인스턴스 변수는 각 인스턴스마다 독립적으로 존재하는 변수입니다. 클래스 변수는 클래스 정의 내에서 선언하고, 인스턴스 변수는 주로 __init__() 메서드에서 self로 선언합니다.

**특징/원리:**
- 공유 vs 독립: 클래스 변수는 모든 인스턴스가 공유, 인스턴스 변수는 각자 소유
- 네임스페이스: 클래스 변수는 클래스 네임스페이스, 인스턴스 변수는 인스턴스 네임스페이스
- 접근 순서: 인스턴스에서 속성 조회 시 인스턴스 네임스페이스 먼저, 없으면 클래스 네임스페이스 검색
- 메모리: 클래스 변수는 하나만 존재, 인스턴스 변수는 인스턴스 개수만큼 존재

**클래스 변수:**
- 선언 위치: 클래스 정의 내에서 메서드 밖에 선언
- 접근: 클래스명이나 인스턴스를 통해 접근 가능
- 수정: 클래스명으로 수정하면 모든 인스턴스에 반영
- 용도: 모든 인스턴스가 공유할 설정, 카운터, 상수 등

**인스턴스 변수:**
- 선언 위치: 주로 __init__() 메서드에서 self.variable로 선언
- 접근: 인스턴스를 통해서만 접근
- 독립성: 각 인스턴스마다 다른 값을 가질 수 있음
- 용도: 객체의 고유한 상태나 속성 저장

**주의사항:**
- 가변 기본값: 클래스 변수로 리스트나 딕셔너리를 선언하면 모든 인스턴스가 공유하여 의도치 않은 동작 발생
- 쉐도잉: 인스턴스 변수가 클래스 변수와 같은 이름이면 인스턴스 변수가 우선
- 수정: 인스턴스를 통해 클래스 변수를 수정하려 하면 실제로는 새로운 인스턴스 변수 생성

**실무 활용:**
- 인스턴스 카운터를 클래스 변수로 구현하여 생성된 객체 수 추적
- 설정 값이나 상수를 클래스 변수로 정의하여 모든 인스턴스가 공유
- 인스턴스 변수로 객체별 상태를 저장하여 독립적인 동작 구현

---

## 질문 83: Python의 매직 메서드(__init__, __str__, __repr__ 등)에 대해 설명해주세요.

**정의:**
매직 메서드는 더블 언더스코어로 시작하고 끝나는 특수 메서드로, Python 객체의 내장 동작을 커스터마이징합니다. 연산자 오버로딩, 객체 생성, 문자열 표현, 컨테이너 동작 등을 정의하여 객체를 Python의 내장 타입처럼 동작하게 만듭니다.

**특징/원리:**
- 암묵적 호출: 직접 호출하지 않고 특정 연산이나 문법에 의해 자동 호출
- 연산자 오버로딩: 사용자 정의 클래스에서 +, -, ==  등의 연산자 의미 정의
- 덕 타이핑: 적절한 매직 메서드를 구현하면 내장 타입처럼 동작
- 프로토콜: 특정 매직 메서드 집합을 구현하면 해당 프로토콜을 만족

**생성과 초기화:**
- __new__(cls): 인스턴스를 생성하는 정적 메서드로 __init__() 전에 호출
- __init__(self): 인스턴스를 초기화하며 생성자 역할
- __del__(self): 인스턴스가 소멸될 때 호출되는 소멸자

**문자열 표현:**
- __str__(self): str()이나 print()로 호출되며 사용자 친화적 문자열 반환
- __repr__(self): repr()로 호출되며 개발자를 위한 명확한 표현 반환, 디버깅에 유용
- __format__(self, format_spec): format()이나 f-string에서 사용할 포맷팅 정의

**비교 연산자:**
- __eq__(self, other): == 연산자
- __ne__(self, other): != 연산자
- __lt__(self, other): < 연산자
- __le__(self, other): <= 연산자
- __gt__(self, other): > 연산자
- __ge__(self, other): >= 연산자

**산술 연산자:**
- __add__(self, other): + 연산자
- __sub__(self, other): - 연산자
- __mul__(self, other): * 연산자
- __truediv__(self, other): / 연산자
- __iadd__(self, other): += 연산자 (in-place 버전)

**컨테이너:**
- __len__(self): len() 함수 지원
- __getitem__(self, key): 인덱스 접근 obj[key]
- __setitem__(self, key, value): 인덱스 할당 obj[key] = value
- __delitem__(self, key): 인덱스 삭제 del obj[key]
- __contains__(self, item): in 연산자 지원
- __iter__(self): 이터레이터 반환하여 for 루프 지원

**컨텍스트 매니저:**
- __enter__(self): with 문 진입 시 호출
- __exit__(self, exc_type, exc_value, traceback): with 블록 종료 시 호출

**실무 활용:**
- __str__과 __repr__을 구현하여 객체의 가독성 있는 출력 제공
- __eq__와 __hash__를 구현하여 객체를 딕셔너리 키나 세트 원소로 사용
- 수학적 객체를 표현할 때 산술 연산자를 오버로딩하여 직관적인 코드 작성

---

## 질문 84: Python의 프로퍼티(Property)와 디스크립터(Descriptor)를 설명해주세요.

**정의:**
프로퍼티는 메서드를 속성처럼 접근할 수 있게 하는 기능으로 getter, setter, deleter를 정의합니다. 디스크립터는 __get__, __set__, __delete__ 메서드를 구현하여 속성 접근을 제어하는 더 일반적이고 강력한 메커니즘입니다.

**특징/원리:**
- 캡슐화: 내부 구현을 숨기고 제어된 접근 제공
- 유효성 검증: setter에서 값의 유효성을 검사
- 계산된 속성: getter에서 동적으로 값을 계산하여 반환
- 하위 호환성: 공개 속성을 나중에 프로퍼티로 변경해도 외부 코드는 수정 불필요

**프로퍼티:**
- @property: getter 메서드를 정의하는 데코레이터
- @x.setter: setter 메서드를 정의하는 데코레이터
- @x.deleter: deleter 메서드를 정의하는 데코레이터
- 읽기 전용: setter 없이 getter만 정의하면 읽기 전용 속성

**디스크립터 프로토콜:**
- __get__(self, instance, owner): 속성 접근 시 호출
- __set__(self, instance, value): 속성 할당 시 호출
- __delete__(self, instance): 속성 삭제 시 호출
- __set_name__(self, owner, name): 디스크립터가 클래스 속성으로 할당될 때 호출

**데이터 vs 비데이터 디스크립터:**
- 데이터 디스크립터: __set__이나 __delete__를 구현하여 인스턴스 속성보다 우선순위 높음
- 비데이터 디스크립터: __get__만 구현하여 인스턴스 속성에 의해 가려질 수 있음

**사용 사례:**
- 프로퍼티: 간단한 getter/setter 로직이나 계산된 속성
- 디스크립터: 여러 클래스에서 재사용할 속성 검증 로직
- 내장 디스크립터: @staticmethod, @classmethod, @property가 디스크립터로 구현됨

**실무 활용:**
- 클래스의 private 속성에 검증 로직을 추가한 프로퍼티로 안전하게 접근
- 타입 검증이나 범위 체크를 디스크립터로 구현하여 여러 속성에 재사용
- 지연 평가나 캐싱을 프로퍼티로 구현하여 성능 최적화

---
