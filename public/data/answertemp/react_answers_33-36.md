# React 답변 33-36

## 질문 33: Render Props 패턴이란 무엇인가요?

**정의:**
Render Props는 함수를 prop으로 전달하여 컴포넌트 간에 코드를 공유하는 패턴입니다. 함수가 렌더링할 내용을 결정하며, 컴포넌트 로직을 재사용하면서도 렌더링을 유연하게 제어할 수 있습니다.

**기본 개념:**
- prop으로 함수를 전달합니다.
- 컴포넌트가 이 함수를 호출하여 렌더링할 내용을 얻습니다.
- 데이터나 메서드를 함수의 인자로 전달합니다.
- 호출하는 쪽에서 UI를 결정합니다.
- render라는 이름을 사용하지만 다른 이름도 가능합니다.

**Render Props의 작동 방식:**
- 공통 로직을 가진 컴포넌트를 만듭니다.
- render prop을 통해 UI를 외부에서 주입받습니다.
- 로직 실행 결과를 render 함수에 전달합니다.
- render 함수가 반환한 JSX를 렌더링합니다.

**일반적인 사용 사례:**
- 마우스 위치 추적을 여러 방식으로 표시합니다.
- 데이터 페칭 로직을 재사용하면서 다른 UI를 보여줍니다.
- 애니메이션 상태를 공유하면서 다른 컴포넌트를 애니메이션합니다.
- 폼 상태를 관리하면서 다양한 폼 UI를 만듭니다.

**children as function:**
- children을 함수로 받는 것도 Render Props 패턴입니다.
- 더 자연스러운 JSX 문법을 제공합니다.
- render prop과 동일한 원리입니다.
- React Router나 React Context에서 많이 사용됩니다.

**Render Props의 장점:**
- 로직과 UI를 명확히 분리합니다.
- 컴포넌트 재사용성이 높아집니다.
- HOC의 래퍼 지옥 문제를 해결합니다.
- 유연성이 뛰어납니다. 다양한 UI를 적용할 수 있습니다.
- props 이름 충돌이 없습니다.

**Render Props의 단점:**
- 콜백 지옥처럼 중첩이 깊어질 수 있습니다.
- 코드가 장황해질 수 있습니다.
- 성능 최적화가 어려울 수 있습니다. 매번 새 함수가 생성됩니다.
- PureComponent와 함께 사용 시 주의가 필요합니다.

**Hooks와의 비교:**
- Hooks가 등장하면서 Render Props 사용이 줄었습니다.
- Custom Hook이 더 간단하고 깔끔합니다.
- Render Props는 JSX 중첩을 만듭니다.
- Hooks는 평평한 구조를 유지합니다.
- 새 코드는 대부분 Hooks를 사용합니다.

**여전히 유용한 경우:**
- UI를 외부에서 주입받아야 할 때입니다.
- 라이브러리에서 유연한 API를 제공할 때입니다.
- React Router처럼 조건부 렌더링이 필요할 때입니다.
- 레거시 코드를 유지보수할 때입니다.

**실무 활용:**
- 데이터 페칭 컴포넌트를 만들어 다양한 UI에 적용합니다.
- 가상화 라이브러리에서 아이템 렌더링을 위임받습니다.
- React Router의 Route 컴포넌트를 사용합니다.
- 기존 Render Props를 점진적으로 Hooks로 마이그레이션합니다.
- 상황에 맞는 패턴을 선택합니다.

---

## 질문 34: Compound Components 패턴이란 무엇인가요?

**정의:**
Compound Components는 여러 컴포넌트가 함께 동작하여 하나의 기능을 완성하는 패턴입니다. 내부 상태를 공유하면서도 유연한 API를 제공하며, HTML의 select와 option 관계와 유사합니다.

**기본 개념:**
- 부모와 자식 컴포넌트가 암묵적으로 상태를 공유합니다.
- 각 컴포넌트는 독립적으로 사용됩니다.
- 조합하여 복잡한 UI를 만듭니다.
- 선언적이고 직관적인 API를 제공합니다.

**구현 방법:**
- Context API로 상태를 공유합니다.
- 부모가 Provider로 상태를 제공합니다.
- 자식들이 useContext로 상태에 접근합니다.
- 각 하위 컴포넌트를 부모의 속성으로 export 합니다.

**일반적인 예시:**
- 탭 컴포넌트: Tabs TabList Tab TabPanel로 구성됩니다.
- 드롭다운 메뉴: Menu MenuButton MenuList MenuItem으로 구성됩니다.
- 아코디언: Accordion AccordionItem AccordionHeader AccordionPanel로 구성됩니다.
- 모달: Modal ModalOverlay ModalContent ModalHeader ModalBody ModalFooter로 구성됩니다.

**Compound Components의 장점:**
- API가 직관적이고 유연합니다.
- 컴포넌트 구조를 자유롭게 조합할 수 있습니다.
- 관심사가 명확히 분리됩니다.
- props drilling이 필요 없습니다.
- 확장성이 뛰어납니다.

**Context를 활용한 구현:**
- 부모에서 createContext로 Context를 만듭니다.
- Provider로 상태와 핸들러를 제공합니다.
- 자식들이 useContext로 접근합니다.
- 자식은 부모 없이 사용할 수 없습니다.

**유연성과 제어:**
- 사용자가 컴포넌트 순서를 바꿀 수 있습니다.
- 필요한 부분만 사용할 수 있습니다.
- 커스텀 스타일링이 쉽습니다.
- 중간에 다른 요소를 추가할 수 있습니다.

**타입 안전성:**
- TypeScript로 타입을 명확히 정의합니다.
- Context의 타입을 정의합니다.
- 각 컴포넌트의 props 타입을 정의합니다.
- 잘못된 사용을 컴파일 타임에 잡습니다.

**주의사항:**
- 컴포넌트가 올바른 부모 안에서 사용되는지 확인합니다.
- Context가 없으면 에러를 던집니다.
- 문서화를 잘 해야 합니다.
- 너무 복잡하면 오히려 혼란스러울 수 있습니다.

**실무 활용:**
- UI 라이브러리에서 많이 사용합니다. Chakra UI Radix UI 등입니다.
- 재사용 가능한 컴포넌트를 만들 때 적용합니다.
- 복잡한 인터랙션을 추상화합니다.
- 디자인 시스템을 구축할 때 활용합니다.
- 사용자에게 유연한 API를 제공합니다.

---

## 질문 35: Portal은 무엇이고 언제 사용하나요?

**정의:**
Portal은 컴포넌트를 부모 DOM 계층 외부의 다른 DOM 노드에 렌더링하는 방법입니다. ReactDOM.createPortal을 사용하며, 논리적 트리 구조는 유지하면서 물리적 위치만 변경합니다.

**Portal의 필요성:**
- 모달이나 툴팁을 최상위에 렌더링해야 합니다.
- 부모의 overflow hidden이나 z-index에 영향받지 않아야 합니다.
- CSS 스타일링 문제를 해결합니다.
- 접근성을 올바르게 구현합니다.

**Portal 작동 방식:**
- ReactDOM.createPortal을 사용합니다.
- 첫 번째 인자는 렌더링할 JSX입니다.
- 두 번째 인자는 대상 DOM 노드입니다.
- 물리적으로는 다른 위치에 렌더링됩니다.
- 논리적으로는 React 트리에 그대로 있습니다.

**이벤트 버블링:**
- Portal에서 발생한 이벤트는 React 트리를 따라 버블링됩니다.
- 물리적 DOM 위치가 아닌 논리적 위치를 따릅니다.
- 부모 컴포넌트에서 이벤트를 캡처할 수 있습니다.
- 일반 컴포넌트처럼 동작합니다.

**Context와 Portal:**
- Portal 내부에서도 Context에 접근할 수 있습니다.
- React 트리 구조가 유지되기 때문입니다.
- Provider 범위 안에 있으면 사용 가능합니다.
- 물리적 위치는 상관없습니다.

**일반적인 사용 사례:**
- 모달 다이얼로그를 body 직속으로 렌더링합니다.
- 툴팁이나 팝오버를 최상위에 표시합니다.
- 드롭다운 메뉴를 올바른 위치에 표시합니다.
- 알림 토스트를 앱 최상위에 표시합니다.
- 전체 화면 오버레이를 만듭니다.

**구현 패턴:**
- HTML에 portal용 div를 미리 만듭니다.
- document.getElementById로 대상 노드를 찾습니다.
- createPortal로 렌더링합니다.
- 재사용 가능한 Portal 컴포넌트를 만듭니다.

**접근성 고려사항:**
- 포커스 관리를 올바르게 해야 합니다.
- 키보드 내비게이션이 작동해야 합니다.
- ARIA 속성을 적절히 사용합니다.
- 스크린 리더가 이해할 수 있게 합니다.

**주의사항:**
- 대상 DOM 노드가 존재하는지 확인합니다.
- 서버 사이드 렌더링에서는 조건부로 사용합니다.
- 메모리 누수를 방지하기 위해 정리합니다.
- 너무 남용하지 않습니다.

**실무 활용:**
- 모달 컴포넌트를 구현할 때 필수적입니다.
- UI 라이브러리의 오버레이 컴포넌트에 사용합니다.
- z-index 스택 문제를 해결합니다.
- 고정 위치 요소를 올바르게 배치합니다.
- React 18의 createRoot와 함께 사용합니다.

---

## 질문 36: Controlled Component와 Uncontrolled Component의 차이점은 무엇인가요?

**정의:**
Controlled Component는 React state로 폼 입력값을 제어하는 컴포넌트이고, Uncontrolled Component는 DOM이 직접 값을 관리하고 ref로 접근하는 컴포넌트입니다.

**Controlled Component 특징:**
- React state가 유일한 진실 공급원입니다.
- value prop으로 값을 설정합니다.
- onChange로 state를 업데이트합니다.
- 모든 변경이 React를 거칩니다.
- 실시간 유효성 검사가 가능합니다.

**Controlled Component 장점:**
- 값을 완전히 제어할 수 있습니다.
- 즉각적인 피드백을 제공합니다.
- 조건부 검증이 쉽습니다.
- 값을 포맷팅할 수 있습니다.
- 여러 입력을 동기화할 수 있습니다.

**Uncontrolled Component 특징:**
- DOM이 값을 관리합니다.
- ref로 필요할 때 값을 읽습니다.
- defaultValue로 초기값만 설정합니다.
- React state를 사용하지 않습니다.
- 기존 HTML 폼과 유사하게 동작합니다.

**Uncontrolled Component 장점:**
- 코드가 간단합니다.
- 성능상 이점이 있을 수 있습니다.
- 레거시 코드와 통합이 쉽습니다.
- 파일 입력은 항상 uncontrolled입니다.
- 빠르게 프로토타입을 만들 수 있습니다.

**언제 Controlled를 사용할까:**
- 실시간 유효성 검사가 필요할 때입니다.
- 입력값을 포맷팅해야 할 때입니다.
- 조건부로 입력을 활성화 비활성화할 때입니다.
- 여러 입력이 상호작용할 때입니다.
- 대부분의 경우 권장됩니다.

**언제 Uncontrolled를 사용할까:**
- 폼 제출 시에만 값이 필요할 때입니다.
- 기존 non-React 코드와 통합할 때입니다.
- 파일 입력을 다룰 때입니다.
- 매우 간단한 폼일 때입니다.
- 성능이 중요하고 실시간 검증이 불필요할 때입니다.

**파일 입력 처리:**
- 파일 입력은 항상 uncontrolled입니다.
- value를 프로그래밍 방식으로 설정할 수 없습니다.
- ref로 파일 객체에 접근합니다.
- onChange로 변경을 감지할 수는 있습니다.

**Controlled로 전환:**
- defaultValue 대신 value를 사용합니다.
- onChange 핸들러를 추가합니다.
- state로 값을 관리합니다.
- 점진적으로 마이그레이션할 수 있습니다.

**실무 활용:**
- 대부분의 폼은 Controlled로 구현합니다.
- React Hook Form 같은 라이브러리는 Uncontrolled를 활용합니다.
- 복잡한 폼은 Formik이나 React Hook Form을 사용합니다.
- 파일 업로드는 ref를 사용합니다.
- 프로젝트 요구사항에 맞게 선택합니다.

---
