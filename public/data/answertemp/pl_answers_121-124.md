## 질문 121: JIT(Just-In-Time) 컴파일러의 동작 원리를 설명해주세요.

**정의:**
JIT 컴파일러는 프로그램 실행 중에 바이트코드나 중간 표현을 기계어로 컴파일하는 기술입니다. 인터프리터의 유연성과 컴파일러의 성능을 결합하며, 런타임 정보를 활용하여 더 공격적인 최적화를 수행할 수 있습니다.

**특징/원리:**
- 런타임 컴파일: 프로그램 실행 중에 필요한 부분을 기계어로 변환
- 핫스팟 탐지: 자주 실행되는 코드(핫스팟)를 식별하여 우선 컴파일
- 적응적 최적화: 실행 프로파일을 기반으로 최적화 수준 조정
- 캐싱: 컴파일된 코드를 캐시하여 재사용

**동작 과정:**
- 초기 실행: 바이트코드를 인터프리터로 실행하며 프로파일링
- 핫스팟 탐지: 실행 빈도가 높은 메서드나 루프 식별
- 컴파일: 핫스팟을 기계어로 컴파일하여 코드 캐시에 저장
- 실행: 이후 호출은 컴파일된 기계어를 직접 실행
- 재최적화: 실행 패턴 변화 시 재컴파일하여 최적화 수정

**최적화 기법:**
- 인라이닝: 자주 호출되는 작은 메서드를 호출 지점에 삽입
- 루프 최적화: 루프 전개, 불변 코드 이동 등으로 루프 가속
- 타입 특화: 런타임 타입 정보로 다형성 코드를 단형성으로 변환
- 데드 코드 제거: 실제로 실행되지 않는 코드 제거
- 탈출 분석: 객체가 메서드 외부로 탈출하지 않으면 스택 할당

**티어드 컴파일:**
- C1 컴파일러: 빠르게 컴파일하여 초기 성능 향상 (클라이언트 컴파일러)
- C2 컴파일러: 느리지만 고도로 최적화 (서버 컴파일러)
- 계층적 전략: C1으로 먼저 컴파일 후 핫한 코드는 C2로 재컴파일

**장점:**
- 빠른 시작: 초기에는 인터프리터로 빠르게 시작
- 고성능: 핫스팟을 최적화하여 네이티브 코드에 근접한 성능
- 적응성: 실행 패턴에 따라 동적으로 최적화
- 플랫폼 독립: 중간 표현은 플랫폼 독립적이고 JIT가 타겟 기계어 생성

**단점:**
- 워밍업: 최적화 전까지 초기 성능이 낮을 수 있음
- 메모리: 컴파일된 코드 캐시와 프로파일 데이터 저장 필요
- 비결정적: 실행마다 최적화가 달라질 수 있음
- 복잡성: JIT 컴파일러 구현이 매우 복잡

**예시:**
- HotSpot JVM: Java의 표준 JIT 컴파일러
- V8: Chrome의 JavaScript 엔진
- .NET CLR: C#의 런타임 환경
- PyPy: Python의 JIT 구현

**실무 활용:**
- JVM 애플리케이션은 워밍업 후 네이티브 코드에 근접한 성능 달성
- 마이크로벤치마크 시 워밍업 시간을 고려하여 정확한 측정
- 서버 애플리케이션은 충분한 워밍업 후 안정적인 성능 유지

---

## 질문 122: 정적 타이핑과 동적 타이핑의 장단점은 무엇인가요?

**정의:**
정적 타이핑은 변수의 타입을 컴파일 타임에 결정하고 검사하는 방식이고, 동적 타이핑은 런타임에 결정하고 검사하는 방식입니다. 각각 안전성, 유연성, 개발 속도 등에서 장단점이 있어 언어 설계와 사용 사례에 영향을 미칩니다.

**특징/원리:**
- 정적: 변수 선언 시 타입 명시하고 컴파일 타임에 검사
- 동적: 타입 선언 없이 런타임에 값에 따라 타입 결정
- 타입 추론: 일부 정적 언어는 타입을 자동으로 추론
- 점진적 타이핑: 정적과 동적을 혼합하여 사용

**정적 타이핑:**
- 언어: Java, C, C++, Go, Rust, TypeScript
- 타입 검사: 컴파일 타임에 타입 오류 검출
- 명시적: 변수, 파라미터, 반환값의 타입을 명시
- IDE 지원: 자동완성, 리팩토링, 타입 정보 제공
- 최적화: 컴파일러가 타입 정보로 최적화 수행

**동적 타이핑:**
- 언어: Python, JavaScript, Ruby, PHP
- 타입 검사: 런타임에 실제 사용 시점에 타입 검사
- 유연성: 타입 선언 없이 자유롭게 변수 사용
- 빠른 프로토타이핑: 타입 고민 없이 빠르게 개발
- 덕 타이핑: 객체의 타입보다 제공하는 메서드가 중요

**정적 타이핑 장점:**
- 안전성: 타입 오류를 컴파일 타임에 조기 발견
- 성능: 타입 정보로 최적화하여 빠른 실행 속도
- 도구 지원: IDE의 강력한 자동완성과 리팩토링
- 문서화: 타입 자체가 코드의 계약을 문서화
- 대규모: 큰 프로젝트에서 타입 시스템이 안전망 역할

**정적 타이핑 단점:**
- 보일러플레이트: 타입 선언으로 코드가 길어짐
- 유연성 부족: 타입 제약으로 표현력 제한
- 학습 곡선: 타입 시스템 이해 필요
- 컴파일 시간: 타입 검사로 컴파일 시간 증가

**동적 타이핑 장점:**
- 간결성: 타입 선언 없이 코드가 짧고 간결
- 유연성: 타입에 구애받지 않고 자유로운 표현
- 빠른 개발: 프로토타이핑과 스크립팅에 적합
- 메타프로그래밍: 런타임에 동적으로 코드 생성 용이

**동적 타이핑 단점:**
- 런타임 에러: 타입 오류가 런타임에 발견되어 프로덕션 장애 가능
- 성능: 런타임 타입 검사로 오버헤드 발생
- 도구 지원: IDE의 자동완성이나 리팩토링 지원 제한적
- 대규모 프로젝트: 타입 관련 버그가 많아지고 추적 어려움

**하이브리드 접근:**
- TypeScript: JavaScript에 정적 타입 추가
- Python 타입 힌트: 점진적으로 타입 힌트 추가하여 정적 검사
- mypy, flow: 동적 언어에 정적 분석 도구 제공

**실무 활용:**
- 대규모 프로젝트나 팀 협업에는 정적 타이핑으로 안전성 확보
- 스크립트나 프로토타입은 동적 타이핑으로 빠르게 개발
- TypeScript로 JavaScript의 유연성과 정적 타입의 안전성 결합

---

## 질문 123: 강타입과 약타입 언어의 차이점은 무엇인가요?

**정의:**
강타입 언어는 타입 간 변환을 엄격히 제한하여 명시적 변환만 허용하고, 약타입 언어는 타입 간 자동 변환(암묵적 타입 변환)을 허용합니다. 정적/동적 타이핑과는 독립적인 개념으로 함께 조합될 수 있습니다.

**특징/원리:**
- 강타입: 타입이 엄격하게 구분되고 호환되지 않는 타입 간 연산 불가
- 약타입: 서로 다른 타입을 자동으로 변환하여 연산 수행
- 타입 강제: 컴파일러나 런타임이 타입을 자동 변환
- 명시성: 강타입은 개발자의 의도를 명확히 표현하도록 강제

**강타입 언어:**
- 예시: Python, Java, Go, Rust
- 엄격성: 타입 불일치 시 에러 발생
- 명시적 변환: 타입 변환을 명시적으로 수행해야 함
- 안전성: 의도하지 않은 타입 변환 방지
- 예측 가능: 타입 관련 동작이 명확하고 일관적

**약타입 언어:**
- 예시: JavaScript, PHP, Perl, C (일부)
- 암묵적 변환: 다른 타입 간 자동 변환(타입 강제)
- 유연성: 타입에 관대하여 코드 작성이 편리
- 위험성: 예상치 못한 타입 변환으로 버그 발생 가능
- 혼란: 타입 변환 규칙이 복잡하고 이해하기 어려울 수 있음

**JavaScript 예시:**
- 약타입: "5" + 3은 "53"으로 문자열 연결
- 타입 강제: "5" - 3은 2로 숫자 연산
- 비교: "5" == 5는 true (암묵적 변환 후 비교)
- 엄격 비교: "5" === 5는 false (타입까지 비교)

**Python 예시:**
- 강타입: "5" + 3은 TypeError 발생
- 명시적: int("5") + 3 또는 "5" + str(3)으로 명시적 변환 필요
- 예측 가능: 타입 불일치가 즉시 에러로 드러남

**정적/동적 vs 강/약:**
- 정적 강타입: Java, C++, Rust - 가장 안전
- 정적 약타입: C - 포인터 산술 등으로 약함
- 동적 강타입: Python, Ruby - 유연하지만 안전
- 동적 약타입: JavaScript, PHP - 가장 유연하지만 위험

**장단점:**
- 강타입 장점: 안전성, 예측 가능성, 조기 오류 발견
- 강타입 단점: 명시적 변환 필요로 코드가 길어짐
- 약타입 장점: 간결함, 유연성, 빠른 개발
- 약타입 단점: 예상 못한 버그, 디버깅 어려움

**실무 활용:**
- JavaScript는 일치 연산자(===)로 타입 강제 회피
- Python은 명시적 변환을 강제하여 의도를 명확히 표현
- 타입스크립트로 JavaScript의 약타입 문제 완화

---

## 질문 124: Call by Value와 Call by Reference의 차이점을 설명해주세요.

**정의:**
Call by Value는 함수 호출 시 인자의 값을 복사하여 전달하는 방식이고, Call by Reference는 인자의 참조(메모리 주소)를 전달하는 방식입니다. 각각 메모리 사용, 성능, 부수 효과 등에서 차이가 있습니다.

**특징/원리:**
- Call by Value: 값 복사로 함수 내부 수정이 외부에 영향 없음
- Call by Reference: 참조 전달로 함수 내부 수정이 외부에 반영됨
- 언어 지원: 언어마다 지원하는 방식이 다름
- 성능: 큰 데이터는 참조 전달이 효율적

**Call by Value:**
- 복사: 인자의 값이 복사되어 함수의 매개변수에 할당
- 독립성: 함수 내부에서 매개변수를 수정해도 원본 변수는 영향 없음
- 안전성: 함수가 외부 상태를 변경하지 못해 부수 효과 없음
- 메모리: 큰 데이터는 복사 비용이 클 수 있음
- 예시: C의 기본 방식, Java의 원시 타입

**Call by Reference:**
- 참조: 변수의 메모리 주소가 전달됨
- 공유: 함수 내부와 외부가 같은 메모리 공간을 가리킴
- 수정 가능: 함수에서 매개변수를 수정하면 원본도 변경됨
- 효율성: 큰 데이터도 주소만 전달하여 빠름
- 예시: C++의 참조(&), Python의 가변 객체

**언어별 동작:**
- C: 기본은 Call by Value, 포인터로 Call by Reference 시뮬레이션
- C++: 값과 참조(&) 모두 지원
- Java: 원시 타입은 Call by Value, 객체는 참조의 값 전달
- Python: 모든 것이 객체 참조 전달, 불변 객체는 값처럼 동작
- JavaScript: 원시값은 Call by Value, 객체는 참조의 값 전달

**Java의 특수성:**
- 원시 타입: int, double 등은 Call by Value로 복사
- 객체: 참조 자체는 Call by Value로 복사되지만 같은 객체를 가리킴
- 재할당: 매개변수를 다른 객체로 재할당해도 원본은 영향 없음
- 수정: 객체 내부 상태 수정은 원본에 반영됨

**Python의 특수성:**
- 불변 객체: int, str, tuple은 수정 불가하여 Call by Value처럼 동작
- 가변 객체: list, dict는 수정 가능하여 Call by Reference처럼 동작
- 재할당: 매개변수 재할당은 로컬 변수만 변경

**실무 활용:**
- 함수가 외부 상태를 변경하지 않게 하려면 불변 데이터나 복사본 전달
- 큰 객체를 효율적으로 전달하려면 참조 방식 활용
- 의도치 않은 수정을 방지하려면 불변 객체 사용하거나 방어적 복사

---
