# JavaScript 답변 37-40

## 질문 37: Array.from()과 스프레드 연산자의 차이점은 무엇인가요?

**정의:**
Array.from과 스프레드 연산자는 모두 이터러블 객체를 배열로 변환하는 방법입니다. 하지만 기능의 범위와 활용도에서 차이가 있습니다.

**Array.from의 특징:**
- 유사 배열 객체와 이터러블을 배열로 변환합니다. 더 넓은 범위를 지원합니다.
- 두 번째 인수로 map 함수를 받을 수 있습니다. 변환과 매핑을 동시에 수행합니다.
- 세 번째 인수로 this 값을 지정할 수 있습니다.
- 배열의 길이를 지정하여 빈 배열을 만들 수도 있습니다.

**스프레드 연산자의 특징:**
- 이터러블 객체만 배열로 변환합니다. 유사 배열은 직접 변환할 수 없습니다.
- 문법이 간결합니다. 더 직관적이고 읽기 쉽습니다.
- 배열 리터럴 안에서 사용합니다.
- 여러 배열을 합칠 때 편리합니다.

**유사 배열 객체 처리:**
- Array.from: 유사 배열을 바로 변환할 수 있습니다. length 속성만 있으면 됩니다.
- 스프레드: 이터러블이 아닌 유사 배열은 변환할 수 없습니다. Symbol.iterator가 필요합니다.
- NodeList나 arguments는 둘 다 가능합니다. 이터러블이기 때문입니다.

**매핑 기능:**
- Array.from은 변환하면서 동시에 매핑할 수 있습니다. 한 번의 순회로 처리됩니다.
- 스프레드는 배열로 만든 후 map을 체이닝해야 합니다. 두 번 순회합니다.
- 성능상 Array.from이 약간 유리할 수 있습니다.

**빈 배열 생성:**
- Array.from으로 특정 길이의 빈 배열을 만들 수 있습니다.
- 각 요소를 초기화하면서 생성할 수 있습니다.
- 스프레드로는 불가능합니다.

**실무 활용:**
- DOM NodeList를 배열로 변환하여 배열 메서드를 사용합니다.
- 문자열을 문자 배열로 변환합니다. 둘 다 가능하지만 스프레드가 간결합니다.
- Set이나 Map을 배열로 변환합니다.
- 범위 배열을 생성할 때 Array.from을 활용합니다.
- 간단한 변환은 스프레드를, 복잡한 변환은 Array.from을 사용합니다.

---

## 질문 38: 배열의 불변성을 유지하면서 요소를 추가/삭제하는 방법은 무엇인가요?

**정의:**
불변성은 원본 데이터를 변경하지 않고 새로운 데이터를 생성하는 것입니다. React 등 현대 프레임워크에서 중요한 개념이며, 예측 가능한 상태 관리를 가능하게 합니다.

**요소 추가 방법:**
- 스프레드 연산자: 기존 배열을 펼치고 새 요소를 추가합니다. 앞이나 뒤, 중간 어디든 가능합니다.
- concat: 배열을 합치는 메서드로 새 배열을 반환합니다. 원본을 변경하지 않습니다.
- slice와 조합: 원하는 위치에 요소를 삽입할 수 있습니다.
- push는 원본을 변경하므로 사용하면 안 됩니다.

**요소 삭제 방법:**
- filter: 특정 조건의 요소를 제외한 새 배열을 만듭니다. 가장 직관적입니다.
- slice: 특정 인덱스의 요소를 제외하고 복사합니다. 인덱스를 알 때 사용합니다.
- 스프레드와 slice 조합: 중간 요소를 제거할 때 사용합니다.
- splice는 원본을 변경하므로 사용하면 안 됩니다.

**요소 수정 방법:**
- map: 특정 조건의 요소만 수정한 새 배열을 만듭니다.
- 스프레드와 slice 조합: 특정 인덱스의 요소를 교체합니다.
- Object.assign이나 스프레드로 객체 요소를 업데이트합니다.

**왜 불변성이 중요한가:**
- React에서 상태 변화를 감지합니다. 참조가 바뀌어야 리렌더링이 발생합니다.
- 이전 상태를 보존할 수 있습니다. undo/redo 기능 구현이 쉽습니다.
- 예측 가능한 코드가 됩니다. 부수 효과가 없어 디버깅이 쉽습니다.
- 동시성 문제를 피할 수 있습니다. 공유 상태를 안전하게 관리합니다.

**성능 고려사항:**
- 작은 배열에서는 문제없습니다. 성능 차이가 미미합니다.
- 큰 배열을 자주 업데이트하면 메모리와 성능에 영향을 줄 수 있습니다.
- 이때는 Immer 같은 라이브러리를 고려합니다. 불변성을 유지하면서 효율적입니다.
- 구조적 공유로 최적화할 수 있습니다.

**실무 패턴:**
- Redux나 Zustand에서 상태 업데이트 시 필수적입니다.
- React의 useState로 배열 상태를 업데이트할 때 항상 새 배열을 만듭니다.
- 중첩 배열이나 객체는 깊은 복사가 필요할 수 있습니다.
- TypeScript의 readonly 타입으로 실수를 방지합니다.
- ESLint 규칙으로 가변 메서드 사용을 경고할 수 있습니다.

---

## 질문 39: 디바운싱(Debouncing)과 스로틀링(Throttling)의 차이점과 구현 방법은 무엇인가요?

**정의:**
디바운싱과 스로틀링은 이벤트 핸들러의 실행 빈도를 제한하는 기법입니다. 성능 최적화와 불필요한 연산 방지에 사용됩니다.

**디바운싱의 특징:**
- 연속된 이벤트 중 마지막 이벤트만 처리합니다. 이벤트가 멈춘 후 실행됩니다.
- 일정 시간 동안 추가 이벤트가 없어야 실행됩니다.
- 타이머를 계속 초기화합니다. 이벤트가 발생할 때마다 지연 시간을 리셋합니다.
- 검색 자동완성에 적합합니다. 입력이 끝난 후에만 검색합니다.

**스로틀링의 특징:**
- 일정 시간 간격으로 이벤트를 처리합니다. 주기적으로 실행됩니다.
- 시간 간격 내에는 한 번만 실행됩니다.
- 첫 번째 이벤트는 즉시 실행될 수 있습니다.
- 스크롤 이벤트 처리에 적합합니다. 일정한 간격으로 체크합니다.

**동작 방식 비교:**
- 디바운싱: 입력이 끝날 때까지 기다립니다. 마지막 호출만 실행합니다.
- 스로틀링: 일정 간격마다 실행합니다. 중간 호출들도 주기적으로 처리합니다.
- 디바운싱은 이벤트가 멈춰야 하고, 스로틀링은 멈추지 않아도 됩니다.

**디바운싱 구현:**
- 타이머 변수를 클로저로 유지합니다.
- 이벤트 발생 시 기존 타이머를 취소합니다.
- 새로운 타이머를 설정합니다.
- 지연 시간 후 함수를 실행합니다.

**스로틀링 구현:**
- 마지막 실행 시간을 기록합니다.
- 현재 시간과 비교하여 간격을 확인합니다.
- 간격이 충분하면 함수를 실행합니다.
- 또는 타이머로 주기적으로 실행합니다.

**사용 사례:**
- 디바운싱: 검색 입력, 폼 유효성 검사, 윈도우 리사이즈, 자동 저장
- 스로틀링: 무한 스크롤, 스크롤 이벤트, 마우스 이동 추적, 버튼 연타 방지

**라이브러리 활용:**
- Lodash의 debounce와 throttle 함수를 사용할 수 있습니다.
- 옵션으로 leading, trailing 실행을 제어합니다.
- 직접 구현보다 안정적이고 기능이 풍부합니다.

**실무 활용:**
- 검색창에서 디바운싱으로 API 호출을 줄입니다. 타이핑할 때마다 호출하지 않습니다.
- 스크롤 이벤트에서 스로틀링으로 성능을 개선합니다.
- 버튼 클릭에서 디바운싱으로 중복 제출을 방지합니다.
- React에서 useCallback과 함께 사용하여 최적화합니다.
- 적절한 지연 시간 설정이 중요합니다. 너무 짧으면 효과가 없고 너무 길면 사용자 경험이 나빠집니다.

---

## 질문 40: 메모이제이션(Memoization)이란 무엇이고 언제 사용하나요?

**정의:**
메모이제이션은 함수의 결과를 캐싱하여 동일한 입력에 대해 재계산하지 않는 최적화 기법입니다. 비용이 큰 연산을 반복할 때 성능을 크게 향상시킵니다.

**메모이제이션의 원리:**
- 함수 호출 결과를 저장합니다. 키-값 쌍으로 캐시합니다.
- 동일한 인수로 호출되면 캐시된 결과를 반환합니다. 재계산하지 않습니다.
- 처음 호출될 때만 실제 계산을 수행합니다.
- 클로저를 사용하여 캐시를 보관합니다.

**메모이제이션이 유용한 경우:**
- 계산 비용이 큰 순수 함수에 사용합니다. 항상 같은 입력에 같은 출력을 보장해야 합니다.
- 같은 인수로 자주 호출되는 함수에 적합합니다.
- 재귀 함수의 성능을 개선합니다. 피보나치 수열 같은 중복 계산을 제거합니다.
- API 응답 캐싱에도 활용할 수 있습니다.

**구현 방법:**
- 객체나 Map으로 캐시를 만듭니다. 인수를 키로 결과를 저장합니다.
- 함수 호출 시 캐시를 먼저 확인합니다.
- 캐시에 있으면 바로 반환하고, 없으면 계산 후 저장합니다.
- 고차 함수로 메모이제이션 래퍼를 만들 수 있습니다.

**주의사항:**
- 순수 함수에만 사용해야 합니다. 부수 효과가 있으면 안 됩니다.
- 메모리를 사용합니다. 캐시가 무한정 커질 수 있습니다.
- 복잡한 객체를 인수로 받으면 키 생성이 어렵습니다.
- 캐시 무효화 전략이 필요할 수 있습니다. LRU 같은 정책을 고려합니다.

**React에서의 메모이제이션:**
- useMemo 훅으로 값을 메모이제이션합니다. 의존성이 변경될 때만 재계산합니다.
- useCallback으로 함수를 메모이제이션합니다. 참조 동일성을 유지합니다.
- React.memo로 컴포넌트를 메모이제이션합니다. props가 같으면 리렌더링하지 않습니다.

**라이브러리 활용:**
- Lodash의 memoize 함수를 사용할 수 있습니다.
- Reselect는 Redux 셀렉터를 메모이제이션합니다.
- React Query는 서버 데이터를 자동으로 캐싱합니다.

**실무 활용:**
- 복잡한 계산이 포함된 컴포넌트에서 useMemo를 사용합니다.
- 자주 호출되는 유틸리티 함수를 메모이제이션합니다.
- 동적 프로그래밍 알고리즘을 구현할 때 활용합니다.
- 과도한 사용은 오히려 성능을 저하시킬 수 있습니다. 프로파일링 후 선택적으로 적용합니다.
- 간단한 계산은 메모이제이션 오버헤드가 더 클 수 있습니다.

---
