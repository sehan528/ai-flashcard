# OS 답변 33-36

## 33. preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?

**선점형(Preemptive) 스케줄링**

**정의**
- 운영체제가 실행 중인 프로세스로부터 강제로 CPU를 빼앗을 수 있는 방식입니다
- 우선순위가 높은 프로세스가 도착하면 현재 프로세스를 중단시킵니다
- 타이머 인터럽트를 사용하여 시간 할당량을 강제합니다

**가능한 상태 전이**
- Running → Ready: 선점 발생 (타이머 인터럽트, 높은 우선순위 프로세스 도착)
- Running → Waiting: I/O 요청
- Running → Terminated: 종료
- Ready → Running: 스케줄러에 의한 선택
- Waiting → Ready: I/O 완료

**모든 상태 존재 가능**
- New, Ready, Running, Waiting, Terminated 모두 존재합니다
- Running에서 Ready로의 전이가 자주 발생합니다
- 이것이 선점형의 핵심 특징입니다

**비선점형(Non-preemptive) 스케줄링**

**정의**
- 프로세스가 자발적으로 CPU를 반납할 때까지 실행을 보장합니다
- 강제로 CPU를 빼앗을 수 없습니다
- 프로세스가 종료되거나 I/O를 요청할 때만 전환됩니다

**가능한 상태 전이**
- Running → Waiting: I/O 요청 (자발적)
- Running → Terminated: 종료 (자발적)
- Ready → Running: 스케줄러에 의한 선택
- Waiting → Ready: I/O 완료

**존재할 수 없는 전이**
- Running → Ready: 이 전이가 발생하지 않습니다
- 선점이 불가능하므로 실행 중인 프로세스를 강제로 Ready 상태로 만들 수 없습니다

**존재 가능한 상태**

**비선점형에서도 모든 상태는 존재합니다**
- New: 프로세스 생성 시
- Ready: CPU 할당 대기 중
- Running: CPU 실행 중
- Waiting: I/O 대기 중
- Terminated: 종료 상태

**중요한 차이점**
- 상태 자체는 동일하게 존재합니다
- 상태 간 전이 방식이 다릅니다
- Running → Ready 전이가 비선점형에서는 발생하지 않습니다

**상태 전이 비교**

**선점형**
```
Ready ←─── Running ──→ Waiting
  ↑    선점    ↓           ↓
  └─────────────┘     I/O 완료
```
- Running → Ready 전이 존재 (선점)
- 타이머, 우선순위로 인한 강제 전환

**비선점형**
```
Ready      Running ──→ Waiting
  ↑          ↓           ↓
  └──────────┴────── I/O 완료
           종료
```
- Running → Ready 전이 없음
- 자발적인 전환만 가능

**Ready 상태의 의미 차이**

**선점형**
- CPU를 기다리는 프로세스
- 선점당한 프로세스도 포함
- Ready Queue가 동적으로 변함

**비선점형**
- CPU를 기다리는 프로세스
- 새로 생성되거나 I/O 완료된 프로세스만
- Running에서 직접 오지 않음

**실무적 의미**

**비선점형의 문제**
- 하나의 프로세스가 CPU를 독점할 수 있습니다
- 무한 루프에 빠지면 시스템 전체가 멈출 수 있습니다
- 응답 시간이 예측 불가능합니다
- 대화형 시스템에 부적합합니다

**선점형의 장점**
- 공정한 CPU 시간 배분
- 시스템 응답성 향상
- 높은 우선순위 작업 보장
- 현대 OS의 표준 방식

**예외 상황**

**협력적 멀티태스킹(Cooperative Multitasking)**
- 비선점형 스케줄링의 한 형태
- 프로세스가 명시적으로 yield() 호출
- 초기 Windows(3.x), 초기 Mac OS 사용
- 현대 OS에서는 거의 사용 안 함

**하이브리드 접근**
- 일부 시스템은 혼합 방식 사용
- 일반 프로세스: 선점형
- 실시간 프로세스: 비선점형(완료까지 실행 보장)
- 커널 내부: 일부 크리티컬 섹션은 비선점

**알고리즘별 특성**

**비선점형 알고리즘**
- FCFS (First-Come, First-Served)
- SJF (Shortest Job First) - 비선점형 버전
- 한 번 실행하면 완료까지 계속

**선점형 알고리즘**
- Round Robin
- SRTF (Shortest Remaining Time First)
- Priority Scheduling (선점형)
- Multi-level Feedback Queue

**상태별 카운트**

**선점형 시스템**
- Ready 상태 프로세스: 많을 수 있음
- Running → Ready 전환이 빈번
- 동적으로 변화

**비선점형 시스템**
- Ready 상태 프로세스: 상대적으로 적음
- 새 프로세스나 I/O 완료만 Ready로 진입
- 덜 동적

**실무 활용**
현대의 모든 범용 운영체제는 선점형 스케줄링을 사용합니다. 하지만 일부 특수 목적 임베디드 시스템이나 실시간 시스템에서는 예측 가능성을 위해 비선점형 또는 제한적 선점을 사용하기도 합니다.

---

## 34. Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?

**상태 변화**

**Suspended (보류) 상태로 전환**

**Ready → Suspended Ready**
- Ready 상태에서 메모리 부족이 발생하면 일부 프로세스를 스왑 아웃합니다
- 중기 스케줄러가 이 결정을 내립니다
- 디스크의 스왑 공간으로 프로세스 이미지가 이동합니다
- 메모리에서 제거되지만 Ready 상태를 유지합니다

**Waiting → Suspended Waiting**
- I/O 대기 중인 프로세스도 스왑 아웃될 수 있습니다
- 어차피 CPU를 사용하지 않으므로 우선 대상이 됩니다
- I/O 완료를 기다리면서 디스크에 저장됩니다

**Suspended 상태의 특징**

**메모리 부재**
- 프로세스가 메모리에 존재하지 않습니다
- 디스크의 스왑 영역에 저장되어 있습니다
- 실행하려면 먼저 메모리로 복귀해야 합니다

**CPU 할당 불가**
- Suspended Ready 상태는 CPU를 할당받을 수 없습니다
- 먼저 스왑 인되어 Ready 상태가 되어야 합니다
- Suspended Waiting은 I/O 완료를 기다립니다

**중기 스케줄러의 역할**

**스왑 아웃 대상 선택**
- 오랫동안 대기한 프로세스
- 우선순위가 낮은 프로세스
- I/O 대기 중인 프로세스 (Waiting 상태)
- 사용자 프로세스 (시스템 프로세스 보호)
- 메모리 사용량이 큰 프로세스

**스왑 인 시점**
- 메모리 공간이 확보되면
- 프로세스의 우선순위가 높아지면
- I/O가 완료되고 실행이 필요하면

**상태 전이**

**메모리 부족 시**
```
Ready → Suspended Ready
Waiting → Suspended Waiting
```

**메모리 회복 시**
```
Suspended Ready → Ready
Suspended Waiting → Waiting
```

**I/O 완료 시 (Suspended 상태에서)**
```
Suspended Waiting → Suspended Ready
```

**전체 상태 다이어그램**

```
      [Ready] ←─────── [Running] ──→ [Waiting]
         ↓                              ↓
      스왑 아웃                     스왑 아웃
         ↓                              ↓
   [Suspended                    [Suspended
      Ready] ←─────I/O 완료──────  Waiting]
         ↑
      스왑 인
```

**현대 운영체제의 처리**

**페이징 시스템**
- 프로세스 전체를 스왑하지 않고 페이지 단위로 처리합니다
- 필요한 페이지만 메모리에 유지합니다
- 사용하지 않는 페이지를 스왑 아웃합니다
- 프로세스는 여전히 Ready나 Running 상태입니다

**OOM Killer (Out Of Memory Killer)**
- 리눅스에서 메모리가 극도로 부족할 때 동작합니다
- 프로세스를 종료시켜 메모리를 확보합니다
- 상태 변화: Running/Ready → Terminated
- 점수 기반으로 희생 프로세스 선택
  - 메모리 사용량이 많은 프로세스
  - 중요도가 낮은 프로세스
  - nice 값, oom_score 등 고려

**메모리 압축**
- macOS, iOS 등에서 사용
- 메모리를 압축하여 공간 확보
- 스왑 아웃보다 빠름
- 프로세스 상태는 변하지 않음

**Android의 Low Memory Killer**
- 백그라운드 앱을 종료합니다
- 상태: Ready/Waiting → Terminated
- 우선순위 기반 선택
  - Foreground 앱: 보호
  - Visible 앱: 낮은 우선순위
  - Background 앱: 높은 희생 우선순위

**메모리 부족의 영향**

**성능 저하**
- 스와핑으로 인한 디스크 I/O 증가
- 페이지 폴트 빈번 발생
- 시스템 전체 응답 속도 감소
- 스래싱(Thrashing) 발생 가능

**프로세스 관점**
- 실행이 지연됩니다
- 스왑 아웃되면 CPU를 받을 수 없습니다
- 스왑 인 시 오버헤드 발생
- 최악의 경우 종료될 수 있습니다

**예방 및 완화**

**메모리 관리**
- 충분한 물리 메모리 확보
- 스왑 공간 적절히 설정
- 메모리 누수 방지
- 불필요한 프로세스 종료

**리소스 제한**
- cgroup으로 메모리 사용 제한
- ulimit으로 프로세스별 제한
- 컨테이너별 메모리 쿼터 설정

**모니터링**
- free, vmstat으로 메모리 상태 확인
- top, htop으로 프로세스별 메모리 사용량 파악
- /proc/meminfo에서 상세 정보 확인

**스와핑 vs 페이징**

**스와핑 (Swapping)**
- 프로세스 전체를 스왑 아웃
- Suspended 상태로 전환
- 오버헤드가 큼
- 과거 시스템의 주 방식

**페이징 (Paging)**
- 페이지 단위로 스왑 아웃
- 프로세스 상태는 유지
- 더 세밀한 제어
- 현대 시스템의 주 방식

**실무 활용**
서버 모니터링 시 스왑 사용량이 증가하면 메모리 부족 신호입니다. 클라우드 환경에서는 메모리 부족 시 스케일 업 또는 불필요한 프로세스 종료를 고려합니다. 컨테이너는 메모리 제한을 초과하면 OOM Killed됩니다.

---

## 35. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?

**컨텍스트 스위칭 정의**
CPU가 현재 실행 중인 프로세스(또는 스레드)를 중단하고 다른 프로세스로 전환하는 과정입니다.

**컨텍스트 스위칭 과정**

**1단계: 현재 프로세스 상태 저장**

**레지스터 저장**
- 프로그램 카운터(PC): 다음 실행할 명령어 주소
- 스택 포인터(SP): 현재 스택 위치
- 범용 레지스터: 연산에 사용된 값들
- 상태 레지스터: CPU 플래그 (Zero, Carry, Overflow 등)
- 부동소수점 레지스터: FPU 상태

**PCB에 저장**
- 모든 레지스터 값을 PCB에 복사합니다
- 프로세스 상태를 Running에서 Ready로 변경합니다
- 실행 시간 등 통계 정보를 업데이트합니다

**2단계: 스케줄러 실행**

**다음 프로세스 선택**
- Ready Queue에서 실행할 프로세스를 선택합니다
- 스케줄링 알고리즘을 적용합니다
- 우선순위, 시간 할당량 등을 고려합니다

**3단계: 새 프로세스의 컨텍스트 로드**

**PCB에서 복원**
- 선택된 프로세스의 PCB를 읽습니다
- 저장된 레지스터 값들을 CPU 레지스터로 복사합니다
- 프로그램 카운터를 복원하여 실행 위치를 설정합니다

**프로세스 상태 변경**
- Ready에서 Running으로 변경합니다

**4단계: 메모리 관리 전환 (프로세스 간 전환 시)**

**주소 공간 전환**
- 페이지 테이블 베이스 레지스터(PTBR)를 변경합니다
- 새 프로세스의 페이지 테이블을 가리키도록 설정합니다
- 가상 메모리 맵을 전환합니다

**TLB 플러시**
- Translation Lookaside Buffer를 비웁니다
- 이전 프로세스의 주소 변환 정보를 제거합니다
- 새 프로세스의 주소 변환 시 TLB 미스 발생
- 시간이 지나면서 TLB가 다시 채워집니다

**캐시 영향**
- L1, L2 캐시의 많은 부분이 무효화될 수 있습니다
- 이전 프로세스의 데이터가 캐시에 남아있습니다
- 새 프로세스 실행 시 캐시 미스 증가
- 워밍업 시간이 필요합니다

**5단계: 실행 재개**
- 복원된 프로그램 카운터 위치부터 실행을 시작합니다
- 새 프로세스는 중단된 지점부터 계속 실행됩니다

**하드웨어 지원**

**특수 명령어**
- 일부 아키텍처는 컨텍스트 스위칭을 위한 하드웨어 명령어를 제공합니다
- 레지스터 세트를 한 번에 저장/복원합니다
- 성능을 향상시킵니다

**다중 레지스터 세트**
- 일부 CPU는 여러 세트의 레지스터를 가집니다
- 전환 시 레지스터 세트만 교체하면 됩니다
- 저장/복원 시간을 줄입니다

**컨텍스트 스위칭 오버헤드**

**직접 비용**
- 레지스터 저장/복원: 수십 ~ 수백 사이클
- 메모리 접근 (PCB 읽기/쓰기): 추가 사이클
- 페이지 테이블 전환: 메모리 접근 시간

**간접 비용**
- TLB 플러시: 이후 주소 변환 시 페이지 테이블 접근 필요
- 캐시 오염: 캐시 미스율 증가
- 파이프라인 플러시: CPU 파이프라인 초기화
- 브랜치 예측 실패: 예측 정보 손실

**측정값**
- 하드웨어만: 수 마이크로초
- TLB/캐시 미스 포함: 수십 마이크로초
- 빈번한 스위칭 시 성능 크게 저하

**언제 발생하는가?**

**타이머 인터럽트**
- 시간 할당량 만료 시
- 주기적으로 발생(보통 1-10ms)
- Round Robin 스케줄링에서 필수

**I/O 요청**
- 프로세스가 I/O를 기다릴 때
- Waiting 상태로 전환
- CPU 유휴 방지

**우선순위 선점**
- 높은 우선순위 프로세스 도착 시
- 인터럽트 서비스 루틴 완료 후

**동기화 대기**
- Mutex, Semaphore 대기 시
- Sleep, Wait 호출 시

**최적화 기법**

**스위칭 빈도 조절**
- 시간 할당량을 적절히 설정
- 너무 짧으면: 오버헤드 증가
- 너무 길면: 응답 시간 저하

**친화성 (Affinity)**
- 프로세스를 특정 CPU 코어에 고정
- 캐시 효율성 향상
- TLB 히트율 증가

**동일 프로세스 우선**
- 캐시가 따뜻한 상태 활용
- 스위칭 비용 감소

**실무 활용**
고성능 시스템에서는 컨텍스트 스위칭 횟수를 모니터링합니다. vmstat의 cs(context switch) 컬럼이나 perf로 측정합니다. 과도한 스위칭은 시스템 병목의 원인이 됩니다.

---

## 36. 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?

**프로세스 간 컨텍스트 스위칭**

**저장/복원 대상**
- 모든 CPU 레지스터
- 프로그램 카운터(PC)
- 스택 포인터(SP)
- 페이지 테이블 베이스 레지스터(PTBR)
- 프로세스 상태 정보
- 파일 디스크립터 (필요시)

**메모리 관리 전환**
- 페이지 테이블을 완전히 교체합니다
- 가상 주소 공간이 완전히 바뀝니다
- PTBR을 새 프로세스의 페이지 테이블로 설정합니다

**TLB (Translation Lookaside Buffer)**
- TLB를 완전히 플러시해야 합니다
- 이전 프로세스의 주소 변환 정보가 모두 무효화됩니다
- 새 프로세스 실행 시 TLB 미스가 빈번합니다
- TLB를 다시 채우는 데 시간이 걸립니다

**캐시**
- L1, L2 데이터 캐시의 많은 부분이 쓸모없게 됩니다
- 새 프로세스는 다른 주소 공간의 데이터를 사용합니다
- 캐시 미스율이 크게 증가합니다
- Cold Cache 상태에서 시작합니다

**비용**
- 매우 높은 오버헤드
- 수십 마이크로초 소요
- TLB/캐시 미스로 인한 추가 비용 큽니다

**스레드 간 컨텍스트 스위칭**

**같은 프로세스 내 스레드**

**저장/복원 대상**
- CPU 레지스터 (PC, SP, 범용 레지스터)
- 스택 포인터만 변경 (각 스레드가 독립 스택)
- TLS (Thread Local Storage) 포인터

**메모리 관리 유지**
- 페이지 테이블을 그대로 유지합니다
- 가상 주소 공간이 동일합니다
- PTBR 변경이 필요 없습니다
- 코드, 데이터, 힙 영역을 공유합니다

**TLB**
- TLB를 플러시하지 않습니다
- 주소 변환 정보가 그대로 유효합니다
- TLB 히트율이 높게 유지됩니다
- 성능 이점이 큽니다

**캐시**
- 캐시의 많은 부분이 여전히 유효합니다
- 공유 데이터는 캐시에 그대로 있습니다
- Warm Cache 상태 유지
- 캐시 미스율이 낮습니다

**비용**
- 낮은 오버헤드
- 수 마이크로초 소요
- 프로세스 전환보다 10-100배 빠릅니다

**다른 프로세스의 스레드**
- 프로세스 간 전환과 동일합니다
- 모든 비용이 발생합니다
- 메모리 맵, TLB, 캐시 모두 전환 필요

**비교표**

| 항목 | 프로세스 전환 | 스레드 전환 (같은 프로세스) |
|------|--------------|---------------------------|
| 레지스터 저장/복원 | ✓ | ✓ |
| 페이지 테이블 전환 | ✓ | ✗ |
| TLB 플러시 | ✓ | ✗ |
| 캐시 무효화 | 대부분 | 일부 |
| 메모리 맵 전환 | ✓ | ✗ |
| 오버헤드 | 높음 | 낮음 |
| 속도 | 느림 | 빠름 |

**실측 예시**

**프로세스 컨텍스트 스위칭**
- 직접 비용: 5-10 마이크로초
- 간접 비용: 20-100 마이크로초
- 총 비용: 25-110 마이크로초

**스레드 컨텍스트 스위칭**
- 직접 비용: 0.5-2 마이크로초
- 간접 비용: 1-5 마이크로초
- 총 비용: 1.5-7 마이크로초

**속도 차이: 약 10-20배**

**장단점**

**프로세스**
- 장점: 완전한 격리, 안전성 높음
- 단점: 컨텍스트 스위칭 비용 높음
- 사용처: 독립적인 작업, 안정성 중요

**스레드**
- 장점: 빠른 컨텍스트 스위칭, 효율적 자원 공유
- 단점: 동기화 필요, 버그 시 전체 영향
- 사용처: 협력적인 작업, 성능 중요

**멀티코어 환경**

**병렬 실행**
- 여러 스레드가 동시에 다른 코어에서 실행 가능
- 컨텍스트 스위칭 없이 병렬성 확보
- 스레드가 프로세스보다 유리

**캐시 코히어런시**
- 스레드는 공유 데이터를 사용하여 캐시 일관성 프로토콜 작동
- 프로세스는 독립적이어서 간섭 적음
- 각각 장단점 존재

**실무 고려사항**

**작업 특성에 따른 선택**
- I/O 위주: 스레드 (빈번한 대기/재개)
- CPU 위주: 프로세스 또는 스레드
- 격리 필요: 프로세스
- 빠른 통신: 스레드

**하이브리드 모델**
- 여러 프로세스, 각 프로세스에 여러 스레드
- 프로세스로 큰 단위 격리
- 스레드로 세밀한 병렬성
- 웹 서버, 데이터베이스 등에서 사용

**최적화**
- 스레드 풀 사용으로 생성/전환 최소화
- CPU 친화성 설정으로 캐시 효율 향상
- 락 프리 자료구조로 동기화 비용 감소

**실무 활용**
고성능 서버는 멀티스레드 모델을 선호하여 컨텍스트 스위칭 비용을 줄입니다. 하지만 Chrome 브라우저는 탭별 프로세스를 사용하여 안정성을 확보합니다(격리 우선).
