# JavaScript 답변 09-12

## 질문 9: 일반 함수와 화살표 함수의 차이점은 무엇인가요?

**정의:**
일반 함수는 function 키워드로 선언하는 전통적인 함수이고, 화살표 함수는 ES6에서 도입된 간결한 함수 표현식입니다. 두 함수는 문법뿐만 아니라 this 바인딩, arguments 객체, 생성자 사용 등에서 근본적인 차이가 있습니다.

**this 바인딩의 차이:**
- 일반 함수: 호출 방식에 따라 this가 동적으로 결정됩니다. 메서드로 호출되면 호출한 객체가 this가 됩니다. 일반 함수로 호출되면 전역 객체 또는 undefined가 됩니다.
- 화살표 함수: 자신만의 this를 가지지 않습니다. 상위 스코프의 this를 렉시컬하게 캡처합니다. 선언될 때의 this가 영구적으로 고정됩니다. call, apply, bind로도 this를 변경할 수 없습니다.

**arguments 객체:**
- 일반 함수: arguments 객체를 가집니다. 전달된 모든 인수에 접근할 수 있습니다. 유사 배열 객체로 배열 메서드를 직접 사용할 수 없습니다.
- 화살표 함수: arguments 객체를 가지지 않습니다. 상위 스코프의 arguments를 참조합니다. 나머지 매개변수를 사용하여 인수를 받아야 합니다.

**생성자 함수로서의 사용:**
- 일반 함수: new 키워드로 생성자 함수로 사용할 수 있습니다. prototype 프로퍼티를 가지며 인스턴스를 생성할 수 있습니다.
- 화살표 함수: 생성자 함수로 사용할 수 없습니다. new와 함께 호출하면 TypeError가 발생합니다. prototype 프로퍼티가 없습니다.

**메서드 정의:**
- 일반 함수: 객체의 메서드로 적합합니다. this가 메서드를 호출한 객체를 가리킵니다.
- 화살표 함수: 메서드로는 부적합합니다. this가 상위 스코프를 가리켜 의도와 다르게 동작합니다. 콜백 함수로 사용하기에 적합합니다.

**실무 활용:**
- 콜백 함수에서는 화살표 함수가 유용합니다. this 바인딩 문제를 해결할 수 있습니다.
- 이벤트 핸들러에서는 상황에 따라 선택합니다. DOM 요소를 참조해야 하면 일반 함수를 사용합니다.
- 메서드 정의 시에는 일반 함수나 메서드 축약 표현을 사용합니다.
- React의 클래스 컴포넌트에서 이벤트 핸들러는 화살표 함수로 정의하면 바인딩이 필요 없습니다.

---

## 질문 10: this 바인딩의 종류와 동작 원리를 설명해주세요.

**정의:**
this는 함수 호출 시 동적으로 결정되는 특수한 객체 참조입니다. 함수가 어떻게 호출되었는지에 따라 this가 가리키는 대상이 달라지며, 이를 this 바인딩이라고 합니다.

**기본 바인딩:**
- 일반 함수 호출 시 적용됩니다. 엄격 모드가 아니면 전역 객체를 가리킵니다. 브라우저에서는 window, Node.js에서는 global입니다.
- 엄격 모드에서는 undefined가 됩니다. 의도치 않은 전역 객체 참조를 방지합니다.

**암시적 바인딩:**
- 메서드로 호출될 때 적용됩니다. 메서드를 호출한 객체가 this가 됩니다.
- 점 표기법이나 대괄호 표기법으로 호출된 경우입니다.
- 주의할 점은 메서드를 변수에 할당하면 암시적 바인딩이 사라집니다. 일반 함수 호출이 되어 this가 변경됩니다.

**명시적 바인딩:**
- call, apply, bind 메서드를 사용하여 this를 명시적으로 지정합니다.
- call과 apply는 즉시 함수를 실행하며 this를 지정합니다. 차이는 인수 전달 방식입니다.
- bind는 this가 고정된 새로운 함수를 반환합니다. 나중에 호출할 수 있습니다.

**new 바인딩:**
- 생성자 함수를 new 키워드로 호출할 때 적용됩니다.
- 새로운 빈 객체가 생성되고 이 객체가 this가 됩니다.
- 함수 내부에서 this에 프로퍼티를 추가하면 새 객체에 추가됩니다.
- 명시적으로 객체를 반환하지 않으면 this가 자동으로 반환됩니다.

**화살표 함수의 this:**
- 렉시컬 this를 사용합니다. 상위 스코프의 this를 그대로 사용합니다.
- 선언될 때 this가 결정되어 변경할 수 없습니다.
- 바인딩 규칙을 따르지 않습니다.

**바인딩 우선순위:**
- new 바인딩이 가장 높습니다. 생성자 함수의 this는 항상 새 객체입니다.
- 명시적 바인딩이 다음입니다. call, apply, bind가 우선됩니다.
- 암시적 바인딩이 그다음입니다. 메서드 호출 시 적용됩니다.
- 기본 바인딩이 가장 낮습니다. 다른 규칙이 없을 때 적용됩니다.

**실무 활용:**
- 콜백 함수에서 this 문제를 해결할 때 화살표 함수나 bind를 사용합니다.
- React 클래스 컴포넌트에서 이벤트 핸들러를 바인딩합니다.
- 프로토타입 메서드에서 this는 인스턴스를 가리키도록 설계합니다.
- 디버깅 시 this가 무엇인지 파악하면 문제 해결이 쉬워집니다.

---

## 질문 11: call, apply, bind 메서드의 차이점과 사용법은 무엇인가요?

**정의:**
call, apply, bind는 함수의 this를 명시적으로 지정하는 메서드입니다. 모두 Function 프로토타입의 메서드로, 함수 호출 시 this 바인딩을 제어할 수 있습니다.

**call 메서드:**
- 함수를 즉시 호출하며 this를 지정합니다. 첫 번째 인수로 this가 될 객체를 전달합니다.
- 이후 인수들은 호출할 함수의 인수로 개별적으로 전달됩니다.
- 인수를 쉼표로 구분하여 나열합니다.
- 인수 개수를 알고 있을 때 사용하기 편리합니다.

**apply 메서드:**
- call과 동일하게 함수를 즉시 호출하며 this를 지정합니다.
- 첫 번째 인수로 this가 될 객체를 전달합니다.
- 두 번째 인수로 배열 또는 유사 배열 객체를 전달합니다. 배열의 요소들이 함수의 인수로 전달됩니다.
- 인수가 배열 형태로 있을 때 유용합니다.
- 가변 인수 함수를 호출할 때 편리합니다.

**bind 메서드:**
- 함수를 즉시 호출하지 않고 새로운 함수를 반환합니다.
- this가 영구적으로 고정된 함수를 생성합니다.
- 첫 번째 인수로 this가 될 객체를 전달합니다.
- 이후 인수들은 부분 적용됩니다. 반환된 함수 호출 시 미리 전달한 인수들이 앞에 고정됩니다.
- 이벤트 핸들러나 콜백 함수로 전달할 때 유용합니다.

**call과 apply의 사용 사례:**
- 유사 배열 객체에 배열 메서드를 사용할 때 활용합니다. arguments 객체를 배열로 변환하지 않고 배열 메서드를 적용할 수 있습니다.
- 최댓값이나 최솟값을 구할 때 apply를 사용합니다. Math.max와 Math.min에 배열을 전달할 수 있습니다.
- 생성자 빌려쓰기 패턴에서 사용합니다. 다른 생성자의 초기화 로직을 재사용할 수 있습니다.

**bind의 사용 사례:**
- 이벤트 핸들러에서 this를 유지할 때 사용합니다. DOM 이벤트 핸들러의 this는 이벤트 타겟이 되므로 bind로 고정합니다.
- React 클래스 컴포넌트의 메서드를 바인딩합니다. constructor에서 bind하거나 화살표 함수를 사용합니다.
- 부분 적용 함수를 만들 때 활용합니다. 일부 인수를 미리 고정한 함수를 생성합니다.
- 타이머 함수의 콜백에서 this를 보존합니다.

**실무 활용:**
- ES6 이후에는 화살표 함수나 스프레드 연산자로 대체할 수 있는 경우가 많습니다.
- call과 apply는 스프레드 연산자로 대체 가능합니다. 하지만 this 바인딩이 필요하면 여전히 유용합니다.
- bind는 this 고정이 필요한 상황에서 여전히 중요합니다.
- 성능상으로는 call이 apply보다 약간 빠릅니다. 인수가 적을 때는 call을 사용하는 것이 좋습니다.

---

## 질문 12: 고차 함수(Higher-Order Function)란 무엇인가요?

**정의:**
고차 함수는 함수를 인수로 받거나 함수를 반환하는 함수입니다. JavaScript에서 함수는 일급 객체이므로 변수에 할당하거나 다른 함수의 인수로 전달하거나 반환값으로 사용할 수 있습니다.

**일급 객체로서의 함수:**
- 변수에 할당할 수 있습니다. 함수를 값처럼 다룰 수 있습니다.
- 함수의 인수로 전달할 수 있습니다. 콜백 패턴의 기초가 됩니다.
- 함수의 반환값으로 사용할 수 있습니다. 클로저와 함께 강력한 패턴을 만듭니다.
- 객체의 프로퍼티나 배열의 요소가 될 수 있습니다.

**함수를 인수로 받는 고차 함수:**
- map, filter, reduce 등 배열 메서드가 대표적입니다. 콜백 함수를 받아 각 요소에 적용합니다.
- forEach, some, every 등도 고차 함수입니다.
- addEventListener도 고차 함수입니다. 이벤트 핸들러 함수를 인수로 받습니다.
- setTimeout, setInterval도 콜백 함수를 받는 고차 함수입니다.

**함수를 반환하는 고차 함수:**
- 클로저를 활용하여 상태를 유지하는 함수를 만듭니다.
- 함수 팩토리 패턴으로 설정을 기억하는 함수를 생성합니다.
- 커링과 부분 적용을 구현할 수 있습니다.
- 데코레이터 패턴을 구현하여 기존 함수에 기능을 추가합니다.

**고차 함수의 장점:**
- 코드 재사용성이 높아집니다. 공통 로직을 고차 함수로 추출할 수 있습니다.
- 추상화 수준이 높아집니다. 구체적인 구현보다 의도를 명확히 표현합니다.
- 함수 조합이 가능합니다. 작은 함수들을 조합하여 복잡한 기능을 만듭니다.
- 선언적 프로그래밍이 가능합니다. 무엇을 할지 명시하여 가독성이 향상됩니다.

**실무 활용 사례:**
- 배열 변환과 필터링에 map, filter를 사용합니다. 반복문보다 의도가 명확합니다.
- 이벤트 핸들러를 고차 함수로 감싸 공통 로직을 처리합니다. 로깅이나 권한 검사를 추가할 수 있습니다.
- 미들웨어 패턴을 구현합니다. Express나 Redux에서 고차 함수로 미들웨어를 연결합니다.
- React의 고차 컴포넌트는 컴포넌트를 받아 새 컴포넌트를 반환하는 고차 함수입니다.
- 유틸리티 함수를 만들어 코드 중복을 줄입니다. 디바운스, 스로틀, 메모이제이션 등을 구현합니다.

---
