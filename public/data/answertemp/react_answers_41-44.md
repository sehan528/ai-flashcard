# React 답변 41-44

## 질문 41: forwardRef는 무엇이고 왜 필요한가요?

**정의:**
forwardRef는 부모 컴포넌트가 자식 컴포넌트의 DOM 노드나 컴포넌트 인스턴스에 접근할 수 있게 해주는 React API입니다. ref를 일반 prop처럼 전달할 수 없는 문제를 해결합니다.

**ref 전달 문제:**
- ref는 특별한 prop이라 일반적으로 전달되지 않습니다.
- props.ref로 접근할 수 없습니다.
- React가 내부적으로 처리하기 때문입니다.
- 컴포넌트를 감싸면 ref가 래퍼를 가리킵니다.
- 내부 DOM 요소에 접근하려면 forwardRef가 필요합니다.

**forwardRef 사용 방법:**
- 컴포넌트를 forwardRef로 감쌉니다.
- 두 번째 매개변수로 ref를 받습니다.
- 첫 번째는 props, 두 번째는 ref입니다.
- ref를 DOM 요소나 useImperativeHandle에 전달합니다.
- 부모는 일반적인 방식으로 ref를 사용합니다.

**forwardRef가 필요한 경우:**
- 재사용 가능한 컴포넌트 라이브러리를 만들 때입니다.
- HOC로 컴포넌트를 감쌀 때 ref를 전달해야 합니다.
- 입력 컴포넌트에서 DOM 요소에 직접 접근해야 할 때입니다.
- 부모가 자식의 DOM을 제어해야 할 때입니다.

**재사용 가능한 컴포넌트:**
- Input, Button 같은 기본 컴포넌트에 사용합니다.
- 라이브러리 사용자가 ref로 DOM에 접근할 수 있게 합니다.
- 포커스 제어나 측정이 가능해집니다.
- 디자인 시스템 구축 시 필수적입니다.

**HOC와 forwardRef:**
- HOC는 컴포넌트를 감싸므로 ref가 HOC를 가리킵니다.
- forwardRef로 내부 컴포넌트에 ref를 전달합니다.
- React.forwardRef를 HOC 내부에서 사용합니다.
- 원래 컴포넌트의 ref 동작을 유지합니다.

**TypeScript와 함께 사용:**
- 제네릭 타입을 사용하여 타입을 정의합니다.
- ref 타입을 명시적으로 지정합니다.
- props 타입도 함께 정의합니다.
- 타입 안전성을 보장합니다.

**displayName 설정:**
- forwardRef로 감싸면 컴포넌트 이름이 사라집니다.
- displayName을 설정하여 디버깅을 쉽게 합니다.
- React DevTools에 표시됩니다.
- 개발 환경에서 유용합니다.

**useImperativeHandle과 조합:**
- forwardRef와 함께 자주 사용됩니다.
- 부모에게 노출할 메서드를 제어합니다.
- 전체 DOM이 아닌 일부 기능만 공개합니다.
- 캡슐화를 유지하면서 필요한 기능을 제공합니다.

**실무 활용:**
- UI 라이브러리의 기본 컴포넌트에 적용합니다.
- 커스텀 Input 컴포넌트에서 포커스를 제어합니다.
- 모달이나 드롭다운에서 첫 요소로 포커스를 이동합니다.
- HOC나 래퍼 컴포넌트에서 ref를 전달합니다.
- 재사용 가능한 컴포넌트를 만들 때 반드시 고려합니다.

---

## 질문 42: useImperativeHandle은 언제 사용하나요?

**정의:**
useImperativeHandle은 부모 컴포넌트에 노출할 인스턴스 값을 커스터마이징하는 Hook입니다. forwardRef와 함께 사용하여 ref로 접근 가능한 메서드를 제어합니다.

**기본 개념:**
- ref를 통해 노출할 값을 정의합니다.
- forwardRef와 함께 사용해야 합니다.
- 전체 DOM 대신 특정 메서드만 공개합니다.
- 컴포넌트의 내부 구현을 숨깁니다.
- 명령형 API를 제공합니다.

**사용 방법:**
- 첫 번째 인자는 forwardRef로 받은 ref입니다.
- 두 번째 인자는 노출할 값을 반환하는 함수입니다.
- 세 번째 인자는 의존성 배열입니다. 선택사항입니다.
- 반환 객체의 메서드를 부모가 호출할 수 있습니다.

**왜 사용할까:**
- DOM 전체를 노출하고 싶지 않을 때입니다.
- 추상화 레벨을 유지하고 싶을 때입니다.
- 컴포넌트의 공개 API를 명확히 정의할 때입니다.
- 내부 구현을 변경해도 공개 API는 유지할 때입니다.
- 선언적 방식으로 불가능한 작업을 명령형으로 제공할 때입니다.

**일반적인 사용 사례:**
- 커스텀 Input에서 focus와 blur만 노출합니다.
- 비디오 플레이어에서 play pause stop 메서드를 제공합니다.
- 모달에서 open과 close 메서드를 제공합니다.
- 애니메이션 컴포넌트에서 start stop reset 메서드를 제공합니다.

**캡슐화와 추상화:**
- 내부 DOM 구조를 숨깁니다.
- 필요한 기능만 선택적으로 노출합니다.
- 컴포넌트 내부를 자유롭게 리팩토링할 수 있습니다.
- 외부 의존성을 줄입니다.
- 더 나은 API를 설계할 수 있습니다.

**의존성 배열:**
- 세 번째 인자로 전달합니다.
- 의존성이 변경되면 노출된 값이 업데이트됩니다.
- 생략하면 매 렌더링마다 재생성됩니다.
- 성능 최적화를 위해 사용합니다.

**남용하지 말아야 할 이유:**
- 선언적 React의 원칙에 어긋납니다.
- props로 해결 가능하면 props를 사용합니다.
- 과도한 명령형 코드는 유지보수를 어렵게 합니다.
- 정말 필요한 경우에만 사용합니다.

**대안 고려:**
- 대부분의 경우 props로 충분합니다.
- 상태를 끌어올려서 부모가 제어하게 합니다.
- 콜백 props로 이벤트를 전달합니다.
- useImperativeHandle은 최후의 수단입니다.

**실무 활용:**
- 폼 라이브러리에서 submit과 reset 메서드를 노출합니다.
- 커스텀 에디터에서 getValue와 setValue를 제공합니다.
- 복잡한 위젯에서 제어 메서드를 제공합니다.
- 라이브러리 컴포넌트에서 공개 API를 정의합니다.
- 선언적으로 불가능한 작업만 명령형으로 제공합니다.

---

## 질문 43: React Router의 주요 컴포넌트와 기능은 무엇인가요?

**정의:**
React Router는 React 애플리케이션에서 라우팅을 구현하는 가장 인기 있는 라이브러리입니다. 클라이언트 사이드 라우팅을 제공하여 싱글 페이지 애플리케이션에서 페이지 간 탐색을 가능하게 합니다.

**주요 컴포넌트:**
- BrowserRouter: HTML5 History API를 사용하는 라우터입니다. 가장 일반적으로 사용됩니다.
- Routes: 여러 Route를 그룹화합니다. v6에서 Switch를 대체했습니다.
- Route: 경로와 컴포넌트를 매핑합니다. path와 element props를 받습니다.
- Link: 클라이언트 사이드 탐색을 위한 링크입니다. 페이지 새로고침 없이 이동합니다.
- NavLink: 활성 상태 스타일링이 가능한 Link입니다.
- Navigate: 리다이렉트를 수행합니다. v6에서 Redirect를 대체했습니다.
- Outlet: 중첩 라우트에서 자식을 렌더링합니다.

**라우터 종류:**
- BrowserRouter: 일반적인 웹 앱에 사용합니다. 깔끔한 URL을 제공합니다.
- HashRouter: Hash 기반 라우팅입니다. 오래된 브라우저나 정적 서버에 적합합니다.
- MemoryRouter: 메모리에 히스토리를 저장합니다. 테스트나 React Native에 사용합니다.
- StaticRouter: 서버 사이드 렌더링에 사용합니다.

**경로 매칭:**
- 정확한 경로를 먼저 매칭합니다. v6는 자동으로 최적 매칭을 찾습니다.
- 동적 세그먼트를 지원합니다. :id 형태로 사용합니다.
- 와일드카드를 지원합니다. 애스터리스크로 모든 경로를 매칭합니다.
- 중첩 라우트를 지원합니다. 레이아웃과 페이지를 분리합니다.

**Hooks:**
- useNavigate: 프로그래매틱 탐색을 수행합니다. v6에서 useHistory를 대체했습니다.
- useParams: URL 파라미터에 접근합니다. 동적 라우트의 값을 읽습니다.
- useLocation: 현재 위치 객체에 접근합니다. pathname, search, hash 등을 포함합니다.
- useSearchParams: 쿼리 스트링을 읽고 수정합니다.
- useMatch: 현재 경로가 특정 패턴과 일치하는지 확인합니다.

**중첩 라우트:**
- 레이아웃과 페이지를 분리합니다.
- 부모 Route 안에 자식 Route를 정의합니다.
- Outlet으로 자식을 렌더링할 위치를 지정합니다.
- 공통 레이아웃을 재사용합니다.

**보호된 라우트:**
- 인증이 필요한 페이지를 보호합니다.
- 조건부로 Navigate를 렌더링합니다.
- 커스텀 컴포넌트로 래핑합니다.
- 권한을 체크하고 리다이렉트합니다.

**코드 스플리팅:**
- React.lazy로 라우트 컴포넌트를 동적 임포트합니다.
- Suspense로 로딩 상태를 처리합니다.
- 초기 번들 크기를 줄입니다.
- 사용자가 방문한 페이지만 로드합니다.

**실무 활용:**
- SPA의 페이지 탐색을 구현합니다.
- 중첩 라우트로 복잡한 레이아웃을 관리합니다.
- 동적 라우트로 상세 페이지를 구현합니다.
- 보호된 라우트로 인증을 처리합니다.
- v6의 새로운 API를 사용하여 더 간결한 코드를 작성합니다.

---

## 질문 44: 동적 라우팅(Dynamic Routing)은 어떻게 구현하나요?

**정의:**
동적 라우팅은 URL의 일부를 변수로 사용하여 다양한 콘텐츠를 같은 컴포넌트로 렌더링하는 방식입니다. React Router에서 경로 파라미터를 사용하여 구현합니다.

**경로 파라미터 정의:**
- 콜론을 사용하여 동적 세그먼트를 정의합니다.
- /users/:id 형태로 작성합니다.
- 여러 파라미터를 사용할 수 있습니다. /posts/:category/:id 같은 형태입니다.
- 선택적 파라미터도 가능합니다.

**useParams Hook 사용:**
- URL 파라미터 값을 읽습니다.
- 객체로 모든 파라미터를 반환합니다.
- 키는 경로에 정의한 파라미터 이름입니다.
- 컴포넌트 어디서든 사용할 수 있습니다.

**파라미터 활용:**
- API 호출에 사용합니다. 특정 리소스를 가져옵니다.
- 데이터 필터링에 사용합니다.
- 조건부 렌더링에 활용합니다.
- useEffect의 의존성으로 사용하여 파라미터 변경을 감지합니다.

**쿼리 파라미터:**
- useSearchParams Hook을 사용합니다.
- 검색 필터나 페이지네이션에 활용합니다.
- get 메서드로 값을 읽습니다.
- set 메서드로 값을 업데이트합니다.
- URL과 상태를 동기화합니다.

**동적 링크 생성:**
- Link의 to prop에 동적 값을 전달합니다.
- 템플릿 리터럴로 URL을 구성합니다.
- map으로 여러 링크를 생성합니다.
- 목록에서 상세 페이지로 이동할 때 사용합니다.

**중첩 동적 라우트:**
- 부모와 자식 모두 동적 파라미터를 가질 수 있습니다.
- /categories/:categoryId/products/:productId 같은 형태입니다.
- useParams는 모든 파라미터를 포함합니다.
- 계층 구조를 URL에 반영합니다.

**데이터 로딩:**
- useParams로 ID를 받습니다.
- useEffect에서 API를 호출합니다.
- 로딩과 에러 상태를 관리합니다.
- ID가 변경되면 새 데이터를 가져옵니다.

**유효성 검사:**
- 파라미터 값의 유효성을 확인합니다.
- 잘못된 값이면 404 페이지로 리다이렉트합니다.
- 숫자가 필요한 곳에 문자가 오면 처리합니다.
- 사용자 입력을 신뢰하지 않습니다.

**실무 활용:**
- 블로그 게시물 상세 페이지를 구현합니다. /posts/:id 형태입니다.
- 사용자 프로필 페이지를 만듭니다. /users/:username 형태입니다.
- 전자상거래 상품 페이지를 만듭니다. /products/:id 형태입니다.
- 쿼리 파라미터로 검색과 필터를 구현합니다.
- URL을 북마크 가능하게 만들어 공유하기 쉽게 합니다.

---
