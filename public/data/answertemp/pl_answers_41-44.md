## 질문 41: JavaScript의 데이터 타입에 대해 설명해주세요.

**정의:**
JavaScript의 데이터 타입은 원시 타입(Primitive Type)과 참조 타입(Reference Type)으로 구분됩니다. 원시 타입은 불변 값으로 스택에 저장되며, 참조 타입은 객체로 힙에 저장되고 참조를 통해 접근합니다.

**특징/원리:**
- 동적 타입: 변수의 타입이 런타임에 결정되며 실행 중 변경 가능
- 타입 변환: 암묵적 타입 변환(Type Coercion)이 자동으로 발생하여 예상치 못한 결과 발생 가능
- typeof 연산자: 변수의 타입을 문자열로 반환하지만 null은 object로 반환되는 버그 존재
- 느슨한 타입 체크: 동등 연산자(==)는 타입 변환 후 비교하고, 일치 연산자(===)는 타입까지 비교

**원시 타입:**
- Number: 정수와 실수를 구분하지 않으며 IEEE 754 표준의 64비트 부동소수점 사용
- String: 문자열로 불변이며 UTF-16 인코딩 사용
- Boolean: true와 false 두 가지 값만 가짐
- undefined: 선언되었지만 값이 할당되지 않은 변수의 기본값
- null: 의도적으로 값이 없음을 나타내는 특수 값
- Symbol: ES6에서 추가된 유일한 식별자를 생성하는 타입
- BigInt: ES2020에서 추가된 큰 정수를 다루는 타입

**참조 타입:**
- Object: 키-값 쌍의 컬렉션으로 객체, 배열, 함수 등이 모두 객체
- Array: 순서가 있는 값의 목록으로 인덱스로 접근
- Function: 실행 가능한 코드 블록으로 일급 객체이며 변수에 할당 가능
- Date, RegExp, Map, Set: 특수 목적의 내장 객체

**실무 활용:**
- 타입 체크 시 typeof를 사용하되 null과 배열은 별도 처리 필요
- 일치 연산자(===)를 기본으로 사용하여 예상치 못한 타입 변환 방지
- TypeScript를 도입하여 정적 타입 체크로 타입 관련 오류를 컴파일 타임에 발견

---

## 질문 42: var, let, const의 차이점과 호이스팅에 대해 설명해주세요.

**정의:**
var, let, const는 JavaScript에서 변수를 선언하는 키워드로, 스코프, 호이스팅, 재할당 가능 여부 등에서 차이가 있습니다. 호이스팅은 변수와 함수 선언이 스코프의 최상단으로 끌어올려지는 JavaScript의 특성입니다.

**특징/원리:**
- 스코프: var는 함수 스코프, let과 const는 블록 스코프를 가짐
- 호이스팅: 모두 호이스팅되지만 let과 const는 Temporal Dead Zone이 존재
- 재선언: var는 재선언 가능, let과 const는 같은 스코프에서 재선언 불가
- 재할당: var와 let은 재할당 가능, const는 재할당 불가

**var의 특징:**
- 함수 스코프: 함수 내에서 선언하면 함수 전체에서 접근 가능하며 블록 무시
- 호이스팅: 선언이 스코프 최상단으로 끌어올려지고 undefined로 초기화
- 재선언 허용: 같은 스코프에서 여러 번 선언 가능하여 의도치 않은 버그 발생 가능
- 전역 객체 속성: 전역 스코프의 var 변수는 window 객체의 속성으로 추가

**let의 특징:**
- 블록 스코프: 중괄호로 둘러싸인 블록 내에서만 접근 가능
- TDZ: 선언 전까지 Temporal Dead Zone에 있어 접근 시 ReferenceError 발생
- 재할당 가능: 값을 변경할 수 있지만 재선언은 불가
- 반복문: for 루프에서 반복마다 새로운 바인딩 생성

**const의 특징:**
- 블록 스코프: let과 동일한 블록 스코프
- 재할당 불가: 선언과 동시에 초기화 필수이며 이후 재할당 불가
- 객체 불변 아님: 객체나 배열을 가리키는 참조는 고정되지만 내부 속성은 변경 가능
- 상수 선언: 변경되지 않아야 하는 값을 선언할 때 사용

**호이스팅:**
- var 호이스팅: 선언이 최상단으로 올라가고 undefined로 초기화되어 선언 전에도 접근 가능
- let/const 호이스팅: 선언은 올라가지만 초기화는 안 되어 TDZ 구간에서 접근 시 오류
- 함수 호이스팅: 함수 선언문은 전체가 호이스팅되어 선언 전 호출 가능
- 함수 표현식: 변수 호이스팅 규칙을 따름

**실무 활용:**
- const를 기본으로 사용하고, 재할당이 필요한 경우만 let 사용
- var는 레거시 코드를 제외하고는 사용하지 않음
- 블록 스코프를 활용하여 변수의 생명주기를 최소화하고 의도치 않은 접근 방지

---

## 질문 43: 실행 컨텍스트와 스코프 체인에 대해 설명해주세요.

**정의:**
실행 컨텍스트는 JavaScript 코드가 실행되는 환경으로, 변수, 함수, this 등의 정보를 담고 있습니다. 스코프 체인은 변수를 찾을 때 현재 스코프부터 상위 스코프로 순차적으로 탐색하는 메커니즘입니다.

**특징/원리:**
- 실행 스택: 실행 컨텍스트가 LIFO 구조의 스택에 쌓여 관리됨
- 생성 단계: 변수와 함수 선언을 메모리에 할당하는 Creation Phase
- 실행 단계: 실제 코드를 한 줄씩 실행하는 Execution Phase
- 렉시컬 스코프: 함수가 정의된 위치에 따라 스코프가 결정되는 정적 스코프

**실행 컨텍스트 구성 요소:**
- Variable Environment: var로 선언된 변수와 함수 선언을 저장
- Lexical Environment: let, const로 선언된 변수를 저장하며 블록 스코프 지원
- this 바인딩: 함수 호출 방식에 따라 this가 가리키는 객체 결정
- Outer Environment Reference: 외부 렉시컬 환경에 대한 참조로 스코프 체인 형성

**실행 컨텍스트 종류:**
- 전역 실행 컨텍스트: 코드 실행 시 가장 먼저 생성되며 하나만 존재
- 함수 실행 컨텍스트: 함수 호출 시마다 생성되며 여러 개 존재 가능
- Eval 실행 컨텍스트: eval() 함수 실행 시 생성되지만 사용 권장되지 않음

**스코프 체인:**
- 변수 검색: 현재 스코프에서 변수를 찾지 못하면 외부 스코프로 이동하여 검색
- 렉시컬 환경: 함수가 정의될 때 외부 환경에 대한 참조를 저장하여 체인 형성
- 종료 조건: 전역 스코프까지 도달했는데 변수를 못 찾으면 ReferenceError 발생
- 성능: 스코프 체인이 길수록 변수 검색 시간이 증가하므로 지역 변수 사용 권장

**실무 활용:**
- 클로저 이해와 활용을 위한 기본 개념으로 스코프 체인 메커니즘 숙지
- 변수를 가능한 한 가까운 스코프에 선언하여 검색 속도 향상
- 전역 변수 남발을 피하고 모듈 패턴이나 IIFE로 스코프 격리

---

## 질문 44: 클로저(Closure)란 무엇이고 어떻게 활용할 수 있나요?

**정의:**
클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합으로, 외부 함수의 변수에 접근할 수 있는 내부 함수를 말합니다. 외부 함수가 종료된 후에도 내부 함수는 외부 함수의 변수를 기억하고 접근할 수 있어 데이터 은닉과 상태 유지에 활용됩니다.

**특징/원리:**
- 렉시컬 스코프: 함수가 정의될 때의 스코프를 기억하여 외부 변수에 접근
- 메모리 유지: 외부 함수 종료 후에도 내부 함수가 참조하는 변수는 가비지 컬렉션되지 않음
- 데이터 은닉: 외부에서 직접 접근할 수 없는 private 변수 구현 가능
- 함수 팩토리: 클로저를 반환하는 함수로 설정이 다른 함수들을 생성

**동작 메커니즘:**
- 외부 함수 실행: 외부 함수가 호출되어 실행 컨텍스트 생성
- 내부 함수 정의: 내부 함수가 정의되면서 외부 렉시컬 환경을 참조
- 외부 함수 종료: 외부 함수가 종료되어 실행 컨텍스트는 스택에서 제거되지만 렉시컬 환경은 유지
- 클로저 실행: 내부 함수가 실행될 때 저장된 외부 환경에 접근하여 변수 사용

**활용 패턴:**
- 데이터 캡슐화: private 변수를 만들어 외부에서 직접 접근 못하게 하고 메서드로만 접근 허용
- 함수 팩토리: 매개변수를 받아 특정 동작을 하는 함수를 생성하여 반환
- 콜백 함수: 이벤트 핸들러나 setTimeout에서 외부 변수를 기억하는 함수 전달
- 모듈 패턴: 즉시 실행 함수와 클로저로 private/public 멤버를 가진 모듈 구현

**주의사항:**
- 메모리 누수: 클로저가 더 이상 필요 없는데도 외부 변수를 참조하면 메모리 누수 발생 가능
- 반복문 주의: var로 선언된 변수를 클로저에서 참조 시 예상과 다른 값 참조 가능
- 성능: 클로저 생성과 메모리 유지에 오버헤드가 있으므로 과도한 사용 지양
- 디버깅: 스코프 체인이 복잡해져 디버깅이 어려울 수 있음

**실무 활용:**
- React의 useState 훅이 클로저를 활용하여 상태를 함수 외부에서 유지
- 이벤트 핸들러에서 특정 데이터를 기억하는 콜백 함수 생성
- 모듈 패턴으로 라이브러리의 내부 구현을 숨기고 공개 API만 노출

---
