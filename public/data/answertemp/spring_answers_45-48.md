# Spring 답변 45-48

## 질문 45: 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?

네, DispatcherServlet은 한 번에 여러 요청을 동시에 처리할 수 있습니다.

**멀티스레드 처리:**

서블릿 컨테이너(Tomcat, Jetty 등)는 스레드 풀을 관리합니다. 각 HTTP 요청은 풀의 스레드 하나에 할당됩니다. DispatcherServlet은 여러 스레드에서 동시에 실행될 수 있도록 설계되었습니다.

DispatcherServlet 인스턴스는 하나지만 여러 스레드가 공유합니다. 각 스레드가 동일한 DispatcherServlet 인스턴스의 service 메서드를 호출합니다.

**싱글톤 서블릿:**

서블릿 사양에 따라 서블릿은 기본적으로 싱글톤입니다. 컨테이너는 서블릿 인스턴스를 하나만 생성합니다. 모든 요청이 이 하나의 인스턴스를 공유합니다.

따라서 DispatcherServlet도 하나의 인스턴스만 존재합니다. 여러 스레드가 동시에 접근할 수 있어야 하므로 스레드 안전해야 합니다.

**스레드 안전성:**

DispatcherServlet과 Spring MVC 컴포넌트들은 스레드 안전하게 설계되어 있습니다. 인스턴스 변수로 상태를 저장하지 않습니다. 요청별 데이터는 로컬 변수나 스레드 로컬에 저장됩니다.

Controller, Service, Repository 빈들도 기본적으로 싱글톤이므로 스레드 안전해야 합니다. 인스턴스 변수에 요청별 데이터를 저장하면 동시성 문제가 발생합니다.

**스레드 풀 크기:**

Tomcat의 기본 스레드 풀 크기는 보통 200개입니다. server.tomcat.threads.max로 설정할 수 있습니다. 최대 200개의 요청을 동시에 처리할 수 있습니다.

스레드 풀이 가득 차면 새로운 요청은 큐에서 대기합니다. 큐도 가득 차면 연결이 거부될 수 있습니다.

**요청별 격리:**

각 요청은 독립적인 스레드에서 처리되므로 서로 영향을 주지 않습니다. HttpServletRequest와 HttpServletResponse는 스레드별로 다릅니다. 로컬 변수는 스택에 저장되어 스레드 간 공유되지 않습니다.

Spring은 요청 범위(Request Scope)를 지원하여 요청별로 독립적인 빈을 생성할 수 있습니다. ThreadLocal을 사용하여 스레드별 데이터를 저장할 수 있습니다.

**동시성 문제 주의사항:**

싱글톤 빈에서 인스턴스 변수를 변경하면 안 됩니다. 여러 스레드가 동시에 접근하여 경합 상태(race condition)가 발생합니다.

공유 자원에 접근할 때는 동기화가 필요합니다. 데이터베이스나 외부 API 호출은 일반적으로 연결 풀을 통해 안전하게 관리됩니다.

정적 변수나 싱글톤 객체의 상태를 변경할 때 주의해야 합니다.

**비동기 요청 처리:**

Spring MVC는 비동기 요청 처리를 지원합니다. Callable이나 DeferredResult를 반환하면 요청 스레드를 해제하고 나중에 응답합니다. 스레드를 효율적으로 사용하여 더 많은 동시 요청을 처리할 수 있습니다.

WebFlux는 완전히 비동기 논블로킹 방식으로 동작합니다. 적은 스레드로 많은 요청을 처리할 수 있습니다.

**성능 튜닝:**

스레드 풀 크기를 애플리케이션의 특성에 맞게 조정합니다. CPU 집약적 작업이 많으면 코어 수에 맞춥니다. I/O 집약적 작업이 많으면 더 크게 설정할 수 있습니다.

커넥션 풀 크기도 함께 고려해야 합니다. 데이터베이스 연결, HTTP 클라이언트 풀 등을 적절히 설정합니다.

**모니터링:**

Actuator의 메트릭으로 활성 스레드 수를 모니터링할 수 있습니다. 스레드 덤프로 병목이나 데드락을 분석할 수 있습니다.

따라서 DispatcherServlet은 멀티스레드 환경에서 동시에 여러 요청을 효율적으로 처리할 수 있습니다.

## 질문 46: @Controller를 DispatcherServlet은 어떻게 구분 할까요?

DispatcherServlet이 @Controller를 구분하는 과정은 컴포넌트 스캔과 HandlerMapping을 통해 이루어집니다.

**컴포넌트 스캔 단계:**

애플리케이션 시작 시 @ComponentScan이 실행됩니다. 지정된 패키지를 스캔하여 @Component, @Controller, @Service, @Repository 어노테이션이 붙은 클래스를 찾습니다.

@Controller는 @Component의 특수화된 형태입니다. 내부적으로 @Component를 메타 어노테이션으로 가집니다. 따라서 컴포넌트 스캔에 의해 자동으로 감지됩니다.

Spring은 이러한 클래스들의 인스턴스를 생성하여 Bean으로 등록합니다. ApplicationContext에 Bean Definition이 생성됩니다.

**HandlerMapping 초기화:**

DispatcherServlet이 초기화될 때 HandlerMapping 구현체들을 설정합니다. RequestMappingHandlerMapping이 가장 중요한 구현체입니다.

RequestMappingHandlerMapping은 @RequestMapping 어노테이션을 찾아 매핑 정보를 수집합니다. ApplicationContext의 모든 Bean을 검사합니다. @Controller나 @RestController가 붙은 Bean을 찾습니다.

**매핑 정보 생성:**

@RequestMapping이 붙은 메서드를 찾습니다. 클래스 레벨과 메서드 레벨의 @RequestMapping을 결합합니다. URL 패턴, HTTP 메서드, 헤더, 파라미터 등의 조건을 추출합니다.

RequestMappingInfo 객체로 매핑 정보를 저장합니다. HandlerMethod 객체로 실제 실행할 메서드를 캡슐화합니다.

내부적으로 MappingRegistry에 URL과 Handler의 매핑을 저장합니다. URL을 키로, HandlerMethod를 값으로 하는 맵 구조입니다.

**요청 처리 시:**

클라이언트 요청이 들어오면 DispatcherServlet이 받습니다. HandlerMapping의 getHandler 메서드를 호출합니다.

RequestMappingHandlerMapping은 요청 URL과 메서드를 분석합니다. 저장된 매핑 정보와 비교하여 가장 적합한 Handler를 찾습니다. 패턴 매칭, 경로 변수 추출, 조건 검사 등을 수행합니다.

HandlerExecutionChain을 반환합니다. 이는 Handler와 적용할 Interceptor 목록을 포함합니다.

**매칭 우선순위:**

구체적인 패턴이 일반적인 패턴보다 우선합니다. 경로 변수가 없는 것이 있는 것보다 우선합니다. HTTP 메서드가 명시된 것이 우선합니다.

여러 Handler가 매칭되면 가장 구체적인 것을 선택합니다. 모호한 경우 예외가 발생합니다.

**@RestController의 차이:**

@RestController는 @Controller + @ResponseBody입니다. HandlerMapping은 동일하게 처리합니다. 차이는 HandlerAdapter와 MessageConverter 단계에서 발생합니다.

@ResponseBody가 있으면 View를 거치지 않고 직접 응답을 작성합니다. HttpMessageConverter가 객체를 JSON이나 XML로 변환합니다.

**커스텀 매핑:**

@GetMapping, @PostMapping 등은 @RequestMapping의 특수화된 형태입니다. 내부적으로 @RequestMapping으로 변환되어 처리됩니다.

커스텀 어노테이션을 만들어 @RequestMapping을 메타 어노테이션으로 사용할 수 있습니다. RequestMappingHandlerMapping이 자동으로 인식합니다.

**성능 최적화:**

매핑 정보는 애플리케이션 시작 시 한 번만 생성됩니다. 요청 처리 시에는 캐시된 정보를 사용하여 빠르게 Handler를 찾습니다.

Ant 패턴 매칭이나 정규식 매칭은 최적화되어 있습니다.

**디버깅:**

Actuator의 /mappings 엔드포인트로 모든 매핑 정보를 확인할 수 있습니다. 어떤 URL이 어느 Controller 메서드에 매핑되는지 볼 수 있습니다.

로그 레벨을 DEBUG로 설정하면 매핑 과정을 자세히 볼 수 있습니다.

따라서 @Controller는 컴포넌트 스캔으로 발견되고, HandlerMapping에 의해 URL과 매핑되어 DispatcherServlet이 요청을 라우팅할 수 있게 됩니다.

## 질문 47: JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

JPA(Java Persistence API)와 같은 ORM(Object-Relational Mapping)을 사용하는 이유는 객체 지향과 관계형 데이터베이스 간의 패러다임 불일치를 해결하고 개발 생산성을 높이기 위함입니다.

**객체-관계 임피던스 불일치 해결:**

객체 지향 프로그래밍과 관계형 데이터베이스는 근본적으로 다른 패러다임입니다. 객체는 상속, 다형성, 참조를 가지지만 테이블은 외래 키와 조인만 가집니다.

ORM은 이러한 차이를 자동으로 매핑합니다. 객체의 상속 구조를 테이블로 매핑합니다. 객체 참조를 외래 키로 변환합니다. 컬렉션을 일대다 관계로 표현합니다.

**SQL 자동 생성:**

ORM은 CRUD 작업을 위한 SQL을 자동으로 생성합니다. 개발자가 SQL을 직접 작성할 필요가 없습니다. 반복적인 보일러플레이트 코드가 줄어듭니다.

find, save, delete 같은 기본 메서드만으로 데이터베이스 작업을 수행할 수 있습니다. 복잡한 쿼리도 JPQL이나 Criteria API로 객체 지향적으로 작성할 수 있습니다.

**데이터베이스 독립성:**

ORM은 특정 데이터베이스에 종속되지 않습니다. Dialect 설정만 변경하면 다른 데이터베이스로 전환할 수 있습니다. MySQL, PostgreSQL, Oracle 등을 쉽게 교체할 수 있습니다.

SQL 방언의 차이를 ORM이 흡수합니다. 페이징, 함수, 데이터 타입 등의 차이를 자동으로 처리합니다.

**생산성 향상:**

엔티티 클래스만 정의하면 테이블이 자동 생성됩니다. 스키마 변경 시 엔티티만 수정하면 됩니다. Repository 인터페이스만 선언하면 구현체가 자동 생성됩니다.

Spring Data JPA는 메서드 이름만으로 쿼리를 생성합니다. findByNameAndAge 같은 메서드를 선언하면 자동으로 쿼리가 만들어집니다.

**유지보수성:**

객체 모델과 데이터베이스 스키마가 동기화됩니다. 한 곳만 수정하면 양쪽이 일관되게 유지됩니다. 타입 안전성이 보장되어 컴파일 시점에 오류를 잡을 수 있습니다.

SQL 문자열이 아닌 타입 기반 API를 사용하여 IDE의 자동 완성과 리팩토링을 활용할 수 있습니다.

**영속성 컨텍스트:**

1차 캐시로 동일한 엔티티를 여러 번 조회해도 한 번만 DB에 접근합니다. 변경 감지(Dirty Checking)로 명시적인 update 호출 없이 자동으로 변경사항이 저장됩니다. 지연 로딩으로 필요한 시점에만 연관 데이터를 조회하여 성능을 최적화합니다.

**관계 매핑:**

일대다, 다대일, 다대다, 일대일 관계를 어노테이션으로 간단히 표현합니다. 양방향 관계를 쉽게 구현할 수 있습니다. Cascade 옵션으로 연관 엔티티의 영속성 전이를 자동화합니다.

**트랜잭션 관리:**

@Transactional과 통합되어 선언적 트랜잭션을 지원합니다. 트랜잭션 경계 내에서 영속성 컨텍스트가 관리됩니다. 자동 커밋, 롤백, 예외 처리가 간편합니다.

**테스트 용이성:**

인메모리 데이터베이스(H2)로 쉽게 테스트할 수 있습니다. 엔티티 중심으로 테스트를 작성하여 데이터베이스와 독립적으로 로직을 검증할 수 있습니다.

**단점과 주의사항:**

N+1 문제 같은 성능 이슈가 발생할 수 있습니다. Fetch Join이나 Entity Graph로 해결할 수 있습니다.

복잡한 쿼리는 JPQL이나 Native Query로 작성해야 합니다. ORM이 생성하는 SQL을 이해하고 모니터링해야 합니다.

학습 곡선이 있습니다. 영속성 컨텍스트, 지연 로딩, 프록시 등의 개념을 이해해야 합니다.

**언제 사용하면 좋은가:**

도메인 주도 설계(DDD)를 따르는 애플리케이션에 적합합니다. CRUD 위주의 애플리케이션에서 생산성이 높습니다. 객체 중심의 비즈니스 로직이 많은 경우 유리합니다.

반대로 복잡한 통계 쿼리나 대량 데이터 처리에는 Native SQL이나 MyBatis가 더 적합할 수 있습니다.

ORM은 객체 지향과 데이터베이스를 연결하는 다리 역할을 하며, 적절히 사용하면 개발 효율성과 코드 품질을 크게 향상시킬 수 있습니다.

## 질문 48: 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?

영속성 컨텍스트(Persistence Context)는 JPA의 핵심 개념으로, 엔티티를 관리하는 환경입니다. 성능 향상과 일관성 보장에 중요한 역할을 합니다.

**영속성 컨텍스트의 기능:**

첫째, 1차 캐시 기능입니다. 조회한 엔티티를 메모리에 저장합니다. 같은 트랜잭션 내에서 동일한 엔티티를 여러 번 조회해도 한 번만 DB에 접근합니다. 식별자(ID)로 엔티티를 관리하여 빠르게 찾을 수 있습니다.

둘째, 동일성 보장입니다. 같은 식별자를 가진 엔티티는 항상 같은 객체 인스턴스를 반환합니다. Java의 == 비교가 true가 됩니다. 애플리케이션 레벨에서 Repeatable Read 수준의 격리를 보장합니다.

셋째, 변경 감지(Dirty Checking)입니다. 엔티티의 변경사항을 자동으로 감지합니다. 명시적으로 update를 호출하지 않아도 트랜잭션 커밋 시 자동으로 UPDATE SQL이 실행됩니다. 스냅샷과 비교하여 변경된 필드만 업데이트합니다.

넷째, 쓰기 지연(Write-Behind)입니다. SQL을 즉시 실행하지 않고 모아둡니다. 트랜잭션 커밋 시점에 한 번에 DB로 전송합니다. 네트워크 왕복 횟수를 줄여 성능을 향상시킵니다.

다섯째, 지연 로딩(Lazy Loading)입니다. 연관된 엔티티를 실제로 사용할 때까지 로딩을 미룹니다. 프록시 객체를 반환하고 실제 접근 시 DB에서 조회합니다. 불필요한 데이터 로딩을 방지합니다.

**성능 향상 효과:**

1차 캐시로 인한 성능 향상은 트랜잭션 내에서만 유효합니다. 같은 엔티티를 여러 번 조회하는 경우 DB 접근을 줄입니다. 하지만 트랜잭션이 끝나면 캐시도 사라지므로 장기적인 캐시는 아닙니다.

쓰기 지연은 배치 작업에서 효과적입니다. 여러 엔티티를 저장할 때 한 번에 전송하여 네트워크 비용을 줄입니다. JDBC 배치를 활성화하면 더 큰 효과를 볼 수 있습니다.

변경 감지는 개발 편의성을 높입니다. 성능적으로는 변경된 필드만 업데이트하여 불필요한 업데이트를 방지합니다. 하지만 스냅샷 비교 비용이 있으므로 대량 업데이트에는 적합하지 않습니다.

지연 로딩은 양날의 검입니다. 필요한 데이터만 조회하여 초기 로딩 비용을 줄입니다. 하지만 N+1 문제를 일으킬 수 있어 주의가 필요합니다.

**실제 성능 영향:**

긍정적 영향으로는 반복 조회 시 DB 접근 감소, 배치 처리 효율성 향상, 불필요한 데이터 로딩 방지가 있습니다.

부정적 영향으로는 메모리 사용량 증가, 대량 엔티티 관리 시 오버헤드, N+1 문제 발생 가능성, 플러시 시점의 성능 저하가 있습니다.

**최적화 방법:**

Fetch Join으로 N+1 문제를 해결합니다. 한 번의 쿼리로 연관 엔티티를 함께 조회합니다.

@EntityGraph로 로딩 전략을 선언적으로 지정합니다. 특정 쿼리에만 즉시 로딩을 적용할 수 있습니다.

배치 크기를 조정하여 쓰기 지연 효과를 극대화합니다. hibernate.jdbc.batch_size 설정으로 제어합니다.

대량 작업은 벌크 연산을 사용합니다. executeUpdate로 직접 SQL을 실행하여 영속성 컨텍스트를 우회합니다.

2차 캐시를 활용합니다. 트랜잭션을 넘어서 엔티티를 캐싱하여 장기적인 성능 향상을 얻습니다.

**트랜잭션 범위:**

영속성 컨텍스트는 기본적으로 트랜잭션과 생명주기를 같이합니다. @Transactional이 시작되면 생성되고 끝나면 종료됩니다. 웹 애플리케이션에서는 OSIV(Open Session In View) 패턴으로 View 렌더링까지 확장할 수 있습니다.

**개발 편의성:**

성능 향상보다 더 큰 가치는 개발 편의성입니다. 객체 지향적으로 코드를 작성할 수 있습니다. SQL을 직접 다루지 않아도 됩니다. 일관성 있는 데이터 관리가 자동화됩니다.

**결론:**

영속성 컨텍스트는 적절히 사용하면 성능과 생산성을 모두 향상시킵니다. 하지만 만능은 아니며 상황에 따라 다릅니다. 작은 트랜잭션과 반복 조회가 많은 경우 효과적입니다. 대량 데이터 처리나 복잡한 쿼리에는 다른 접근이 필요합니다. 성능 모니터링과 프로파일링으로 실제 효과를 측정하는 것이 중요합니다.
