# OS 답변 5-8

## 5. 운영체제의 Dual Mode 에 대해 설명해 주세요.

**정의**
Dual Mode는 운영체제가 사용자 모드(User Mode)와 커널 모드(Kernel Mode) 두 가지 실행 모드를 통해 시스템 자원을 보호하는 메커니즘입니다.

**사용자 모드(User Mode)**
- 일반 응용 프로그램이 실행되는 모드입니다
- 제한된 명령어만 실행할 수 있습니다
- 하드웨어 자원에 직접 접근할 수 없습니다
- 메모리 접근이 제한되어 있습니다
- 잘못된 동작이 시스템 전체에 영향을 주지 않습니다

**커널 모드(Kernel Mode)**
- 운영체제 커널이 실행되는 모드입니다
- 모든 명령어를 실행할 수 있습니다
- 하드웨어 자원에 직접 접근 가능합니다
- 전체 메모리에 접근할 수 있습니다
- 시스템의 모든 부분을 제어할 수 있습니다

**모드 전환**
- 시스템 콜 호출 시: 사용자 모드 → 커널 모드
- 인터럽트 발생 시: 사용자 모드 → 커널 모드
- 시스템 콜 완료 시: 커널 모드 → 사용자 모드
- 예외 처리 시: 사용자 모드 → 커널 모드

**하드웨어 지원**
- CPU의 모드 비트를 통해 현재 실행 모드를 추적합니다
- 특권 명령어는 커널 모드에서만 실행 가능하도록 하드웨어적으로 강제됩니다
- 모드 비트 확인을 통해 불법적인 접근을 차단합니다

**장점**
- 시스템 자원을 악의적이거나 잘못된 프로그램으로부터 보호합니다
- 프로그램 간 격리를 제공하여 안정성을 높입니다
- 보안과 안전성을 확보합니다

**실무 활용**
모든 현대 운영체제는 Dual Mode를 기반으로 동작하며, 이는 시스템 보안과 안정성의 핵심 요소입니다. 가상화 기술에서는 하이퍼바이저 모드 등 추가 모드를 사용하기도 합니다.

---

## 6. 왜 유저모드와 커널모드를 구분해야 하나요?

**시스템 안정성 보호**
- 응용 프로그램의 오류가 전체 시스템을 다운시키는 것을 방지합니다
- 한 프로그램의 버그가 다른 프로그램에 영향을 주지 않도록 격리합니다
- 시스템 크래시를 최소화하여 전체적인 안정성을 향상시킵니다

**보안 강화**
- 악의적인 프로그램이 시스템 자원을 무단으로 접근하는 것을 차단합니다
- 중요한 시스템 데이터와 다른 프로세스의 메모리를 보호합니다
- 권한이 없는 작업을 수행하려는 시도를 탐지하고 차단합니다
- 바이러스나 악성코드의 피해를 제한합니다

**자원 관리 및 제어**
- 운영체제가 하드웨어 자원에 대한 독점적 제어권을 유지합니다
- 여러 프로세스 간 자원 분배를 공정하게 관리할 수 있습니다
- CPU, 메모리, 디스크 등의 자원을 효율적으로 할당합니다
- 자원 경쟁 상황을 운영체제가 중재할 수 있습니다

**추상화 제공**
- 하드웨어의 복잡한 세부사항을 숨기고 일관된 인터페이스를 제공합니다
- 응용 프로그램 개발자가 하드웨어를 직접 다루지 않아도 됩니다
- 다양한 하드웨어 플랫폼에서 동일한 코드를 실행할 수 있습니다

**동시성 제어**
- 여러 프로그램이 동시에 실행될 때 발생할 수 있는 충돌을 방지합니다
- 공유 자원에 대한 접근을 동기화할 수 있습니다
- 데드락과 레이스 컨디션을 예방합니다

**감사 및 모니터링**
- 모든 중요한 작업이 커널을 통과하므로 시스템 활동을 추적할 수 있습니다
- 보안 정책을 일관되게 적용할 수 있습니다
- 시스템 사용 통계를 수집하고 분석할 수 있습니다

**실무 활용**
서버 환경에서 여러 사용자의 프로그램이 동시에 실행될 때, 모드 구분이 없다면 한 사용자의 프로그램이 전체 시스템을 장악하거나 다른 사용자의 데이터를 접근할 수 있습니다. Dual Mode는 이러한 위험을 원천적으로 차단합니다.

---

## 7. 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?

**시스템 콜 번호(System Call Number)**
- 각 시스템 콜에는 고유한 번호가 할당되어 있습니다
- 시스템 콜을 호출할 때 이 번호를 레지스터에 저장합니다
- 커널은 이 번호를 통해 어떤 서비스를 요청하는지 식별합니다
- 예: Linux x86-64에서 read는 0번, write는 1번, open은 2번입니다

**시스템 콜 테이블(System Call Table)**
- 운영체제 커널은 시스템 콜 번호를 인덱스로 하는 함수 포인터 배열을 유지합니다
- 각 엔트리는 해당 시스템 콜을 처리하는 커널 함수를 가리킵니다
- 시스템 콜 핸들러는 이 테이블을 참조하여 적절한 함수를 호출합니다
- 테이블은 커널 초기화 시 설정되며 보호된 메모리 영역에 저장됩니다

**매개변수 전달 방법**
- 레지스터를 통한 전달: 빠르지만 전달할 수 있는 매개변수 수가 제한적입니다
- 메모리 블록 전달: 매개변수를 메모리에 저장하고 주소를 레지스터로 전달합니다
- 스택을 통한 전달: 매개변수를 스택에 푸시하고 커널이 팝하여 사용합니다
- 실제로는 이들을 혼합하여 사용합니다

**호출 규약(Calling Convention)**
- 각 아키텍처마다 정해진 호출 규약이 있습니다
- x86-64 Linux의 경우 rax에 시스템 콜 번호, rdi, rsi, rdx, r10, r8, r9에 매개변수를 전달합니다
- ARM에서는 r7에 시스템 콜 번호, r0-r6에 매개변수를 전달합니다

**인터럽트 벡터**
- 시스템 콜은 특정 인터럽트 번호를 통해 호출됩니다
- x86에서는 전통적으로 int 0x80 명령어를 사용했습니다
- 최신 시스템에서는 syscall이나 sysenter 같은 전용 명령어를 사용합니다
- 이 명령어들이 실행되면 CPU가 자동으로 시스템 콜 핸들러로 점프합니다

**구분 과정**
1. 응용 프로그램이 시스템 콜 번호를 레지스터에 설정합니다
2. 매개변수를 정해진 레지스터나 메모리에 저장합니다
3. 시스템 콜 명령어를 실행하여 커널 모드로 전환합니다
4. 커널은 레지스터에서 시스템 콜 번호를 읽습니다
5. 시스템 콜 테이블에서 해당 번호에 대응하는 함수를 찾습니다
6. 해당 커널 함수를 호출하여 서비스를 제공합니다

**실무 활용**
시스템 프로그래밍 시 직접 시스템 콜 번호를 다루기보다는 libc와 같은 시스템 라이브러리가 제공하는 래퍼 함수를 사용합니다. 이들 함수는 내부적으로 적절한 시스템 콜 번호와 매개변수를 설정하여 커널을 호출합니다.

---

## 8. 인터럽트가 무엇인지 설명해 주세요.

**정의**
인터럽트(Interrupt)는 CPU가 현재 실행 중인 작업을 중단하고, 발생한 이벤트를 처리하도록 하는 메커니즘입니다. 하드웨어나 소프트웨어가 CPU의 즉각적인 주의를 요구할 때 사용됩니다.

**특징**
- 비동기적으로 발생합니다
- CPU의 정상적인 실행 흐름을 변경합니다
- 우선순위에 따라 처리 순서가 결정됩니다
- 처리 후 원래 작업으로 복귀합니다

**인터럽트의 목적**
- 효율적인 CPU 활용: 폴링 방식의 비효율성을 해결합니다
- 실시간 응답: 긴급한 이벤트를 즉시 처리할 수 있습니다
- 비동기 처리: CPU가 I/O 완료를 기다리지 않고 다른 작업을 수행할 수 있습니다
- 멀티태스킹: 타이머 인터럽트를 통해 프로세스 전환을 구현합니다

**하드웨어 인터럽트**
- 외부 장치에서 발생하는 신호입니다
- I/O 장치 완료, 타이머, 전원 이상 등이 원인입니다
- 인터럽트 라인을 통해 CPU에 전달됩니다
- 예: 키보드 입력, 디스크 읽기 완료, 네트워크 패킷 도착

**소프트웨어 인터럽트**
- 프로그램 실행 중 명령어에 의해 발생합니다
- 시스템 콜이 대표적인 예입니다
- 예외 상황 처리에도 사용됩니다
- 예: trap, exception, 0으로 나누기, 잘못된 메모리 접근

**인터럽트 벡터 테이블**
- 각 인터럽트 번호에 대응하는 처리 루틴의 주소를 저장합니다
- 메모리의 고정된 위치에 저장됩니다
- 운영체제 부팅 시 초기화됩니다

**동작 과정**
1. 인터럽트 발생
2. 현재 실행 중인 명령어 완료
3. 현재 상태(레지스터, 프로그램 카운터 등) 저장
4. 인터럽트 벡터 테이블을 통해 핸들러 주소 확인
5. 인터럽트 핸들러 실행
6. 저장된 상태 복원
7. 중단되었던 작업 재개

**마스킹**
- 일부 인터럽트는 일시적으로 비활성화할 수 있습니다
- 중요한 작업 수행 중 다른 인터럽트를 차단합니다
- 마스킹 불가능한 인터럽트(NMI)도 존재합니다

**실무 활용**
인터럽트는 운영체제의 핵심 메커니즘으로, 효율적인 I/O 처리, 멀티태스킹, 실시간 시스템 구현에 필수적입니다. 임베디드 시스템에서는 인터럽트 처리 속도가 시스템 성능의 핵심 요소입니다.
