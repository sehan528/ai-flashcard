# Network 답변 모음 (85-88)

## 85. Stateless와 Connectionless에 대해 설명해 주세요.

**Stateless(무상태)**와 **Connectionless(비연결)**는 HTTP 프로토콜의 핵심 특성입니다.

**Stateless (무상태성):**

**정의:**
서버가 클라이언트의 이전 요청 정보를 저장하지 않는 특성입니다. 각 요청은 완전히 독립적이며 이전 요청과 무관합니다.

**특징:**
서버는 클라이언트의 상태, 세션, 컨텍스트를 유지하지 않습니다. 매 요청마다 필요한 모든 정보를 포함해야 합니다. 요청 간에 어떤 관계도 존재하지 않습니다.

**예시:**
사용자가 로그인 후 상품 목록을 조회하고, 장바구니에 추가하는 과정에서 각 요청은 독립적입니다. 서버는 "이 사용자가 방금 로그인했다"는 정보를 자동으로 기억하지 않습니다.

**장점:**

**확장성:**
서버가 상태를 저장하지 않으므로 어떤 서버든 요청을 처리할 수 있습니다. 로드 밸런서가 요청을 자유롭게 분산할 수 있습니다. 서버 추가/제거가 쉽습니다.

**단순성:**
서버 구현이 단순해집니다. 메모리 관리 부담이 줄어듭니다. 세션 동기화 문제가 없습니다.

**안정성:**
서버 크래시 시에도 다른 서버가 즉시 대체할 수 있습니다. 상태 손실 위험이 없습니다.

**단점:**

**반복 전송:**
매 요청마다 인증 정보 등을 다시 보내야 합니다. 네트워크 트래픽이 증가합니다.

**사용자 경험:**
로그인 상태, 장바구니 등을 유지하기 어렵습니다. 쿠키, 세션, 토큰 등 별도 메커니즘이 필요합니다.

**해결 방법:**

**쿠키(Cookie):**
클라이언트가 상태 정보를 저장하고 매 요청마다 전송합니다.

**세션(Session):**
서버가 세션 ID만 발급하고 실제 데이터는 서버에 저장합니다. 엄밀히는 Stateful이지만 HTTP는 여전히 Stateless입니다.

**토큰(JWT):**
클라이언트가 암호화된 토큰을 보관하고 매 요청에 포함합니다. 서버는 토큰을 검증만 하고 저장하지 않습니다.

**Connectionless (비연결성):**

**정의:**
서버와 클라이언트가 연결을 지속적으로 유지하지 않는 특성입니다. 요청과 응답이 완료되면 TCP 연결을 끊습니다.

**HTTP/1.0의 동작:**
클라이언트가 요청마다 새로운 TCP 연결을 생성합니다. 서버가 응답하면 즉시 연결을 종료합니다. 하나의 HTML 페이지에 10개의 이미지가 있다면 11번의 연결이 필요합니다.

**장점:**

**서버 리소스 절약:**
불필요한 연결을 유지하지 않아 메모리와 포트를 절약합니다. 동시 사용자 수가 많아도 부담이 적습니다.

**단순성:**
연결 관리의 복잡성이 줄어듭니다.

**단점:**

**성능 저하:**
매번 TCP 3-way handshake를 수행해야 합니다. 연결 수립에 시간이 소요됩니다(1.5 RTT). 리소스가 많은 페이지는 매우 느립니다.

**오버헤드:**
반복적인 연결/종료로 CPU와 네트워크 자원을 낭비합니다.

**HTTP/1.1의 개선 - Keep-Alive:**

**Persistent Connection:**
HTTP/1.1부터 기본적으로 연결을 유지합니다. Connection: keep-alive 헤더를 사용합니다. 한 연결로 여러 요청/응답을 처리합니다.

**타임아웃:**
일정 시간(예: 5초) 동안 요청이 없으면 연결을 종료합니다. 서버 리소스를 절약하면서도 성능을 개선합니다.

**HTTP/2의 개선:**

**멀티플렉싱:**
하나의 연결에서 여러 요청/응답을 동시에 처리합니다. 연결 비용을 최소화하면서 성능을 극대화합니다.

**비교:**

**Stateless vs Stateful:**
- Stateless: HTTP, DNS, UDP
- Stateful: TCP, FTP 제어 연결, WebSocket

**Connectionless vs Connection-Oriented:**
- Connectionless: HTTP/1.0, UDP
- Connection-Oriented: TCP, WebSocket

**실무적 의미:**

**RESTful API 설계:**
Stateless 원칙을 따라 각 요청이 자체 완결적이어야 합니다. 인증 토큰, 필요한 파라미터를 모두 포함합니다.

**확장성:**
Stateless 특성 덕분에 수평 확장이 용이합니다. 클라우드 환경에서 오토스케일링이 가능합니다.

**캐싱:**
Stateless 요청은 캐싱하기 쉽습니다. 같은 요청은 같은 응답을 반환하므로 CDN, 프록시 캐시를 활용할 수 있습니다.

---

## 86. 왜 HTTP는 Stateless 구조를 채택하고 있을까요?

HTTP가 Stateless 구조를 채택한 이유는 **확장성, 단순성, 안정성**을 위해서입니다.

**역사적 배경:**

**웹의 초기 목적:**
1990년대 초 웹은 단순한 문서 공유 시스템으로 설계되었습니다. 정적 HTML 페이지를 요청하고 받는 것이 주요 용도였습니다. 복잡한 상태 관리가 필요 없었습니다.

**단순성 우선:**
팀 버너스리는 단순하고 확장 가능한 시스템을 원했습니다. Stateless는 가장 단순한 설계였습니다.

**확장성(Scalability):**

**서버 독립성:**
서버가 상태를 저장하지 않으므로 요청이 어느 서버로 가도 상관없습니다. 로드 밸런서가 자유롭게 트래픽을 분산할 수 있습니다.

**수평 확장:**
서버를 추가하거나 제거하는 것이 간단합니다. 세션 동기화나 상태 복제가 필요 없습니다. 트래픽 증가 시 서버만 추가하면 됩니다.

**무한 확장 가능:**
상태 정보를 공유할 필요가 없어 이론적으로 무한대로 확장할 수 있습니다. 대규모 웹 서비스(Google, Facebook)가 가능한 이유입니다.

**단순성(Simplicity):**

**구현 간소화:**
서버가 클라이언트 상태를 추적하지 않아 코드가 단순합니다. 메모리 관리, 세션 타임아웃, 동기화 등의 복잡성이 없습니다.

**디버깅 용이:**
각 요청이 독립적이므로 문제를 격리하기 쉽습니다. 특정 요청만 재현하면 버그를 찾을 수 있습니다.

**프로토콜 진화:**
Stateless 설계로 HTTP 프로토콜을 점진적으로 발전시킬 수 있었습니다.

**안정성(Reliability):**

**장애 격리:**
한 서버가 크래시해도 다른 서버가 즉시 대체할 수 있습니다. 클라이언트는 단순히 다시 요청하면 됩니다.

**상태 손실 없음:**
서버에 저장된 상태가 없으므로 손실될 것도 없습니다. 롤링 재시작이 안전합니다.

**캐싱 가능성:**

**프록시 캐시:**
Stateless 요청은 캐싱하기 쉽습니다. 같은 URL에 같은 요청은 같은 결과를 반환합니다.

**CDN 활용:**
정적 콘텐츠를 전 세계 CDN에 캐싱할 수 있습니다. 서버 부하를 크게 줄입니다.

**네트워크 효율:**

**중간 장비:**
프록시, 게이트웨이, 캐시 서버 등이 요청을 독립적으로 처리할 수 있습니다. 복잡한 상태 동기화가 필요 없습니다.

**RESTful 아키텍처:**

**REST 원칙:**
Roy Fielding의 REST 아키텍처는 Stateless를 핵심 제약 조건으로 정의합니다. Stateless 덕분에 REST API의 장점이 실현됩니다.

**트레이드오프:**

**상태 유지의 필요성:**
실제 웹 애플리케이션은 상태가 필요합니다(로그인, 장바구니 등). Stateless HTTP 위에 상태 관리 레이어를 추가합니다(쿠키, 세션, 토큰).

**복잡성 이동:**
서버의 복잡성이 클라이언트나 별도 저장소(Redis, DB)로 이동합니다. 하지만 HTTP 자체는 단순하게 유지됩니다.

**실무적 해결:**

**클라이언트 측 저장:**
쿠키, LocalStorage, SessionStorage에 상태를 저장합니다.

**토큰 기반 인증:**
JWT 같은 자체 포함 토큰을 사용합니다. 서버는 토큰을 검증만 하고 저장하지 않습니다.

**외부 세션 저장소:**
Redis, Memcached에 세션을 저장합니다. 여러 서버가 공유할 수 있습니다.

**대안 프로토콜:**

**WebSocket:**
Stateful한 양방향 연결이 필요한 경우 사용합니다. 실시간 채팅, 게임, 협업 도구 등에 적합합니다.

**HTTP/2 Server Push:**
일부 상태를 유지하는 것처럼 동작할 수 있습니다.

**결론:**
HTTP의 Stateless 설계는 웹이 글로벌 규모로 확장될 수 있었던 핵심 요소입니다. 단순성과 확장성의 이점이 상태 관리의 불편함을 상회합니다. 필요한 경우 애플리케이션 레벨에서 상태를 추가하면 됩니다.

---

## 87. Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?

Connectionless의 성능 문제는 여러 **최적화 기법**으로 해결되었습니다.

**문제점:**

**반복적인 연결 수립:**
매 요청마다 TCP 3-way handshake가 필요합니다(1.5 RTT). 수십 개의 리소스가 있는 웹 페이지는 매우 느립니다.

**느린 시작(Slow Start):**
새 TCP 연결은 혼잡 제어의 Slow Start 단계를 거칩니다. 초기 전송 속도가 제한됩니다.

**자원 낭비:**
연결/종료에 CPU와 메모리가 소모됩니다.

**해결 방법:**

**1. HTTP/1.1 Keep-Alive (Persistent Connection):**

**원리:**
한 번 수립한 TCP 연결을 재사용합니다. Connection: keep-alive 헤더로 연결 유지를 요청합니다. 서버가 일정 시간 동안 연결을 열어둡니다.

**효과:**
여러 요청이 하나의 연결로 처리됩니다. 핸드셰이크 오버헤드가 대폭 감소합니다. 페이지 로딩 속도가 2-3배 향상됩니다.

**타임아웃:**
일정 시간(예: 5초) 동안 요청이 없으면 연결을 종료합니다. 서버 리소스를 절약하면서도 성능을 유지합니다.

**2. HTTP Pipelining:**

**원리:**
첫 번째 응답을 기다리지 않고 여러 요청을 연속으로 보냅니다. 네트워크를 더 효율적으로 사용합니다.

**한계:**
응답은 요청 순서대로 받아야 합니다(HOL Blocking). 프록시 서버와의 호환성 문제. 실무에서 거의 사용되지 않습니다.

**3. HTTP/2 Multiplexing:**

**원리:**
하나의 TCP 연결에서 여러 요청/응답을 동시에 처리합니다. 스트림 단위로 독립적으로 전송됩니다. 순서 제약 없이 병렬 처리가 가능합니다.

**효과:**
연결 수를 1개로 줄여도 성능이 우수합니다. HOL Blocking을 애플리케이션 레벨에서 해결했습니다. 헤더 압축(HPACK)으로 추가 최적화됩니다.

**4. HTTP/3 (QUIC):**

**원리:**
UDP 기반 QUIC 프로토콜을 사용합니다. 0-RTT 연결 재개가 가능합니다. 스트림별 독립적인 전송으로 TCP HOL Blocking도 해결합니다.

**효과:**
첫 연결은 1-RTT, 재연결은 0-RTT로 매우 빠릅니다. 모바일 환경에서 성능이 크게 향상됩니다.

**5. 도메인 샤딩(Domain Sharding):**

**원리:**
리소스를 여러 도메인(cdn1, cdn2, cdn3)에 분산합니다. 브라우저가 도메인당 6-8개의 병렬 연결을 생성합니다. 총 병렬 다운로드 수가 증가합니다.

**적용:**
HTTP/1.1 환경에서 유용합니다. HTTP/2에서는 오히려 역효과입니다(연결이 분산되어 멀티플렉싱 이점 감소).

**6. 리소스 최적화:**

**번들링:**
여러 JS/CSS 파일을 하나로 합칩니다. 요청 수를 줄입니다.

**스프라이트:**
여러 이미지를 하나의 파일로 결합합니다.

**인라이닝:**
작은 리소스를 HTML에 직접 포함합니다(Base64 인코딩).

**7. 캐싱:**

**브라우저 캐시:**
Cache-Control, Expires 헤더로 리소스를 캐시합니다. 재방문 시 요청 자체를 하지 않습니다.

**CDN:**
정적 리소스를 전 세계에 배포합니다. 사용자와 가까운 서버에서 제공합니다.

**8. 프리커넥트(Preconnect):**

**원리:**
필요한 도메인에 미리 연결합니다.
```
<link rel="preconnect" href="https://api.example.com">
```
DNS 조회, TCP 핸드셰이크, TLS 핸드셰이크를 사전에 수행합니다.

**9. DNS 프리페치:**

**원리:**
필요한 도메인의 DNS를 미리 조회합니다.
```
<link rel="dns-prefetch" href="//cdn.example.com">
```

**10. TCP Fast Open:**

**원리:**
첫 SYN 패킷에 데이터를 포함합니다. 재연결 시 핸드셰이크 없이 즉시 데이터 전송합니다.

**효과:**
연결 수립 시간을 1 RTT 절약합니다.

**11. Early Hints (HTTP 103):**

**원리:**
서버가 최종 응답 전에 힌트를 먼저 보냅니다. 브라우저가 CSS, JS를 미리 로드할 수 있습니다.

**실무 적용:**

**HTTP/1.1:**
Keep-Alive + 도메인 샤딩 + 캐싱 + 번들링

**HTTP/2:**
단일 연결 + 멀티플렉싱 + 서버 푸시 + 캐싱

**HTTP/3:**
QUIC + 0-RTT + 연결 마이그레이션 + 캐싱

**성능 비교:**

**HTTP/1.0 (Connectionless):**
10개 리소스 = 10번 연결 = 15 RTT

**HTTP/1.1 (Keep-Alive):**
10개 리소스 = 1번 연결 + 10번 순차 요청 = 1.5 RTT + 지연

**HTTP/2:**
10개 리소스 = 1번 연결 + 병렬 전송 = 1.5 RTT + 최소 지연

**HTTP/3:**
10개 리소스 = 0-1 RTT + 병렬 전송 = 최소 지연

**결론:**
초기 HTTP의 Connectionless 문제는 Keep-Alive, 멀티플렉싱, QUIC 등으로 해결되었습니다. 현대 웹은 연결을 효율적으로 재사용하여 뛰어난 성능을 제공합니다.

---

## 88. TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?

**TCP Keep-Alive**와 **HTTP Keep-Alive**는 이름은 비슷하지만 **목적과 동작 방식이 다릅니다**.

**TCP Keep-Alive:**

**목적:**
유휴 상태의 TCP 연결이 여전히 살아있는지 확인합니다. Dead Connection을 감지하고 정리합니다.

**동작 방식:**
일정 시간(기본 2시간) 동안 데이터 전송이 없으면 Keep-Alive 프로브를 보냅니다. 작은 패킷(일반적으로 1바이트)을 전송합니다. 상대방이 ACK로 응답하면 연결이 살아있다고 판단합니다. 응답이 없으면 일정 간격(기본 75초)으로 재시도합니다(기본 9회). 모두 실패하면 연결을 종료합니다.

**레벨:**
전송 계층(Layer 4) 메커니즘입니다. 운영체제 커널에서 처리됩니다. 애플리케이션과 무관하게 동작합니다.

**설정:**
소켓 옵션 SO_KEEPALIVE로 활성화합니다. sysctl로 시스템 전역 설정을 조정합니다. Linux: tcp_keepalive_time, tcp_keepalive_intvl, tcp_keepalive_probes.

**사용 사례:**
방화벽이나 NAT가 유휴 연결을 끊는 것을 방지합니다. 서버/클라이언트 크래시를 감지합니다. 장시간 유지되는 연결(DB, SSH)에서 유용합니다.

**문제점:**
기본 타임아웃(2시간)이 너무 깁니다. 빠른 감지가 필요한 경우 부적합합니다. 네트워크 트래픽을 약간 증가시킵니다.

**HTTP Keep-Alive:**

**목적:**
TCP 연결을 재사용하여 여러 HTTP 요청/응답을 처리합니다. 연결 수립 오버헤드를 줄입니다.

**동작 방식:**
HTTP/1.1에서 기본적으로 활성화됩니다. Connection: keep-alive 헤더로 명시할 수 있습니다. 한 요청/응답이 끝나도 TCP 연결을 즉시 끊지 않습니다. 다음 요청이 올 때까지 대기합니다(일반적으로 5-120초). 타임아웃 내에 요청이 없으면 연결을 종료합니다.

**레벨:**
애플리케이션 계층(Layer 7) 메커니즘입니다. 웹 서버와 클라이언트가 처리합니다.

**헤더:**
```
요청:
Connection: keep-alive

응답:
Connection: keep-alive
Keep-Alive: timeout=5, max=100
```

**timeout:**
연결을 유지할 최대 시간(초)입니다.

**max:**
이 연결로 처리할 최대 요청 수입니다.

**사용 사례:**
웹 페이지의 여러 리소스(HTML, CSS, JS, 이미지)를 하나의 연결로 다운로드합니다. API 클라이언트가 여러 요청을 연속으로 보냅니다. 페이지 로딩 속도를 크게 향상시킵니다.

**HTTP/1.0 vs HTTP/1.1:**
HTTP/1.0: 기본적으로 비활성화, 명시적으로 요청해야 함. HTTP/1.1: 기본적으로 활성화, Connection: close로 비활성화 가능.

**주요 차이점:**

**계층:**
- TCP Keep-Alive: 전송 계층(OS 커널)
- HTTP Keep-Alive: 애플리케이션 계층(웹 서버/클라이언트)

**목적:**
- TCP: 연결 상태 확인, Dead Connection 감지
- HTTP: 연결 재사용, 성능 최적화

**타임아웃:**
- TCP: 매우 김(2시간 기본)
- HTTP: 짧음(5-120초)

**프로브:**
- TCP: Keep-Alive 프로브 패킷 전송
- HTTP: 프로브 없음, 단순히 연결 유지

**설정 위치:**
- TCP: 운영체제 설정, 소켓 옵션
- HTTP: 웹 서버 설정, HTTP 헤더

**대상:**
- TCP: 모든 TCP 연결(HTTP, FTP, SSH 등)
- HTTP: HTTP 연결만

**함께 사용:**
두 메커니즘은 독립적으로 동작하며 동시에 활성화될 수 있습니다. HTTP Keep-Alive로 연결을 재사용하고, TCP Keep-Alive로 연결 상태를 확인합니다.

**실무 예시:**

**웹 브라우징:**
HTTP Keep-Alive가 활성화되어 여러 리소스를 빠르게 다운로드합니다. TCP Keep-Alive는 대부분 비활성화되어 있습니다(필요없음).

**WebSocket:**
장시간 연결 유지를 위해 TCP Keep-Alive를 활성화하는 경우가 많습니다. 애플리케이션 레벨 Ping/Pong도 함께 사용합니다.

**데이터베이스 연결:**
Connection Pool이 TCP Keep-Alive를 활성화하여 유휴 연결을 유지합니다.

**선택 기준:**
단기 연결(웹): HTTP Keep-Alive만으로 충분. 장기 연결(DB, SSH): TCP Keep-Alive 활성화 권장. 방화벽/NAT 뒤: 두 메커니즘 모두 고려.

**HTTP/2와 HTTP/3:**
HTTP/2: Keep-Alive 개념이 없음, 멀티플렉싱으로 하나의 연결 사용. HTTP/3: QUIC의 Connection ID로 연결 유지, 별도 Keep-Alive 불필요.
