## 질문 113: 함수형 프로그래밍의 특징과 장점은 무엇인가요?

**정의:**
함수형 프로그래밍은 순수 함수와 불변 데이터를 중심으로 프로그램을 구성하는 선언적 프로그래밍 패러다임입니다. 함수를 일급 객체로 다루고, 부수 효과를 최소화하며, 상태 변경 대신 값의 변환에 집중합니다.

**특징/원리:**
- 순수 함수: 같은 입력에 항상 같은 출력을 반환하고 부수 효과가 없음
- 불변성: 데이터를 변경하지 않고 새로운 데이터를 생성
- 일급 함수: 함수를 값처럼 다루어 변수에 할당하거나 인자로 전달 가능
- 선언적: 어떻게(how)보다 무엇을(what) 계산할지 기술

**순수 함수:**
- 결정적: 입력이 같으면 출력도 항상 같음
- 부수 효과 없음: 외부 상태를 변경하지 않고 파일, 네트워크 등 I/O 수행 안 함
- 참조 투명성: 표현식을 그 결과값으로 대체 가능
- 장점: 테스트가 쉽고 예측 가능하며 병렬 처리에 안전

**불변성:**
- 상태 변경 금지: 데이터를 수정하는 대신 새로운 데이터 생성
- 공유 안전: 불변 데이터는 여러 곳에서 안전하게 공유 가능
- 시간 여행: 이전 상태를 보존하여 되돌리기나 재생 가능
- 장점: 동시성 문제 감소하고 디버깅 용이

**고차 함수:**
- 정의: 함수를 인자로 받거나 함수를 반환하는 함수
- map: 각 요소를 변환하여 새 컬렉션 생성
- filter: 조건에 맞는 요소만 선택
- reduce: 요소들을 하나의 값으로 집계
- 장점: 공통 패턴을 추상화하여 재사용성 향상

**함수 합성:**
- 작은 함수 조합: 단순한 함수들을 조합하여 복잡한 기능 구현
- 파이프라인: 데이터가 함수 체인을 통과하며 변환
- 가독성: 각 단계가 명확하여 이해하기 쉬움

**장점:**
- 테스트 용이: 순수 함수는 독립적으로 테스트 가능
- 병렬 처리: 부수 효과가 없어 안전하게 병렬화 가능
- 모듈화: 작은 함수들로 구성되어 재사용과 조합 용이
- 디버깅: 불변 데이터로 상태 추적이 명확

**실무 활용:**
- React의 함수형 컴포넌트와 Hooks로 선언적 UI 구축
- 데이터 처리 파이프라인을 map, filter, reduce로 간결하게 표현
- Redux에서 불변성 유지하여 상태 변화 추적 및 시간 여행 디버깅

---

## 질문 114: 순수 함수(Pure Function)란 무엇인가요?

**정의:**
순수 함수는 같은 입력에 대해 항상 같은 출력을 반환하고, 외부 상태를 변경하거나 의존하지 않는 함수입니다. 함수형 프로그래밍의 핵심 개념으로, 예측 가능하고 테스트하기 쉬운 코드를 작성하는 기반이 됩니다.

**특징/원리:**
- 결정적: 입력 인자만으로 출력이 완전히 결정됨
- 부수 효과 없음: 함수 외부의 어떤 것도 변경하지 않음
- 참조 투명성: 함수 호출을 그 결과값으로 대체해도 프로그램 동작이 같음
- 독립성: 외부 상태나 컨텍스트에 의존하지 않음

**순수 함수 조건:**
- 동일 입력 동일 출력: 파라미터가 같으면 결과도 항상 같음
- 외부 상태 읽기 금지: 전역 변수, 파일, 데이터베이스 등 외부 상태 참조 안 함
- 외부 상태 변경 금지: 전역 변수 수정, 파일 쓰기, 네트워크 통신 등 부수 효과 없음
- 예외 금지: 예외 발생도 부수 효과로 간주될 수 있음

**부수 효과 종류:**
- 변수 수정: 외부 변수나 파라미터로 받은 객체의 상태 변경
- I/O 작업: 콘솔 출력, 파일 읽기/쓰기, 네트워크 통신
- 예외 발생: 함수를 호출한 쪽에 예외를 던짐
- 시간 의존: 현재 시각, 난수 등 호출 시점에 따라 결과가 달라짐

**장점:**
- 테스트 용이: 목이나 스텁 없이 입력만으로 테스트 가능
- 병렬 처리: 스레드 안전하여 동시 실행에 안전
- 캐싱: 메모이제이션으로 결과를 캐시하여 성능 향상
- 디버깅: 입력과 출력만 확인하면 되어 디버깅 쉬움
- 합성: 순수 함수끼리 자유롭게 조합 가능

**비순수 함수 예시:**
- 전역 변수 참조나 수정
- 현재 시각 반환 (Date.now(), time.Now())
- 난수 생성 (Math.random(), rand.Int())
- 콘솔 출력 (console.log(), fmt.Println())
- 데이터베이스 조회나 수정

**순수 함수로 만들기:**
- 의존성 주입: 필요한 모든 데이터를 파라미터로 전달
- 새 객체 반환: 기존 객체를 수정하지 않고 새 객체 생성하여 반환
- 부수 효과 분리: 순수 함수에서 계산만 하고 I/O는 호출자가 담당

**실무 활용:**
- 비즈니스 로직을 순수 함수로 작성하여 테스트와 재사용성 향상
- reducer 함수를 순수하게 유지하여 상태 관리 예측 가능하게 구현
- 순수 함수로 계산하고 부수 효과는 경계에서만 수행하여 코드 구조화

---

## 질문 115: 불변성(Immutability)의 중요성과 구현 방법은 무엇인가요?

**정의:**
불변성은 데이터를 생성 후 변경하지 않는 속성으로, 기존 데이터를 수정하는 대신 새로운 데이터를 생성합니다. 함수형 프로그래밍의 핵심 개념으로, 상태 변화를 명시적으로 만들어 예측 가능하고 안전한 코드를 작성할 수 있게 합니다.

**특징/원리:**
- 수정 불가: 데이터 생성 후 내용을 변경할 수 없음
- 새 객체 생성: 변경이 필요하면 수정된 새 객체를 만듦
- 공유 안전: 불변 데이터는 여러 곳에서 안전하게 공유 가능
- 시간적 독립: 데이터가 시간에 따라 변하지 않아 추론 용이

**중요성:**
- 동시성 안전: 여러 스레드가 동시에 접근해도 경쟁 조건 없음
- 예측 가능: 데이터가 변하지 않아 프로그램 동작 예측 쉬움
- 디버깅: 상태 변화 추적이 명확하여 버그 찾기 쉬움
- 시간 여행: 이전 상태를 보존하여 되돌리기나 재생 가능
- 캐싱: 불변 데이터는 안전하게 캐시 가능

**구현 방법:**
- 원시 타입: 불변이므로 별도 조치 불필요
- 객체 동결: Object.freeze()로 객체를 읽기 전용으로 만듦
- 복사 후 수정: 스프레드 연산자나 Object.assign()으로 복사 후 수정
- 불변 라이브러리: Immutable.js, Immer 등 불변 자료구조 라이브러리 사용
- 함수형 메서드: map, filter, concat 등 새 배열을 반환하는 메서드 활용

**JavaScript 구현:**
- const: 재할당을 방지하지만 객체 내용은 변경 가능
- Object.freeze: 얕은 동결로 1단계만 불변, 중첩 객체는 재귀적으로 동결 필요
- 스프레드: 얕은 복사로 새 객체 생성
- Immer: produce 함수로 불변 업데이트를 변경하는 것처럼 작성 가능

**불변 자료구조:**
- 구조적 공유: 변경되지 않은 부분은 공유하여 메모리 효율
- 영속 자료구조: 이전 버전도 유지하면서 새 버전 생성
- 성능: 최적화된 불변 자료구조는 가변보다 약간 느리지만 충분히 빠름

**주의사항:**
- 얕은 복사: 중첩 객체는 참조가 복사되어 진정한 불변 아님
- 성능: 대용량 데이터를 매번 복사하면 성능 저하 가능
- 메모리: 이전 버전을 모두 유지하면 메모리 사용량 증가
- 균형: 성능과 안전성 사이 균형 필요

**실무 활용:**
- React에서 state를 불변으로 관리하여 변경 감지와 렌더링 최적화
- Redux의 reducer는 불변 업데이트를 수행하여 시간 여행 디버깅 가능
- 멀티스레드 환경에서 불변 데이터로 동기화 오버헤드 제거

---

## 질문 116: 동시성(Concurrency)과 병렬성(Parallelism)의 차이점은 무엇인가요?

**정의:**
동시성은 여러 작업을 논리적으로 동시에 다루는 것이고, 병렬성은 물리적으로 동시에 실행하는 것입니다. 동시성은 작업 구조에 관한 것이고, 병렬성은 실행 방식에 관한 것으로, 동시성이 없어도 병렬성이 가능하고 그 반대도 가능합니다.

**특징/원리:**
- 동시성: 여러 작업을 빠르게 전환하며 처리하여 동시에 진행되는 것처럼 보임
- 병렬성: 여러 CPU 코어에서 실제로 동시에 작업 실행
- 독립성: 동시성과 병렬성은 독립적인 개념이며 함께 사용될 수도 있음
- 목적: 동시성은 구조적 개선, 병렬성은 성능 향상

**동시성(Concurrency):**
- 논리적 개념: 여러 작업을 독립적으로 구성하여 동시에 다룸
- 인터리빙: 단일 코어에서도 시간 분할로 여러 작업 처리
- I/O 대기: I/O 작업 중 다른 작업을 수행하여 대기 시간 활용
- 예시: 웹 서버가 여러 요청을 처리, 비동기 프로그래밍
- 목표: 응답성과 처리량 향상

**병렬성(Parallelism):**
- 물리적 개념: 여러 작업을 실제로 동시에 실행
- 멀티코어: 여러 CPU 코어를 활용하여 진정한 동시 실행
- CPU 집약적: 계산 집약적 작업을 병렬 처리하여 속도 향상
- 예시: 대용량 배열 정렬, 행렬 연산, 영상 처리
- 목표: 처리 속도 향상

**관계:**
- 동시성 없이 병렬: 데이터 병렬성으로 동일 작업을 여러 데이터에 병렬 적용
- 병렬 없이 동시성: 단일 코어에서 비동기나 멀티스레딩으로 동시성 구현
- 동시성 + 병렬: 동시성 있는 프로그램을 여러 코어에서 병렬 실행
- 선택: 문제 특성에 따라 동시성, 병렬성 또는 둘 다 선택

**구현 방법:**
- 동시성: 스레드, 코루틴, 비동기, 이벤트 루프, 액터 모델
- 병렬성: 멀티프로세싱, 멀티스레딩 (GIL 없는 환경), GPU 연산
- 하이브리드: 비동기 + 워커 풀, 고루틴 + 멀티코어

**실무 활용:**
- 웹 서버는 동시성으로 많은 요청을 동시에 처리
- 데이터 분석은 병렬성으로 계산 속도 향상
- 마이크로서비스는 동시성과 병렬성을 조합하여 높은 처리량 달성

---
