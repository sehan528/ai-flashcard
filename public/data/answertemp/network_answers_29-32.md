# Network 답변 모음 (29-32)

## 29. Checksum이 무엇인가요?

**Checksum**은 데이터의 무결성을 검증하기 위해 계산되는 값으로, 전송 중 오류가 발생했는지 확인하는 데 사용됩니다.

**기본 원리:**
송신자가 데이터로부터 특정 알고리즘을 사용하여 checksum 값을 계산하고 데이터와 함께 전송합니다. 수신자는 받은 데이터로 동일한 알고리즘을 적용하여 checksum을 계산하고, 수신한 checksum과 비교합니다.

**계산 방법:**
- **단순 합산**: 데이터 바이트들을 모두 더하고 오버플로우를 처리합니다
- **1의 보수 합**: TCP/UDP에서 사용하는 방식으로, 16비트 단위로 더한 후 1의 보수를 취합니다
- **CRC(Cyclic Redundancy Check)**: 다항식 나눗셈을 이용한 더 강력한 방법입니다

**네트워크에서의 활용:**
여러 프로토콜 계층에서 checksum을 사용하여 데이터 무결성을 검증합니다:
- **IP 계층**: IP 헤더의 무결성 검증
- **전송 계층**: TCP/UDP 세그먼트의 무결성 검증
- **데이터링크 계층**: 이더넷 프레임의 CRC 검증

**검출 가능한 오류:**
- 비트 반전 오류
- 일부 다중 비트 오류
- 전송 중 데이터 손상

**한계:**
- **오류 정정 불가**: 오류를 발견할 수는 있지만 수정할 수는 없습니다
- **완벽하지 않음**: 일부 오류 패턴은 검출하지 못할 수 있습니다
- **충돌 가능성**: 서로 다른 데이터가 같은 checksum을 가질 수 있습니다

**pseudo-header:**
TCP와 UDP는 checksum 계산 시 IP 헤더의 일부 정보(송신/수신 IP 주소, 프로토콜 번호)를 포함하는 pseudo-header를 사용합니다. 이는 잘못된 목적지로 전달되는 것을 방지합니다.

**성능 고려사항:**
checksum 계산은 CPU 자원을 소모하지만, 현대 하드웨어에서는 오프로딩 기능을 통해 네트워크 카드가 직접 계산하여 CPU 부담을 줄입니다.

**보안 측면:**
checksum은 무결성 검증용이지 보안용이 아닙니다. 의도적인 변조를 막기 위해서는 암호학적 해시(SHA, MD5 등)나 MAC(Message Authentication Code)를 사용해야 합니다.

**IPv6의 변화:**
IPv6는 IP 헤더에서 checksum을 제거했습니다. 상위 계층(TCP/UDP)과 하위 계층(데이터링크)에서 이미 검증하므로 중복이라고 판단했기 때문입니다.

**UDP checksum:**
IPv4에서는 UDP checksum이 선택사항이었지만, IPv6에서는 필수가 되었습니다.

**실무적 의미:**
checksum은 네트워크 통신의 기본적인 신뢰성 메커니즘으로, 물리적 전송 오류를 조기에 발견하여 상위 계층으로 전달되는 것을 방지합니다.

---

## 30. TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?

**TCP와 UDP 모두 checksum을 수행**합니다. 두 프로토콜 모두 전송 계층에서 데이터 무결성을 검증합니다.

**TCP의 Checksum:**
TCP는 항상 필수적으로 checksum을 계산하고 검증합니다. TCP 헤더와 데이터를 포함한 전체 세그먼트에 대해 checksum을 수행합니다.

**TCP Checksum의 필수성:**
TCP는 신뢰성 있는 전송을 보장해야 하므로, checksum은 필수 항목입니다. checksum 검증에 실패하면 해당 세그먼트를 폐기하고 재전송을 요청합니다.

**UDP의 Checksum:**
UDP도 checksum 필드를 가지고 있으며, IPv6에서는 필수이지만 IPv4에서는 선택사항입니다.

**IPv4에서의 UDP Checksum:**
IPv4 환경에서 UDP checksum은 선택사항입니다. 계산하지 않으면 checksum 필드를 0으로 설정합니다. 하지만 대부분의 현대 구현은 성능보다 안정성을 위해 checksum을 수행합니다.

**IPv6에서의 UDP Checksum:**
IPv6는 IP 계층에서 checksum을 제거했기 때문에, UDP checksum이 필수가 되었습니다. 신뢰성 검증 계층이 하나 줄어들었으므로 UDP에서 반드시 검증해야 합니다.

**Checksum 계산 범위:**
두 프로토콜 모두:
- Pseudo-header (송신/수신 IP, 프로토콜, 길이)
- 프로토콜 헤더
- 데이터 부분

**오류 처리 차이:**
- **TCP**: Checksum 오류 발견 시 세그먼트를 폐기하고 재전송을 통해 복구합니다
- **UDP**: Checksum 오류 발견 시 데이터그램을 폐기하지만 재전송 메커니즘이 없습니다

**성능 영향:**
checksum 계산은 약간의 오버헤드를 발생시키지만, 현대 시스템에서는 하드웨어 가속(offloading)을 통해 영향을 최소화합니다.

**실시간 애플리케이션:**
일부 실시간 스트리밍 애플리케이션에서는 UDP checksum을 비활성화하여 지연을 최소화하기도 했지만, 현재는 하드웨어 성능 향상으로 대부분 활성화합니다.

**ICMPv6의 변화:**
IPv6 환경에서는 ICMP도 checksum이 필수가 되었습니다. 전반적으로 IPv6는 상위 계층의 checksum을 더 강조합니다.

**결론:**
TCP와 UDP 모두 checksum을 수행하지만, TCP는 항상 필수이고 UDP는 IPv6에서만 필수입니다. 두 프로토콜 모두 데이터 무결성 검증의 기본 메커니즘으로 checksum을 사용합니다.

---

## 31. 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?

아니요, **checksum은 오류를 검출만 할 수 있고 정정할 수는 없습니다**.

**오류 검출과 오류 정정의 차이:**
- **오류 검출(Error Detection)**: 데이터에 오류가 있는지 확인만 합니다
- **오류 정정(Error Correction)**: 오류가 어디에 있고 원래 값이 무엇인지 찾아 수정합니다

**Checksum의 한계:**
checksum은 데이터가 손상되었다는 사실만 알려줄 뿐, 어느 비트가 잘못되었는지, 원래 값이 무엇인지는 알 수 없습니다. 단순히 계산된 값과 수신한 값이 다르다는 것만 확인합니다.

**오류 발견 시 처리:**
- **TCP**: 오류가 발견된 세그먼트를 폐기하고 재전송을 요청합니다
- **UDP**: 오류가 발견된 데이터그램을 폐기하고 끝입니다 (재전송 없음)
- **IP**: 오류가 발견된 패킷을 폐기합니다

**왜 정정하지 않을까:**
checksum은 단순한 알고리즘으로 오버헤드가 적지만, 이는 정정에 필요한 충분한 정보를 제공하지 못합니다. 정정을 위해서는 더 많은 중복 데이터가 필요합니다.

**오류 정정 코드(ECC):**
실제로 오류를 정정하려면 다음과 같은 기법이 필요합니다:
- **해밍 코드(Hamming Code)**: 단일 비트 오류 정정 가능
- **Reed-Solomon 코드**: 다중 비트 오류 정정 가능
- **Turbo 코드, LDPC 코드**: 무선 통신에서 사용

**네트워크에서의 오류 정정:**
물리 계층과 데이터링크 계층에서는 일부 오류 정정 기법을 사용하기도 합니다:
- **무선 통신**: FEC(Forward Error Correction)로 재전송 없이 오류 복구
- **위성 통신**: 높은 지연 때문에 재전송 대신 오류 정정 사용
- **저장 장치**: RAID, SSD 등에서 ECC 메모리 사용

**재전송 방식의 장점:**
네트워크 환경에서는 오류 정정보다 재전송이 더 효율적입니다:
- **낮은 오류율**: 대부분의 패킷이 정상 전송되므로 정정 코드의 오버헤드가 낭비됩니다
- **단순성**: 구현이 간단하고 오버헤드가 적습니다
- **유연성**: 필요한 경우에만 재전송하면 됩니다

**ARQ(Automatic Repeat reQuest):**
TCP는 ARQ 방식을 사용하여 오류를 처리합니다. 오류를 정정하는 대신 재전송을 요청하는 것이 더 효율적입니다.

**CRC의 경우:**
이더넷에서 사용하는 CRC도 강력한 오류 검출 능력을 가지지만 정정은 하지 못합니다. 오류 발견 시 프레임을 폐기합니다.

**하이브리드 접근:**
일부 시스템은 FEC와 ARQ를 결합하여 작은 오류는 정정하고, 큰 오류는 재전송합니다. 이를 Hybrid ARQ라고 합니다.

**실무적 의미:**
checksum은 빠르고 효율적인 오류 검출 메커니즘이며, 정정은 재전송이나 상위 계층에서 처리하는 것이 네트워크 프로토콜의 일반적인 설계 철학입니다.

---

## 32. TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.

TCP는 여러 메커니즘을 결합하여 **신뢰성 있는 데이터 전송**을 보장합니다.

**순서 번호(Sequence Number):**
송신하는 모든 바이트에 순서 번호를 부여합니다. 수신자는 이를 통해 데이터를 올바른 순서로 재조립하고 중복을 제거할 수 있습니다.

**확인 응답(Acknowledgment):**
수신자는 정상적으로 받은 데이터에 대해 ACK를 보냅니다. ACK 번호는 다음에 받기를 기대하는 바이트의 번호를 나타냅니다. 송신자는 ACK를 받아야 전송이 성공했음을 확인합니다.

**재전송 메커니즘:**
일정 시간(RTO, Retransmission Timeout) 내에 ACK를 받지 못하면 데이터를 재전송합니다. 타임아웃 시간은 네트워크 상태에 따라 동적으로 조정됩니다.

**체크섬(Checksum):**
헤더와 데이터의 무결성을 검증합니다. 체크섬이 맞지 않으면 세그먼트를 폐기하고, 송신자는 ACK를 받지 못해 재전송하게 됩니다.

**흐름 제어(Flow Control):**
수신자의 버퍼 크기를 고려하여 전송 속도를 조절합니다. 수신 윈도우(Receive Window) 필드를 통해 수신 가능한 데이터 양을 알립니다. 송신자는 수신자가 처리할 수 있는 만큼만 전송합니다.

**혼잡 제어(Congestion Control):**
네트워크의 혼잡 상황을 감지하고 전송 속도를 조절합니다. 주요 알고리즘으로 Slow Start, Congestion Avoidance, Fast Retransmit, Fast Recovery가 있습니다.

**연결 지향:**
3-way handshake로 연결을 수립하고, 4-way handshake로 안전하게 종료합니다. 연결 수립 시 초기 순서 번호를 교환하고 양쪽이 준비되었음을 확인합니다.

**중복 ACK 처리:**
같은 ACK를 여러 번 받으면 (일반적으로 3번) 패킷 손실로 판단하고 타임아웃을 기다리지 않고 즉시 재전송합니다 (Fast Retransmit).

**누적 확인응답:**
ACK는 누적 방식으로, 특정 순서 번호까지의 모든 데이터를 받았음을 의미합니다. 이는 ACK 자체가 손실되어도 이후 ACK로 확인될 수 있게 합니다.

**선택적 확인응답(SACK):**
TCP 옵션으로 SACK를 사용하면 순서가 맞지 않게 도착한 데이터 블록을 구체적으로 알릴 수 있어, 불필요한 재전송을 줄입니다.

**타임스탬프 옵션:**
RTT를 정확히 측정하여 재전송 타임아웃을 최적화하고, PAWS(Protection Against Wrapped Sequence numbers)로 오래된 세그먼트를 구별합니다.

**지속 타이머:**
수신 윈도우가 0이 되어 전송이 중단된 상태에서 윈도우 업데이트 메시지가 손실될 경우를 대비한 타이머입니다.

**상태 관리:**
연결의 각 상태(ESTABLISHED, FIN_WAIT, TIME_WAIT 등)를 명확히 관리하여 예외 상황에서도 안정적으로 동작합니다.

**결합된 신뢰성:**
이러한 메커니즘들이 계층적으로 결합되어 패킷 손실, 손상, 중복, 순서 변경 등 모든 전송 오류에 대응하여 완벽한 신뢰성을 제공합니다.
