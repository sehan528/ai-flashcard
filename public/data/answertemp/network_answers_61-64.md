# Network 답변 모음 (61-64)

## 61. 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.

**2-Way Handshaking**만으로는 **양방향 통신의 신뢰성을 보장할 수 없기** 때문에 사용하지 않습니다.

**양방향 연결의 필요성:**
TCP는 전이중(Full-Duplex) 통신을 제공합니다. 클라이언트와 서버가 모두 데이터를 송신하고 수신할 수 있어야 합니다. 각 방향에 대해 독립적인 순서 번호와 확인 응답이 필요합니다.

**2-Way의 문제점:**

**문제 1 - 서버의 준비 상태 미확인:**
2-Way(SYN → SYN-ACK)만으로는 서버가 보낸 SYN-ACK를 클라이언트가 받았는지 서버가 알 수 없습니다. 서버는 자신의 ISN이 확인되었는지 모른 채 데이터를 보낼 수 있습니다. 클라이언트가 SYN-ACK를 받지 못했다면 서버의 데이터는 모두 버려집니다.

**문제 2 - 오래된 연결 요청:**
네트워크 지연으로 이전 연결의 SYN 패킷이 늦게 도착할 수 있습니다. 2-Way만으로는 이 오래된 SYN을 구별할 수 없습니다. 서버가 SYN-ACK를 보내면 잘못된 연결이 수립될 수 있습니다. 클라이언트는 예상하지 못한 연결로 혼란스러워집니다.

**문제 3 - 반쪽 열린 연결(Half-Open Connection):**
클라이언트가 SYN을 보낸 후 크래시될 수 있습니다. 서버는 SYN-ACK를 보내고 연결이 수립되었다고 생각합니다. 하지만 클라이언트는 존재하지 않아 데이터를 받을 수 없습니다. 서버 자원이 불필요하게 낭비됩니다.

**3-Way가 해결하는 방법:**

**서버 확인:**
클라이언트의 ACK(3단계)로 서버는 자신의 SYN-ACK가 도착했음을 확인합니다. 이제 양쪽 모두 상대방의 준비 상태를 확인했습니다. 안전하게 데이터 전송을 시작할 수 있습니다.

**순서 번호 검증:**
클라이언트는 3단계 ACK에서 서버의 ISN + 1을 확인합니다. 오래된 SYN에 대한 SYN-ACK라면 순서 번호가 맞지 않아 연결을 거부합니다. 클라이언트가 예상하는 ISN과 일치해야만 연결이 완성됩니다.

**반쪽 열린 연결 방지:**
클라이언트가 크래시되면 3단계 ACK를 보낼 수 없습니다. 서버는 타임아웃 후 SYN_RECEIVED 상태를 정리합니다. 완전히 열린 연결만 유지되어 자원 낭비를 방지합니다.

**구체적 예시:**

**오래된 연결 시나리오:**
1. 클라이언트가 SYN(ISN=100)을 보내지만 네트워크 지연으로 늦게 도착
2. 클라이언트가 타임아웃 후 새 연결을 시도(ISN=500)
3. 새 연결이 정상 수립되고 종료됨
4. 뒤늦게 첫 SYN(ISN=100)이 서버에 도착
5. 2-Way라면: 서버가 SYN-ACK(ISN_S=200, ACK=101)를 보내고 연결 수립으로 착각
6. 3-Way라면: 클라이언트가 예상하지 않은 SYN-ACK를 받고 RST로 거부

**수학적 관점:**
3-Way Handshake는 양쪽의 ISN을 각각 확인받는 최소 단계입니다:
- 1단계: 클라이언트 ISN 전달
- 2단계: 서버 ISN 전달 + 클라이언트 ISN 확인
- 3단계: 서버 ISN 확인
총 2개의 ISN × 각 1회 확인 = 최소 3단계

**대안은 없는가:**
4-Way도 가능하지만 불필요한 오버헤드입니다. 2단계에서 SYN과 ACK를 결합(SYN-ACK)하여 효율성을 높였습니다. 3-Way가 최소한의 단계로 양방향 확인을 달성하는 최적 설계입니다.

**RFC 793의 설계:**
TCP 표준(RFC 793)은 이러한 문제들을 고려하여 3-Way Handshake를 명시했습니다. 40년 이상 검증된 신뢰성 있는 방법입니다.

**성능 영향:**
3-Way Handshake는 1.5 RTT(Round Trip Time)가 소요됩니다. 이는 신뢰성을 위해 필요한 비용입니다. HTTP/3와 QUIC의 0-RTT는 이전 연결 정보를 활용하여 최적화합니다.

---

## 62. 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?

네, **동시 개방(Simultaneous Open)**이 가능하며, TCP는 이를 지원합니다.

**정상적인 시나리오:**
일반적으로는 한쪽이 능동 개방(Active Open, connect()), 다른 쪽이 수동 개방(Passive Open, listen())을 수행합니다. 클라이언트-서버 모델에서 서버는 LISTEN 상태에서 대기합니다.

**동시 개방 시나리오:**
양쪽 호스트가 모두 능동적으로 연결을 시도합니다. 두 호스트가 거의 동시에 SYN을 서로에게 보냅니다. 양쪽 모두 클라이언트이자 서버가 되는 특수한 상황입니다.

**동시 개방의 4-Way Handshake:**

**1단계 - 양쪽에서 SYN 전송:**
호스트 A가 호스트 B에게 SYN(ISN_A=100)을 보냅니다. 호스트 B가 호스트 A에게 SYN(ISN_B=200)을 보냅니다. 두 SYN이 네트워크 상에서 교차합니다. 양쪽 모두 SYN_SENT 상태가 됩니다.

**2단계 - 상대방의 SYN 수신:**
호스트 A가 B의 SYN을 받습니다. 호스트 B가 A의 SYN을 받습니다. 일반적인 3-Way라면 SYN_SENT에서 SYN을 받는 것은 예상 밖입니다. TCP는 이를 동시 개방으로 인식합니다.

**3단계 - SYN-ACK 교환:**
호스트 A가 B에게 SYN-ACK(ISN_A=100, ACK=201)를 보냅니다. 호스트 B가 A에게 SYN-ACK(ISN_B=200, ACK=101)를 보냅니다. 양쪽 모두 SYN_RECEIVED 상태가 됩니다.

**4단계 - 최종 ACK:**
호스트 A가 B의 SYN-ACK를 받고 ESTABLISHED 상태로 전환합니다. 호스트 B가 A의 SYN-ACK를 받고 ESTABLISHED 상태로 전환합니다. 연결이 완전히 수립됩니다.

**상태 전이:**
- **정상 3-Way**: CLOSED → SYN_SENT → ESTABLISHED (클라이언트)
- **동시 개방**: CLOSED → SYN_SENT → SYN_RECEIVED → ESTABLISHED (양쪽)

**왜 4단계가 필요한가:**
정상 3-Way에서는 서버가 LISTEN 상태에서 대기하므로 SYN-ACK로 응답합니다. 동시 개방에서는 양쪽 모두 SYN_SENT 상태이므로 먼저 SYN을 수신합니다. 각자의 SYN을 확인받기 위해 SYN-ACK를 교환해야 합니다.

**실제 발생 가능성:**
실무에서는 매우 드뭅니다. 정확히 같은 시간에 연결을 시도해야 하기 때문입니다. P2P 애플리케이션이나 NAT 홀 펀칭에서 의도적으로 사용될 수 있습니다.

**포트 번호:**
동시 개방이 성공하려면 양쪽이 서로의 포트로 연결을 시도해야 합니다. 예: A(IP1:Port1)와 B(IP2:Port2)가 서로를 향해 연결합니다. 일반적인 클라이언트-서버에서는 클라이언트가 임의 포트를 사용하므로 이런 일치가 어렵습니다.

**NAT 홀 펀칭(Hole Punching):**
P2P 연결을 위해 동시 개방을 활용합니다. 양쪽이 NAT 뒤에 있을 때 중계 서버가 타이밍을 조정합니다. 양쪽이 동시에 SYN을 보내면 NAT가 포트를 열어줍니다. 이를 통해 직접 P2P 연결이 가능해집니다.

**RFC 793 지원:**
TCP 표준은 동시 개방을 명시적으로 지원합니다. 모든 TCP 구현은 이 시나리오를 올바르게 처리해야 합니다. 대칭적인 연결로, 클라이언트와 서버의 구분이 없습니다.

**방화벽과 NAT:**
동시 개방은 방화벽 규칙을 복잡하게 만듭니다. 양방향 연결을 모두 허용해야 합니다. 상태 추적(Stateful) 방화벽은 이를 올바르게 처리합니다.

**실험 방법:**
두 호스트에서 동시에 특정 포트로 서로 연결을 시도합니다. 타이밍이 정확하면 4-Way Handshake를 관찰할 수 있습니다. 패킷 캡처로 SYN → SYN, SYN-ACK → SYN-ACK 교환을 확인합니다.

**응용 사례:**
- **P2P 파일 공유**: 양쪽이 모두 NAT 뒤에 있을 때
- **VoIP**: 직접 미디어 연결 설정
- **온라인 게임**: P2P 멀티플레이어 연결

**주의사항:**
의도적인 동시 개방 구현 시 정확한 타이밍 조정이 필요합니다. 중계 서버나 STUN 서버가 도와줍니다.

---

## 63. SYN Flooding 에 대해 설명해 주세요.

**SYN Flooding**은 TCP의 3-Way Handshake 메커니즘을 악용한 서비스 거부 공격(DoS)입니다.

**공격 원리:**
공격자가 대량의 SYN 패킷을 서버에 전송합니다. 송신 IP 주소를 위조(Spoofing)하여 실제로 존재하지 않는 주소를 사용합니다. 서버는 각 SYN에 대해 SYN-ACK를 보내고 연결을 대기합니다. 위조된 IP는 응답하지 않으므로 ACK가 오지 않습니다. 서버는 타임아웃까지 연결을 유지하며 자원을 소모합니다.

**피해:**
서버의 백로그 큐(Backlog Queue)가 가득 차서 정상적인 연결 요청을 받을 수 없습니다. SYN_RECEIVED 상태의 연결들이 메모리를 고갈시킵니다. CPU 자원도 재전송과 타임아웃 처리로 소모됩니다. 결과적으로 정상 사용자가 서비스를 이용할 수 없게 됩니다.

**반쪽 열린 연결(Half-Open Connections):**
SYN_RECEIVED 상태에서 대기하는 불완전한 연결들입니다. 각 연결은 메모리(TCB, Transmission Control Block)를 차지합니다. 타임아웃이 길면(수십 초) 공격 효과가 커집니다.

**백로그 큐:**
서버의 listen() 함수가 설정하는 대기 큐입니다. 일반적으로 수십에서 수백 개의 연결을 저장합니다. SYN Flooding으로 큐가 가득 차면 새로운 SYN을 거부합니다.

**대응 방법:**

**1. SYN 쿠키(SYN Cookies):**
가장 효과적인 방어 기법입니다. 서버가 SYN을 받을 때 상태를 저장하지 않습니다. 대신 암호학적 해시로 쿠키를 생성하여 SYN-ACK에 포함합니다. 클라이언트의 ACK를 받을 때 쿠키를 검증하여 연결을 수립합니다. 메모리 소모 없이 공격을 방어하지만, 일부 TCP 옵션을 사용할 수 없는 단점이 있습니다.

**2. 백로그 큐 크기 증가:**
더 많은 연결을 대기할 수 있도록 큐 크기를 늘립니다. 완전한 해결책은 아니지만 공격 규모가 작을 때 효과적입니다.

**3. 타임아웃 시간 단축:**
SYN_RECEIVED 상태의 타임아웃을 줄여 빠르게 정리합니다. 정상 연결도 영향을 받을 수 있으므로 신중하게 조정합니다.

**4. 방화벽과 라우터 필터링:**
비정상적인 SYN 비율을 감지하고 제한합니다. 특정 IP나 네트워크의 SYN을 차단합니다. Rate Limiting으로 초당 SYN 수를 제한합니다.

**5. SYN 프록시:**
전용 장비나 소프트웨어가 SYN을 대신 처리합니다. 3-Way Handshake를 완료한 후에만 실제 서버로 연결을 전달합니다. 서버를 공격으로부터 격리시킵니다.

**6. Reverse Path Forwarding(RPF) 확인:**
라우터가 송신 IP의 유효성을 확인합니다. 해당 IP로의 응답 경로가 없으면 패킷을 폐기합니다. IP 스푸핑을 어렵게 만듭니다.

**7. 클라우드 DDoS 보호:**
Cloudflare, AWS Shield 같은 서비스를 사용합니다. 대규모 인프라로 공격 트래픽을 분산시킵니다.

**운영체제 설정:**
리눅스에서는 sysctl로 설정을 조정합니다:
- tcp_max_syn_backlog: 백로그 큐 크기
- tcp_synack_retries: SYN-ACK 재전송 횟수
- tcp_syncookies: SYN 쿠키 활성화

**공격 감지:**
netstat으로 SYN_RECEIVED 상태가 비정상적으로 많은지 확인합니다. 서버 로그에서 연결 시도 실패율을 모니터링합니다. IDS/IPS 시스템으로 패턴을 탐지합니다.

**분산 SYN Flooding (DDoS):**
여러 봇넷이 동시에 공격하면 더 강력합니다. IP 차단이 어려워지고 트래픽 양이 압도적입니다. 전문적인 DDoS 방어 서비스가 필요합니다.

**역사적 배경:**
1990년대 중반부터 알려진 고전적인 공격입니다. SYN 쿠키(1996년 발명)로 근본적 해결책이 마련되었습니다. 현대 서버는 기본적으로 SYN 쿠키를 지원합니다.

**실무 권장:**
SYN 쿠키를 활성화하고 모니터링 시스템을 구축합니다. 방화벽 규칙과 Rate Limiting을 설정합니다. 정기적인 보안 점검과 업데이트를 수행합니다.

---

## 64. 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?

**0-RTT(Zero Round Trip Time)**는 이전 연결의 정보를 재사용하여 즉시 데이터를 전송하는 최적화 기법입니다.

**기존 핸드셰이크의 오버헤드:**
일반 TCP 3-Way Handshake는 1.5 RTT가 소요됩니다. TLS를 추가하면 총 2-3 RTT가 필요합니다. 지연 시간이 큰 환경(모바일, 장거리)에서는 수백 ms가 걸립니다. 사용자 경험에 직접적인 영향을 줍니다.

**TCP Fast Open (TFO):**

**원리:**
클라이언트와 서버가 이전에 연결한 적이 있을 때 쿠키를 교환합니다. 이 쿠키는 클라이언트를 인증하는 토큰입니다.

**첫 연결:**
일반 3-Way Handshake를 수행합니다. 서버가 SYN-ACK에 TFO 쿠키를 포함하여 보냅니다. 클라이언트가 이 쿠키를 저장합니다.

**재연결 시:**
클라이언트가 SYN 패킷에 TFO 쿠키와 함께 실제 데이터를 포함합니다. 서버가 쿠키를 검증하고 데이터를 즉시 처리합니다. 동시에 SYN-ACK를 보내 핸드셰이크를 완료합니다. 데이터 전송에 0-RTT가 소요됩니다(핸드셰이크와 동시).

**TLS 1.3의 0-RTT:**

**세션 재개:**
이전 TLS 세션의 암호화 키를 재사용합니다. 클라이언트가 PSK(Pre-Shared Key) 또는 세션 티켓을 저장합니다.

**Early Data:**
ClientHello와 함께 암호화된 애플리케이션 데이터를 보냅니다. 서버가 세션 정보를 확인하고 즉시 데이터를 처리합니다. 핸드셰이크 완료를 기다리지 않습니다.

**QUIC (HTTP/3):**

**연결 ID 사용:**
이전 연결의 Connection ID와 암호화 정보를 저장합니다.

**0-RTT 재개:**
첫 패킷에 Connection ID, 암호화된 데이터, 연결 재개 토큰을 포함합니다. 서버가 검증 후 즉시 응답하며 데이터를 처리합니다.

**1-RTT 초기 연결:**
처음 연결할 때도 TLS 핸드셰이크를 QUIC 핸드셰이크와 통합하여 1-RTT로 단축합니다.

**0-RTT의 보안 고려사항:**

**재생 공격(Replay Attack):**
0-RTT 데이터는 공격자가 캡처하여 재전송할 수 있습니다. 서버는 같은 요청이 여러 번 처리될 수 있음을 인지해야 합니다.

**멱등성(Idempotency) 요구:**
0-RTT로 전송되는 요청은 멱등성을 가져야 합니다. GET 요청은 안전하지만 POST, DELETE 등은 위험합니다. 중요한 상태 변경 작업은 1-RTT 이후에 수행해야 합니다.

**서버 측 방어:**
단일 사용 토큰, 타임스탬프 검증, 중복 요청 감지 메커니즘을 구현합니다. 일부 서버는 0-RTT를 특정 작업으로만 제한합니다.

**적용 범위:**
모든 연결이 0-RTT를 사용할 수 없습니다. 첫 연결은 항상 전체 핸드셰이크가 필요합니다. 쿠키나 세션이 만료되면 다시 전체 핸드셰이크를 수행합니다.

**실무 활용:**
웹 브라우저와 CDN이 0-RTT를 적극 활용합니다. 정적 콘텐츠 요청(이미지, CSS, JS)에 적합합니다. API 중에서도 읽기 전용 작업에 사용합니다.

**성능 개선:**
0-RTT는 페이지 로딩 시간을 20-30% 단축할 수 있습니다. 특히 모바일이나 고지연 네트워크에서 효과가 큽니다. 사용자 경험이 크게 향상됩니다.

**프로토콜별 지원:**
- **TCP Fast Open**: RFC 7413, 리눅스/윈도우 지원
- **TLS 1.3 0-RTT**: RFC 8446, 주요 브라우저 지원
- **QUIC 0-RTT**: HTTP/3의 핵심 기능

**활성화 방법:**
서버 설정에서 TCP Fast Open, TLS 1.3, QUIC을 활성화합니다. 클라이언트(브라우저)도 지원해야 합니다. 보안 정책에 따라 0-RTT 허용 범위를 조정합니다.

**미래 전망:**
0-RTT는 점점 더 표준이 되고 있습니다. 5G, 위성 인터넷 등 고지연 환경에서 특히 중요합니다. 보안과 성능의 균형을 맞추는 발전이 계속되고 있습니다.
