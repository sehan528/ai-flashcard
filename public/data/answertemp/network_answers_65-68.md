# Network 답변 모음 (65-68)

## 65. 4-Way Handshake에 대해 설명해 주세요.

**4-Way Handshake**는 TCP 연결을 안전하게 종료하는 과정입니다.

**필요성:**
TCP는 전이중(Full-Duplex) 통신이므로 양방향을 독립적으로 종료해야 합니다. 한쪽이 데이터 전송을 끝내도 상대방은 계속 보낼 수 있습니다. 양쪽 모두 종료에 동의하고 모든 데이터가 전달되었음을 확인해야 합니다.

**4단계 과정:**

**1단계 - FIN (클라이언트 → 서버):**
클라이언트가 연결 종료를 시작합니다. FIN(Finish) 플래그를 1로 설정한 세그먼트를 보냅니다. "더 이상 보낼 데이터가 없습니다"라는 의미입니다. 클라이언트는 FIN_WAIT_1 상태가 됩니다. 하지만 서버로부터 데이터는 계속 받을 수 있습니다.

**2단계 - ACK (서버 → 클라이언트):**
서버가 FIN을 확인합니다. ACK 플래그를 1로 설정하고 ACK 번호는 FIN의 순서 번호 + 1입니다. 서버는 CLOSE_WAIT 상태가 됩니다. 클라이언트는 FIN_WAIT_2 상태가 됩니다. 서버는 아직 보낼 데이터가 있을 수 있습니다.

**3단계 - FIN (서버 → 클라이언트):**
서버가 남은 데이터를 모두 전송한 후 연결 종료를 요청합니다. FIN 플래그를 1로 설정합니다. 서버는 LAST_ACK 상태가 됩니다. "이제 나도 보낼 데이터가 없습니다"라는 의미입니다.

**4단계 - ACK (클라이언트 → 서버):**
클라이언트가 서버의 FIN을 확인합니다. ACK 플래그를 1로 설정하고 ACK 번호는 FIN의 순서 번호 + 1입니다. 클라이언트는 TIME_WAIT 상태로 전환됩니다. 서버는 ACK를 받고 CLOSED 상태가 됩니다. 클라이언트는 일정 시간(2MSL) 대기 후 CLOSED가 됩니다.

**상태 전이:**
- **클라이언트(능동 종료)**: ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
- **서버(수동 종료)**: ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED

**반쪽 종료(Half-Close):**
1단계와 3단계 사이에 서버는 데이터를 계속 보낼 수 있습니다. 이를 half-close 상태라고 합니다. 클라이언트는 더 이상 보내지 않지만 받을 수는 있습니다. 대용량 파일 다운로드 후 연결 종료 시 유용합니다.

**TIME_WAIT 상태:**
클라이언트가 마지막 ACK를 보낸 후 2MSL(Maximum Segment Lifetime, 일반적으로 2-4분) 동안 대기합니다.

**TIME_WAIT의 이유:**
1. 마지막 ACK가 손실될 경우를 대비합니다. 서버가 FIN을 재전송하면 클라이언트가 ACK를 다시 보낼 수 있습니다
2. 이전 연결의 지연된 패킷이 새 연결에 영향을 주는 것을 방지합니다

**동시 종료(Simultaneous Close):**
양쪽이 동시에 FIN을 보낼 수 있습니다. 각자 상대방의 FIN에 ACK로 응답합니다. 총 4개의 세그먼트가 교환되지만 순서가 다릅니다. 최종적으로는 정상 종료됩니다.

**3-Way 종료가 아닌 이유:**
2단계 ACK와 3단계 FIN을 결합하면 3-Way가 가능합니다. 하지만 서버가 즉시 종료할 준비가 안 될 수 있습니다. Half-close 기능이 필요하므로 4-Way를 사용합니다.

**RST로 종료:**
비정상 종료 시에는 4-Way Handshake 없이 RST(Reset)로 즉시 종료합니다. 애플리케이션 크래시, 프로그래밍 오류, 강제 종료 시 발생합니다. RST는 확인 응답이 없으며 즉시 연결을 끊습니다.

**SO_LINGER 옵션:**
소켓 옵션으로 종료 동작을 제어할 수 있습니다. 기본값: close() 시 4-Way Handshake 수행하고 즉시 반환합니다. linger=0: 버퍼 데이터를 버리고 RST로 강제 종료합니다. linger=N: N초 동안 대기하며 데이터 전송을 시도합니다.

**FIN_WAIT_2 타임아웃:**
클라이언트가 FIN_WAIT_2 상태에서 서버의 FIN을 무한정 기다리지 않습니다. 타임아웃 후(일반적으로 수 분) 연결을 강제 종료합니다.

**실무 고려사항:**
서버 재시작 시 TIME_WAIT 상태의 소켓들이 포트를 점유할 수 있습니다. SO_REUSEADDR 옵션으로 포트를 즉시 재사용할 수 있습니다. 하지만 보안과 안정성을 위해 TIME_WAIT는 중요합니다.

**패킷 캡처 예시:**
Wireshark에서 정상 종료 시 [F.], [.], [F.], [.] 플래그 순서를 볼 수 있습니다. 비정상 종료 시 [R.] 플래그를 볼 수 있습니다.

---

## 66. 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?

패킷이 4-Way Handshake인지는 **TCP 헤더의 플래그 비트와 연결 상태**를 확인하여 파악합니다.

**FIN 플래그 확인:**
4-Way Handshake의 핵심은 FIN 플래그입니다. TCP 헤더의 제어 플래그에서 FIN 비트가 1인지 확인합니다. FIN이 설정된 패킷은 연결 종료 관련 패킷입니다.

**플래그 조합으로 단계 구분:**

**1단계 - 첫 FIN:**
FIN 플래그만 설정되어 있습니다(일반적으로 ACK도 함께). 플래그: [F.] 또는 [FA] (FIN + ACK). 이전 데이터에 대한 ACK와 함께 FIN이 올 수 있습니다.

**2단계 - FIN에 대한 ACK:**
ACK 플래그만 설정됩니다. 플래그: [.] 또는 [A]. ACK 번호가 받은 FIN의 순서 번호 + 1입니다. 이 시점에서는 일반 데이터 ACK와 구별하기 어려울 수 있습니다.

**3단계 - 두 번째 FIN:**
반대 방향에서 FIN 플래그가 설정됩니다. 플래그: [F.] 또는 [FA]. 서버가 클라이언트에게 종료를 알립니다.

**4단계 - 두 번째 FIN에 대한 ACK:**
ACK 플래그가 설정됩니다. 플래그: [.] 또는 [A]. 이것이 연결 종료의 마지막 패킷입니다.

**순서 번호와 ACK 번호 추적:**
FIN도 순서 번호를 소비합니다(1 바이트처럼 계산). FIN의 Seq=X를 받으면 ACK=X+1로 응답합니다. 순서 번호의 흐름을 추적하면 종료 과정을 명확히 파악할 수 있습니다.

**연결 상태 추적:**
상태 기반 방화벽이나 모니터링 도구는 각 연결의 상태를 추적합니다. ESTABLISHED 상태에서 FIN을 받으면 종료 과정 시작으로 인식합니다. FIN_WAIT, CLOSE_WAIT 등의 상태로 전환됩니다.

**방향성 확인:**
누가 먼저 종료를 시작했는지 확인합니다. 첫 FIN의 송신자가 능동 종료(Active Close)를 수행합니다. 반대쪽은 수동 종료(Passive Close)를 수행합니다.

**타이밍 분석:**
FIN 패킷들 사이의 시간 간격을 확인합니다. 정상적인 종료는 일정한 패턴을 보입니다. 비정상적으로 긴 간격은 문제를 나타낼 수 있습니다.

**Wireshark에서 파악:**

**Info 컬럼:**
Wireshark는 패킷의 의미를 해석하여 표시합니다. "[FIN, ACK]"로 표시되어 종료 패킷임을 알 수 있습니다.

**Stream 추적:**
"Follow TCP Stream"으로 특정 연결의 전체 흐름을 볼 수 있습니다. 연결 수립(SYN), 데이터 전송, 연결 종료(FIN) 과정을 시간순으로 확인합니다.

**필터 사용:**
"tcp.flags.fin == 1"로 FIN 패킷만 필터링합니다. 특정 연결의 종료 과정만 집중해서 볼 수 있습니다.

**프로그래밍적 파악:**
패킷 캡처 라이브러리(libpcap, Scapy)를 사용할 때 TCP 헤더를 파싱합니다. 플래그 필드의 FIN 비트(0x01)를 확인합니다.

**운영체제 레벨:**
netstat 명령으로 현재 연결 상태를 확인합니다. FIN_WAIT, TIME_WAIT, CLOSE_WAIT 상태는 종료 중임을 나타냅니다.

**비정상 종료 구별:**
RST 플래그가 설정된 패킷은 4-Way Handshake가 아닌 강제 종료입니다. 플래그: [R.] 또는 [RA]. RST는 즉시 연결을 끊으며 확인 응답이 없습니다.

**동시 종료:**
양쪽에서 거의 동시에 FIN이 전송되는 경우도 있습니다. 두 개의 FIN과 두 개의 ACK가 다른 순서로 나타날 수 있습니다. 최종적으로는 양쪽 모두 종료됩니다.

**실무 활용:**
네트워크 문제 진단 시 연결이 정상 종료되는지 확인합니다. FIN을 보냈지만 ACK를 받지 못하면 네트워크 문제나 상대방 크래시를 의심합니다. TIME_WAIT 상태가 과도하게 많으면 서버 설정을 조정합니다.

---

## 67. 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?

빠르게 연결을 종료해야 할 때는 **RST(Reset) 패킷**을 사용합니다.

**RST의 역할:**
RST는 TCP 연결을 즉시 강제 종료합니다. 4-Way Handshake 없이 일방적으로 연결을 끊습니다. 확인 응답을 기다리지 않으며, 상대방도 응답하지 않습니다.

**RST 전송 상황:**

**1. 애플리케이션의 명시적 요청:**
SO_LINGER 소켓 옵션을 linger=0으로 설정하고 close()를 호출합니다. 버퍼에 남은 데이터를 버리고 즉시 RST를 보냅니다. 강제 종료가 필요한 특수한 경우에 사용합니다.

**2. 존재하지 않는 포트 접근:**
서버에서 리스닝하지 않는 포트로 SYN이 도착하면 RST로 응답합니다. "해당 포트는 열려있지 않습니다"라는 의미입니다. 포트 스캐닝에서 닫힌 포트를 감지하는 방법입니다.

**3. 반쪽 열린 연결(Half-Open Connection):**
한쪽이 크래시된 후 재부팅했을 때 상대방이 데이터를 보내면 RST로 응답합니다. "이 연결을 모르겠습니다"라는 의미입니다.

**4. 잘못된 세그먼트:**
예상하지 못한 순서 번호나 잘못된 ACK를 받으면 RST를 보낼 수 있습니다. 연결 상태가 맞지 않는 패킷을 거부합니다.

**5. 타임아웃:**
일부 구현은 연결이 오래 유휴 상태일 때 FIN 대신 RST로 종료합니다.

**6. 보안 정책:**
방화벽이나 IDS가 악의적인 연결을 차단할 때 RST를 보냅니다.

**RST의 동작:**
RST 플래그가 1로 설정된 세그먼트를 전송합니다. 플래그 표시: [R] 또는 [R.] 또는 [RA]. 송신 버퍼와 수신 버퍼의 데이터를 모두 버립니다. 양쪽 모두 즉시 CLOSED 상태로 전환합니다. TIME_WAIT 상태가 없습니다.

**RST의 장점:**
즉각적인 연결 종료로 자원을 빠르게 회수합니다. 비정상 상태의 연결을 정리할 수 있습니다. 오버헤드가 최소화됩니다(1개 패킷).

**RST의 단점:**
버퍼에 남은 데이터가 손실됩니다. 상대방이 이미 보낸 데이터도 받지 못할 수 있습니다. 비정상 종료로 간주되어 애플리케이션이 오류를 인식합니다. TIME_WAIT 없이 즉시 포트를 재사용하면 이전 연결의 지연 패킷 문제가 발생할 수 있습니다.

**정상 종료와의 비교:**
- **4-Way Handshake**: 모든 데이터 전송 보장, 우아한 종료(Graceful Shutdown), 양쪽 합의
- **RST**: 즉시 종료, 데이터 손실 가능, 일방적 종료

**프로그래밍 예시:**
일반적인 close()는 4-Way Handshake를 수행합니다. SO_LINGER를 사용하여 RST 강제 종료를 선택할 수 있습니다. shutdown() 함수로 half-close를 수행한 후 close()를 호출할 수도 있습니다.

**실무 권장:**
가능하면 정상적인 4-Way Handshake를 사용해야 합니다. RST는 예외적인 상황이나 보안 목적으로만 사용합니다. 데이터 무결성이 중요한 애플리케이션은 반드시 정상 종료를 해야 합니다.

**클라이언트 측 경험:**
RST를 받은 애플리케이션은 "Connection reset by peer" 오류를 받습니다. 이는 상대방이 강제로 연결을 끊었다는 의미입니다. 애플리케이션은 이를 적절히 처리해야 합니다(재시도, 오류 표시 등).

**서버 측 고려사항:**
서버가 과부하 상태에서 새 연결을 RST로 거부할 수 있습니다. 백로그 큐가 가득 찬 경우 SYN에 RST로 응답합니다. 클라이언트는 "Connection refused" 오류를 받습니다.

**보안 측면:**
RST는 공격에도 사용될 수 있습니다. TCP RST 공격: 위조된 RST 패킷으로 정상 연결을 끊습니다. 방어: 순서 번호 검증을 강화합니다.

**실무 진단:**
패킷 캡처에서 예상치 못한 RST가 나타나면 문제를 조사해야 합니다. 방화벽 정책, 서버 크래시, 애플리케이션 버그 등을 확인합니다.

---

## 68. 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?

한쪽이 강제로 종료되면 반대쪽은 **타임아웃과 재전송 메커니즘, 킵얼라이브**를 통해 인식합니다.

**시나리오별 분석:**

**시나리오 1 - FIN 전송 후 크래시:**
클라이언트가 FIN을 보낸 후 크래시됩니다. 서버가 ACK를 보내도 응답이 없습니다. 서버가 자신의 FIN을 보내도 ACK를 받지 못합니다.

**서버의 인식 과정:**
서버는 FIN에 대한 ACK를 받지 못해 재전송을 시도합니다. 일정 횟수(일반적으로 5-8회) 재전송 후 타임아웃됩니다. 타임아웃 시간은 지수 백오프로 증가합니다(1초, 2초, 4초, 8초...). 최종적으로 연결이 비정상 종료되었다고 판단하고 정리합니다.

**시나리오 2 - ACK 전송 후 크래시:**
클라이언트가 서버의 FIN에 ACK를 보낸 직후 크래시됩니다. 서버는 ACK를 받아 정상 종료합니다. 클라이언트만 비정상 상태로 남습니다.

**이 경우 문제:**
서버는 정상 종료로 인식하지만 클라이언트는 TIME_WAIT 없이 사라집니다. 이전 연결의 지연 패킷이 새 연결에 영향을 줄 위험이 있습니다. 하지만 클라이언트 재시작 시 새로운 포트를 사용하므로 실질적 문제는 적습니다.

**시나리오 3 - ESTABLISHED 상태에서 크래시:**
정상 통신 중에 한쪽이 갑자기 크래시됩니다. 운영체제가 종료되거나 네트워크 케이블이 뽑힙니다. 어떤 종료 패킷(FIN, RST)도 보내지 못합니다.

**반대쪽의 인식:**

**데이터 전송 시도 시:**
크래시를 모르고 데이터를 계속 보냅니다. ACK를 받지 못해 재전송을 시도합니다. 재전송 타임아웃(RTO)이 지수적으로 증가합니다. 일정 시간(몇 분에서 십수 분) 후 최종 타임아웃됩니다. "Connection timed out" 오류가 발생합니다.

**데이터 전송이 없을 때:**
아무것도 보낼 데이터가 없으면 상대방의 크래시를 모릅니다. 연결이 ESTABLISHED 상태로 남아있습니다. 이를 "Dead Connection" 또는 "Zombie Connection"이라고 합니다.

**TCP Keep-Alive 메커니즘:**

**목적:**
오랫동안 유휴 상태인 연결이 여전히 유효한지 확인합니다. Dead Connection을 감지하고 정리합니다.

**동작 방식:**
일정 시간(기본 2시간) 동안 데이터 전송이 없으면 Keep-Alive 프로브를 보냅니다. 작은 패킷(1 바이트)을 전송하여 상대방의 응답을 확인합니다. 응답이 오면 연결이 살아있다고 판단합니다.

**응답 없을 때:**
일정 간격(기본 75초)으로 여러 번(기본 9회) 재시도합니다. 모두 실패하면 연결을 종료합니다. 애플리케이션에 "Connection timed out" 오류를 알립니다.

**Keep-Alive 설정:**
SO_KEEPALIVE 소켓 옵션으로 활성화합니다. 시스템 설정으로 간격과 횟수를 조정할 수 있습니다. 리눅스: tcp_keepalive_time, tcp_keepalive_intvl, tcp_keepalive_probes.

**한계:**
기본 설정으로는 2시간 이상 걸려 느립니다. 모든 애플리케이션이 활성화하지 않습니다.

**애플리케이션 레벨 Heartbeat:**
TCP Keep-Alive 대신 애플리케이션이 직접 heartbeat 메시지를 교환합니다. 주기적으로(예: 30초마다) ping/pong 메시지를 보냅니다. 응답이 없으면 빠르게 연결을 끊고 재연결합니다. 웹소켓, MQTT, gRPC 등에서 사용합니다.

**ICMP 오류:**
경우에 따라 ICMP 메시지로 인식할 수 있습니다. 상대방 호스트가 다운되면 라우터가 "Destination Unreachable"을 보낼 수 있습니다. TCP는 이를 받아 연결 종료를 판단합니다.

**RST 수신:**
상대방이 재부팅 후 데이터를 받으면 "알 수 없는 연결"로 판단하고 RST를 보냅니다. 이를 받으면 즉시 연결이 끊어졌음을 인식합니다.

**실무 권장사항:**
중요한 연결은 애플리케이션 레벨 heartbeat를 구현합니다. Keep-Alive를 활성화하되 간격을 짧게 조정합니다(예: 60초). 재연결 로직을 구현하여 연결 끊김에 자동 대응합니다. 타임아웃 설정을 적절히 조정합니다.

**로드밸런서와 프록시:**
중간 장비들도 유휴 연결을 타임아웃시킬 수 있습니다. 로드밸런서의 idle timeout보다 짧은 주기로 heartbeat를 보내야 합니다.

**클라우드 환경:**
AWS ELB, Azure Load Balancer 등은 기본 idle timeout(보통 60초)이 있습니다. 이를 고려하여 애플리케이션 설계를 해야 합니다.
