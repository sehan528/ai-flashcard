# Spring 답변 77-80

## 질문 77: Spring Boot에서 프로파일 관리와 환경별 설정 적용 방법은 무엇인가요?

Spring Boot의 프로파일은 환경별로 다른 설정을 적용할 수 있게 하는 기능입니다. 개발, 테스트, 프로덕션 환경마다 다른 데이터베이스, 로그 레벨, 외부 API 주소 등을 사용할 수 있습니다.

**프로파일의 필요성:**

첫째, 환경 분리입니다. 개발 환경과 프로덕션 환경의 설정이 다릅니다. 개발에서는 H2 데이터베이스를 사용하고 프로덕션에서는 MySQL을 사용합니다. 개발에서는 디버그 로그를 켜고 프로덕션에서는 에러 로그만 남깁니다.

둘째, 설정 관리 편의성입니다. 환경마다 다른 설정 파일을 관리할 필요가 없습니다. 하나의 프로젝트에서 모든 환경 설정을 관리합니다. 빌드 아티팩트는 하나이지만 실행 환경에 따라 다르게 동작합니다.

셋째, 유연성입니다. 새로운 환경을 쉽게 추가할 수 있습니다. QA, Staging 환경을 별도로 만들 수 있습니다. 환경 전환이 간단합니다.

**프로파일 설정 파일:**

application.properties 또는 application.yml이 기본 설정 파일입니다. 모든 프로파일에 공통으로 적용됩니다.

프로파일별 설정 파일을 만들 수 있습니다. application-dev.properties는 dev 프로파일 설정입니다. application-prod.properties는 prod 프로파일 설정입니다. application-test.properties는 test 프로파일 설정입니다.

YAML 파일에서는 하나의 파일에 여러 프로파일을 정의할 수 있습니다. 세 개의 하이픈으로 구분합니다. spring.config.activate.on-profile로 프로파일을 지정합니다.

**프로파일 활성화 방법:**

첫째, application.properties에서 설정합니다. spring.profiles.active 속성으로 지정합니다. 기본 프로파일을 설정할 때 사용합니다.

둘째, 커맨드 라인 인자로 전달합니다. JAR 실행 시 --spring.profiles.active=prod를 추가합니다. 배포 스크립트에서 환경에 맞게 지정합니다.

셋째, 환경 변수로 설정합니다. SPRING_PROFILES_ACTIVE 환경 변수를 설정합니다. 컨테이너 환경에서 많이 사용합니다. Kubernetes나 Docker에서 환경 변수로 주입합니다.

넷째, JVM 시스템 프로퍼티로 설정합니다. -Dspring.profiles.active=dev를 JVM 옵션에 추가합니다.

다섯째, 프로그래밍 방식으로 설정합니다. SpringApplication.setAdditionalProfiles 메서드를 사용합니다. 메인 메서드에서 동적으로 설정할 수 있습니다.

**프로파일 우선순위:**

여러 곳에서 프로파일을 설정하면 우선순위가 있습니다. 커맨드 라인 인자가 가장 높습니다. 환경 변수, JVM 시스템 프로퍼티, application.properties 순서입니다. 외부 설정이 내부 설정보다 우선합니다.

**여러 프로파일 동시 활성화:**

쉼표로 구분하여 여러 프로파일을 동시에 활성화할 수 있습니다. spring.profiles.active=dev,local처럼 지정합니다. 뒤에 오는 프로파일이 앞의 프로파일을 덮어씁니다.

**프로파일 그룹:**

Spring Boot 2.4부터 프로파일 그룹을 사용할 수 있습니다. spring.profiles.group으로 그룹을 정의합니다. 하나의 프로파일 이름으로 여러 프로파일을 활성화합니다. 예를 들어 production 그룹에 proddb, prodcache를 포함시킵니다.

**@Profile 어노테이션:**

Bean 레벨에서 프로파일을 적용할 수 있습니다. @Profile 어노테이션을 Bean이나 Configuration 클래스에 붙입니다. 특정 프로파일에서만 해당 Bean이 등록됩니다.

예를 들어 @Profile("dev")를 붙이면 dev 프로파일에서만 Bean이 생성됩니다. @Profile("!prod")처럼 느낌표를 사용하면 prod가 아닐 때만 활성화됩니다. @Profile({"dev", "test"})처럼 배열로 여러 프로파일을 지정할 수 있습니다.

**Configuration 클래스 분리:**

환경별로 Configuration 클래스를 분리할 수 있습니다. DevConfig에 @Profile("dev")를 붙입니다. ProdConfig에 @Profile("prod")를 붙입니다. 각 환경에 맞는 Bean들을 정의합니다.

**프로파일별 데이터소스 설정:**

개발 환경에서는 H2 인메모리 데이터베이스를 사용합니다. 프로덕션 환경에서는 MySQL이나 PostgreSQL을 사용합니다. application-dev.yml에 H2 설정을 넣습니다. application-prod.yml에 MySQL 설정을 넣습니다.

**프로파일별 로그 레벨:**

개발 환경에서는 DEBUG 레벨로 상세한 로그를 남깁니다. 프로덕션 환경에서는 INFO나 WARN 레벨로 필수 로그만 남깁니다. logging.level 속성을 프로파일별로 다르게 설정합니다.

**외부 설정 파일:**

JAR 외부에 설정 파일을 둘 수 있습니다. 같은 디렉토리의 application.properties가 JAR 내부 설정보다 우선합니다. config 디렉토리를 만들면 더 높은 우선순위를 가집니다. 설정 변경 시 재빌드 없이 재시작만 하면 됩니다.

**Spring Cloud Config:**

중앙 집중식 설정 관리를 위해 Spring Cloud Config를 사용할 수 있습니다. Git 저장소에 모든 환경의 설정을 저장합니다. Config 서버에서 설정을 제공합니다. 마이크로서비스들이 Config 서버에서 설정을 가져옵니다. 설정 변경 시 애플리케이션 재시작 없이 갱신할 수 있습니다.

**기본 프로파일:**

프로파일이 지정되지 않으면 default 프로파일이 활성화됩니다. spring.profiles.default로 기본 프로파일을 변경할 수 있습니다. application-default.properties에 기본 설정을 넣습니다.

**프로파일 감지:**

Environment 객체를 주입받아 활성 프로파일을 확인할 수 있습니다. getActiveProfiles 메서드로 배열을 받습니다. 특정 프로파일이 활성화되었는지 체크할 수 있습니다. 프로파일에 따라 동적으로 동작을 변경할 수 있습니다.

**@Conditional과 조합:**

@Conditional 어노테이션과 함께 사용하여 더 복잡한 조건을 만들 수 있습니다. @ConditionalOnProperty로 프로퍼티 값에 따라 Bean을 등록합니다. 프로파일과 프로퍼티를 조합하여 세밀하게 제어합니다.

**테스트에서의 프로파일:**

@ActiveProfiles 어노테이션으로 테스트 프로파일을 지정합니다. test 프로파일을 활성화하여 테스트용 설정을 사용합니다. 인메모리 데이터베이스, Mock 객체 등을 설정합니다.

**실무 활용 팁:**

local, dev, qa, staging, prod 같은 환경별 프로파일을 만듭니다. 공통 설정은 application.yml에 두고 차이만 프로파일별 파일에 둡니다. 민감한 정보는 환경 변수나 외부 설정으로 관리합니다. 프로덕션 설정은 코드 저장소에 포함시키지 않습니다.

프로파일 관리는 Spring Boot의 강력한 기능입니다. 하나의 코드베이스로 여러 환경을 지원하며, 환경 전환이 간단하고 안전합니다.

## 질문 78: Spring Bean의 Scope(싱글톤, 프로토타입 등) 차이점과 활용 사례는 무엇인가요?

Bean Scope는 Bean의 생명주기와 인스턴스 생성 방식을 정의합니다. 언제, 얼마나 많은 인스턴스를 만들지 결정합니다.

**주요 Scope 종류:**

첫째, Singleton Scope입니다. Spring의 기본 Scope입니다. 컨테이너당 하나의 인스턴스만 생성됩니다. 모든 요청이 같은 인스턴스를 공유합니다. 애플리케이션 시작 시 생성되고 종료 시 소멸됩니다.

둘째, Prototype Scope입니다. 요청할 때마다 새로운 인스턴스를 생성합니다. 컨테이너는 인스턴스를 반환한 후 관리하지 않습니다. 초기화 콜백은 호출되지만 소멸 콜백은 호출되지 않습니다. 클라이언트가 직접 정리해야 합니다.

셋째, Request Scope입니다. 웹 애플리케이션에서 사용합니다. HTTP 요청마다 하나의 인스턴스를 생성합니다. 요청이 끝나면 Bean도 소멸됩니다. 요청 컨텍스트 정보를 저장하는 데 유용합니다.

넷째, Session Scope입니다. 웹 애플리케이션에서 사용합니다. HTTP 세션마다 하나의 인스턴스를 생성합니다. 세션이 만료되면 Bean도 소멸됩니다. 사용자별 정보를 저장하는 데 유용합니다.

다섯째, Application Scope입니다. ServletContext 생명주기에 맞춰집니다. 웹 애플리케이션 전체에서 하나의 인스턴스를 공유합니다. Singleton과 비슷하지만 ServletContext에 저장됩니다.

여섯째, WebSocket Scope입니다. WebSocket 세션마다 인스턴스를 생성합니다. WebSocket 연결이 유지되는 동안 Bean이 살아있습니다.

**Scope 지정 방법:**

@Scope 어노테이션을 사용합니다. Bean 정의 메서드나 클래스에 붙입니다. value 속성으로 scope 이름을 지정합니다. ConfigurableBeanFactory.SCOPE_SINGLETON이나 "singleton" 문자열을 사용합니다.

**Singleton Scope 상세:**

Spring 컨테이너가 시작될 때 Bean을 생성합니다. 하나의 공유 인스턴스를 캐시합니다. getBean 호출 시 항상 같은 인스턴스를 반환합니다.

장점은 메모리 효율성입니다. 인스턴스를 재사용하여 오버헤드가 적습니다. 상태를 공유할 수 있습니다.

단점은 동시성 문제입니다. 여러 스레드가 같은 인스턴스에 접근합니다. 상태를 가지면 스레드 안전성 문제가 발생합니다. 무상태(Stateless)로 설계해야 합니다.

활용 사례는 무상태 서비스 객체입니다. Repository, Service, Controller 등이 해당합니다. 설정이나 유틸리티 Bean에 적합합니다.

**Prototype Scope 상세:**

Bean을 요청할 때마다 새 인스턴스를 생성합니다. 생성 후 컨테이너가 관리하지 않습니다. 클라이언트가 Bean의 생명주기를 책임집니다.

소멸 콜백이 호출되지 않습니다. @PreDestroy가 실행되지 않습니다. 리소스 해제가 필요하면 직접 처리해야 합니다.

장점은 독립적인 상태 관리입니다. 각 인스턴스가 독립적입니다. 동시성 문제가 없습니다.

단점은 메모리 오버헤드입니다. 매번 새로운 객체를 생성합니다. 가비지 컬렉션 부담이 증가합니다.

활용 사례는 상태를 가지는 객체입니다. 요청마다 다른 데이터를 담는 객체입니다. 명령(Command) 패턴 객체에 적합합니다.

**Singleton과 Prototype 혼용 시 주의:**

Singleton Bean이 Prototype Bean을 주입받으면 문제가 발생합니다. Singleton Bean은 한 번만 생성되므로 Prototype Bean도 한 번만 주입됩니다. Prototype의 의도가 무시됩니다.

해결 방법은 여러 가지입니다.

첫째, Provider를 사용합니다. ObjectProvider나 JSR-330의 Provider를 주입받습니다. get 메서드를 호출할 때마다 새 인스턴스를 받습니다.

둘째, ApplicationContext를 주입받습니다. 필요할 때 getBean을 호출합니다. 하지만 컨테이너에 의존하게 되어 권장되지 않습니다.

셋째, Lookup 메서드 주입을 사용합니다. @Lookup 어노테이션을 추상 메서드에 붙입니다. Spring이 동적으로 구현을 제공합니다. 메서드 호출 시마다 새 Bean을 반환합니다.

넷째, Scoped Proxy를 사용합니다. proxyMode 속성을 설정합니다. 프록시 객체가 주입되고, 메서드 호출 시 실제 Bean을 가져옵니다.

**Request Scope 상세:**

HTTP 요청마다 새로운 Bean 인스턴스를 생성합니다. 요청이 처리되는 동안 같은 인스턴스를 사용합니다. 요청이 끝나면 Bean이 소멸됩니다.

@RequestScope 어노테이션을 사용할 수 있습니다. @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)와 동일합니다.

proxyMode가 필요한 이유는 Singleton Bean에 주입하기 위해서입니다. 프록시가 주입되고, 실제 호출 시 현재 요청의 Bean을 사용합니다.

활용 사례는 요청 컨텍스트 정보입니다. 현재 사용자 정보, 요청 ID, 로깅 컨텍스트 등을 저장합니다. 요청 전반에서 공유해야 하는 데이터에 적합합니다.

**Session Scope 상세:**

HTTP 세션마다 Bean 인스턴스를 생성합니다. 세션이 유지되는 동안 같은 인스턴스를 사용합니다. 세션이 만료되면 Bean도 소멸됩니다.

@SessionScope 어노테이션을 사용할 수 있습니다.

활용 사례는 사용자별 상태 정보입니다. 장바구니, 사용자 설정, 위저드 폼 데이터 등을 저장합니다. 여러 요청에 걸쳐 유지되어야 하는 데이터에 적합합니다.

주의점은 세션에 너무 많은 데이터를 저장하면 메모리 문제가 발생합니다. 직렬화 가능한 객체여야 세션 복제가 됩니다.

**Application Scope 상세:**

ServletContext 레벨의 Scope입니다. 웹 애플리케이션 전체에서 하나의 인스턴스를 공유합니다. Singleton과 유사하지만 ServletContext에 속성으로 저장됩니다.

@ApplicationScope 어노테이션을 사용할 수 있습니다.

활용 사례는 애플리케이션 레벨 공유 데이터입니다. 전역 설정, 공통 캐시 등에 사용합니다.

**커스텀 Scope:**

Scope 인터페이스를 구현하여 커스텀 Scope를 만들 수 있습니다. get, remove, registerDestructionCallback 등의 메서드를 구현합니다. ConfigurableBeanFactory에 등록합니다. 특수한 생명주기 요구사항을 만족시킬 수 있습니다.

**Scope와 AOP:**

Scoped Proxy는 AOP 프록시를 사용합니다. CGLIB 프록시나 JDK Dynamic Proxy를 생성합니다. 메서드 호출을 가로채 실제 Bean을 조회합니다. 현재 컨텍스트의 Bean 인스턴스를 사용합니다.

**성능 고려사항:**

Singleton은 가장 효율적입니다. 인스턴스 생성 비용이 한 번만 발생합니다. 가능한 한 Singleton을 사용하는 것이 좋습니다.

Prototype은 매번 생성 비용이 발생합니다. 무거운 객체는 피하는 것이 좋습니다. 정말 필요한 경우에만 사용합니다.

Request와 Session Scope는 프록시 오버헤드가 있습니다. 하지만 편의성이 오버헤드보다 큽니다.

**테스트에서의 Scope:**

테스트에서는 대부분 Singleton으로 동작합니다. @SpringBootTest가 애플리케이션 컨텍스트를 생성합니다. Request나 Session Scope를 테스트하려면 MockHttpServletRequest나 MockHttpSession을 사용합니다.

**실무 권장사항:**

기본적으로 Singleton을 사용합니다. 상태를 가지지 않도록 설계합니다. 필드 대신 메서드 파라미터로 데이터를 전달합니다. 정말 필요한 경우에만 다른 Scope를 사용합니다. Prototype은 드물게 사용합니다. Request Scope는 요청 컨텍스트 정보에 유용합니다.

Bean Scope를 올바르게 이해하고 사용하면 메모리 효율성과 스레드 안전성을 모두 확보할 수 있습니다.

## 질문 79: Spring의 이벤트 발행 및 리스너(Event Listener) 메커니즘에 대해 설명해주세요.

Spring의 이벤트 메커니즘은 애플리케이션 내에서 느슨하게 결합된 컴포넌트 간 통신을 가능하게 합니다. 발행-구독 패턴을 구현한 것입니다.

**이벤트가 필요한 이유:**

첫째, 결합도 감소입니다. 발행자는 구독자를 알 필요가 없습니다. 구독자도 발행자를 직접 의존하지 않습니다. 인터페이스나 이벤트만 의존합니다.

둘째, 확장성입니다. 새로운 리스너를 쉽게 추가할 수 있습니다. 기존 코드를 수정하지 않습니다. 개방-폐쇄 원칙(OCP)을 따릅니다.

셋째, 단일 책임 원칙입니다. 각 컴포넌트가 자신의 책임에만 집중합니다. 다른 컴포넌트를 직접 호출하지 않습니다.

넷째, 비동기 처리 가능성입니다. 이벤트 처리를 비동기로 할 수 있습니다. 메인 로직의 성능에 영향을 주지 않습니다.

**이벤트 정의:**

이벤트는 일반 POJO 클래스입니다. ApplicationEvent를 상속할 필요가 없습니다. (Spring 4.2부터) 이벤트 데이터를 필드로 가집니다. 불변 객체로 만드는 것이 좋습니다.

레거시 방식은 ApplicationEvent를 상속합니다. source 객체를 생성자로 받습니다. 하지만 현재는 권장되지 않습니다.

**이벤트 발행:**

ApplicationEventPublisher를 주입받습니다. publishEvent 메서드로 이벤트를 발행합니다. 이벤트 객체를 인자로 전달합니다.

ApplicationEventPublisher는 ApplicationContext의 일부입니다. ApplicationContext를 직접 주입받아도 됩니다. 하지만 ApplicationEventPublisher를 주입받는 것이 더 명확합니다.

**이벤트 리스너:**

@EventListener 어노테이션을 사용합니다. 메서드에 붙이면 해당 메서드가 이벤트 리스너가 됩니다. 메서드 파라미터로 이벤트 타입을 지정합니다. Spring이 자동으로 해당 타입의 이벤트를 전달합니다.

레거시 방식은 ApplicationListener 인터페이스를 구현합니다. onApplicationEvent 메서드를 오버라이드합니다. 제네릭으로 이벤트 타입을 지정합니다. 하지만 현재는 @EventListener가 권장됩니다.

**조건부 이벤트 처리:**

@EventListener의 condition 속성을 사용합니다. SpEL 표현식으로 조건을 지정합니다. 이벤트 속성 값에 따라 처리 여부를 결정합니다. 예를 들어 특정 타입의 주문만 처리할 수 있습니다.

**이벤트 순서:**

여러 리스너가 있을 때 순서를 지정할 수 있습니다. @Order 어노테이션을 사용합니다. 숫자가 낮을수록 먼저 실행됩니다. Ordered 인터페이스를 구현할 수도 있습니다.

**비동기 이벤트 처리:**

@Async 어노테이션을 리스너 메서드에 붙입니다. @EnableAsync로 비동기 처리를 활성화합니다. 이벤트 처리가 별도 스레드에서 실행됩니다. 발행자는 블로킹되지 않고 계속 진행합니다.

주의점은 예외 처리입니다. 비동기로 실행되므로 예외가 발생해도 발행자는 알 수 없습니다. AsyncUncaughtExceptionHandler를 설정하여 예외를 처리합니다.

또한 트랜잭션 컨텍스트가 공유되지 않습니다. 리스너는 별도의 트랜잭션을 가집니다.

**트랜잭션 이벤트:**

@TransactionalEventListener를 사용합니다. 트랜잭션 상태에 따라 이벤트를 처리합니다.

phase 속성으로 실행 시점을 지정합니다. AFTER_COMMIT은 트랜잭션 커밋 후 실행됩니다. 기본값입니다. AFTER_ROLLBACK은 트랜잭션 롤백 후 실행됩니다. AFTER_COMPLETION은 커밋이나 롤백 후 실행됩니다. BEFORE_COMMIT은 커밋 전에 실행됩니다.

활용 사례는 데이터 일관성 보장입니다. 트랜잭션이 성공한 후에만 이메일을 발송합니다. 외부 API 호출을 트랜잭션 성공 후에 합니다. 롤백 시에는 이벤트가 처리되지 않습니다.

**제네릭 이벤트:**

제네릭 타입의 이벤트를 만들 수 있습니다. ResolvableTypeProvider 인터페이스를 구현합니다. getResolvableType 메서드로 타입 정보를 제공합니다. 리스너는 구체적인 제네릭 타입으로 이벤트를 받습니다.

**Spring의 내장 이벤트:**

ContextRefreshedEvent는 ApplicationContext가 초기화되거나 갱신될 때 발행됩니다. 모든 Bean이 로드되고 초기화된 후입니다. 애플리케이션 시작 후 초기화 작업을 수행할 때 사용합니다.

ContextStartedEvent는 start 메서드 호출 시 발행됩니다.

ContextStoppedEvent는 stop 메서드 호출 시 발행됩니다.

ContextClosedEvent는 ApplicationContext가 닫힐 때 발행됩니다. 애플리케이션 종료 시 정리 작업을 수행할 때 사용합니다.

RequestHandledEvent는 HTTP 요청이 처리된 후 발행됩니다. 웹 애플리케이션에서만 사용합니다.

**이벤트 리스너 반환값:**

리스너 메서드가 값을 반환하면 그 값이 새로운 이벤트로 발행됩니다. 이벤트 체이닝이 가능합니다. 하나의 이벤트가 다른 이벤트를 트리거합니다.

Collection을 반환하면 각 요소가 개별 이벤트로 발행됩니다.

**예외 처리:**

이벤트 리스너에서 예외가 발생하면 다른 리스너에 영향을 줍니다. 기본적으로 첫 예외에서 중단됩니다. 다른 리스너들이 실행되지 않을 수 있습니다.

ApplicationEventMulticaster를 커스터마이징하여 예외 처리 방식을 변경할 수 있습니다. ErrorHandler를 설정하여 예외를 로깅하고 계속 진행할 수 있습니다.

**실무 활용 사례:**

첫째, 회원 가입 시나리오입니다. 회원 가입 이벤트를 발행합니다. 이메일 발송 리스너가 환영 메일을 보냅니다. 통계 리스너가 가입 통계를 업데이트합니다. 쿠폰 리스너가 가입 쿠폰을 발급합니다. 각 리스너는 독립적으로 동작합니다.

둘째, 주문 완료 시나리오입니다. 주문 완료 이벤트를 발행합니다. 재고 리스너가 재고를 감소시킵니다. 알림 리스너가 판매자에게 알림을 보냅니다. 포인트 리스너가 포인트를 적립합니다.

셋째, 감사(Audit) 로깅입니다. 중요한 작업 후 감사 이벤트를 발행합니다. 감사 로그 리스너가 별도 테이블에 기록합니다. 비즈니스 로직에서 로깅 코드가 분리됩니다.

넷째, 캐시 무효화입니다. 데이터 변경 이벤트를 발행합니다. 캐시 리스너가 관련 캐시를 무효화합니다. 데이터 일관성을 유지합니다.

**장점:**

느슨한 결합으로 유지보수가 쉽습니다. 새로운 기능 추가가 간단합니다. 테스트가 용이합니다. 각 리스너를 독립적으로 테스트할 수 있습니다. 비동기 처리로 성능을 향상시킬 수 있습니다.

**주의사항:**

과도한 사용은 코드 흐름을 파악하기 어렵게 만듭니다. 이벤트가 어디서 처리되는지 추적하기 어려울 수 있습니다. 디버깅이 복잡해질 수 있습니다. 순환 이벤트 발행을 조심해야 합니다.

트랜잭션 경계를 명확히 해야 합니다. 비동기 리스너는 별도 트랜잭션입니다. 데이터 일관성을 고려해야 합니다.

**메시징 시스템과의 차이:**

Spring 이벤트는 같은 JVM 내에서만 동작합니다. 프로세스 간 통신은 불가능합니다. 간단한 이벤트 처리에 적합합니다.

Kafka나 RabbitMQ 같은 메시징 시스템은 분산 환경에서 동작합니다. 서비스 간 통신에 사용합니다. 메시지 영속성과 재처리를 보장합니다.

Spring 이벤트는 애플리케이션 내부 컴포넌트 간 통신에 적합합니다. 간단하고 오버헤드가 적습니다. 복잡한 분산 시스템에는 메시징 시스템을 사용하는 것이 좋습니다.

## 질문 80: 커스텀 어노테이션을 생성하고 이를 Spring에서 활용하는 방법은 무엇인가요?

커스텀 어노테이션은 메타데이터를 선언적으로 표현하고 반복적인 코드를 줄이는 강력한 도구입니다. Spring에서는 AOP, 리플렉션, 프록시를 활용하여 커스텀 어노테이션에 동작을 부여할 수 있습니다.

**어노테이션 생성 기본:**

@interface 키워드로 어노테이션을 정의합니다. 일반 인터페이스와 구분됩니다.

메타 어노테이션을 붙입니다. @Target으로 어노테이션을 적용할 위치를 지정합니다. ElementType.METHOD는 메서드에 적용합니다. ElementType.TYPE은 클래스나 인터페이스에 적용합니다. ElementType.FIELD는 필드에 적용합니다. ElementType.PARAMETER는 파라미터에 적용합니다. 배열로 여러 타입을 지정할 수 있습니다.

@Retention으로 어노테이션 정보를 언제까지 유지할지 지정합니다. RetentionPolicy.SOURCE는 컴파일 시 제거됩니다. 주석 정도의 역할만 합니다. RetentionPolicy.CLASS는 컴파일 후 클래스 파일에는 남지만 런타임에는 사라집니다. 기본값입니다. RetentionPolicy.RUNTIME은 런타임까지 유지됩니다. 리플렉션으로 읽을 수 있습니다. Spring에서 사용하려면 RUNTIME이어야 합니다.

@Documented를 붙이면 JavaDoc에 포함됩니다.

@Inherited를 붙이면 하위 클래스가 상속받습니다.

**어노테이션 속성:**

메서드 형태로 속성을 정의합니다. 반환 타입이 속성의 타입입니다. 기본값을 지정할 수 있습니다. default 키워드를 사용합니다.

속성 타입은 기본 타입, String, Class, 열거형, 어노테이션, 배열이 가능합니다.

value라는 이름의 속성은 특별합니다. 단일 속성이면 이름을 생략하고 값만 지정할 수 있습니다.

**메타 어노테이션 활용:**

기존 어노테이션을 조합하여 새로운 어노테이션을 만들 수 있습니다. 여러 어노테이션을 하나로 묶습니다. 반복을 줄이고 의도를 명확히 합니다.

예를 들어 @RestController와 @RequestMapping을 묶어 커스텀 어노테이션을 만들 수 있습니다. @Service와 @Transactional을 묶을 수도 있습니다.

**AOP로 동작 부여:**

커스텀 어노테이션에 실제 동작을 부여하려면 AOP를 사용합니다.

@Aspect 클래스를 만듭니다. @Around 어드바이스를 정의합니다. Pointcut 표현식에서 @annotation을 사용합니다. 커스텀 어노테이션이 붙은 메서드를 대상으로 합니다.

ProceedingJoinPoint로 원본 메서드를 제어합니다. proceed 호출 전후에 로직을 추가합니다. 어노테이션 속성 값을 읽어 동작을 커스터마이징합니다.

**어노테이션 속성 읽기:**

리플렉션으로 어노테이션 정보를 읽습니다. Method 객체에서 getAnnotation 메서드를 호출합니다. 어노테이션 인스턴스를 얻습니다. 속성 값을 읽어 사용합니다.

JoinPoint에서 MethodSignature를 얻습니다. getMethod로 Method 객체를 얻습니다. 어노테이션을 조회합니다.

**실무 활용 사례:**

첫째, 로깅 어노테이션입니다. @Logging 어노테이션을 만듭니다. 메서드 실행 시간, 파라미터, 반환값을 자동으로 로깅합니다. level 속성으로 로그 레벨을 지정할 수 있습니다. AOP로 구현하여 모든 @Logging 메서드에 적용합니다.

둘째, 재시도 어노테이션입니다. @Retry 어노테이션을 만듭니다. 실패 시 자동으로 재시도합니다. maxAttempts와 delay 속성을 정의합니다. AOP에서 예외 발생 시 재시도 로직을 실행합니다.

셋째, 캐싱 어노테이션입니다. @CustomCache 어노테이션을 만듭니다. 메서드 결과를 캐싱합니다. Spring의 @Cacheable과 유사하지만 커스텀 로직을 추가할 수 있습니다. TTL, 캐시 키 생성 전략 등을 속성으로 지정합니다.

넷째, 권한 검사 어노테이션입니다. @RequiresRole 어노테이션을 만듭니다. 특정 역할을 가진 사용자만 메서드를 실행할 수 있습니다. AOP에서 SecurityContext를 확인합니다. 권한이 없으면 AccessDeniedException을 던집니다.

다섯째, 실행 시간 측정 어노테이션입니다. @Timed 어노테이션을 만듭니다. 메서드 실행 시간을 측정하여 메트릭으로 수집합니다. Micrometer와 통합하여 Prometheus로 전송합니다.

여섯째, 검증 어노테이션입니다. Bean Validation의 커스텀 제약 조건을 만듭니다. @ValidPhoneNumber 같은 도메인 특화 검증 어노테이션을 정의합니다. ConstraintValidator를 구현하여 검증 로직을 작성합니다.

**ArgumentResolver와 조합:**

HandlerMethodArgumentResolver를 구현합니다. 컨트롤러 메서드의 파라미터를 자동으로 바인딩합니다. 커스텀 어노테이션이 붙은 파라미터를 처리합니다.

예를 들어 @CurrentUser 어노테이션을 만듭니다. 현재 로그인한 사용자 객체를 자동으로 주입합니다. SecurityContext에서 사용자를 조회하여 반환합니다.

**Interceptor와 조합:**

HandlerInterceptor를 구현합니다. 컨트롤러 메서드의 어노테이션을 확인합니다. preHandle에서 어노테이션 유무에 따라 처리합니다. 권한 검사, 로깅, 사전 조건 확인 등을 수행합니다.

**BeanPostProcessor와 조합:**

BeanPostProcessor를 구현합니다. Bean 초기화 단계에서 어노테이션을 처리합니다. 클래스나 메서드의 어노테이션을 스캔합니다. 특정 설정을 자동으로 적용하거나 프록시를 생성합니다.

예를 들어 @Scheduled가 이 방식으로 동작합니다. ScheduledAnnotationBeanPostProcessor가 @Scheduled 메서드를 찾아 스케줄링을 등록합니다.

**조건부 Bean 등록:**

@Conditional과 유사한 커스텀 어노테이션을 만들 수 있습니다. Condition 인터페이스를 구현합니다. matches 메서드에서 조건을 평가합니다. 어노테이션 속성 값에 따라 Bean 등록 여부를 결정합니다.

**주의사항:**

어노테이션 남용을 피해야 합니다. 너무 많은 커스텀 어노테이션은 복잡도를 높입니다. 팀원이 이해하기 어려워집니다. 표준 어노테이션으로 해결할 수 있으면 그것을 사용합니다.

문서화가 중요합니다. JavaDoc으로 어노테이션의 목적과 사용법을 명확히 합니다. 예제를 포함시킵니다.

테스트를 작성해야 합니다. 어노테이션이 올바르게 동작하는지 검증합니다. AOP나 Interceptor 로직을 테스트합니다.

**디버깅:**

어노테이션 기반 로직은 디버깅이 어려울 수 있습니다. 명시적인 메서드 호출이 아니기 때문입니다. 충분한 로깅을 추가합니다. 어노테이션 처리 시점을 로그로 남깁니다.

**성능 고려:**

리플렉션은 성능 오버헤드가 있습니다. 자주 호출되는 메서드에서는 주의합니다. 어노테이션 정보를 캐싱하여 반복적인 리플렉션을 피합니다.

**Spring의 어노테이션 처리 메커니즘:**

Spring은 다양한 방법으로 어노테이션을 처리합니다. BeanPostProcessor로 Bean 레벨 어노테이션을 처리합니다. AOP로 메서드 레벨 어노테이션을 처리합니다. Resolver로 파라미터 레벨 어노테이션을 처리합니다. Interceptor로 요청 레벨 어노테이션을 처리합니다.

이 메커니즘들을 이해하면 원하는 동작을 구현할 수 있습니다.

커스텀 어노테이션은 코드를 선언적이고 간결하게 만듭니다. 횡단 관심사를 우아하게 분리할 수 있습니다. Spring의 강력한 기능들과 결합하여 생산성을 크게 높일 수 있습니다.
