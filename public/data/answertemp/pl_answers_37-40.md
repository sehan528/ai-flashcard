## 질문 37: var 키워드(Java 10+)의 사용과 제한사항은 무엇인가요?

**정의:**
var 키워드는 Java 10에서 도입된 지역 변수 타입 추론 기능으로, 컴파일러가 초기화 표현식으로부터 변수의 타입을 자동으로 추론합니다. 명시적 타입 선언을 생략하여 코드를 간결하게 만들지만, 가독성을 해치지 않는 범위에서 사용해야 합니다.

**특징/원리:**
- 컴파일 타임 추론: 컴파일러가 우변의 표현식으로부터 타입을 추론하며 런타임 오버헤드 없음
- 강타입 유지: 추론된 후에는 해당 타입으로 고정되며 다른 타입 할당 불가
- 지역 변수 전용: 메서드 내 지역 변수에만 사용 가능하며 필드, 메서드 파라미터, 리턴 타입에는 사용 불가
- 초기화 필수: var 선언 시 반드시 초기화 표현식 필요

**사용 가능한 위치:**
- 지역 변수: 메서드 내에서 선언하는 변수에 사용 가능
- for 루프: 향상된 for문과 전통적 for문의 초기화 부분에서 사용 가능
- try-with-resources: 리소스 선언에 사용 가능
- 람다 파라미터: Java 11부터 람다 표현식의 파라미터에도 사용 가능하며 어노테이션 추가 가능

**제한사항:**
- 초기화 없는 선언 불가: var x; 같은 선언은 불가능하며 반드시 초기값 필요
- null 초기화 불가: var x = null;은 타입 추론 불가하여 컴파일 에러
- 필드 불가: 클래스나 인스턴스 필드에는 사용 불가
- 메서드 시그니처 불가: 파라미터, 리턴 타입에는 사용 불가
- 배열 초기화: var arr = {1, 2, 3};은 불가하며 new int[]{1, 2, 3} 필요

**가독성 고려사항:**
- 명확한 경우: var list = new ArrayList<String>(); 처럼 우변이 명확하면 사용 권장
- 불명확한 경우: var result = process(); 처럼 반환 타입이 명확하지 않으면 사용 지양
- 다이아몬드 연산자: var map = new HashMap<>();는 HashMap<Object, Object>로 추론되므로 주의
- 네이밍: 변수명을 명확하게 작성하여 추론된 타입을 알 수 있도록 함

**실무 활용:**
- 긴 제네릭 타입 선언을 var로 간결하게 표현하여 가독성 향상
- Stream API나 복잡한 빌더 패턴 사용 시 var로 중간 변수 타입 생략
- 코드 리팩토링 시 타입 변경이 자동으로 반영되어 유지보수성 향상

---

## 질문 38: Record 클래스(Java 14+)의 특징과 사용 시나리오를 설명해주세요.

**정의:**
Record는 Java 14에서 프리뷰로 도입되어 Java 16에서 정식 기능이 된 특수한 클래스로, 불변 데이터를 저장하는 투명한 캐리어 역할을 합니다. 보일러플레이트 코드 없이 간결하게 데이터 클래스를 정의할 수 있으며, 자동으로 생성자, getter, equals, hashCode, toString을 제공합니다.

**특징/원리:**
- 불변성: 모든 필드가 final이며 setter가 없어 생성 후 변경 불가
- 자동 생성: 컴파일러가 표준 메서드들을 자동으로 생성하여 보일러플레이트 제거
- 투명성: 클래스의 상태가 선언된 필드로만 구성되어 예측 가능하고 명확
- 간결성: 한 줄로 데이터 클래스 정의 가능하여 코드 양 대폭 감소

**자동 생성 메서드:**
- 정규 생성자: 모든 필드를 파라미터로 받는 생성자 자동 생성
- 접근자 메서드: 각 필드에 대한 getter 자동 생성하며, getX() 형태가 아닌 필드명과 동일한 메서드
- equals(): 모든 필드 값을 비교하는 equals() 메서드 자동 생성
- hashCode(): 모든 필드를 기반으로 한 hashCode() 메서드 자동 생성
- toString(): 클래스명과 모든 필드 값을 포함하는 toString() 메서드 자동 생성

**커스터마이징:**
- Compact 생성자: 파라미터 목록 없이 검증 로직만 작성하면 정규 생성자에 자동 통합
- 명시적 생성자: 정규 생성자를 명시적으로 정의하여 검증이나 정규화 수행
- 메서드 오버라이드: 자동 생성된 메서드를 재정의하여 커스텀 동작 구현
- 추가 메서드: 일반 메서드와 static 메서드 정의 가능

**제약사항:**
- 상속 불가: Record는 암묵적으로 final이며 다른 클래스를 상속하거나 상속될 수 없음
- 필드 불변: 모든 필드는 final이어야 하며 변경 불가
- 인스턴스 필드 추가 불가: 선언한 필드 외에 추가 인스턴스 필드 정의 불가
- 네이티브 메서드 불가: Record에서는 네이티브 메서드 정의 불가

**실무 활용:**
- DTO나 VO 같은 데이터 전달 객체를 Record로 간결하게 정의
- 불변 설정 클래스나 설정 객체를 Record로 구현하여 안전성 확보
- Stream API의 중간 결과나 튜플처럼 여러 값을 묶어 반환할 때 사용

---

## 질문 39: Sealed Class(Java 17+)란 무엇이고 왜 필요한가요?

**정의:**
Sealed Class는 Java 17에서 정식 기능이 된 것으로, 어떤 클래스가 이 클래스를 상속하거나 구현할 수 있는지를 명시적으로 제한하는 기능입니다. permits 키워드로 허용된 하위 타입만 상속 가능하여 타입 계층을 더 안전하고 예측 가능하게 만듭니다.

**특징/원리:**
- 제한된 상속: sealed 클래스는 permits로 명시된 클래스만 상속 가능
- 완전성 검증: 컴파일러가 모든 하위 타입을 알고 있어 switch 문에서 완전성 체크 가능
- 명시적 계층: 타입 계층 구조를 코드에 명확히 표현하여 이해하기 쉬움
- 하위 타입 선택: 하위 클래스는 final, sealed, non-sealed 중 하나로 선언 필수

**하위 클래스 수정자:**
- final: 더 이상 상속 불가능하며 계층 종료
- sealed: 또 다시 제한된 하위 타입만 허용하는 sealed 클래스
- non-sealed: sealed 제약을 해제하여 누구나 상속 가능하게 개방

**permits 절:**
- 명시적 선언: permits 키워드로 허용할 하위 클래스 나열
- 같은 모듈/패키지: 허용된 하위 클래스는 같은 모듈이나 패키지에 있어야 함
- 암묵적 permits: 같은 파일에 모든 하위 클래스가 있으면 permits 생략 가능

**패턴 매칭과의 시너지:**
- 완전한 switch: 모든 하위 타입을 알고 있어 switch 문에서 default 불필요
- 컴파일 검증: 새로운 하위 타입 추가 시 switch 문을 업데이트하지 않으면 컴파일 에러
- 타입 안전성: instanceof 패턴 매칭과 결합하여 타입 안전한 분기 처리

**실무 활용:**
- 도메인 모델의 제한된 타입 계층 표현 (예: 결제 수단을 카드, 현금, 포인트로 제한)
- 상태 패턴 구현 시 가능한 모든 상태를 명시적으로 선언
- API 설계 시 확장 가능한 부분과 불가능한 부분을 명확히 구분

---

## 질문 40: Pattern Matching(Java 14+)의 개선사항을 설명해주세요.

**정의:**
Pattern Matching은 Java 14부터 단계적으로 도입된 기능으로, 타입 검사와 형변환을 하나의 표현식으로 결합하여 코드를 간결하고 안전하게 만듭니다. instanceof, switch 문 등에서 패턴 매칭을 지원하여 조건 분기 로직을 더 직관적으로 작성할 수 있습니다.

**특징/원리:**
- 타입 패턴: 타입 검사와 동시에 변수 바인딩을 수행하여 명시적 캐스팅 불필요
- 스코프: 패턴 변수는 해당 패턴이 성공하는 범위에서만 사용 가능
- 타입 안전성: 컴파일러가 타입을 보장하여 ClassCastException 방지
- 가독성: 의도가 명확하게 드러나는 선언적 코드 작성 가능

**instanceof 패턴 매칭:**
- 전통적 방식: instanceof로 타입 체크 후 명시적 캐스팅 필요
- 패턴 매칭: if (obj instanceof String s)로 타입 체크와 변수 선언을 동시에 수행
- 스코프: 조건이 true인 블록 내에서만 패턴 변수 사용 가능
- 논리 연산: && 연산자로 연결 시 후속 조건에서도 패턴 변수 사용 가능

**switch 표현식 패턴 매칭:**
- 타입 패턴: case String s -> 형태로 타입별 분기 처리
- 가드 조건: case String s when s.length() > 10 -> 처럼 추가 조건 지정
- 완전성: sealed 클래스와 함께 사용 시 모든 하위 타입을 다루면 default 불필요
- null 처리: case null -> 로 null을 명시적으로 처리 가능

**Record 패턴:**
- 분해: Record의 컴포넌트를 패턴으로 추출하여 중첩된 구조 분해 가능
- 네스팅: 중첩된 Record를 한 번에 분해하여 깊은 구조 접근 간소화
- 타입 안전: 컴파일러가 Record 구조를 검증하여 안전성 보장

**실무 활용:**
- 다형성 처리 시 instanceof 패턴 매칭으로 타입별 로직을 간결하게 구현
- sealed 클래스의 하위 타입을 switch로 처리하여 모든 경우를 완전하게 다룸
- JSON 파싱이나 이벤트 처리 등에서 타입에 따른 분기를 명확하고 안전하게 표현

---
