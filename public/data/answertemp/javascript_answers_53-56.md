# JavaScript 답변 53-56

## 질문 53: 이벤트 위임(Event Delegation)이란 무엇이고 왜 사용하나요?

**정의:**
이벤트 위임은 여러 자식 요소의 이벤트를 부모 요소에서 한 번에 처리하는 패턴입니다. 이벤트 버블링을 활용하여 효율적인 이벤트 관리를 가능하게 합니다.

**동작 원리:**
- 부모 요소에 이벤트 리스너를 등록합니다. 자식마다 등록하지 않습니다.
- 자식 요소에서 이벤트가 발생하면 버블링됩니다.
- 부모의 핸들러에서 event.target으로 실제 타겟을 확인합니다.
- 조건에 따라 적절히 처리합니다.

**이벤트 위임의 장점:**
- 메모리 사용량이 줄어듭니다. 리스너 하나만 필요합니다.
- 동적으로 추가되는 요소도 자동으로 처리됩니다. 새로 등록할 필요가 없습니다.
- 코드가 간결해집니다. 반복적인 리스너 등록을 피합니다.
- 제거 시 관리가 쉽습니다. 한 곳에서만 제거하면 됩니다.

**구현 방법:**
- 부모 요소를 선택합니다. 공통 조상을 찾습니다.
- 이벤트 리스너를 부모에 등록합니다.
- event.target으로 실제 클릭된 요소를 확인합니다.
- 조건문으로 원하는 요소인지 검사합니다. 클래스나 태그를 확인합니다.
- 적절한 처리를 수행합니다.

**target과 currentTarget 구분:**
- target은 실제 이벤트가 발생한 요소입니다. 클릭된 정확한 요소입니다.
- currentTarget은 리스너가 등록된 요소입니다. 항상 부모 요소입니다.
- 위임에서는 target을 사용하여 자식을 식별합니다.

**closest 메서드 활용:**
- 이벤트 타겟에서 가장 가까운 조건 요소를 찾습니다.
- 정확한 요소를 클릭하지 않아도 처리할 수 있습니다.
- 중첩된 구조에서 유용합니다.
- 버튼 내부의 아이콘을 클릭해도 버튼을 찾을 수 있습니다.

**matches 메서드:**
- 요소가 특정 선택자와 일치하는지 확인합니다.
- 조건부 처리를 간결하게 만듭니다.
- 복잡한 선택자도 사용할 수 있습니다.

**주의사항:**
- 모든 이벤트가 버블링되지는 않습니다. focus, blur 등은 위임이 어렵습니다.
- 너무 깊은 중첩은 성능에 영향을 줄 수 있습니다.
- stopPropagation을 사용한 요소는 위임에서 처리되지 않습니다.
- 너무 상위에 등록하면 불필요한 이벤트도 처리하게 됩니다.

**실무 활용:**
- 목록 아이템의 클릭 이벤트를 처리합니다. 수백 개의 아이템도 효율적으로 관리합니다.
- 동적으로 생성되는 요소를 다룹니다. Ajax로 추가된 요소도 자동 처리됩니다.
- 테이블의 행 클릭, 삭제 버튼 등을 구현합니다.
- 싱글 페이지 애플리케이션에서 라우팅 링크를 처리합니다.
- React나 Vue 같은 프레임워크도 내부적으로 이벤트 위임을 사용합니다.

---

## 질문 54: preventDefault()와 stopPropagation()의 차이점은 무엇인가요?

**정의:**
preventDefault는 브라우저의 기본 동작을 취소하고, stopPropagation은 이벤트 전파를 중단합니다. 목적과 영향 범위가 완전히 다릅니다.

**preventDefault의 동작:**
- 브라우저의 기본 동작을 막습니다. 링크 이동, 폼 제출 등을 차단합니다.
- 이벤트 전파에는 영향을 주지 않습니다. 버블링은 계속됩니다.
- 취소 가능한 이벤트에만 효과가 있습니다.
- event.defaultPrevented로 취소 여부를 확인할 수 있습니다.

**기본 동작의 예:**
- 링크 클릭 시 페이지 이동합니다.
- 폼 제출 시 페이지가 새로고침됩니다.
- 마우스 우클릭 시 컨텍스트 메뉴가 나타납니다.
- 텍스트 드래그 시 선택됩니다.
- Enter 키 시 폼이 제출됩니다.

**preventDefault 사용 사례:**
- 싱글 페이지 애플리케이션에서 링크를 JavaScript로 처리합니다.
- Ajax로 폼을 제출합니다. 페이지 새로고침을 막습니다.
- 커스텀 컨텍스트 메뉴를 구현합니다.
- 드래그 앤 드롭을 커스터마이징합니다.
- 키보드 입력을 제한합니다.

**stopPropagation의 동작:**
- 이벤트 전파를 중단합니다. 부모나 자식으로 전파되지 않습니다.
- 기본 동작에는 영향을 주지 않습니다. 브라우저 동작은 계속됩니다.
- 같은 요소의 다른 핸들러는 실행됩니다.
- 버블링과 캡처링 모두 중단할 수 있습니다.

**stopImmediatePropagation:**
- stopPropagation보다 강력합니다.
- 같은 요소의 다른 핸들러도 실행하지 않습니다.
- 이벤트를 완전히 차단합니다.
- 핸들러 등록 순서에 따라 일부만 실행될 수 있습니다.

**stopPropagation 사용 사례:**
- 부모의 클릭 핸들러를 실행하지 않아야 할 때 사용합니다.
- 중첩된 요소에서 각각 다른 동작을 해야 할 때 유용합니다.
- 모달 내부 클릭 시 모달이 닫히지 않도록 합니다.
- 드롭다운 메뉴 내부 클릭을 분리합니다.

**함께 사용:**
- 두 메서드는 독립적입니다. 동시에 사용할 수 있습니다.
- 링크의 기본 동작을 막으면서 버블링도 차단할 수 있습니다.
- 필요에 따라 하나만 사용하거나 둘 다 사용합니다.

**return false의 의미:**
- jQuery에서는 두 메서드를 모두 호출합니다.
- 순수 JavaScript에서는 기본 동작만 막습니다. 비표준 동작입니다.
- 명시적으로 메서드를 호출하는 것이 권장됩니다.
- 혼란을 피하기 위해 사용을 자제합니다.

**실무 권장사항:**
- 의도를 명확히 합니다. 무엇을 막으려는지 생각합니다.
- 기본 동작을 막으려면 preventDefault를 사용합니다.
- 이벤트 전파를 막으려면 stopPropagation을 사용합니다.
- stopPropagation은 신중하게 사용합니다. 예상치 못한 부작용이 있을 수 있습니다.
- 이벤트 위임을 사용할 때는 전파를 막지 않도록 주의합니다.

---

## 질문 55: DOM 조작을 최소화해야 하는 이유는 무엇인가요?

**정의:**
DOM 조작은 브라우저 렌더링 엔진의 재계산을 유발하여 성능 저하를 일으킵니다. 최소화하면 애플리케이션의 반응성과 성능이 크게 향상됩니다.

**DOM 조작의 비용:**
- 리플로우가 발생합니다. 레이아웃을 다시 계산합니다. 위치와 크기를 재계산하는 비용이 큽니다.
- 리페인트가 발생합니다. 화면을 다시 그립니다. 색상 변경 등에서 발생합니다.
- JavaScript 엔진과 렌더링 엔진 간 통신이 필요합니다. 컨텍스트 전환 비용이 있습니다.
- 동기적으로 처리됩니다. 다른 작업을 블로킹합니다.

**리플로우를 유발하는 작업:**
- 요소의 추가, 제거, 크기 변경을 할 때 발생합니다.
- 클래스 추가나 스타일 변경 시 발생할 수 있습니다.
- 레이아웃 정보를 읽을 때도 발생합니다. offsetWidth, clientHeight 등을 읽으면 최신 값을 계산합니다.
- 폰트 변경, 윈도우 리사이즈 시 발생합니다.

**성능 저하 사례:**
- 반복문에서 DOM을 여러 번 조작하면 매번 리플로우가 발생합니다.
- 레이아웃 정보를 읽고 쓰기를 반복하면 강제 동기 레이아웃이 발생합니다.
- 애니메이션에서 레이아웃 속성을 변경하면 성능이 크게 저하됩니다.

**최적화 방법:**
- 배치 처리: 여러 변경을 한 번에 적용합니다. DocumentFragment를 사용합니다.
- 클래스 사용: 여러 스타일을 한 번에 변경합니다. 클래스 추가로 통합합니다.
- 오프라인 DOM: 요소를 DOM에서 분리하여 작업한 후 다시 붙입니다.
- 레이아웃 스래싱 방지: 읽기와 쓰기를 분리합니다. 읽기를 먼저 모두 수행합니다.

**DocumentFragment 활용:**
- 여러 요소를 메모리에서 조립합니다.
- DOM에 한 번만 추가합니다. 리플로우를 최소화합니다.
- 대량의 요소를 추가할 때 효과적입니다.
- 임시 컨테이너 역할을 합니다.

**가상 DOM의 개념:**
- React 등에서 사용하는 최적화 기법입니다.
- JavaScript 객체로 DOM을 표현합니다.
- 변경사항을 가상 DOM에서 계산합니다.
- 최소한의 실제 DOM 조작만 수행합니다.
- 배치 업데이트로 성능을 개선합니다.

**CSS 활용:**
- transform과 opacity는 리플로우를 유발하지 않습니다. GPU 가속을 활용합니다.
- position: absolute나 fixed는 다른 요소에 영향을 주지 않습니다.
- will-change 속성으로 브라우저에 최적화 힌트를 줍니다.
- CSS 애니메이션이 JavaScript보다 성능이 좋을 수 있습니다.

**실무 권장사항:**
- 불필요한 DOM 조작을 피합니다. 상태 변경을 먼저 고려합니다.
- 반복문에서 DOM 조작을 최소화합니다. 템플릿을 만들어 한 번에 추가합니다.
- 성능 프로파일링으로 병목을 찾습니다. 크롬 개발자 도구의 Performance 탭을 활용합니다.
- 프레임워크를 활용하여 최적화를 자동화합니다.
- requestAnimationFrame으로 애니메이션을 최적화합니다.

---

## 질문 56: DocumentFragment는 언제 사용하나요?

**정의:**
DocumentFragment는 경량 문서 객체로, DOM 트리에 추가되지 않은 채 여러 요소를 담을 수 있는 컨테이너입니다. 성능 최적화를 위해 배치 DOM 조작에 사용됩니다.

**DocumentFragment의 특징:**
- 부모 노드가 없는 최소한의 문서 객체입니다.
- 자식 요소를 가질 수 있습니다. 일반 요소처럼 appendChild 등을 사용합니다.
- DOM 트리에 삽입 시 자신은 사라지고 자식만 추가됩니다.
- 리플로우를 한 번만 발생시킵니다.
- 메모리 효율적입니다.

**생성 방법:**
- document.createDocumentFragment로 생성합니다.
- 빈 fragment 객체가 반환됩니다.
- 일반 DOM 메서드로 요소를 추가할 수 있습니다.

**사용 시나리오:**
- 여러 요소를 한 번에 추가할 때 사용합니다. 반복문에서 요소를 생성하는 경우입니다.
- 복잡한 구조를 조립한 후 추가합니다. 테이블이나 리스트를 만들 때 유용합니다.
- 성능이 중요한 대량 DOM 조작에 적합합니다.

**성능 이점:**
- 리플로우가 한 번만 발생합니다. 각 요소를 따로 추가하면 여러 번 발생합니다.
- 레이아웃 계산이 최소화됩니다.
- 특히 많은 요소를 추가할 때 효과가 큽니다.
- 수백 개 이상의 요소에서 체감 가능합니다.

**일반적인 패턴:**
- fragment를 생성합니다.
- 반복문에서 요소를 만들어 fragment에 추가합니다.
- 완성된 fragment를 실제 DOM에 한 번에 추가합니다.
- 간단하고 효과적인 최적화입니다.

**innerHTML과의 비교:**
- innerHTML은 문자열로 처리합니다. 간단하지만 보안 위험이 있습니다.
- DocumentFragment는 DOM 메서드를 사용합니다. 더 안전합니다.
- innerHTML은 파싱 비용이 있습니다.
- DocumentFragment는 타입 안전합니다.

**template 요소와의 관계:**
- template 요소의 content가 DocumentFragment입니다.
- 템플릿을 복제하여 fragment를 얻습니다.
- HTML에서 템플릿을 정의하고 JavaScript에서 복제합니다.
- 재사용 가능한 구조를 만들 때 유용합니다.

**현대적인 대안:**
- 프레임워크의 가상 DOM이 비슷한 역할을 합니다.
- 하지만 바닐라 JavaScript에서는 여전히 유용합니다.
- insertAdjacentHTML도 대안이 될 수 있습니다.
- 상황에 따라 적절한 방법을 선택합니다.

**주의사항:**
- fragment 자체는 DOM에 남지 않습니다. 자식만 추가됩니다.
- 이벤트 리스너는 fragment가 아닌 자식에 추가해야 합니다.
- fragment를 재사용할 수 없습니다. 한 번 추가되면 비워집니다.

**실무 활용:**
- 리스트 렌더링 시 대량의 아이템을 효율적으로 추가합니다.
- 테이블 행을 동적으로 생성할 때 사용합니다.
- Ajax 응답 데이터를 DOM에 반영할 때 활용합니다.
- 성능이 중요한 대시보드나 데이터 시각화에 적합합니다.
- 간단한 최적화로 큰 효과를 볼 수 있습니다.

---
