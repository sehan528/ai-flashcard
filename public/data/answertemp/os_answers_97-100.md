# OS 답변 97-100

## 97. 내부 단편화와, 외부 단편화에 대해 설명해 주세요.

**기본 개념**

단편화는 메모리 낭비를 의미하며, 내부 단편화와 외부 단편화 두 가지 유형이 있습니다. 각각 발생 원인과 해결 방법이 다르며, 메모리 관리 방식에 따라 어느 것이 문제가 되는지 달라집니다.

**내부 단편화**

내부 단편화는 할당된 메모리 블록 내부에서 사용되지 않는 공간이 발생하는 현상입니다. 고정 크기 할당에서 요청 크기가 블록 크기보다 작을 때 발생합니다. 예를 들어, 4KB 페이지에 3KB 데이터를 저장하면 1KB가 낭비됩니다. 할당 단위와 실제 사용량의 차이로 인한 낭비이며, 블록 내부에서 발생하므로 내부 단편화라고 합니다.

**내부 단편화의 예시**

페이징 시스템에서 프로세스의 마지막 페이지는 평균적으로 절반이 비어 있습니다. 페이지 크기가 4KB이면 평균 2KB가 낭비됩니다. 메모리 할당자가 16바이트 단위로 할당하면, 10바이트 요청 시 6바이트가 낭비됩니다. 이는 할당 단위 크기에 비례하여 발생합니다.

**내부 단편화 해결 방법**

할당 단위를 작게 하면 내부 단편화가 줄어듭니다. 하지만 관리 오버헤드가 증가하므로 적절한 균형이 필요합니다. 가변 크기 할당을 사용하여 정확한 크기만큼만 할당할 수 있지만, 외부 단편화 문제가 발생합니다. 실무에서는 적절한 고정 크기를 선택하여 관리 효율과 낭비를 균형있게 조절합니다.

**외부 단편화**

외부 단편화는 사용 가능한 메모리 공간이 작은 조각들로 흩어져서 큰 요청을 만족할 수 없는 현상입니다. 가변 크기 할당에서 할당과 해제가 반복되면서 발생합니다. 총 여유 공간은 충분하지만 연속되지 않아 사용할 수 없습니다. 메모리 블록들 사이의 빈 공간에서 발생하므로 외부 단편화라고 합니다.

**외부 단편화의 예시**

세그멘테이션에서 다양한 크기의 세그먼트가 할당되고 해제되면, 메모리에 사용할 수 없는 작은 구멍들이 생깁니다. 100MB 세그먼트를 할당하려는데, 200MB 여유 공간이 10MB씩 20개 조각으로 흩어져 있으면 할당할 수 없습니다. 연속할당 방식의 고질적 문제입니다.

**외부 단편화 해결 방법**

압축은 사용 중인 메모리를 한쪽으로 모아 빈 공간을 연속되게 만듭니다. 하지만 모든 포인터와 주소를 업데이트해야 하므로 비용이 매우 큽니다. 페이징을 사용하면 외부 단편화를 근본적으로 해결할 수 있습니다. 고정 크기 프레임은 모두 동일하여 어느 페이지든 어느 프레임에나 들어가므로, 연속성이 필요없습니다.

**페이징과 단편화**

페이징은 외부 단편화를 제거하지만 내부 단편화를 가집니다. 평균적으로 페이지 크기의 절반 정도가 낭비되지만, 페이지가 작으면 이 낭비도 작습니다. 4KB 페이지에서 평균 2KB 낭비는 전체 메모리 대비 무시할 수 있는 수준입니다. 이는 외부 단편화로 인한 할당 실패보다 훨씬 나은 상황입니다.

**세그멘테이션과 단편화**

세그멘테이션은 내부 단편화가 없지만 외부 단편화가 심각합니다. 필요한 만큼만 할당하므로 낭비가 없지만, 가변 크기로 인해 조각화가 발생합니다. 압축이 필요하거나 할당 실패가 빈번합니다. 이것이 현대 시스템이 페이징을 선호하는 주된 이유입니다.

**실무 영향**

내부 단편화는 메모리 낭비이지만 예측 가능하고 관리하기 쉽습니다. 외부 단편화는 예측 불가능하고 시간이 지날수록 악화됩니다. 시스템 가동 시간이 길어지면 단편화가 누적되어 성능이 저하됩니다. 페이징의 작은 내부 단편화가 세그멘테이션의 외부 단편화보다 실용적으로 우수합니다.

---

## 98. 페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.

**기본 개념**

페이징 시스템에서 가상 주소를 물리 주소로 변환하는 과정은 페이지 테이블과 MMU를 통해 하드웨어적으로 수행됩니다. 프로그램은 가상 주소만 사용하고, 변환은 투명하게 이루어집니다.

**가상 주소 구조**

가상 주소는 페이지 번호와 오프셋 두 부분으로 나뉩니다. 페이지 번호는 상위 비트이고, 오프셋은 하위 비트입니다. 예를 들어, 32비트 주소 공간에서 4KB 페이지를 사용하면, 하위 12비트가 오프셋이고 상위 20비트가 페이지 번호입니다. 오프셋 12비트는 4096바이트를 표현하며, 페이지 번호 20비트는 100만 개 페이지를 식별합니다.

**페이지 테이블 조회**

CPU가 가상 주소를 생성하면, MMU가 페이지 번호를 추출합니다. 페이지 번호를 인덱스로 페이지 테이블을 조회합니다. 페이지 테이블 엔트리에는 프레임 번호와 제어 비트들이 저장되어 있습니다. Present 비트가 1이면 페이지가 메모리에 있고, 0이면 페이지 폴트가 발생합니다. 권한 비트를 확인하여 읽기/쓰기/실행 가능 여부를 검사합니다.

**물리 주소 구성**

페이지 테이블에서 얻은 프레임 번호와 가상 주소의 오프셋을 결합합니다. 프레임 번호를 상위 비트로, 오프셋을 하위 비트로 배치하여 물리 주소를 만듭니다. 예를 들어, 프레임 번호가 5이고 오프셋이 100이면, 물리 주소는 5번 프레임의 시작 주소에 100을 더한 값입니다. 이 물리 주소로 실제 메모리에 접근합니다.

**TLB 가속화**

매번 페이지 테이블을 접근하면 느리므로, TLB가 최근 변환을 캐시합니다. MMU는 먼저 TLB를 확인하여 히트되면 즉시 프레임 번호를 얻습니다. TLB 미스 시에만 페이지 테이블을 접근합니다. TLB 히트율이 95% 이상이면 대부분의 변환이 빠르게 처리됩니다. TLB는 병렬 검색하는 연관 메모리로 구현되어 매우 빠릅니다.

**멀티레벨 페이지 테이블**

64비트 시스템에서 단일 레벨 페이지 테이블은 너무 커서 비실용적입니다. 4단계 페이지 테이블을 사용하여 가상 주소를 여러 부분으로 나눕니다. 각 레벨의 인덱스로 다음 레벨 테이블을 찾아가며, 최종 레벨에서 프레임 번호를 얻습니다. 4번의 메모리 접근이 필요하지만, TLB가 대부분을 캐시하여 실제로는 드물게 발생합니다.

**하드웨어 페이지 워크**

x86-64 같은 현대 CPU는 페이지 테이블 워크를 하드웨어가 자동으로 수행합니다. TLB 미스 시 MMU가 페이지 테이블을 탐색하여 변환을 완료합니다. 소프트웨어 개입 없이 하드웨어만으로 처리되어 빠릅니다. 운영체제는 페이지 테이블 구조만 설정하고, 실제 변환은 하드웨어가 담당합니다.

**페이지 폴트 처리**

Present 비트가 0이면 MMU가 페이지 폴트 예외를 발생시킵니다. CPU가 현재 명령어를 중단하고 페이지 폴트 핸들러로 점프합니다. 운영체제가 필요한 페이지를 디스크에서 로드하고 페이지 테이블을 업데이트합니다. 이후 명령어를 재실행하면 이번에는 Present 비트가 1이어서 정상 처리됩니다.

**실무 예시**

프로그램이 0x12345678 주소에 접근하면, 상위 비트로 페이지 번호를 추출하고 페이지 테이블을 조회합니다. 프레임 번호가 0xABC라면, 하위 12비트 오프셋 0x678과 결합하여 물리 주소 0xABC678을 만듭니다. 이 과정은 수 나노초 내에 하드웨어로 완료됩니다. 프로그래머는 이를 의식할 필요 없이 가상 주소만 사용하면 됩니다.

---

## 99. 어떤 주소공간이 있을 때, 이 공간이 수정 가능한지 확인할 수 있는 방법이 있나요?

**기본 개념**

페이지 테이블 엔트리에는 권한 비트가 있어서 각 페이지의 접근 권한을 지정합니다. 읽기, 쓰기, 실행 권한을 개별적으로 설정할 수 있으며, 하드웨어와 운영체제가 이를 검사합니다.

**페이지 테이블의 권한 비트**

각 페이지 테이블 엔트리에는 프레임 번호 외에도 제어 비트들이 있습니다. Read, Write, Execute 비트로 해당 페이지에 대한 읽기, 쓰기, 실행 권한을 표시합니다. Writable 비트가 0이면 읽기 전용이고, 1이면 수정 가능합니다. Executable 비트로 코드 실행 가능 여부를 제어합니다. User 비트로 사용자 모드 접근 허용 여부를 지정합니다.

**하드웨어 검사**

CPU가 메모리에 쓰기를 시도할 때, MMU가 자동으로 권한을 검사합니다. Writable 비트가 0인 페이지에 쓰기를 시도하면 페이지 폴트가 발생합니다. 운영체제의 폴트 핸들러가 호출되어 Segmentation Fault로 프로세스를 종료시킵니다. 이는 하드웨어 레벨에서 자동으로 이루어지는 보호 메커니즘입니다.

**운영체제 API**

운영체제는 메모리 권한을 조회하고 변경하는 시스템 콜을 제공합니다. POSIX의 mprotect는 메모리 영역의 권한을 변경합니다. 읽기 전용 페이지를 쓰기 가능으로, 또는 그 반대로 바꿀 수 있습니다. /proc/self/maps 파일을 읽으면 현재 프로세스의 모든 메모리 영역과 권한을 확인할 수 있습니다. 각 영역이 r, w, x 플래그로 표시됩니다.

**프로그램에서 확인**

특정 주소의 권한을 확인하려면 /proc/self/maps를 파싱하거나, mprotect로 권한 변경을 시도할 수 있습니다. 직접 접근하여 예외를 처리하는 방법도 있지만 위험합니다. 신호 핸들러를 설정하여 SIGSEGV를 잡고, 쓰기를 시도하여 예외 발생 여부로 판단할 수 있습니다. 하지만 이는 부작용이 있어 권장되지 않습니다.

**전형적인 권한 설정**

코드 영역은 읽기와 실행만 가능하고 쓰기는 불가능합니다. 자기 수정 코드를 방지하고 보안을 강화합니다. 데이터 영역은 읽기와 쓰기가 가능하지만 실행은 불가능합니다. NX 비트로 데이터 영역 실행을 차단하여 버퍼 오버플로 공격을 방어합니다. 스택과 힙도 실행 불가능하게 설정됩니다.

**Copy-on-Write 활용**

fork 후 부모와 자식의 페이지는 읽기 전용으로 공유됩니다. 한쪽이 쓰기를 시도하면 페이지 폴트가 발생하고, 운영체제가 페이지를 복사한 후 쓰기 가능으로 변경합니다. 이는 권한 비트를 활용한 효율적인 메모리 공유 기법입니다. 실제 수정이 일어날 때만 복사하여 메모리를 절약합니다.

**메모리 맵 파일**

mmap으로 파일을 메모리에 매핑할 때 권한을 지정합니다. PROT_READ, PROT_WRITE, PROT_EXEC 플래그로 읽기, 쓰기, 실행 권한을 설정합니다. MAP_PRIVATE로 매핑하면 수정이 파일에 반영되지 않고, MAP_SHARED는 반영됩니다. 권한 설정을 잘못하면 접근 시 SIGSEGV가 발생합니다.

**실무 활용**

디버거는 /proc/PID/maps를 읽어 프로세스의 메모리 레이아웃과 권한을 표시합니다. JIT 컴파일러는 코드를 생성할 때 쓰기 가능한 메모리에 작성하고, 완료 후 실행 가능하게 변경합니다. 보안 소프트웨어는 페이지 권한을 모니터링하여 비정상적인 변경을 탐지합니다. 권한 관리는 메모리 안전성과 보안의 핵심입니다.

---

## 100. 32비트에서, 페이지의 크기가 1kb 이라면 페이지 테이블의 최대 크기는 몇 개일까요?

**기본 개념**

페이지 테이블 크기는 가상 주소 공간 크기와 페이지 크기에 의해 결정됩니다. 32비트 주소 공간을 1KB 페이지로 나누면 필요한 페이지 테이블 엔트리 수를 계산할 수 있습니다.

**주소 공간 크기**

32비트 주소는 2의 32제곱 바이트, 즉 4GB 주소 공간을 표현합니다. 이는 4,294,967,296 바이트입니다. 모든 가능한 주소를 커버하려면 이 전체 공간을 페이지로 나누어야 합니다.

**페이지 수 계산**

1KB는 1024 바이트, 즉 2의 10제곱 바이트입니다. 4GB를 1KB로 나누면 페이지 수가 나옵니다. 2의 32제곱을 2의 10제곱으로 나누면 2의 22제곱입니다. 따라서 4,194,304개의 페이지가 필요합니다. 이는 약 400만 개입니다.

**페이지 테이블 엔트리 수**

각 페이지마다 하나의 페이지 테이블 엔트리가 필요합니다. 따라서 페이지 테이블은 4,194,304개의 엔트리를 가져야 합니다. 이것이 페이지 테이블의 최대 크기입니다. 모든 가상 주소를 매핑하려면 이만큼의 엔트리가 필요합니다.

**페이지 테이블 메모리 사용량**

각 엔트리가 4바이트라고 가정하면, 전체 페이지 테이블 크기는 4,194,304 곱하기 4로 16,777,216 바이트입니다. 이는 16MB입니다. 프로세스마다 이만큼의 메모리가 페이지 테이블에만 사용됩니다. 이는 상당히 큰 오버헤드입니다.

**실용성 문제**

16MB 페이지 테이블은 프로세스당 큰 부담입니다. 10개 프로세스면 160MB가 페이지 테이블에만 사용됩니다. 대부분의 프로세스는 4GB 주소 공간을 모두 사용하지 않으므로, 단일 레벨 페이지 테이블은 낭비가 심합니다. 이것이 멀티레벨 페이지 테이블이 필요한 이유입니다.

**멀티레벨 대안**

2단계 페이지 테이블을 사용하면 실제 사용되는 영역만 테이블을 할당할 수 있습니다. 상위 디렉토리와 하위 테이블로 나누어, 사용되지 않는 영역의 하위 테이블은 생성하지 않습니다. 희소한 주소 공간에서는 메모리를 크게 절약합니다. 현대 시스템은 모두 멀티레벨 방식을 사용합니다.

**페이지 크기의 영향**

페이지 크기가 작을수록 페이지 테이블이 커집니다. 1KB 페이지는 4KB 페이지보다 4배 많은 엔트리가 필요합니다. 4KB 페이지면 100만 엔트리로 4MB 테이블이면 충분합니다. 이는 페이지 크기 선택에서 고려해야 할 trade-off입니다.

**실무 적용**

실제 32비트 시스템은 대부분 4KB 페이지를 사용하여 100만 엔트리 페이지 테이블을 가집니다. 2단계 테이블로 구현하여 메모리를 절약합니다. 64비트 시스템은 4단계 또는 5단계 테이블을 사용하여 거대한 주소 공간을 효율적으로 관리합니다. 단일 레벨 테이블은 이론적 개념이며, 실제로는 사용되지 않습니다.
