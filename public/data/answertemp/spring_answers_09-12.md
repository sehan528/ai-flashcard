# Spring 답변 9-12

## 질문 9: 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?

클래스의 단일 상속과 인터페이스의 다중 구현이 다르게 설계된 이유는 다이아몬드 문제와 상태 관리의 복잡성 때문입니다.

**클래스 다중 상속의 문제점:**

다이아몬드 문제는 다중 상속의 가장 대표적인 문제입니다. 만약 클래스 C가 클래스 A와 B를 동시에 상속받고, A와 B가 모두 같은 메서드를 가지고 있다면, C는 어느 것을 상속받아야 할지 모호해집니다. 특히 A와 B가 공통 조상 클래스를 가질 때 더욱 복잡해집니다.

상태의 충돌 문제도 있습니다. 클래스는 인스턴스 변수를 가질 수 있는데, 두 부모 클래스가 같은 이름의 변수를 가진다면 어느 것을 사용해야 할지 불명확합니다. 메모리 레이아웃도 복잡해져서 어떤 순서로 부모 클래스의 필드를 배치할지 결정하기 어렵습니다.

생성자 호출 순서도 문제가 됩니다. 여러 부모 클래스의 생성자를 어떤 순서로 호출해야 하는지, 공통 조상이 있다면 그 생성자를 몇 번 호출해야 하는지 모호합니다.

**인터페이스 다중 구현이 가능한 이유:**

전통적으로 인터페이스는 상태를 가지지 않았습니다. 인스턴스 변수가 없고 오직 추상 메서드만 선언했기 때문에 상태 충돌 문제가 발생하지 않습니다. 구현 클래스가 모든 메서드를 직접 구현하므로 어느 것을 상속받을지 고민할 필요가 없습니다.

여러 인터페이스가 같은 시그니처의 메서드를 선언해도 문제없습니다. 구현 클래스는 하나의 구현만 제공하면 되고, 이 구현이 모든 인터페이스의 요구사항을 만족합니다.

**Java 8 이후의 변화:**

Java 8에서 default 메서드가 도입되면서 상황이 조금 복잡해졌습니다. 이제 인터페이스도 구현을 가질 수 있게 되었고, 다이아몬드 문제가 발생할 가능성이 생겼습니다.

하지만 자바는 명확한 규칙으로 이를 해결합니다. 첫째, 클래스의 메서드가 인터페이스의 default 메서드보다 우선합니다. 둘째, 더 구체적인 인터페이스의 default 메서드가 우선합니다. 셋째, 여전히 모호하다면 명시적으로 선택해야 합니다.

인터페이스는 여전히 인스턴스 변수를 가질 수 없으므로 상태 충돌 문제는 발생하지 않습니다.

**설계 철학:**

자바는 복잡성보다 단순성을 선택했습니다. 클래스 다중 상속의 복잡한 문제들을 피하면서도, 인터페이스를 통해 다형성과 유연한 설계를 가능하게 했습니다. 이는 "is-a" 관계는 명확하게 하나만 유지하되, "can-do" 능력은 여러 개 가질 수 있다는 의미입니다.

## 질문 10: 리플렉션에 대해 설명해 주세요.

리플렉션(Reflection)은 프로그램이 실행 시간에 자기 자신의 구조를 조사하고 수정할 수 있는 기능입니다. 클래스, 메서드, 필드 등의 메타데이터에 접근하여 동적으로 객체를 생성하고 메서드를 호출할 수 있습니다.

**주요 기능:**

클래스 정보 조회가 가능합니다. Class 객체를 통해 클래스의 이름, 패키지, 부모 클래스, 구현된 인터페이스, 선언된 필드와 메서드, 생성자, 어노테이션 등의 모든 정보를 얻을 수 있습니다.

동적 객체 생성이 가능합니다. 클래스 이름이 문자열로 주어지더라도 런타임에 해당 클래스의 인스턴스를 생성할 수 있습니다. Constructor 객체를 얻어서 newInstance 메서드로 객체를 만듭니다.

메서드 동적 호출이 가능합니다. Method 객체를 얻어서 invoke 메서드로 실행할 수 있습니다. 메서드 이름이 문자열로만 알려져 있어도 호출할 수 있습니다.

필드 접근 및 수정이 가능합니다. Field 객체를 통해 private 필드에도 접근하고 값을 읽거나 쓸 수 있습니다. setAccessible 메서드로 접근 제어를 우회할 수 있습니다.

**동작 원리:**

자바는 클래스를 로딩할 때 해당 클래스의 메타데이터를 Method Area에 저장합니다. 이 메타데이터는 Class 객체로 표현되며, 리플렉션 API는 이 정보에 접근하는 인터페이스를 제공합니다.

모든 클래스는 Class 타입의 객체를 가지며, 이를 통해 클래스의 구조를 탐색할 수 있습니다. Class.forName, 객체.getClass, 클래스.class 등의 방법으로 Class 객체를 얻을 수 있습니다.

**장점:**

유연성과 확장성이 뛰어납니다. 컴파일 타임에 타입을 알 수 없는 경우에도 동적으로 처리할 수 있습니다. 플러그인 시스템이나 프레임워크 개발에 필수적입니다.

프레임워크 개발에 핵심적입니다. Spring의 DI, Hibernate의 ORM, JUnit의 테스트 실행 등 대부분의 프레임워크가 리플렉션을 사용합니다.

**단점:**

성능 오버헤드가 있습니다. 일반 메서드 호출보다 리플렉션을 통한 호출이 훨씬 느립니다. 타입 체크와 메서드 탐색 등의 추가 작업이 필요하기 때문입니다.

컴파일 타임 타입 안전성을 잃습니다. 리플렉션은 런타임에 동작하므로 컴파일러가 타입 오류를 잡아낼 수 없습니다. 오류가 실행 시점에만 발견됩니다.

코드 가독성이 떨어집니다. 리플렉션 코드는 일반 코드보다 복잡하고 이해하기 어렵습니다.

보안 문제가 발생할 수 있습니다. private 멤버에 접근할 수 있어 캡슐화를 깨뜨릴 수 있습니다.

## 질문 11: 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?

네, 리플렉션은 실제로 여러 보안 문제를 일으킬 수 있습니다.

**주요 보안 문제:**

첫째, 캡슐화 위반입니다. 리플렉션은 setAccessible 메서드를 통해 private 필드나 메서드에 접근할 수 있습니다. 이는 클래스 설계자가 의도적으로 숨긴 내부 구현에 접근하여 객체의 불변성을 깨뜨리거나 일관성을 해칠 수 있습니다.

둘째, 타입 안전성 우회입니다. 제네릭의 타입 소거를 이용하여 타입 체크를 우회할 수 있습니다. 컴파일 타임에 안전하다고 판단된 코드가 런타임에 ClassCastException을 발생시킬 수 있습니다.

셋째, 보안 관리자 우회 가능성입니다. 리플렉션을 통해 보안 관련 메서드를 호출하거나 보안 설정을 변경할 수 있습니다.

넷째, 의도하지 않은 동작 실행입니다. 악의적인 코드가 리플렉션을 통해 예상하지 못한 메서드를 호출하거나 시스템 설정을 변경할 수 있습니다.

**방지 방법:**

첫째, SecurityManager를 사용합니다. Java의 보안 관리자는 리플렉션 사용을 제어할 수 있습니다. ReflectPermission을 통해 setAccessible 호출을 제한할 수 있습니다. suppressAccessChecks 권한을 제거하면 private 멤버 접근을 막을 수 있습니다.

둘째, Java Module System(JIGSAW)을 활용합니다. Java 9부터 도입된 모듈 시스템은 강력한 캡슐화를 제공합니다. 모듈이 명시적으로 opens 하지 않은 패키지는 리플렉션으로도 접근할 수 없습니다. 이는 SecurityManager보다 강력하고 명확한 보호를 제공합니다.

셋째, 최소 권한 원칙을 적용합니다. 리플렉션을 꼭 필요한 곳에만 사용하고, 사용 범위를 최소화합니다. 가능하면 대안을 찾습니다.

넷째, 코드 리뷰와 정적 분석을 수행합니다. 리플렉션 사용을 추적하고 검토합니다. setAccessible 호출을 특히 주의 깊게 살펴봅니다.

다섯째, 불변 객체와 방어적 복사를 사용합니다. 리플렉션으로 접근되더라도 피해를 최소화할 수 있도록 설계합니다. 중요한 필드는 final로 선언하여 리플렉션으로도 수정할 수 없게 합니다.

여섯째, 입력 검증을 철저히 합니다. 리플렉션에 사용되는 클래스 이름이나 메서드 이름이 외부에서 오는 경우, 화이트리스트 방식으로 검증합니다.

**실무적 접근:**

완전히 막기보다는 신뢰할 수 있는 코드에서만 사용하도록 합니다. 프레임워크나 라이브러리 내부에서는 필요하지만, 애플리케이션 코드에서는 최소화합니다. 보안이 중요한 환경에서는 모듈 시스템과 SecurityManager를 조합하여 사용합니다.

## 질문 12: 리플렉션을 언제 활용할 수 있을까요?

리플렉션은 컴파일 타임에 타입 정보를 알 수 없거나, 동적인 동작이 필요한 다양한 상황에서 활용됩니다.

**프레임워크와 라이브러리 개발:**

의존성 주입 컨테이너가 대표적입니다. Spring은 리플렉션을 사용하여 빈을 생성하고, 의존성을 주입하며, 어노테이션을 처리합니다. 설정 파일이나 어노테이션에 선언된 클래스 이름으로 객체를 동적으로 생성합니다.

ORM 프레임워크에서도 필수적입니다. Hibernate나 JPA는 엔티티 클래스의 필드를 검사하고, 데이터베이스 컬럼과 매핑하며, 동적으로 값을 설정합니다.

테스트 프레임워크인 JUnit은 리플렉션으로 테스트 메서드를 찾아서 실행합니다. 어노테이션으로 표시된 메서드들을 동적으로 호출하고, private 메서드도 테스트할 수 있게 합니다.

**직렬화와 역직렬화:**

JSON 라이브러리인 Jackson이나 Gson은 리플렉션을 사용하여 자바 객체를 JSON으로 변환하고, JSON을 자바 객체로 변환합니다. 객체의 필드를 동적으로 읽고 쓰는 것이 가능해집니다.

Java의 표준 직렬화도 리플렉션을 사용하여 객체의 상태를 저장하고 복원합니다.

**동적 프록시 생성:**

AOP 구현에서 리플렉션과 동적 프록시를 사용합니다. Spring AOP는 런타임에 프록시 객체를 생성하여 메서드 호출을 가로채고 부가 기능을 추가합니다.

RPC 프레임워크도 동적 프록시로 원격 메서드 호출을 로컬 메서드 호출처럼 보이게 합니다.

**플러그인 시스템:**

애플리케이션이 런타임에 플러그인을 로드하고 실행할 때 리플렉션을 사용합니다. 플러그인의 클래스 이름을 설정 파일에서 읽어와 동적으로 인스턴스를 생성하고 실행합니다.

**개발 도구와 IDE:**

코드 자동 완성, 리팩토링, 디버깅 기능이 리플렉션을 활용합니다. 클래스의 구조를 분석하여 사용 가능한 메서드와 필드를 보여줍니다.

**API 라우팅과 컨트롤러 매핑:**

웹 프레임워크는 리플렉션으로 컨트롤러 메서드를 찾고, URL과 매핑하며, 파라미터를 자동으로 바인딩합니다. Spring MVC의 @RequestMapping이 이렇게 동작합니다.

**빌더와 팩토리 패턴:**

설정 기반 객체 생성에서 리플렉션을 사용합니다. 설정 파일에 명시된 클래스를 동적으로 인스턴스화합니다.

**어노테이션 처리:**

커스텀 어노테이션을 읽고 처리하는 데 리플렉션이 필요합니다. 런타임 어노테이션을 검사하여 검증, 로깅, 트랜잭션 관리 등을 수행합니다.

**제네릭 유틸리티:**

타입에 관계없이 동작하는 범용 유틸리티를 만들 때 유용합니다. 객체 복사, 비교, toString 자동 생성 등에 사용됩니다.

일반 애플리케이션 코드에서는 리플렉션을 최소화하는 것이 좋지만, 프레임워크나 라이브러리 개발에서는 필수불가결한 도구입니다.
