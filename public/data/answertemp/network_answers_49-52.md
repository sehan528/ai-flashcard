# Network 답변 모음 (49-52)

## 49. IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?

아니요, **IP 프로토콜 자체는 신뢰성을 보장하지 않습니다**. IP는 최선형 전달(Best Effort Delivery) 방식을 사용합니다.

**Best Effort의 의미:**
IP는 패킷을 목적지까지 전달하기 위해 최선을 다하지만, 성공을 보장하지는 않습니다. 패킷이 손실되거나, 순서가 바뀌거나, 중복되거나, 손상될 수 있습니다. 이러한 문제들을 감지하거나 복구하는 메커니즘이 없습니다.

**발생 가능한 문제들:**
- **패킷 손실**: 네트워크 혼잡, 버퍼 오버플로우, 물리적 오류로 패킷이 사라집니다
- **순서 변경**: 서로 다른 경로로 전송되어 순서가 바뀔 수 있습니다
- **중복**: 네트워크 장비 오류로 같은 패킷이 여러 번 전달될 수 있습니다
- **손상**: 전송 중 비트 오류가 발생할 수 있습니다
- **지연**: 도착 시간이 보장되지 않습니다

**IP의 역할:**
IP는 라우팅과 주소 지정만 담당합니다. 송신자와 수신자를 식별하고, 네트워크 간 패킷을 전달하는 경로를 찾습니다. 전달의 성공 여부는 상위 계층(전송 계층)의 책임입니다.

**왜 신뢰성을 제공하지 않나:**
네트워크 계층을 단순하고 빠르게 유지하기 위함입니다. 신뢰성 메커니즘은 복잡하고 오버헤드가 크므로, 필요한 애플리케이션만 상위 계층에서 구현하는 것이 효율적입니다. 실시간 스트리밍 같은 애플리케이션은 신뢰성보다 속도가 중요합니다.

**계층적 설계 철학:**
OSI 모델의 계층적 접근에 따라, 각 계층은 특정 책임만 가집니다. IP는 주소 지정과 라우팅, TCP/UDP는 전송 제어, 애플리케이션은 비즈니스 로직을 담당합니다. 이러한 분리로 유연성과 확장성이 향상됩니다.

**TCP의 보완:**
신뢰성이 필요한 애플리케이션은 TCP를 사용합니다. TCP는 IP 위에서 순서 보장, 재전송, 흐름 제어, 혼잡 제어를 구현합니다. IP의 비신뢰적 전달을 TCP가 신뢰적으로 변환합니다.

**UDP의 선택:**
신뢰성이 불필요한 애플리케이션은 UDP를 사용합니다. UDP도 IP처럼 최선형 전달이지만 포트 번호와 간단한 checksum을 추가합니다. 실시간 영상, 음성, 게임 등이 해당됩니다.

**IP Checksum의 한계:**
IPv4는 헤더에 checksum을 가지지만, 이는 헤더의 무결성만 확인합니다. 데이터 부분은 검증하지 않으며, 오류를 발견해도 복구하지 않고 폐기만 합니다.

**라우팅 불확실성:**
인터넷은 동적으로 변하는 네트워크입니다. 라우팅 테이블이 불완전하거나 업데이트 중이면 패킷이 목적지에 도달하지 못할 수 있습니다. TTL이 0이 되면 패킷이 폐기됩니다.

**실제 신뢰성:**
실무에서는 현대 네트워크의 품질이 좋아 IP 패킷의 대부분이 성공적으로 전달됩니다. 하지만 완벽하지 않으므로 중요한 데이터는 반드시 TCP를 사용해야 합니다.

**엔드투엔드 원칙:**
네트워크 설계의 기본 원칙으로, 신뢰성 같은 고급 기능은 네트워크 내부가 아닌 엔드포인트에서 구현되어야 합니다. 이를 통해 네트워크는 단순하고, 다양한 요구사항에 유연하게 대응할 수 있습니다.

**ICMP의 역할:**
IP는 오류 보고를 위해 ICMP를 사용합니다. 패킷 전달 실패 시 ICMP 메시지로 송신자에게 알리지만, 이마저도 보장되지 않습니다.

**결론:**
IP는 의도적으로 신뢰성을 제공하지 않으며, 이는 설계 철학의 일부입니다. 신뢰성이 필요한 경우 TCP를 사용하고, 불필요한 경우 UDP를 사용하는 것이 올바른 접근입니다.

---

## 50. IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?

IPv4와 TCP의 checksum은 **검증 범위와 목적**에서 차이가 있습니다.

**검증 범위의 차이:**
- **IPv4 Checksum**: IP 헤더만 검증합니다. 20-60 바이트의 헤더 정보만 대상입니다. 데이터 부분(페이로드)은 검증하지 않습니다
- **TCP Checksum**: TCP 헤더와 데이터 전체를 검증합니다. pseudo-header, TCP 헤더, 전체 페이로드를 포함합니다

**Pseudo-Header:**
TCP checksum 계산 시 IP 계층의 일부 정보를 포함한 가상 헤더를 사용합니다. 송신자 IP 주소, 수신자 IP 주소, 프로토콜 번호, TCP 세그먼트 길이가 포함됩니다. 이를 통해 잘못된 목적지로의 전달을 감지할 수 있습니다.

**목적의 차이:**
- **IPv4**: 라우팅 중 헤더 손상을 감지하여 잘못된 목적지로 전달되는 것을 방지합니다. TTL, 주소 등의 헤더 필드가 올바른지 확인합니다
- **TCP**: 엔드투엔드 데이터 무결성을 보장합니다. 전송된 데이터가 손상되지 않았음을 확인합니다

**계층적 책임:**
- **IPv4**: 네트워크 계층으로, 패킷 전달 과정의 무결성을 담당합니다
- **TCP**: 전송 계층으로, 전체 통신의 엔드투엔드 무결성을 담당합니다

**처리 위치:**
- **IPv4 Checksum**: 모든 라우터가 패킷을 받을 때마다 재계산합니다. TTL이 변경되므로 checksum도 업데이트됩니다
- **TCP Checksum**: 송신자와 수신자(엔드포인트)만 계산합니다. 중간 라우터는 TCP checksum을 확인하거나 변경하지 않습니다

**재계산 필요성:**
- **IPv4**: 라우터가 TTL을 감소시키므로 매 홉마다 checksum 재계산이 필요합니다
- **TCP**: 세그먼트가 변경되지 않으므로 재계산이 불필요합니다

**오류 발견 시 동작:**
- **IPv4**: Checksum 오류가 발견되면 패킷을 즉시 폐기합니다. ICMP 메시지를 보낼 수도 있지만 보장되지 않습니다
- **TCP**: Checksum 오류가 발견되면 세그먼트를 폐기하고, ACK를 보내지 않아 재전송을 유도합니다

**IPv6에서의 변화:**
IPv6는 IP 헤더에서 checksum을 완전히 제거했습니다. 상위 계층(TCP/UDP)과 하위 계층(이더넷)에서 이미 검증하므로 중복이라고 판단했습니다. 라우터 처리 성능이 향상되었습니다.

**필수 여부:**
- **IPv4 Checksum**: 필수입니다. 모든 IPv4 패킷은 올바른 checksum을 가져야 합니다
- **TCP Checksum**: 필수입니다. TCP 세그먼트는 항상 checksum을 계산하고 검증합니다

**계산 알고리즘:**
둘 다 16비트 1의 보수 합을 사용하는 동일한 알고리즘입니다. 하지만 계산 대상 데이터가 다릅니다.

**하드웨어 오프로딩:**
현대 네트워크 카드는 TCP checksum을 하드웨어로 계산하여 CPU 부담을 줄입니다. IPv4 checksum은 라우터의 ASIC이나 NPU에서 처리합니다.

**실무적 의미:**
IPv4 checksum은 라우팅 무결성을, TCP checksum은 데이터 무결성을 보장합니다. 계층별로 적절한 검증을 수행하여 전체 통신의 신뢰성을 확보합니다.

**다중 검증의 장점:**
여러 계층에서 독립적으로 검증하므로 오류 감지율이 높아집니다. 한 계층에서 놓친 오류를 다른 계층에서 발견할 수 있습니다.

---

## 51. TTL(Hop Limit)이란 무엇인가요?

**TTL(Time To Live)**은 패킷이 네트워크에서 무한정 순환하는 것을 방지하기 위한 메커니즘입니다.

**기본 개념:**
TTL은 패킷이 거쳐갈 수 있는 최대 라우터(홉) 수를 나타냅니다. 송신자가 초기값을 설정하면, 패킷이 라우터를 통과할 때마다 1씩 감소합니다. TTL이 0이 되면 라우터는 패킷을 폐기하고 ICMP Time Exceeded 메시지를 송신자에게 보냅니다.

**왜 필요한가:**
라우팅 루프가 발생하면 패킷이 무한히 순환할 수 있습니다. 라우팅 테이블 오류, 네트워크 장애, 설정 실수 등으로 발생합니다. TTL이 없다면 이러한 패킷들이 네트워크 대역폭을 계속 소모하여 네트워크 마비를 일으킬 수 있습니다.

**라우팅 루프의 예:**
라우터 A가 목적지로 가려면 라우터 B를 거쳐야 하고, 라우터 B는 다시 라우터 A를 거쳐야 한다고 잘못 설정된 경우입니다. 패킷이 A와 B 사이를 무한히 왕복하게 됩니다.

**초기 TTL 값:**
운영체제마다 기본값이 다릅니다:
- **Linux**: 64
- **Windows**: 128
- **Cisco 라우터**: 255
- **일부 Unix**: 255

**동작 과정:**
1. 송신자가 TTL을 64로 설정하여 패킷을 보냅니다
2. 첫 번째 라우터가 받아서 TTL을 63으로 감소시키고 전달합니다
3. 각 라우터가 이를 반복합니다
4. TTL이 1인 패킷을 받은 라우터는 0으로 감소시키고 폐기합니다
5. 송신자에게 ICMP Time Exceeded를 보냅니다

**IPv6의 Hop Limit:**
IPv6에서는 TTL 대신 Hop Limit이라는 용어를 사용합니다. 기능은 동일하지만 이름이 더 정확합니다. "시간"이 아닌 "홉 수"를 제한하기 때문입니다.

**TTL의 또 다른 용도 - Traceroute:**
traceroute 명령은 TTL을 활용합니다. TTL을 1, 2, 3... 순으로 증가시키며 패킷을 보냅니다. 각 라우터에서 Time Exceeded 메시지를 받아 경로를 파악합니다. 목적지까지의 모든 라우터를 순서대로 확인할 수 있습니다.

**보안적 활용:**
TTL 값으로 운영체제를 식별할 수 있습니다(OS Fingerprinting). 초기값이 64면 Linux, 128이면 Windows일 가능성이 높습니다. 현재 TTL로 거쳐온 홉 수를 추정할 수 있습니다.

**적절한 TTL 선정:**
너무 작으면 정상 패킷도 목적지에 도달하지 못합니다. 인터넷에서 가장 먼 거리도 30홉 이내이므로 64면 충분합니다. 너무 크면 루프 패킷이 오래 순환하여 자원을 낭비합니다.

**TTL과 캐시:**
DNS, CDN 등에서 TTL은 다른 의미로 사용됩니다. 캐시된 데이터가 유효한 시간(초 단위)을 나타냅니다. 같은 용어지만 문맥에 따라 의미가 다릅니다.

**Checksum 재계산:**
TTL이 변경되면 IPv4 헤더 checksum도 재계산해야 합니다. 모든 라우터가 매 홉마다 수행하므로 처리 오버헤드가 있습니다. IPv6가 checksum을 제거한 이유 중 하나입니다.

**ICMP Time Exceeded 메시지:**
TTL 만료 시 라우터는 송신자에게 알립니다. ICMP 타입 11, 코드 0(TTL exceeded in transit)입니다. 송신자는 이를 통해 라우팅 문제를 인식할 수 있습니다.

**실무 사례:**
네트워크 장애 시 라우팅 루프가 발생하면 대량의 ICMP Time Exceeded 메시지가 생성됩니다. 이를 모니터링하여 라우팅 문제를 조기에 발견할 수 있습니다.

**제한값:**
TTL은 8비트 필드이므로 최대값은 255입니다. 실제로 255홉을 거쳐야 하는 경우는 거의 없습니다.

---

## 52. IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.

**IP 주소**와 **MAC 주소**는 서로 다른 계층에서 동작하는 주소 체계로, 역할과 특성이 다릅니다.

**계층적 차이:**
- **MAC 주소**: 데이터링크 계층(2계층)에서 사용하는 물리 주소입니다
- **IP 주소**: 네트워크 계층(3계층)에서 사용하는 논리 주소입니다

**주소 구조:**
- **MAC 주소**: 48비트(6바이트)로 16진수 12자리입니다. 예: AA:BB:CC:DD:EE:FF 또는 AA-BB-CC-DD-EE-FF
- **IP 주소**: IPv4는 32비트, IPv6는 128비트입니다. 예: 192.168.1.1 또는 2001:db8::1

**고유성과 범위:**
- **MAC 주소**: 전 세계적으로 고유합니다. 제조사가 하드웨어에 영구적으로 부여합니다(일부 예외 존재)
- **IP 주소**: 네트워크 내에서 고유하지만, 사설 IP는 여러 네트워크에서 중복 사용됩니다

**변경 가능성:**
- **MAC 주소**: 하드웨어에 고정되어 있습니다(물리적 주소). 소프트웨어로 변경 가능하지만 일반적이지 않습니다
- **IP 주소**: 쉽게 변경 가능합니다(논리적 주소). DHCP로 자동 할당받거나 수동 설정합니다

**용도:**
- **MAC 주소**: 같은 네트워크(브로드캐스트 도메인) 내에서 프레임을 전달하는 데 사용합니다
- **IP 주소**: 서로 다른 네트워크 간에 패킷을 라우팅하는 데 사용합니다

**작동 범위:**
- **MAC 주소**: 로컬 네트워크 세그먼트 내에서만 유효합니다. 라우터를 넘어가면 MAC 주소가 변경됩니다
- **IP 주소**: 엔드투엔드로 변경되지 않고 유지됩니다. 송신지에서 목적지까지 동일합니다

**주소 지정 방식:**
- **MAC 주소**: 플랫(Flat) 주소 체계로 계층 구조가 없습니다. 앞 24비트는 제조사 식별(OUI), 뒤 24비트는 일련번호입니다
- **IP 주소**: 계층적(Hierarchical) 주소 체계로 네트워크 부분과 호스트 부분으로 나뉩니다

**ARP의 역할:**
IP 주소를 알고 있을 때 MAC 주소를 찾기 위해 ARP(Address Resolution Protocol)를 사용합니다. "이 IP 주소를 가진 장치의 MAC 주소는 무엇인가"라고 브로드캐스트로 질의합니다.

**패킷 전달 과정:**
1. 송신자는 목적지 IP 주소를 알고 있습니다
2. 같은 네트워크면 ARP로 목적지 MAC 주소를 찾습니다
3. 다른 네트워크면 게이트웨이의 MAC 주소를 찾습니다
4. 이더넷 프레임에 목적지 MAC과 IP를 모두 포함하여 전송합니다
5. 각 라우터는 IP 주소를 보고 라우팅하며, MAC 주소는 홉마다 변경합니다

**비유:**
- **IP 주소**: 우편 주소(예: 서울시 강남구 테헤란로 123)로, 어디로 가야 하는지를 나타냅니다
- **MAC 주소**: 주민등록번호로, 사람(장치)을 고유하게 식별합니다
- **패킷 전달**: 우편배달부가 주소를 보고 배달하지만, 각 우체국마다 다음 우체국 주소로 바꿔 씁니다

**보안 측면:**
- **MAC 주소**: MAC 필터링으로 네트워크 접근을 제어할 수 있지만, 스푸핑이 가능합니다
- **IP 주소**: 방화벽, ACL로 트래픽을 제어합니다. IP 스푸핑도 가능하지만 응답을 받기 어렵습니다

**유니캐스트, 브로드캐스트, 멀티캐스트:**
두 주소 체계 모두 이러한 통신 방식을 지원하지만 표현 방법이 다릅니다.

**실무적 중요성:**
네트워크 문제 해결 시 두 주소의 관계를 이해해야 합니다. ARP 테이블, 라우팅 테이블, MAC 주소 테이블(스위치) 등을 확인하여 진단합니다.

**결론:**
IP 주소는 "어디로"를, MAC 주소는 "누구에게"를 나타냅니다. 두 주소가 협력하여 완전한 통신을 가능하게 합니다.
