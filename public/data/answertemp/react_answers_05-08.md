# React 답변 05-08

## 질문 5: React의 렌더링 과정을 설명해주세요.

**정의:**
React의 렌더링은 컴포넌트의 현재 상태를 기반으로 UI를 생성하고 화면에 표시하는 전체 프로세스입니다. 초기 렌더링과 리렌더링으로 나뉘며, Virtual DOM을 활용한 효율적인 업데이트 메커니즘을 사용합니다.

**렌더링 과정의 단계:**
- 트리거 단계: 초기 렌더링이나 상태 변경으로 렌더링이 시작됩니다. setState, useState 훅 호출 등이 트리거가 됩니다.
- 렌더 단계: 컴포넌트 함수를 호출하여 새로운 Virtual DOM 트리를 생성합니다. 순수한 계산 과정이며 부작용이 없어야 합니다.
- 재조정 단계: 이전 Virtual DOM과 새 Virtual DOM을 비교합니다. Diffing 알고리즘으로 변경사항을 찾습니다.
- 커밋 단계: 변경된 부분만 실제 DOM에 반영합니다. 한 번에 배치 업데이트로 적용됩니다.
- 브라우저 렌더링: DOM 변경 후 브라우저가 레이아웃과 페인트를 수행합니다.

**초기 렌더링:**
- 루트 컴포넌트에서 시작합니다. ReactDOM.render 또는 createRoot를 호출합니다.
- 전체 컴포넌트 트리를 순회하며 Virtual DOM을 생성합니다.
- 실제 DOM 노드를 생성하여 화면에 삽입합니다.
- useEffect 같은 부작용 훅이 실행됩니다.

**리렌더링 조건:**
- 상태가 변경되면 해당 컴포넌트와 자식들이 리렌더링됩니다.
- 부모가 리렌더링되면 자식도 기본적으로 리렌더링됩니다.
- Context 값이 변경되면 구독 중인 컴포넌트들이 리렌더링됩니다.
- 최적화 기법으로 불필요한 리렌더링을 방지할 수 있습니다.

**렌더와 커밋의 분리:**
- 렌더 단계는 순수해야 합니다. 같은 입력에 같은 출력을 보장합니다.
- 커밋 단계에서만 DOM을 조작합니다.
- React 18의 Concurrent 기능으로 렌더 단계를 중단하고 재개할 수 있습니다.
- 우선순위가 높은 업데이트를 먼저 처리할 수 있습니다.

**실무 활용:**
- 렌더링 성능을 모니터링합니다. React DevTools Profiler를 사용합니다.
- 불필요한 렌더링을 최소화합니다. memo, useMemo, useCallback을 활용합니다.
- 상태를 적절히 분리하여 리렌더링 범위를 제한합니다.
- 큰 리스트는 가상화 기법을 사용합니다.
- 렌더 단계에서 부작용을 일으키지 않도록 주의합니다.

---

## 질문 6: React의 단방향 데이터 흐름(Unidirectional Data Flow)이란 무엇인가요?

**정의:**
단방향 데이터 흐름은 데이터가 부모 컴포넌트에서 자식 컴포넌트로만 흐르는 React의 핵심 원칙입니다. Props를 통해 위에서 아래로만 전달되며, 자식이 직접 부모의 데이터를 수정할 수 없습니다.

**단방향 흐름의 원리:**
- 부모가 props로 데이터를 전달합니다. 자식은 읽기만 가능합니다.
- 자식이 데이터를 변경하려면 부모가 제공한 콜백을 호출합니다.
- 상태는 소유한 컴포넌트에서만 변경됩니다.
- 데이터의 출처가 명확합니다. 추적이 쉽고 버그를 찾기 용이합니다.

**양방향 바인딩과의 차이:**
- 양방향 바인딩은 뷰와 모델이 자동 동기화됩니다. Angular 1.x가 대표적입니다.
- 데이터 흐름이 복잡해지고 예측하기 어렵습니다.
- 디버깅이 어렵습니다. 어디서 변경이 일어났는지 추적이 힘듭니다.
- React의 단방향은 명시적이고 예측 가능합니다.

**단방향 흐름의 장점:**
- 데이터 흐름이 명확합니다. 위에서 아래로만 흐르므로 이해하기 쉽습니다.
- 디버깅이 용이합니다. 상태 변경 지점을 쉽게 찾을 수 있습니다.
- 예측 가능성이 높습니다. 입력이 같으면 출력도 같습니다.
- 유지보수가 쉽습니다. 코드의 동작을 파악하기 쉽습니다.
- 테스트하기 좋습니다. 순수 함수처럼 동작합니다.

**데이터 전달 패턴:**
- Props로 하위로 전달: 가장 기본적인 방법입니다.
- 콜백으로 상위로 알림: 자식이 이벤트를 부모에게 전달합니다.
- State 끌어올리기: 공통 상태를 부모로 이동합니다.
- Context로 깊은 전달: 중간 컴포넌트를 거치지 않고 전달합니다.

**상태 관리와의 관계:**
- 로컬 상태는 해당 컴포넌트에서만 관리합니다.
- 공유 상태는 공통 조상으로 끌어올립니다.
- 전역 상태는 Context나 Redux 같은 라이브러리를 사용합니다.
- 단방향 원칙은 여전히 유지됩니다.

**실무 활용:**
- 상태를 최상위에 집중하지 말고 필요한 곳에 둡니다.
- Props drilling이 심하면 Context나 상태 관리 라이브러리를 고려합니다.
- 콜백 함수로 자식의 이벤트를 부모에게 전달합니다.
- 데이터 흐름을 명확하게 설계하여 복잡도를 낮춥니다.
- 컴포넌트 구조를 잘 설계하면 자연스럽게 단방향을 따르게 됩니다.

---

## 질문 7: React Hooks가 등장한 이유는 무엇인가요?

**정의:**
React Hooks는 함수형 컴포넌트에서 상태와 생명주기 기능을 사용할 수 있게 해주는 함수들입니다. React 16.8에서 도입되어 클래스 컴포넌트의 한계를 극복하고 코드 재사용성을 높였습니다.

**클래스 컴포넌트의 문제점:**
- this 바인딩이 복잡합니다. 이벤트 핸들러마다 bind를 해야 합니다. 초보자에게 혼란스럽습니다.
- 생명주기 메서드에 로직이 분산됩니다. 관련 없는 코드가 섞이고 관련된 코드가 나뉩니다.
- 컴포넌트 재사용이 어렵습니다. HOC나 Render Props는 래퍼 지옥을 만듭니다.
- 코드 최소화와 최적화가 어렵습니다. 클래스는 압축이 잘 안 됩니다.
- 코드량이 많습니다. 보일러플레이트가 많습니다.

**Hooks의 등장 배경:**
- 상태 관련 로직을 재사용하기 어려웠습니다. Custom Hook으로 해결합니다.
- 복잡한 컴포넌트를 이해하기 어려웠습니다. 로직을 훅으로 분리합니다.
- 클래스가 사람과 기계 모두에게 어려웠습니다.
- 함수형 프로그래밍이 트렌드였습니다.

**Hooks가 제공하는 이점:**
- 함수형 컴포넌트에서 모든 기능을 사용할 수 있습니다.
- 로직을 Custom Hook으로 분리하여 재사용합니다.
- 관련된 코드를 한곳에 모을 수 있습니다. useEffect 여러 개를 사용합니다.
- 컴포넌트 트리가 단순해집니다. HOC 래퍼가 필요 없습니다.
- 테스트하기 쉽습니다. 순수 함수에 가깝습니다.
- 번들 크기가 작아집니다. 클래스보다 압축이 잘 됩니다.

**주요 Hooks:**
- useState: 상태를 관리합니다.
- useEffect: 부작용을 처리합니다.
- useContext: Context를 구독합니다.
- useReducer: 복잡한 상태 로직을 관리합니다.
- useRef: 변경 가능한 값을 저장하거나 DOM에 접근합니다.
- useMemo, useCallback: 성능을 최적화합니다.

**Hooks의 철학:**
- 클래스를 대체하는 것이 목표입니다. 점진적으로 도입할 수 있습니다.
- 기존 개념을 제거하지 않습니다. 클래스도 여전히 작동합니다.
- 100% 하위 호환됩니다. 기존 코드를 바꿀 필요가 없습니다.
- 함수형 프로그래밍을 장려합니다.

**실무 활용:**
- 새 컴포넌트는 함수형과 Hooks로 작성합니다.
- Custom Hook으로 로직을 재사용합니다. 여러 컴포넌트에서 공유합니다.
- 클래스 컴포넌트를 점진적으로 마이그레이션합니다. 급할 필요는 없습니다.
- Hooks 규칙을 준수합니다. ESLint 플러그인을 사용합니다.
- React 생태계가 Hooks 중심으로 발전하고 있습니다.

---

## 질문 8: useState의 동작 원리와 사용법은 무엇인가요?

**정의:**
useState는 함수형 컴포넌트에서 상태를 관리할 수 있게 해주는 가장 기본적인 Hook입니다. 현재 상태 값과 이를 업데이트하는 함수를 배열로 반환합니다.

**기본 사용법:**
- 배열 구조 분해로 상태와 업데이트 함수를 받습니다.
- 초기값을 인자로 전달합니다. 모든 타입이 가능합니다.
- 업데이트 함수를 호출하면 컴포넌트가 리렌더링됩니다.
- 여러 useState를 사용하여 여러 상태를 관리할 수 있습니다.

**동작 원리:**
- React는 컴포넌트별로 상태 배열을 관리합니다.
- 호출 순서로 상태를 식별합니다. 조건문 안에서 사용하면 안 되는 이유입니다.
- 클로저를 활용하여 상태를 보존합니다.
- 상태 업데이트는 비동기적으로 배치됩니다.
- 같은 값으로 업데이트하면 리렌더링을 건너뜁니다. Object.is로 비교합니다.

**상태 업데이트 방식:**
- 직접 값을 전달: 새로운 값을 직접 설정합니다.
- 함수형 업데이트: 이전 상태를 기반으로 계산합니다. 현재 상태가 필요할 때 사용합니다.
- 함수형 업데이트는 클로저 문제를 해결합니다.
- 여러 업데이트가 배치되어 처리됩니다.

**초기값 설정:**
- 단순한 값을 직접 전달합니다.
- 계산 비용이 크면 함수를 전달합니다. 지연 초기화입니다.
- 함수는 초기 렌더링 시에만 실행됩니다.
- localStorage에서 읽기 같은 작업에 유용합니다.

**주의사항:**
- 상태는 불변성을 유지해야 합니다. 객체나 배열을 직접 수정하면 안 됩니다.
- 스프레드 연산자나 map, filter로 새 객체를 만듭니다.
- 상태 업데이트는 즉시 반영되지 않습니다. 비동기적입니다.
- 같은 렌더링 안에서 여러 번 호출해도 마지막 렌더링 때의 값을 참조합니다.

**객체와 배열 상태:**
- 중첩된 객체는 전체를 새로 만들어야 합니다.
- Immer 같은 라이브러리로 간편하게 업데이트할 수 있습니다.
- 배열은 push 대신 concat이나 스프레드를 사용합니다.
- 삭제는 filter를 사용합니다.

**실무 활용:**
- 폼 입력값을 관리합니다. 각 필드마다 useState를 사용하거나 객체로 묶습니다.
- 토글 상태를 관리합니다. 모달 열림 닫힘 등입니다.
- 목록 데이터를 관리합니다. 추가 삭제 수정 기능을 구현합니다.
- 복잡한 상태는 useReducer를 고려합니다.
- TypeScript와 함께 사용하면 타입 안전성을 얻습니다.

---
