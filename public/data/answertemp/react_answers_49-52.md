# React 답변 49-52

## 질문 49: CSR, SSR, SSG의 차이점은 무엇인가요?

**정의:**
CSR, SSR, SSG는 웹 애플리케이션의 렌더링 방식입니다. CSR은 클라이언트에서, SSR은 서버에서 요청마다, SSG는 빌드 시에 HTML을 생성합니다. 각각 장단점이 있으며 상황에 맞게 선택해야 합니다.

**CSR (Client-Side Rendering):**
- 브라우저에서 JavaScript로 HTML을 생성합니다.
- 초기 HTML은 거의 비어 있습니다.
- JavaScript가 다운로드되고 실행되면 UI가 렌더링됩니다.
- Create React App의 기본 방식입니다.
- SPA의 전통적인 방식입니다.

**CSR의 장단점:**
- 장점: 빠른 페이지 전환, 풍부한 인터랙션, 서버 부하 적음, 개발이 단순합니다.
- 단점: 초기 로딩 느림, SEO 불리, JavaScript 필수, 느린 네트워크에서 문제입니다.
- 적합한 경우: 대시보드, 관리자 페이지, SEO 불필요한 앱, 인터랙션 많은 앱입니다.

**SSR (Server-Side Rendering):**
- 서버에서 요청마다 HTML을 생성합니다.
- 완전한 HTML이 클라이언트로 전송됩니다.
- Hydration으로 인터랙티브하게 만듭니다.
- Next.js의 getServerSideProps를 사용합니다.
- 동적 데이터에 적합합니다.

**SSR의 장단점:**
- 장점: 빠른 초기 로딩, SEO 우수, 동적 데이터 가능, JavaScript 없이도 작동합니다.
- 단점: 서버 부하 큼, TTFB 느릴 수 있음, 복잡한 설정, 비용 증가 가능합니다.
- 적합한 경우: 전자상거래, 뉴스 사이트, 개인화된 콘텐츠, SEO 중요한 페이지입니다.

**SSG (Static Site Generation):**
- 빌드 타임에 HTML을 미리 생성합니다.
- 정적 파일을 CDN에서 제공합니다.
- 매우 빠른 로딩 속도를 제공합니다.
- Next.js의 getStaticProps를 사용합니다.
- JAMstack 아키텍처의 핵심입니다.

**SSG의 장단점:**
- 장점: 최고의 성능, 낮은 비용, 뛰어난 확장성, SEO 우수, 보안 좋습니다.
- 단점: 빌드 시간 증가, 동적 데이터 불가, 업데이트 시 재빌드, 실시간 데이터 어려움입니다.
- 적합한 경우: 블로그, 문서 사이트, 마케팅 페이지, 자주 변하지 않는 콘텐츠입니다.

**ISR (Incremental Static Regeneration):**
- SSG의 발전된 형태입니다.
- 정적 페이지를 주기적으로 재생성합니다.
- 최신 데이터를 유지하면서 성능도 좋습니다.
- Next.js의 revalidate 옵션을 사용합니다.
- SSG와 SSR의 장점을 결합합니다.

**선택 기준:**
- SEO가 중요한가: SSR이나 SSG를 선택합니다.
- 데이터가 자주 변하는가: 자주 변하면 SSR, 아니면 SSG입니다.
- 성능이 최우선인가: SSG가 가장 빠릅니다.
- 서버 리소스 제한이 있는가: SSG가 가장 저렴합니다.
- 개인화가 필요한가: SSR이 적합합니다.

**하이브리드 접근:**
- Next.js는 페이지별로 다른 방식을 선택할 수 있습니다.
- 홈페이지는 SSG, 상품 상세는 SSR, 대시보드는 CSR을 사용합니다.
- 각 페이지의 특성에 맞게 최적화합니다.
- 유연성이 가장 큰 장점입니다.

**실무 활용:**
- 블로그는 SSG로 구축합니다.
- 전자상거래 상품 목록은 SSR을 사용합니다.
- 사용자 대시보드는 CSR로 충분합니다.
- Next.js로 하이브리드 접근을 구현합니다.
- 프로젝트 요구사항에 맞는 방식을 선택합니다.

---

## 질문 50: Next.js는 무엇이고 왜 사용하나요?

**정의:**
Next.js는 React 기반의 프레임워크로, SSR, SSG, ISR을 지원하며 프로덕션 환경에 최적화된 기능을 제공합니다. Vercel에서 개발했으며 풀스택 React 애플리케이션을 쉽게 구축할 수 있게 해줍니다.

**Next.js의 핵심 기능:**
- 하이브리드 렌더링: 페이지별로 SSR, SSG, CSR을 선택할 수 있습니다.
- 파일 시스템 기반 라우팅: 파일 구조가 곧 라우트입니다.
- API 라우트: 서버리스 API를 쉽게 만들 수 있습니다.
- 자동 코드 스플리팅: 페이지별로 번들이 자동 분리됩니다.
- 이미지 최적화: next/image로 이미지를 자동 최적화합니다.
- TypeScript 지원: 설정 없이 바로 사용 가능합니다.

**왜 Next.js를 사용할까:**
- SEO가 중요한 사이트를 만들 때입니다.
- 초기 로딩 속도가 중요할 때입니다.
- 서버와 클라이언트 코드를 함께 관리하고 싶을 때입니다.
- 라우팅 설정을 간소화하고 싶을 때입니다.
- 프로덕션 최적화를 자동으로 하고 싶을 때입니다.

**파일 시스템 라우팅:**
- pages 디렉토리의 구조가 URL이 됩니다.
- pages/about.js는 /about 경로가 됩니다.
- pages/blog/[id].js는 동적 라우트입니다.
- React Router 설정이 필요 없습니다.
- 직관적이고 관리하기 쉽습니다.

**데이터 페칭 메서드:**
- getServerSideProps: 요청마다 서버에서 데이터를 가져옵니다.
- getStaticProps: 빌드 시 데이터를 가져옵니다.
- getStaticPaths: 동적 SSG 경로를 정의합니다.
- 페이지 컴포넌트에서만 사용 가능합니다.

**API 라우트:**
- pages/api 디렉토리에 API를 만듭니다.
- 서버리스 함수로 배포됩니다.
- 별도 백엔드 없이 API를 구현할 수 있습니다.
- 데이터베이스와 직접 연결 가능합니다.
- 간단한 백엔드 로직에 적합합니다.

**이미지 최적화:**
- next/image 컴포넌트를 사용합니다.
- 자동으로 크기를 조정하고 형식을 변환합니다.
- 지연 로딩을 기본 제공합니다.
- WebP 같은 최신 형식을 자동 지원합니다.
- 성능이 크게 향상됩니다.

**자동 최적화:**
- 코드 스플리팅이 자동으로 됩니다.
- Tree shaking으로 불필요한 코드를 제거합니다.
- CSS와 폰트를 최적화합니다.
- 프리페칭으로 페이지 전환을 빠르게 합니다.
- 프로덕션 빌드가 고도로 최적화됩니다.

**배포:**
- Vercel에 원클릭 배포가 가능합니다.
- 자동 HTTPS와 CDN을 제공받습니다.
- Git과 연동되어 자동 배포됩니다.
- 프리뷰 배포로 PR을 미리 확인할 수 있습니다.
- 다른 플랫폼에도 배포 가능합니다.

**실무 활용:**
- 기업 웹사이트를 Next.js로 구축합니다.
- 전자상거래 플랫폼에 적합합니다.
- 블로그와 콘텐츠 사이트를 만듭니다.
- SEO가 중요한 마케팅 페이지를 제작합니다.
- React의 강력함과 SEO를 동시에 얻습니다.

---

## 질문 51: getServerSideProps와 getStaticProps의 차이점은 무엇인가요?

**정의:**
getServerSideProps와 getStaticProps는 Next.js에서 데이터를 페칭하는 메서드입니다. getServerSideProps는 요청마다 실행되고, getStaticProps는 빌드 시 한 번만 실행됩니다.

**getServerSideProps 특징:**
- 매 요청마다 서버에서 실행됩니다.
- 항상 최신 데이터를 가져올 수 있습니다.
- context 객체로 쿠키, 쿼리 등에 접근합니다.
- 서버에서만 실행되므로 데이터베이스 직접 접근 가능합니다.
- props를 반환하여 페이지에 전달합니다.

**getServerSideProps 사용 시기:**
- 데이터가 자주 변경될 때입니다.
- 요청별로 다른 데이터를 보여줘야 할 때입니다.
- 사용자별 개인화된 콘텐츠가 필요할 때입니다.
- 쿠키나 헤더를 확인해야 할 때입니다.
- 실시간성이 중요할 때입니다.

**getServerSideProps 장단점:**
- 장점: 항상 최신 데이터, 동적 콘텐츠 가능, 사용자 정보 활용 가능합니다.
- 단점: 서버 부하, TTFB 증가, CDN 캐싱 불가, 비용 높을 수 있습니다.
- 성능: SSG보다 느리지만 CSR보다 초기 로딩은 빠릅니다.

**getStaticProps 특징:**
- 빌드 타임에 한 번만 실행됩니다.
- 정적 HTML 파일을 생성합니다.
- CDN에서 제공되어 매우 빠릅니다.
- 개발 모드에서는 매 요청마다 실행됩니다.
- 프로덕션에서는 빌드 시에만 실행됩니다.

**getStaticProps 사용 시기:**
- 데이터가 거의 변하지 않을 때입니다.
- 모든 사용자에게 같은 콘텐츠를 보여줄 때입니다.
- 빌드 시 데이터를 가져올 수 있을 때입니다.
- 성능이 최우선일 때입니다.
- SEO가 중요하지만 동적 데이터는 필요 없을 때입니다.

**getStaticProps 장단점:**
- 장점: 최고의 성능, 낮은 비용, 뛰어난 확장성, CDN 활용 가능합니다.
- 단점: 빌드 시간 증가, 데이터 업데이트 어려움, 실시간 불가능합니다.
- 성능: 가장 빠르지만 데이터가 오래될 수 있습니다.

**revalidate 옵션:**
- ISR을 활성화합니다.
- 지정된 시간마다 페이지를 재생성합니다.
- 초 단위로 설정합니다.
- 오래된 데이터 문제를 완화합니다.
- SSG와 SSR의 중간 지점입니다.

**fallback 옵션:**
- getStaticPaths와 함께 사용합니다.
- false: 빌드하지 않은 경로는 404입니다.
- true: 백그라운드에서 생성하고 로딩을 보여줍니다.
- blocking: 생성될 때까지 기다립니다.
- 동적 페이지 수에 따라 선택합니다.

**선택 기준:**
- 데이터 신선도: 중요하면 getServerSideProps, 아니면 getStaticProps입니다.
- 트래픽: 많으면 getStaticProps가 유리합니다.
- 개인화: 필요하면 getServerSideProps입니다.
- 비용: getStaticProps가 저렴합니다.
- 페이지 수: 많으면 ISR을 고려합니다.

**실무 활용:**
- 블로그 게시물은 getStaticProps를 사용합니다.
- 사용자 대시보드는 getServerSideProps를 사용합니다.
- 상품 목록은 ISR을 사용합니다.
- 정적 페이지는 getStaticProps로 성능을 최적화합니다.
- 프로젝트 요구사항에 따라 적절히 선택합니다.

---

## 질문 52: getStaticPaths는 언제 사용하나요?

**정의:**
getStaticPaths는 동적 라우트를 SSG로 생성할 때 어떤 경로를 미리 만들지 지정하는 Next.js 함수입니다. getStaticProps와 함께 사용하여 동적 페이지를 정적으로 생성합니다.

**필요한 이유:**
- 동적 라우트는 무한히 많을 수 있습니다.
- 빌드 시 어떤 경로를 생성할지 알려줘야 합니다.
- params를 반환하여 각 경로를 정의합니다.
- getStaticProps와 반드시 함께 사용됩니다.

**기본 구조:**
- paths 배열을 반환합니다. 생성할 경로 목록입니다.
- 각 경로는 params 객체를 포함합니다.
- fallback 값을 반환합니다. 빌드하지 않은 경로 처리 방식입니다.
- 빌드 타임에 실행됩니다.

**paths 생성:**
- 데이터베이스에서 모든 ID를 가져옵니다.
- API를 호출하여 목록을 받습니다.
- map으로 params 배열로 변환합니다.
- 각 params는 동적 세그먼트 값을 포함합니다.

**fallback 옵션:**
- false: paths에 없는 경로는 404입니다. 적은 수의 페이지에 적합합니다.
- true: 백그라운드에서 생성합니다. useRouter의 isFallback으로 로딩을 보여줍니다.
- blocking: 생성 완료까지 기다립니다. 사용자는 기다리지만 로딩 처리 불필요합니다.

**fallback: false 사용:**
- 페이지가 적을 때 사용합니다.
- 모든 경로를 빌드 시 생성합니다.
- 가장 빠르지만 빌드 시간이 길 수 있습니다.
- 새 경로는 재배포가 필요합니다.

**fallback: true 사용:**
- 페이지가 매우 많을 때 사용합니다.
- 일부만 빌드하고 나머지는 요청 시 생성합니다.
- 로딩 상태를 처리해야 합니다.
- 첫 요청은 느리지만 이후는 빠릅니다.

**fallback: blocking 사용:**
- true와 유사하지만 로딩 처리가 불필요합니다.
- 서버에서 생성이 완료될 때까지 기다립니다.
- 사용자 경험이 더 나을 수 있습니다.
- 간단하지만 TTFB가 증가합니다.

**ISR과 함께 사용:**
- revalidate와 fallback: true를 조합합니다.
- 새 경로를 동적으로 추가할 수 있습니다.
- 기존 경로는 주기적으로 업데이트됩니다.
- 최고의 유연성을 제공합니다.

**성능 고려사항:**
- 너무 많은 경로를 빌드하면 시간이 오래 걸립니다.
- 인기 있는 페이지만 미리 생성합니다.
- 나머지는 fallback으로 처리합니다.
- 빌드 시간과 사용자 경험의 균형을 맞춥니다.

**실무 활용:**
- 블로그는 모든 게시물을 미리 생성합니다. fallback: false입니다.
- 전자상거래는 인기 상품만 생성합니다. fallback: true입니다.
- 사용자 프로필은 fallback: blocking을 사용합니다.
- 페이지 수와 업데이트 빈도에 따라 전략을 선택합니다.
- ISR과 조합하여 최적의 성능을 얻습니다.

---
