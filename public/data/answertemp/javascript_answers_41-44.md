# JavaScript 답변 41-44

## 질문 41: 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이점과 구현 방법은 무엇인가요?

**정의:**
얕은 복사는 객체의 최상위 레벨만 복사하여 내부 객체는 참조를 공유하는 방식입니다. 깊은 복사는 모든 중첩된 객체까지 재귀적으로 복사하여 완전히 독립적인 복사본을 만드는 방식입니다.

**얕은 복사의 특징:**
- 원시 값은 값이 복사됩니다. 독립적인 값이 생성됩니다.
- 객체나 배열은 참조가 복사됩니다. 같은 메모리 주소를 가리킵니다.
- 한 단계만 복사합니다. 중첩된 구조는 공유됩니다.
- 내부 객체를 수정하면 원본도 영향을 받습니다.

**얕은 복사 방법:**
- 스프레드 연산자: 가장 간편하고 직관적입니다. 객체와 배열 모두 가능합니다.
- Object.assign: 여러 객체를 병합하며 복사합니다.
- Array.from이나 slice: 배열을 복사합니다.
- 모두 한 단계만 복사합니다.

**깊은 복사의 특징:**
- 모든 레벨의 값을 복사합니다. 완전히 독립적인 객체가 생성됩니다.
- 중첩된 객체도 새로운 메모리에 할당됩니다.
- 원본과 복사본이 완전히 분리됩니다. 서로 영향을 주지 않습니다.
- 구현이 복잡하고 성능 비용이 있습니다.

**깊은 복사 방법:**
- JSON 방식: JSON.stringify 후 JSON.parse합니다. 간단하지만 제한사항이 있습니다.
- 재귀 함수: 모든 속성을 순회하며 복사합니다. 가장 완전하지만 구현이 복잡합니다.
- structuredClone: 최신 API로 대부분의 타입을 지원합니다. 가장 권장되는 방법입니다.
- Lodash cloneDeep: 라이브러리를 사용하여 안정적으로 복사합니다.

**JSON 방식의 제한사항:**
- 함수는 복사되지 않습니다. undefined가 됩니다.
- undefined와 Symbol은 누락됩니다.
- Date 객체는 문자열로 변환됩니다.
- 순환 참조가 있으면 에러가 발생합니다.
- 프로토타입 체인은 복사되지 않습니다.

**structuredClone의 장점:**
- 대부분의 타입을 지원합니다. Date, RegExp, Map, Set 등도 복사됩니다.
- 순환 참조를 처리할 수 있습니다.
- 네이티브 API로 빠릅니다.
- 함수와 DOM 노드는 여전히 복사할 수 없습니다.

**실무에서의 선택:**
- 중첩이 없거나 얕은 복사로 충분하면 스프레드를 사용합니다.
- 깊은 복사가 필요하면 structuredClone을 우선 고려합니다.
- 특수한 타입이 있으면 라이브러리나 커스텀 구현을 사용합니다.
- 성능이 중요하면 필요한 부분만 수동으로 복사합니다.
- 불변성 라이브러리 사용을 고려합니다. Immer는 편리하고 효율적입니다.

---

## 질문 42: Proxy 객체의 동작 원리와 활용 사례는 무엇인가요?

**정의:**
Proxy는 객체의 기본 동작을 가로채고 재정의할 수 있는 메타프로그래밍 기능입니다. 객체 접근, 할당, 함수 호출 등을 커스터마이징할 수 있습니다.

**Proxy의 구조:**
- target: 원본 객체입니다. 프록시가 감싸는 대상입니다.
- handler: 트랩 함수들을 정의한 객체입니다. 동작을 가로챕니다.
- trap: handler의 메서드로 특정 동작을 가로챕니다.
- Proxy 생성자로 프록시 객체를 만듭니다.

**주요 트랩 종류:**
- get: 속성 읽기를 가로챕니다. 접근 로깅이나 기본값 제공에 사용합니다.
- set: 속성 쓰기를 가로챕니다. 유효성 검사나 변경 추적에 사용합니다.
- has: in 연산자를 가로챕니다. 속성 존재 여부 확인을 커스터마이징합니다.
- deleteProperty: delete 연산자를 가로챕니다.
- apply: 함수 호출을 가로챕니다.
- construct: new 연산자를 가로챕니다.

**Proxy의 활용 사례:**
- 유효성 검사: 속성 할당 시 값을 검증합니다. 잘못된 값을 차단합니다.
- 로깅과 디버깅: 객체 접근을 추적합니다. 어떤 속성이 사용되는지 파악합니다.
- 기본값 제공: 존재하지 않는 속성에 기본값을 반환합니다.
- 읽기 전용 객체: set 트랩에서 에러를 발생시켜 불변 객체를 만듭니다.
- 음수 인덱싱: 배열에서 음수 인덱스를 지원합니다.

**반응형 시스템 구현:**
- Vue 3의 반응성이 Proxy로 구현됩니다.
- 속성 변경을 자동으로 감지합니다.
- 의존성을 추적하여 자동 업데이트합니다.
- Object.defineProperty보다 강력하고 완전합니다.

**Reflect와의 조합:**
- Reflect는 Proxy 트랩에 대응하는 메서드를 제공합니다.
- 기본 동작을 수행하면서 커스텀 로직을 추가할 수 있습니다.
- Reflect.get, Reflect.set 등을 사용합니다.
- receiver 매개변수로 this 바인딩을 올바르게 처리합니다.

**주의사항:**
- 성능 오버헤드가 있습니다. 모든 객체에 사용하면 느려질 수 있습니다.
- 프록시는 원본 객체와 다른 참조입니다. 동등성 비교 시 주의가 필요합니다.
- 일부 내장 객체는 프록시로 완전히 감쌀 수 없습니다.
- 디버깅이 복잡해질 수 있습니다.

**실무 활용:**
- 상태 관리 라이브러리에서 반응성을 구현합니다.
- API 래퍼로 요청을 가로채고 수정합니다.
- 폼 데이터의 실시간 유효성 검사를 구현합니다.
- 객체 접근 로깅으로 사용 패턴을 분석합니다.
- 지연 로딩을 구현합니다. 실제 접근 시점에 데이터를 로드합니다.

---

## 질문 43: Reflect API는 무엇이고 왜 사용하나요?

**정의:**
Reflect는 JavaScript 연산을 메서드로 제공하는 내장 객체입니다. Proxy 트랩과 일대일 대응하며, 객체 조작을 더 명시적이고 안전하게 만듭니다.

**Reflect의 목적:**
- 객체 연산을 함수화합니다. 연산자 대신 메서드로 제공합니다.
- Proxy 트랩과 동일한 시그니처를 가집니다. 기본 동작을 쉽게 호출할 수 있습니다.
- 더 명확한 반환값을 제공합니다. 성공 여부를 불리언으로 반환합니다.
- 에러 처리가 일관적입니다.

**Reflect의 주요 메서드:**
- Reflect.get: 속성 값을 가져옵니다. 대괄호 접근과 같지만 receiver를 지정할 수 있습니다.
- Reflect.set: 속성 값을 설정합니다. 성공 여부를 반환합니다.
- Reflect.has: in 연산자와 같습니다.
- Reflect.deleteProperty: delete 연산자와 같습니다. 성공 여부를 반환합니다.
- Reflect.apply: 함수를 호출합니다. call이나 apply와 비슷하지만 더 명시적입니다.
- Reflect.construct: new 연산자와 같습니다.

**기존 방식과의 비교:**
- delete obj.prop 대신 Reflect.deleteProperty를 사용합니다. 반환값이 명확합니다.
- prop in obj 대신 Reflect.has를 사용할 수 있습니다.
- 함수 호출도 Reflect.apply로 통일할 수 있습니다.
- 일관된 인터페이스로 코드가 더 예측 가능해집니다.

**Proxy와 함께 사용:**
- Proxy 트랩에서 기본 동작을 수행하기 위해 Reflect를 사용합니다.
- 커스텀 로직을 추가한 후 Reflect로 원래 동작을 실행합니다.
- receiver 매개변수를 올바르게 전달할 수 있습니다.
- 코드가 간결하고 명확해집니다.

**receiver 매개변수:**
- getter나 setter에서 this 값을 지정합니다.
- 상속 관계에서 올바른 this 바인딩을 보장합니다.
- Proxy를 통한 접근 시 원래의 this를 유지합니다.

**성공 여부 반환:**
- Object 메서드는 에러를 throw하거나 undefined를 반환합니다.
- Reflect 메서드는 성공 시 true, 실패 시 false를 반환합니다.
- try-catch 없이 성공 여부를 확인할 수 있습니다.
- 더 함수형 프로그래밍에 가까운 스타일입니다.

**실무 활용:**
- Proxy 핸들러를 작성할 때 Reflect를 사용하여 기본 동작을 위임합니다.
- 조건부 객체 조작 시 반환값으로 성공 여부를 확인합니다.
- 메타프로그래밍에서 명시적인 객체 조작을 구현합니다.
- 라이브러리나 프레임워크에서 안전한 객체 접근을 제공합니다.
- 대부분의 경우 직접 사용하기보다 Proxy와 함께 사용합니다.

---

## 질문 44: Generator 함수의 동작 원리와 사용 사례는 무엇인가요?

**정의:**
Generator는 함수 실행을 중간에 멈추고 재개할 수 있는 특별한 함수입니다. function* 문법으로 선언하며 yield 키워드로 값을 반환하고 일시 정지합니다.

**Generator의 특징:**
- 함수 실행을 제어할 수 있습니다. 필요할 때만 다음 값을 계산합니다.
- yield로 값을 반환하고 일시 정지합니다. 여러 번 값을 반환할 수 있습니다.
- next 메서드로 실행을 재개합니다. 다음 yield까지 실행됩니다.
- Iterator를 반환합니다. for-of 루프와 스프레드 연산자를 사용할 수 있습니다.

**동작 원리:**
- Generator 함수를 호출하면 Iterator 객체를 반환합니다. 즉시 실행되지 않습니다.
- next를 호출하면 다음 yield까지 실행됩니다.
- yield 표현식의 값이 value로 반환됩니다.
- done 속성으로 완료 여부를 알 수 있습니다.
- return 문을 만나거나 함수가 끝나면 done이 true가 됩니다.

**양방향 통신:**
- next에 인수를 전달하면 yield 표현식의 값이 됩니다.
- Generator 내부로 값을 전달할 수 있습니다.
- 호출자와 Generator 간 데이터를 주고받습니다.

**에러 처리:**
- throw 메서드로 Generator 내부에 에러를 던질 수 있습니다.
- Generator 내부의 try-catch로 에러를 처리합니다.
- 제어 흐름을 외부에서 조작할 수 있습니다.

**지연 평가:**
- 값을 필요할 때만 계산합니다. 무한 시퀀스를 표현할 수 있습니다.
- 메모리 효율적입니다. 모든 값을 미리 생성하지 않습니다.
- 큰 데이터셋을 다룰 때 유용합니다.

**사용 사례:**
- 무한 시퀀스 생성: ID 생성기, 피보나치 수열 등을 구현합니다.
- 상태 머신: 복잡한 상태 전환 로직을 명확하게 표현합니다.
- 비동기 흐름 제어: async/await 이전에 사용되었습니다. co 같은 라이브러리와 함께 사용합니다.
- 데이터 스트리밍: 대용량 데이터를 청크 단위로 처리합니다.
- 이터레이터 구현: 커스텀 이터레이션 로직을 간단히 작성합니다.

**실무 활용:**
- Redux Saga에서 사이드 이펙트를 관리합니다. Generator로 복잡한 비동기 흐름을 표현합니다.
- 테스트 데이터 생성기를 만듭니다. 필요한 만큼만 데이터를 생성합니다.
- 대용량 파일 처리 시 메모리를 절약합니다.
- 복잡한 반복 로직을 명확하게 표현합니다.
- 현대에는 async/await로 대체되는 경향이 있지만 특수한 경우에 여전히 유용합니다.

---
