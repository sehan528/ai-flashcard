# Network 답변 모음 (73-76)

## 73. URL, URI, URN은 어떤 차이가 있나요?

**URI(Uniform Resource Identifier)**, **URL(Uniform Resource Locator)**, **URN(Uniform Resource Name)**은 리소스를 식별하는 서로 다른 방식입니다.

**URI (Uniform Resource Identifier):**

**정의:**
리소스를 고유하게 식별하는 문자열의 총칭입니다. URL과 URN을 모두 포함하는 상위 개념입니다.

**구성:**
Scheme + Authority + Path + Query + Fragment로 이루어집니다. 리소스를 "무엇"으로 식별하는지에 관계없이 모든 식별자를 포함합니다.

**예시:**
- https://www.example.com/path/to/resource
- mailto:user@example.com
- urn:isbn:0-486-27557-4
- tel:+1-816-555-1212

**URL (Uniform Resource Locator):**

**정의:**
리소스의 **위치**를 나타내는 URI의 한 종류입니다. 리소스를 "어디서" 찾을 수 있는지 명시합니다.

**구성 요소:**
- **Scheme(Protocol)**: http, https, ftp, mailto 등
- **Authority**: 사용자 정보(선택), 호스트(도메인 또는 IP), 포트(선택)
- **Path**: 리소스의 경로
- **Query**: 쿼리 파라미터(선택)
- **Fragment**: 문서 내 특정 부분(선택)

**예시:**
- https://www.example.com:443/path/to/resource?key=value#section
- ftp://ftp.example.com/file.zip
- file:///C:/Users/Documents/file.txt

**특징:**
위치 기반이므로 리소스가 이동하면 URL이 변경됩니다. 네트워크에서 리소스에 접근하는 방법을 제공합니다.

**URN (Uniform Resource Name):**

**정의:**
리소스의 **이름**으로 식별하는 URI의 한 종류입니다. 위치와 무관하게 리소스를 고유하게 식별합니다.

**구성:**
urn:namespace:specific-string 형식을 사용합니다.

**예시:**
- urn:isbn:0451450523 (책의 ISBN)
- urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66
- urn:ietf:rfc:3986 (RFC 문서)

**특징:**
리소스의 위치가 변경되어도 URN은 동일합니다. 영구적이고 위치 독립적인 식별자입니다. 하지만 URN만으로는 리소스에 접근할 수 없고, 별도의 해석 메커니즘이 필요합니다.

**관계:**

**포함 관계:**
URI는 최상위 개념입니다. URI는 URL과 URN을 포함합니다. 모든 URL은 URI이지만, 모든 URI가 URL은 아닙니다. 모든 URN은 URI이지만, 모든 URI가 URN은 아닙니다.

**벤 다이어그램:**
```
         URI
    ┌───────────┐
    │  ┌─URL─┐  │
    │  │     │  │
    │  └─────┘  │
    │  ┌─URN─┐  │
    │  │     │  │
    │  └─────┘  │
    └───────────┘
```

**실제 예시 비교:**

**URL이면서 URI:**
https://www.example.com/users/123 - 위치를 나타내므로 URL이고, 식별자이므로 URI입니다.

**URN이면서 URI:**
urn:isbn:0-486-27557-4 - 이름으로 식별하므로 URN이고, 식별자이므로 URI입니다.

**URI이지만 명확히 URL/URN이 아닌 경우:**
현대적으로는 거의 모든 URI가 URL 또는 URN으로 분류되지만, 이론적으로는 중간 영역도 존재합니다.

**실무에서의 사용:**

**용어 선택:**
대부분의 경우 "URL"이라고 부릅니다. 웹 개발에서는 URL이 압도적으로 많이 사용됩니다. 정확하게는 "URI"라고 해야 하지만 관습적으로 "URL"을 사용합니다.

**REST API:**
RESTful API의 엔드포인트는 정확히는 URI입니다. 하지만 "API URL"이라고 부르는 것이 일반적입니다.

**URN의 사용:**
실무에서 URN은 드물게 사용됩니다. ISBN, UUID, ISSN 등 표준 식별자 체계에서 주로 사용합니다. 도서관, 출판, 학술 분야에서 활용됩니다.

**URI 구문 상세:**

**일반 형식:**
scheme:[//authority]path[?query][#fragment]

**Authority 구성:**
[userinfo@]host[:port]

**실제 예시 분해:**
https://user:pass@www.example.com:8080/path/to/resource?key1=value1&key2=value2#section1
- Scheme: https
- Userinfo: user:pass
- Host: www.example.com
- Port: 8080
- Path: /path/to/resource
- Query: key1=value1&key2=value2
- Fragment: section1

**인코딩:**
URI에는 특수 문자가 포함될 수 있습니다. 퍼센트 인코딩(Percent Encoding)으로 변환합니다. 예: 공백 → %20, 한글 → UTF-8 인코딩 후 %로 표현합니다.

**절대 URI vs 상대 URI:**
- **절대 URI**: 완전한 정보 포함 (https://example.com/path)
- **상대 URI**: 기준 URI를 기반으로 해석 (/path, ../other)

**보안 고려사항:**
URI에 민감한 정보(비밀번호, 토큰)를 포함하면 로그에 남을 수 있습니다. 쿼리 파라미터는 리퍼러 헤더에 노출될 수 있습니다. POST 바디나 헤더를 사용하는 것이 안전합니다.

**SEO 관점:**
의미 있는 URI 구조는 검색 엔진 최적화에 유리합니다. /users/123보다 /users/john-doe가 더 친화적입니다.

**결론:**
일상적으로는 URL이라는 용어를 사용하지만, 엄밀하게는 URI가 정확한 표현인 경우가 많습니다. URN은 특수한 식별 체계에서 사용됩니다.

---

## 74. DNS에 대해 설명해 주세요.

**DNS(Domain Name System)**는 사람이 읽을 수 있는 도메인 이름을 컴퓨터가 사용하는 IP 주소로 변환하는 시스템입니다.

**필요성:**
IP 주소(예: 192.0.2.1)는 기억하기 어렵습니다. 도메인 이름(예: www.example.com)은 직관적이고 기억하기 쉽습니다. IP 주소는 변경될 수 있지만 도메인 이름은 유지할 수 있습니다. DNS는 이 두 가지를 연결하는 인터넷의 전화번호부 역할을 합니다.

**계층적 구조:**

**루트 도메인(Root Domain):**
최상위 계층으로 "."로 표현됩니다(일반적으로 생략). 전 세계에 13개의 루트 DNS 서버가 있습니다(논리적으로는 13개, 물리적으로는 수백 개가 분산). a.root-servers.net부터 m.root-servers.net까지 있습니다.

**최상위 도메인(TLD, Top-Level Domain):**
.com, .org, .net 같은 일반 TLD(gTLD)가 있습니다. .kr, .jp, .uk 같은 국가 코드 TLD(ccTLD)가 있습니다. .google, .samsung 같은 브랜드 TLD도 있습니다.

**2차 도메인(Second-Level Domain):**
example.com에서 "example" 부분입니다. 조직이나 개인이 등록하는 도메인입니다.

**서브도메인(Subdomain):**
www.example.com에서 "www" 부분입니다. 도메인 소유자가 자유롭게 생성할 수 있습니다.

**FQDN(Fully Qualified Domain Name):**
완전한 도메인 이름으로 www.example.com.(루트 포함)입니다.

**DNS 레코드 타입:**

**A 레코드:**
도메인을 IPv4 주소로 매핑합니다. 예: example.com → 192.0.2.1

**AAAA 레코드:**
도메인을 IPv6 주소로 매핑합니다. 예: example.com → 2001:db8::1

**CNAME 레코드:**
도메인을 다른 도메인으로 매핑(별칭)합니다. 예: www.example.com → example.com

**MX 레코드:**
메일 서버를 지정합니다. 우선순위 값을 포함합니다.

**TXT 레코드:**
임의의 텍스트 정보를 저장합니다. SPF, DKIM, 도메인 검증 등에 사용합니다.

**NS 레코드:**
도메인의 권한 있는 네임서버를 지정합니다.

**SOA 레코드:**
도메인 영역의 시작을 나타내며, 관리 정보를 포함합니다.

**PTR 레코드:**
역방향 DNS로 IP를 도메인으로 변환합니다.

**DNS 조회 과정:**

**1. 브라우저 캐시:**
최근에 방문한 사이트의 IP는 브라우저에 캐시됩니다.

**2. OS 캐시:**
운영체제의 DNS 캐시를 확인합니다.

**3. 리졸버(Resolver):**
ISP 또는 설정된 DNS 리졸버(8.8.8.8, 1.1.1.1)에 쿼리합니다.

**4. 재귀적 조회:**
리졸버가 루트 서버에 문의하여 TLD 서버 주소를 받습니다. TLD 서버에 문의하여 권한 있는 네임서버 주소를 받습니다. 권한 있는 네임서버에서 최종 IP 주소를 받습니다.

**5. 응답 반환:**
리졸버가 받은 IP를 클라이언트에 반환하고 캐시합니다.

**재귀 쿼리 vs 반복 쿼리:**

**재귀 쿼리(Recursive Query):**
클라이언트가 리졸버에 "최종 답을 찾아주세요"라고 요청합니다. 리졸버가 모든 과정을 처리하여 최종 IP를 반환합니다.

**반복 쿼리(Iterative Query):**
리졸버가 루트, TLD, 권한 서버에 차례로 질의합니다. 각 서버는 "다음 단계는 여기에 물어보세요"라고 응답합니다.

**DNS 캐싱:**

**TTL(Time To Live):**
DNS 레코드마다 유효 시간이 지정됩니다. TTL 동안은 캐시된 값을 사용합니다. 만료 후 다시 조회합니다.

**캐시 위치:**
브라우저, OS, 리졸버, ISP 서버 등 여러 단계에서 캐싱합니다. 이를 통해 DNS 조회 속도가 크게 향상됩니다.

**DNS 서버 종류:**

**권한 있는 네임서버(Authoritative Name Server):**
특정 도메인의 공식 DNS 레코드를 보유합니다. 도메인 소유자가 관리합니다.

**재귀 리졸버(Recursive Resolver):**
클라이언트를 대신하여 DNS 조회를 수행합니다. ISP 또는 공개 DNS 서비스(Google, Cloudflare)가 운영합니다.

**공개 DNS 서비스:**
- **Google Public DNS**: 8.8.8.8, 8.8.4.4
- **Cloudflare DNS**: 1.1.1.1, 1.0.0.1
- **Quad9**: 9.9.9.9

**DNS 보안:**

**DNS 스푸핑/캐시 포이즈닝:**
공격자가 거짓 DNS 응답을 주입하여 사용자를 악의적인 사이트로 리다이렉트합니다.

**DNSSEC:**
DNS 응답에 디지털 서명을 추가하여 무결성을 검증합니다. 위변조를 방지하지만 아직 완전히 보편화되지 않았습니다.

**DNS over HTTPS(DoH):**
DNS 쿼리를 HTTPS로 암호화하여 프라이버시를 보호합니다.

**DNS over TLS(DoT):**
TLS로 DNS 통신을 암호화합니다.

**성능 최적화:**
DNS 프리페칭으로 미리 조회를 수행합니다. 낮은 TTL로 빠른 전환을, 높은 TTL로 안정성을 추구합니다. GeoDNS로 지역별 최적 서버를 제공합니다.

---

## 75. DNS는 몇 계층 프로토콜인가요?

DNS는 **애플리케이션 계층(7계층) 프로토콜**입니다.

**OSI 모델에서의 위치:**
DNS는 최상위 계층인 애플리케이션 계층에서 동작합니다. 사용자나 애플리케이션에게 도메인 이름 해석 서비스를 제공합니다. HTTP, FTP, SMTP 등과 같은 계층에 위치합니다.

**이유:**
DNS는 특정 애플리케이션 기능(이름 해석)을 제공합니다. 하위 계층(전송, 네트워크)의 서비스를 이용하는 상위 프로토콜입니다. 네트워크 인프라가 아닌 애플리케이션 지원 서비스입니다.

**전송 계층 프로토콜:**
DNS는 주로 **UDP 포트 53번**을 사용합니다. 작은 쿼리/응답은 UDP로 빠르게 처리합니다. 응답이 512 바이트를 초과하면 TCP를 사용합니다. DNSSEC 등으로 응답이 커지면서 TCP 사용이 증가하고 있습니다. 존 전송(Zone Transfer)은 항상 TCP를 사용합니다.

**왜 UDP를 주로 사용하나:**

**낮은 오버헤드:**
DNS 쿼리는 단순한 요청-응답 구조입니다. TCP의 3-way handshake는 불필요한 오버헤드입니다. UDP로 빠르게 처리하는 것이 효율적입니다.

**상태 비저장:**
각 쿼리가 독립적이므로 연결 상태를 유지할 필요가 없습니다. UDP의 비연결 특성이 적합합니다.

**재전송 메커니즘:**
DNS 클라이언트가 애플리케이션 레벨에서 재전송을 구현합니다. 응답이 없으면 다른 DNS 서버로 재시도합니다. TCP의 신뢰성 보장이 필수적이지 않습니다.

**성능:**
DNS는 인터넷 사용의 첫 단계이므로 속도가 중요합니다. UDP의 낮은 지연 시간이 사용자 경험을 개선합니다.

**TCP를 사용하는 경우:**

**응답 크기 초과:**
전통적으로 UDP DNS 응답은 512 바이트 제한이 있었습니다. EDNS0으로 확장되었지만 여전히 크기 제한이 있습니다. 초과 시 TC(Truncated) 플래그를 설정하고 클라이언트가 TCP로 재시도합니다.

**존 전송(Zone Transfer):**
권한 서버 간 DNS 레코드를 동기화할 때 사용합니다. 대량의 데이터를 전송하므로 TCP의 신뢰성이 필요합니다. AXFR(전체 전송), IXFR(증분 전송) 모두 TCP를 사용합니다.

**보안 프로토콜:**
DNS over TLS(DoT, 포트 853)는 TCP 기반입니다. DNS over HTTPS(DoH, 포트 443)도 TCP 기반입니다.

**포트 번호:**
표준 DNS 쿼리: UDP/TCP 53번. DNS over TLS: TCP 853번. DNS over HTTPS: TCP 443번.

**다른 계층 프로토콜과의 협력:**

**애플리케이션 계층:**
DNS는 다른 애플리케이션(웹 브라우저, 이메일 클라이언트)에게 서비스를 제공합니다.

**전송 계층:**
UDP 또는 TCP를 사용하여 데이터를 전송합니다.

**네트워크 계층:**
IP 프로토콜로 DNS 패킷을 라우팅합니다. DNS 서버의 IP 주소는 미리 설정되어 있어야 합니다(부트스트랩 문제).

**부트스트랩 문제:**
DNS를 사용하려면 DNS 서버의 IP 주소를 알아야 합니다. 이 IP는 DHCP로 자동 설정되거나 수동으로 입력됩니다. 루트 DNS 서버의 IP는 모든 리졸버에 하드코딩되어 있습니다.

**DNS 메시지 구조:**

**헤더:**
쿼리 ID, 플래그(쿼리/응답, 재귀, 권한 등), 섹션 카운트를 포함합니다.

**질문 섹션:**
조회할 도메인 이름과 레코드 타입을 명시합니다.

**응답 섹션:**
요청한 레코드의 답변을 포함합니다.

**권한 섹션:**
권한 있는 네임서버 정보를 제공합니다.

**추가 정보 섹션:**
관련된 추가 레코드를 포함합니다.

**실무적 의미:**
DNS를 애플리케이션 계층으로 이해하면 네트워크 문제 진단 시 적절한 레벨에서 접근할 수 있습니다. DNS 문제는 애플리케이션/서비스 설정을 확인해야 합니다.

---

## 76. UDP와 TCP 중 어떤 것을 사용하나요?

DNS는 **주로 UDP를 사용하지만, 상황에 따라 TCP도 사용**합니다.

**기본 선택 - UDP:**

**일반 쿼리:**
대부분의 DNS 쿼리/응답은 UDP를 사용합니다. 클라이언트가 UDP 53번 포트로 쿼리를 보냅니다. 서버가 UDP로 응답을 반환합니다. 전체 DNS 트래픽의 약 95% 이상이 UDP입니다.

**UDP를 선택한 이유:**

**빠른 응답 시간:**
TCP는 3-way handshake에 1.5 RTT가 필요합니다. UDP는 즉시 데이터를 전송하여 0.5 RTT만 필요합니다. DNS는 웹 브라우징의 첫 단계이므로 지연이 치명적입니다.

**낮은 서버 부하:**
DNS 서버는 초당 수만~수십만 건의 쿼리를 처리합니다. TCP 연결 관리는 엄청난 오버헤드를 발생시킵니다. UDP의 상태 비저장 특성으로 서버 부하를 최소화합니다.

**단순한 요청-응답:**
대부분의 DNS 쿼리는 하나의 요청과 하나의 응답으로 완료됩니다. 복잡한 세션 관리가 필요 없습니다.

**자체 재전송 메커니즘:**
DNS 클라이언트는 타임아웃 시 재전송을 직접 구현합니다. 다른 DNS 서버로 폴오버할 수 있습니다. TCP의 재전송 메커니즘이 불필요합니다.

**TCP를 사용하는 경우:**

**1. 응답 크기 초과:**

**512 바이트 제한:**
전통적으로 UDP DNS 응답은 512 바이트로 제한되었습니다. 이더넷 MTU와 IPv4 단편화를 고려한 안전한 크기입니다.

**TC(Truncated) 플래그:**
응답이 512 바이트를 초과하면 서버는 잘린 응답을 보내고 TC 플래그를 설정합니다. 클라이언트는 이를 감지하고 TCP로 재시도합니다.

**EDNS0 확장:**
Extension Mechanisms for DNS로 UDP 페이로드 크기를 확장합니다. 일반적으로 4096 바이트까지 지원합니다. 하지만 네트워크에서 단편화 문제가 발생할 수 있습니다.

**2. 존 전송(Zone Transfer):**

**AXFR(Full Zone Transfer):**
전체 DNS 존 데이터를 전송합니다. 수백 MB에 달할 수 있어 TCP가 필수입니다. 마스터-슬레이브 서버 간 동기화에 사용합니다.

**IXFR(Incremental Zone Transfer):**
변경된 레코드만 전송합니다. 여전히 TCP를 사용하여 신뢰성을 보장합니다.

**3. DNS over TLS (DoT):**
포트 853번에서 TLS로 암호화된 DNS 통신을 제공합니다. TCP 기반으로 동작합니다. 프라이버시 보호가 목적입니다.

**4. DNS over HTTPS (DoH):**
포트 443번에서 HTTPS로 DNS 쿼리를 전송합니다. 일반 웹 트래픽으로 위장되어 검열 우회에 유리합니다. TCP 기반입니다.

**5. 대용량 DNSSEC 응답:**
DNSSEC은 암호화 서명을 추가하여 응답 크기를 크게 증가시킵니다. 512 바이트를 초과하는 경우가 많아 TCP 사용이 증가합니다.

**실제 동작 흐름:**

**일반적인 경우:**
1. 클라이언트가 UDP로 쿼리를 보냅니다
2. 서버가 UDP로 응답합니다
3. 완료

**응답이 큰 경우:**
1. 클라이언트가 UDP로 쿼리를 보냅니다
2. 서버가 잘린 UDP 응답을 보냅니다 (TC=1)
3. 클라이언트가 TCP로 재시도합니다
4. 서버가 TCP로 완전한 응답을 보냅니다

**최신 트렌드:**

**TCP 사용 증가:**
DNSSEC, IPv6, CDN 등으로 응답 크기가 커지고 있습니다. TCP 사용 비율이 점점 증가하는 추세입니다. 일부 환경에서는 TCP를 기본으로 사용하기도 합니다.

**Fast Open:**
TCP Fast Open으로 TCP의 지연을 줄일 수 있습니다. TLS 1.3의 0-RTT로 DoT 성능을 개선합니다.

**QUIC 기반 DNS:**
DNS over QUIC(DoQ)가 제안되었습니다. UDP 기반이지만 TCP의 신뢰성을 제공합니다.

**듀얼 스택 지원:**
현대 DNS 서버는 UDP와 TCP를 모두 지원합니다. 클라이언트가 필요에 따라 선택할 수 있습니다.

**방화벽 고려사항:**
DNS는 UDP 53번과 TCP 53번을 모두 허용해야 합니다. TCP를 차단하면 큰 응답을 받을 수 없습니다. DoT(853), DoH(443)도 고려해야 합니다.

**성능 비교:**
UDP DNS: 평균 20-50ms. TCP DNS: 평균 50-150ms (핸드셰이크 포함). DoH: 평균 100-200ms (HTTPS 오버헤드).

**결론:**
DNS는 기본적으로 빠른 UDP를 사용하지만, 신뢰성과 보안이 필요한 경우 TCP를 사용합니다. 두 프로토콜이 상호보완적으로 동작합니다.
