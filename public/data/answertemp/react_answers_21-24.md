# React 답변 21-24

## 질문 21: 불변성(Immutability)을 유지해야 하는 이유는 무엇인가요?

**정의:**
불변성은 기존 값을 직접 수정하지 않고 새로운 값을 생성하는 원칙입니다. React에서는 상태 객체를 직접 변경하지 않고 새로운 객체를 만들어 교체하는 방식으로 불변성을 유지합니다.

**불변성이 중요한 이유:**
- React가 변경을 감지합니다. 참조 비교로 빠르게 확인합니다.
- 이전 상태와 새 상태를 비교할 때 Object.is로 참조만 비교합니다.
- 직접 수정하면 참조가 같아서 변경을 감지하지 못합니다.
- 리렌더링이 일어나지 않거나 예측 불가능하게 동작합니다.
- Virtual DOM 비교 알고리즘이 효율적으로 작동합니다.

**변경 감지 메커니즘:**
- React는 얕은 비교를 합니다. 깊은 비교는 비용이 큽니다.
- 참조가 다르면 변경되었다고 판단합니다.
- 참조가 같으면 내용이 바뀌어도 모릅니다.
- 불변성을 지키면 참조만 비교해도 충분합니다.
- 성능과 정확성을 동시에 얻습니다.

**불변성을 지키는 방법:**
- 스프레드 연산자로 새 객체를 만듭니다.
- 배열 메서드는 map filter concat을 사용합니다. push pop splice는 피합니다.
- Object.assign으로 객체를 복사합니다.
- 구조 분해 할당을 활용합니다.
- Immer 같은 라이브러리를 사용합니다.

**객체 업데이트:**
- 중첩된 객체는 각 레벨을 새로 만들어야 합니다.
- 스프레드 연산자를 여러 번 사용합니다.
- 깊은 중첩은 복잡해집니다.
- Immer를 사용하면 직접 수정하는 것처럼 쓸 수 있습니다.
- 내부적으로 불변 업데이트를 처리합니다.

**배열 업데이트:**
- 추가는 concat이나 스프레드를 사용합니다.
- 삭제는 filter를 사용합니다.
- 수정은 map을 사용합니다.
- 정렬은 slice 후 sort 하거나 스프레드 후 sort 합니다.
- 원본 배열을 건드리지 않습니다.

**성능과 최적화:**
- 불변성을 지키면 메모이제이션이 효과적입니다.
- React.memo가 Props 비교를 정확히 할 수 있습니다.
- useMemo와 useCallback의 의존성 체크가 정확합니다.
- PureComponent가 제대로 동작합니다.
- 불필요한 리렌더링을 방지합니다.

**디버깅과 시간 여행:**
- 이전 상태가 보존됩니다. 상태 히스토리를 추적할 수 있습니다.
- 디버깅이 쉬워집니다. 어느 시점의 상태든 확인 가능합니다.
- 실행 취소와 다시 실행을 구현할 수 있습니다.
- Redux DevTools 같은 도구가 가능해집니다.
- 시간 여행 디버깅을 지원합니다.

**실무 활용:**
- 모든 상태 업데이트에서 불변성을 지킵니다.
- ESLint 규칙으로 직접 수정을 방지합니다.
- Immer를 사용하여 코드를 간결하게 만듭니다.
- TypeScript의 readonly 타입을 활용합니다.
- 팀 전체가 불변성의 중요성을 이해해야 합니다.

---

## 질문 22: 클래스 컴포넌트의 라이프사이클 메서드에 대해 설명해주세요.

**정의:**
라이프사이클 메서드는 클래스 컴포넌트에서 컴포넌트의 생성부터 소멸까지 특정 시점에 실행되는 메서드들입니다. 마운트 업데이트 언마운트의 세 단계로 나뉩니다.

**마운트 단계:**
- constructor: 컴포넌트가 생성될 때 호출됩니다. state 초기화와 메서드 바인딩을 합니다.
- static getDerivedStateFromProps: Props로부터 State를 동기화합니다. 거의 사용하지 않습니다.
- render: JSX를 반환합니다. 순수해야 하며 부작용이 없어야 합니다.
- componentDidMount: 컴포넌트가 DOM에 추가된 직후 호출됩니다. API 호출이나 구독 설정을 합니다.

**업데이트 단계:**
- static getDerivedStateFromProps: Props 변경 시에도 호출됩니다.
- shouldComponentUpdate: 리렌더링 여부를 결정합니다. 성능 최적화에 사용합니다.
- render: 새로운 JSX를 반환합니다.
- getSnapshotBeforeUpdate: DOM 업데이트 직전 정보를 캡처합니다. 스크롤 위치 등을 저장합니다.
- componentDidUpdate: 업데이트 후 호출됩니다. 이전 Props나 State와 비교할 수 있습니다.

**언마운트 단계:**
- componentWillUnmount: 컴포넌트가 제거되기 직전 호출됩니다. 정리 작업을 합니다.
- 타이머 제거 구독 해제 등을 수행합니다.
- 메모리 누수를 방지합니다.

**에러 처리:**
- static getDerivedStateFromError: 에러 발생 시 State를 업데이트합니다.
- componentDidCatch: 에러 정보를 로깅합니다.
- Error Boundary를 구현할 때 사용합니다.
- 자식 컴포넌트의 에러를 잡습니다.

**레거시 메서드:**
- componentWillMount: 더 이상 사용하지 않습니다. constructor를 사용합니다.
- componentWillReceiveProps: getDerivedStateFromProps로 대체되었습니다.
- componentWillUpdate: getSnapshotBeforeUpdate로 대체되었습니다.
- 비동기 렌더링에서 문제가 있어 deprecated 되었습니다.

**일반적인 사용 패턴:**
- componentDidMount에서 데이터를 가져옵니다.
- componentDidUpdate에서 Props 변경에 반응합니다.
- componentWillUnmount에서 리소스를 정리합니다.
- shouldComponentUpdate로 성능을 최적화합니다.
- render는 순수하게 유지합니다.

**함수형 컴포넌트와 비교:**
- 클래스는 라이프사이클 메서드를 사용합니다.
- 함수형은 useEffect Hook을 사용합니다.
- useEffect가 여러 라이프사이클을 대체합니다.
- 함수형이 더 간결하고 직관적입니다.
- 새 코드는 함수형을 권장합니다.

**실무 활용:**
- 레거시 코드를 유지보수할 때 필요합니다.
- Error Boundary는 아직 클래스로만 구현 가능합니다.
- 점진적으로 함수형으로 마이그레이션합니다.
- 라이프사이클을 이해하면 useEffect를 더 잘 사용할 수 있습니다.
- 각 메서드의 실행 시점과 목적을 명확히 파악합니다.

---

## 질문 23: 함수형 컴포넌트에서 라이프사이클을 어떻게 구현하나요?

**정의:**
함수형 컴포넌트는 useEffect Hook을 사용하여 클래스 컴포넌트의 라이프사이클 메서드를 대체합니다. 하나의 Hook으로 마운트 업데이트 언마운트를 모두 처리할 수 있습니다.

**useEffect의 역할:**
- 부작용을 처리하는 Hook입니다.
- 여러 라이프사이클 메서드를 통합합니다.
- 의존성 배열로 실행 시점을 제어합니다.
- 클린업 함수로 정리 작업을 합니다.
- 여러 개를 사용하여 관심사를 분리할 수 있습니다.

**componentDidMount 구현:**
- 의존성 배열을 빈 배열로 설정합니다.
- 컴포넌트가 마운트될 때 한 번만 실행됩니다.
- API 호출이나 구독 설정에 사용합니다.
- 초기 데이터 로딩을 수행합니다.

**componentDidUpdate 구현:**
- 의존성 배열에 감시할 값을 넣습니다.
- 해당 값이 변경될 때마다 실행됩니다.
- 여러 의존성을 추가할 수 있습니다.
- Props나 State 변경에 반응합니다.

**componentWillUnmount 구현:**
- useEffect에서 클린업 함수를 반환합니다.
- 컴포넌트가 언마운트될 때 실행됩니다.
- 타이머 제거 구독 해제 등을 합니다.
- 메모리 누수를 방지합니다.

**라이프사이클 조합:**
- 빈 배열 의존성은 마운트와 언마운트만 처리합니다.
- 특정 값 의존성은 업데이트도 처리합니다.
- 여러 useEffect로 로직을 분리합니다.
- 관련된 코드를 한곳에 모을 수 있습니다.
- 클래스보다 유연하고 강력합니다.

**여러 useEffect 사용:**
- 관심사별로 effect를 분리합니다.
- 데이터 페칭 이벤트 구독 타이머를 각각 다른 effect로 만듭니다.
- 클래스에서는 한 메서드에 여러 로직이 섞였습니다.
- 함수형에서는 깔끔하게 분리됩니다.
- 코드 가독성과 유지보수성이 향상됩니다.

**useLayoutEffect:**
- useEffect와 비슷하지만 동기적으로 실행됩니다.
- DOM 변경 직후 브라우저 페인트 전에 실행됩니다.
- componentDidMount와 componentDidUpdate처럼 동작합니다.
- DOM 측정이나 동기 레이아웃 업데이트에 사용합니다.
- 대부분의 경우 useEffect로 충분합니다.

**실무 활용:**
- API 호출은 빈 배열 의존성으로 마운트 시에만 합니다.
- 검색어 변경에 따른 필터링은 해당 값을 의존성에 넣습니다.
- WebSocket 연결은 마운트 시 생성하고 언마운트 시 정리합니다.
- 여러 독립적인 부작용은 각각 별도 useEffect로 만듭니다.
- 의존성 배열을 정확히 작성하여 버그를 방지합니다.

---

## 질문 24: useEffect의 의존성 배열을 빈 배열로 설정하면 어떻게 되나요?

**정의:**
useEffect의 의존성 배열을 빈 배열로 설정하면 effect가 컴포넌트 마운트 시에만 실행되고, 클린업 함수는 언마운트 시에만 실행됩니다. 클래스 컴포넌트의 componentDidMount와 componentWillUnmount와 유사합니다.

**실행 타이밍:**
- 컴포넌트가 처음 렌더링된 직후 한 번 실행됩니다.
- 이후 리렌더링되어도 다시 실행되지 않습니다.
- Props나 State가 변경되어도 무시합니다.
- 클린업 함수는 컴포넌트가 DOM에서 제거될 때만 실행됩니다.

**일반적인 사용 사례:**
- 초기 데이터 로딩: API를 호출하여 초기 데이터를 가져옵니다.
- 이벤트 리스너 등록: window나 document 이벤트를 설정합니다.
- 타이머 설정: setInterval로 주기적 작업을 시작합니다.
- 외부 라이브러리 초기화: 차트나 맵 라이브러리를 초기화합니다.
- 구독 설정: WebSocket이나 실시간 데이터를 구독합니다.

**클린업 함수 역할:**
- 컴포넌트 언마운트 시 정리 작업을 수행합니다.
- 이벤트 리스너를 제거합니다.
- 타이머를 정리합니다.
- 구독을 해제합니다.
- 메모리 누수를 방지합니다.

**주의사항:**
- effect 내부에서 사용하는 값이 변경되어도 effect는 재실행되지 않습니다.
- 오래된 클로저 값을 참조할 수 있습니다.
- 의도적으로 한 번만 실행하려는 경우에만 사용합니다.
- ESLint exhaustive-deps 규칙이 경고를 표시합니다.
- 정말 한 번만 실행해야 하는지 확인합니다.

**클로저 문제:**
- effect가 생성된 시점의 값을 캡처합니다.
- 이후 Props나 State가 바뀌어도 effect는 초기 값을 참조합니다.
- 최신 값이 필요하면 의존성 배열에 추가해야 합니다.
- useRef로 최신 값을 참조할 수도 있습니다.

**대안과 해결책:**
- 최신 값이 필요하면 의존성에 포함합니다.
- 함수는 useCallback으로 메모이제이션합니다.
- 정말 한 번만 실행이 필요한지 재고합니다.
- 데이터 페칭은 React Query 같은 라이브러리를 고려합니다.

**빈 배열 vs 배열 생략:**
- 빈 배열은 마운트 시에만 실행됩니다.
- 배열을 생략하면 매 렌더링마다 실행됩니다.
- 배열 생략은 거의 사용하지 않습니다.
- 명시적으로 빈 배열을 사용하는 것이 좋습니다.

**실무 활용:**
- 페이지 로드 시 사용자 데이터를 한 번만 가져옵니다.
- 전역 이벤트 리스너를 설정하고 정리합니다.
- 애널리틱스 페이지 뷰를 한 번만 기록합니다.
- 외부 스크립트를 로드합니다.
- 의도를 명확히 하기 위해 주석을 추가합니다.

---
