# React 답변 45-48

## 질문 45: 프로그래매틱 네비게이션(Programmatic Navigation)은 어떻게 구현하나요?

**정의:**
프로그래매틱 네비게이션은 Link 컴포넌트가 아닌 JavaScript 코드로 페이지를 이동하는 방식입니다. React Router의 useNavigate Hook을 사용하여 구현합니다.

**useNavigate Hook:**
- 탐색 함수를 반환합니다.
- 함수를 호출하여 다른 경로로 이동합니다.
- v6에서 useHistory를 대체했습니다.
- 더 간단하고 직관적인 API를 제공합니다.

**기본 사용법:**
- useNavigate를 호출하여 함수를 받습니다.
- 경로를 인자로 전달하여 이동합니다.
- 상대 경로나 절대 경로를 사용할 수 있습니다.
- 이벤트 핸들러나 useEffect에서 호출합니다.

**언제 사용할까:**
- 폼 제출 후 다른 페이지로 이동할 때입니다.
- 로그인 성공 후 대시보드로 리다이렉트합니다.
- 조건부로 페이지를 이동해야 할 때입니다.
- 타이머 후 자동으로 이동할 때입니다.
- API 응답에 따라 다른 페이지로 이동합니다.

**뒤로 가기와 앞으로 가기:**
- 음수를 전달하면 뒤로 갑니다. navigate(-1)은 한 페이지 뒤로입니다.
- 양수를 전달하면 앞으로 갑니다.
- 브라우저의 뒤로 가기 버튼과 동일하게 동작합니다.
- 히스토리 스택을 활용합니다.

**replace 옵션:**
- 두 번째 인자로 옵션 객체를 전달합니다.
- replace: true로 설정하면 히스토리를 대체합니다.
- 새 엔트리를 추가하지 않고 현재를 교체합니다.
- 뒤로 가기로 돌아갈 수 없게 됩니다.
- 로그인 후 리다이렉트에 유용합니다.

**state 전달:**
- 두 번째 인자의 state로 데이터를 전달할 수 있습니다.
- useLocation으로 전달받은 state에 접근합니다.
- URL에 노출되지 않는 데이터를 전달합니다.
- 이전 페이지 정보나 메시지를 전달합니다.

**조건부 탐색:**
- if 문으로 조건을 확인합니다.
- API 응답 성공 여부에 따라 이동합니다.
- 인증 상태를 확인하고 리다이렉트합니다.
- 유효성 검사 통과 시에만 이동합니다.

**Navigate 컴포넌트:**
- 선언적으로 리다이렉트할 수 있습니다.
- 렌더링 중에 사용합니다.
- to prop에 목적지를 지정합니다.
- replace prop으로 히스토리 대체 여부를 결정합니다.
- 조건부 렌더링과 함께 사용합니다.

**실무 활용:**
- 로그인 성공 후 메인 페이지로 이동합니다.
- 폼 제출 후 목록 페이지로 이동합니다.
- 결제 완료 후 완료 페이지로 이동합니다.
- 권한 없는 사용자를 로그인 페이지로 리다이렉트합니다.
- 404 에러 발생 시 에러 페이지로 이동합니다.

---

## 질문 46: Redux의 동작 원리와 주요 개념은 무엇인가요?

**정의:**
Redux는 JavaScript 애플리케이션의 상태를 관리하는 예측 가능한 상태 컨테이너입니다. Flux 아키텍처를 기반으로 하며, 단일 스토어와 단방향 데이터 흐름을 사용합니다.

**Redux의 세 가지 원칙:**
- 단일 진실 공급원: 모든 상태를 하나의 스토어에 저장합니다.
- 상태는 읽기 전용: 액션을 디스패치해야만 변경할 수 있습니다.
- 순수 함수로 변경: 리듀서는 이전 상태와 액션을 받아 새 상태를 반환합니다.

**주요 개념:**
- Store: 상태를 보관하는 객체입니다. 앱 전체에 하나만 존재합니다.
- Action: 무슨 일이 일어났는지 설명하는 객체입니다. type 필드를 반드시 가집니다.
- Reducer: 액션과 이전 상태를 받아 새 상태를 반환하는 순수 함수입니다.
- Dispatch: 액션을 스토어에 전달하는 함수입니다.

**데이터 흐름:**
- 사용자 인터랙션이나 이벤트가 발생합니다.
- 액션을 디스패치합니다.
- 리듀서가 액션을 받아 새 상태를 계산합니다.
- 스토어가 상태를 업데이트합니다.
- 구독 중인 컴포넌트가 리렌더링됩니다.

**Reducer 작성:**
- switch 문으로 액션 타입을 분기합니다.
- 새 상태 객체를 반환합니다. 불변성을 유지합니다.
- 이전 상태를 직접 수정하면 안 됩니다.
- default 케이스에서 이전 상태를 반환합니다.
- 순수 함수여야 합니다. 부작용이 없어야 합니다.

**Action Creator:**
- 액션을 생성하는 함수입니다.
- 액션 객체를 반환합니다.
- 일관성과 재사용성을 높입니다.
- 타입 실수를 줄입니다.

**Store 생성과 사용:**
- createStore로 스토어를 만듭니다. 리듀서를 전달합니다.
- Provider로 React 앱을 감쌉니다.
- useSelector로 상태를 읽습니다.
- useDispatch로 액션을 디스패치합니다.

**미들웨어:**
- Redux의 확장 포인트입니다.
- 액션과 리듀서 사이에 위치합니다.
- 로깅 비동기 처리 등을 수행합니다.
- Redux Thunk와 Redux Saga가 유명합니다.

**Redux의 장점:**
- 예측 가능한 상태 관리입니다.
- 디버깅이 쉽습니다. DevTools로 시간 여행이 가능합니다.
- 테스트하기 쉽습니다. 순수 함수로 구성됩니다.
- 미들웨어로 확장 가능합니다.
- 커뮤니티와 생태계가 방대합니다.

**Redux의 단점:**
- 보일러플레이트가 많습니다.
- 작은 앱에는 과도할 수 있습니다.
- 러닝 커브가 있습니다.
- 간단한 상태는 Context로 충분합니다.

**실무 활용:**
- 대규모 애플리케이션의 상태를 관리합니다.
- 복잡한 상태 로직을 체계적으로 관리합니다.
- Redux Toolkit을 사용하여 보일러플레이트를 줄입니다.
- 미들웨어로 비동기 로직을 처리합니다.
- DevTools로 상태 변화를 추적하고 디버깅합니다.

---

## 질문 47: Redux Toolkit은 무엇이고 왜 사용하나요?

**정의:**
Redux Toolkit은 Redux 공식 권장 도구 세트로, Redux를 더 쉽고 효율적으로 사용하기 위한 라이브러리입니다. 보일러플레이트를 줄이고 모범 사례를 내장하여 개발 경험을 향상시킵니다.

**Redux Toolkit이 해결하는 문제:**
- Redux 설정이 너무 복잡합니다.
- 보일러플레이트 코드가 많습니다.
- 불변성 관리가 번거롭습니다.
- 미들웨어 설정이 어렵습니다.
- 액션과 리듀서를 따로 관리해야 합니다.

**주요 API:**
- configureStore: 스토어를 간편하게 설정합니다. 미들웨어와 DevTools가 자동으로 포함됩니다.
- createSlice: 리듀서와 액션을 한번에 생성합니다. 가장 강력한 기능입니다.
- createAsyncThunk: 비동기 액션을 쉽게 만듭니다.
- createEntityAdapter: 정규화된 상태를 관리합니다.

**createSlice의 장점:**
- 리듀서와 액션 생성자를 함께 정의합니다.
- Immer가 내장되어 불변성을 자동으로 처리합니다.
- 액션 타입을 자동 생성합니다.
- 보일러플레이트가 크게 줄어듭니다.
- 코드가 간결하고 읽기 쉽습니다.

**Immer 통합:**
- 상태를 직접 수정하는 것처럼 쓸 수 있습니다.
- 내부적으로 불변 업데이트로 변환됩니다.
- 중첩된 객체 업데이트가 쉬워집니다.
- 실수로 mutate 해도 안전합니다.

**configureStore 기능:**
- 미들웨어를 자동으로 추가합니다. Redux Thunk가 기본 포함됩니다.
- Redux DevTools가 자동 활성화됩니다.
- 일반적인 실수를 경고합니다.
- 개발 환경에서 유용한 체크를 수행합니다.

**createAsyncThunk:**
- 비동기 로직을 간단하게 작성합니다.
- pending fulfilled rejected 액션을 자동 생성합니다.
- 로딩 상태를 쉽게 관리할 수 있습니다.
- 에러 처리가 일관성 있게 됩니다.

**RTK Query:**
- 데이터 페칭과 캐싱을 자동화합니다.
- API 엔드포인트를 선언적으로 정의합니다.
- 로딩 상태와 에러를 자동 관리합니다.
- 캐시 무효화와 재검증을 지원합니다.
- React Query와 유사한 기능을 제공합니다.

**TypeScript 지원:**
- 타입 추론이 우수합니다.
- 최소한의 타입 정의로 충분합니다.
- 자동 완성이 잘 됩니다.
- 타입 안전성이 보장됩니다.

**기존 Redux와의 비교:**
- 코드량이 절반 이하로 줄어듭니다.
- 불변성 관리가 자동화됩니다.
- 설정이 훨씬 간단합니다.
- 모범 사례가 기본으로 적용됩니다.
- 러닝 커브가 낮아집니다.

**실무 활용:**
- 새 Redux 프로젝트는 Redux Toolkit을 사용합니다.
- 기존 Redux를 점진적으로 마이그레이션합니다.
- RTK Query로 API 호출을 관리합니다.
- createSlice로 간결한 상태 관리를 합니다.
- TypeScript와 함께 사용하여 타입 안전성을 얻습니다.

---

## 질문 48: Zustand, Recoil, Redux의 차이점과 선택 기준은 무엇인가요?

**정의:**
Zustand, Recoil, Redux는 모두 React 상태 관리 라이브러리이지만, 각각 다른 철학과 접근 방식을 가지고 있습니다. 프로젝트 요구사항에 맞는 도구를 선택하는 것이 중요합니다.

**Redux 특징:**
- 가장 오래되고 널리 사용됩니다.
- 단일 스토어에 모든 상태를 저장합니다.
- 액션과 리듀서 패턴을 사용합니다.
- 미들웨어로 확장 가능합니다.
- 강력한 DevTools를 제공합니다.
- Redux Toolkit으로 개선되었습니다.

**Zustand 특징:**
- 매우 작고 간단합니다. 번들 크기가 작습니다.
- Hooks 기반 API입니다.
- Provider가 필요 없습니다.
- 보일러플레이트가 거의 없습니다.
- 선택적 구독이 가능합니다.
- 미들웨어를 지원합니다.

**Recoil 특징:**
- Facebook에서 만들었습니다.
- Atom과 Selector 개념을 사용합니다.
- React처럼 사용할 수 있습니다.
- 분산된 상태 관리가 가능합니다.
- 파생 상태를 쉽게 만듭니다.
- 아직 실험적 단계입니다.

**Redux 장점과 단점:**
- 장점: 강력한 에코시스템, 예측 가능성, DevTools, 대규모 앱에 적합합니다.
- 단점: 보일러플레이트가 많음, 러닝 커브, 작은 앱에 과도합니다.
- 사용 시기: 복잡한 상태 로직, 팀이 익숙함, 디버깅이 중요함, 미들웨어 필요합니다.

**Zustand 장점과 단점:**
- 장점: 간단함, 작은 번들, 빠른 학습, Provider 불필요, 유연합니다.
- 단점: 생태계가 작음, 고급 기능 부족, DevTools가 약합니다.
- 사용 시기: 중소 규모 앱, 간단한 전역 상태, 빠른 프로토타이핑, Redux가 과도합니다.

**Recoil 장점과 단점:**
- 장점: React스러움, 파생 상태 쉬움, 분산 상태, 비동기 지원 좋습니다.
- 단점: 아직 불안정, 생태계 작음, 프로덕션 사용 주의, 문서 부족입니다.
- 사용 시기: Facebook 생태계, 복잡한 파생 상태, 실험적 프로젝트입니다.

**선택 기준:**
- 앱 규모: 작으면 Zustand, 크면 Redux입니다.
- 복잡도: 간단하면 Zustand, 복잡하면 Redux입니다.
- 팀 경험: 팀이 아는 것을 선택합니다.
- 디버깅 중요도: Redux가 가장 강력합니다.
- 번들 크기: Zustand가 가장 작습니다.

**성능 비교:**
- 모두 선택적 구독을 지원합니다.
- Zustand가 가장 가볍고 빠릅니다.
- Redux는 최적화가 잘 되어 있습니다.
- Recoil은 세밀한 구독이 가능합니다.
- 실제 차이는 크지 않습니다.

**마이그레이션:**
- Redux에서 Zustand로는 쉽게 이동 가능합니다.
- Context에서 어느 것으로든 이동할 수 있습니다.
- 점진적 도입이 가능합니다.
- 한 프로젝트에 여러 개를 함께 사용할 수도 있습니다.

**실무 활용:**
- 대규모 엔터프라이즈 앱은 Redux를 선택합니다.
- 중소 규모 프로젝트는 Zustand를 고려합니다.
- Context로 시작하고 필요할 때 도입합니다.
- 팀의 선호도와 프로젝트 특성을 고려합니다.
- 과도한 도구를 사용하지 않습니다.

---
