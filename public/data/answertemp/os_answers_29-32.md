# OS 답변 29-32

## 29. 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?

**스택 크기 결정**

**초기 크기 결정 시점**
- 프로세스 생성 시 운영체제가 기본 스택 크기를 할당합니다
- 시스템 기본값이 사용됩니다(리눅스에서 보통 8MB)
- 스레드 생성 시에도 각 스레드에 스택이 할당됩니다

**실행 중 동적 성장**
- 스택은 필요에 따라 자동으로 성장합니다
- 스택 포인터가 할당된 영역을 벗어나면 페이지 폴트 발생
- 운영체제가 새로운 페이지를 할당하여 확장
- 최대 크기 제한까지만 성장 가능

**최대 크기 제한**
- 시스템 또는 사용자가 설정한 제한값까지만 성장
- 제한을 초과하면 스택 오버플로우 발생
- 세그먼테이션 폴트로 프로그램 종료

**힙 크기 결정**

**초기 상태**
- 프로그램 시작 시 힙은 매우 작거나 존재하지 않습니다
- 첫 동적 할당 시 힙 영역이 생성됩니다

**실행 중 동적 성장**
- malloc(), new 등으로 메모리 할당 시 성장
- 작은 할당: 기존 힙 공간 내에서 처리
- 큰 할당 또는 공간 부족 시: brk() 또는 sbrk()로 힙 확장
- 매우 큰 할당: mmap()으로 별도 영역 할당

**최대 크기**
- 물리 메모리와 스왑 공간의 합
- 가상 주소 공간의 제약
- 시스템 리소스 제한(ulimit)

**사용자가 크기를 수정하는 방법**

**스택 크기 수정**

**1. ulimit 명령어(셸에서)**
```bash
# 현재 스택 크기 확인 (KB 단위)
ulimit -s

# 스택 크기를 16MB로 설정
ulimit -s 16384

# 무제한으로 설정 (권장하지 않음)
ulimit -s unlimited
```

**2. setrlimit() 시스템 콜(프로그램에서)**
- 프로그램 실행 초기에 스택 크기 제한을 변경할 수 있습니다
- RLIMIT_STACK 리소스를 설정합니다
- soft limit와 hard limit 모두 조정 가능
- 개발자가 아닌 사용자는 이 방법을 직접 사용하기 어렵습니다

**3. 스레드 생성 시(pthread)**
- pthread_attr_setstacksize()로 스레드 스택 크기 지정
- 스레드별로 다른 크기 설정 가능

**4. 시스템 전역 설정**
- /etc/security/limits.conf 파일 수정
- 특정 사용자나 그룹에 대한 제한 설정
- 시스템 관리자 권한 필요

**힙 크기 수정**

**1. 직접 제어 어려움**
- 힙은 동적으로 할당되므로 미리 크기를 설정하지 않습니다
- malloc()으로 필요한 만큼 할당받습니다
- 시스템이 자동으로 관리합니다

**2. 간접적인 제한**
```bash
# 데이터 세그먼트(힙 포함) 크기 제한
ulimit -d unlimited

# 가상 메모리 총 크기 제한
ulimit -v 2097152  # 2GB
```

**3. malloc 동작 튜닝**
- 환경 변수로 malloc 동작 변경 가능
- MALLOC_ARENA_MAX, MALLOC_MMAP_THRESHOLD_ 등
- 메모리 할당자 라이브러리 교체 가능(jemalloc, tcmalloc)

**프로그램 개발자의 역할**

**컴파일 시**
- 링커 옵션으로 스택 크기 지정 가능
- 예: -Wl,--stack,16777216 (Windows)
- ELF 헤더에 스택 크기 정보 포함 가능

**런타임 시**
- setrlimit()로 동적 조정
- 스레드 생성 시 속성 설정
- 메모리 할당 패턴 최적화

**사용자(관리자)의 역할**

**시스템 전역 설정**
- /etc/security/limits.conf
- systemd 서비스 파일에서 LimitSTACK 설정
- 커널 파라미터 조정

**프로세스별 설정**
- ulimit으로 셸에서 실행 전 설정
- 서비스 관리자를 통한 제한 설정
- cgroup을 통한 리소스 제어

**왜 크기 제한이 필요한가?**

**시스템 안정성**
- 무한 재귀나 메모리 누수로부터 시스템 보호
- 한 프로세스가 모든 메모리를 소비하는 것을 방지
- 다른 프로세스의 실행 보장

**보안**
- 스택 오버플로우 공격의 영향 제한
- 악의적인 프로그램의 자원 독점 방지

**멀티테넌시**
- 여러 사용자가 공유하는 시스템에서 공정한 자원 분배
- 각 사용자별 메모리 쿼터 적용

**실제 시나리오**

**스택 크기 부족 시**
- 깊은 재귀 함수 사용 시 스택 오버플로우
- 큰 지역 배열 선언 시 문제 발생
- ulimit -s로 증가시켜 해결

**힙 메모리 부족 시**
- malloc()이 NULL 반환
- 메모리 누수 확인 및 수정
- 시스템 메모리 증설 고려

**제한 확인**
```bash
# 모든 리소스 제한 확인
ulimit -a

# 특정 프로세스의 제한 확인
cat /proc/[pid]/limits
```

**실무 활용**
서버 애플리케이션 배포 시 예상 부하에 따라 스택 크기를 조정합니다. 컨테이너 환경에서는 cgroup을 통해 메모리 제한을 설정하여 안정성을 확보합니다. 대용량 데이터 처리 프로그램은 충분한 메모리 제한을 설정해야 합니다.

---

## 30. 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.

**장기 스케줄러(Long-term Scheduler)**

**정의**
- Job Scheduler 또는 Admission Scheduler라고도 불립니다
- 디스크에 있는 프로그램 중 어떤 것을 메모리에 올릴지 결정합니다
- New 상태에서 Ready 상태로의 전환을 제어합니다

**역할**
- 시스템에 진입할 프로세스를 선택합니다
- 다중 프로그래밍의 정도(degree of multiprogramming)를 제어합니다
- 메모리에 동시에 존재하는 프로세스의 수를 조절합니다
- CPU bound와 I/O bound 프로세스의 균형을 맞춥니다

**실행 빈도**
- 매우 낮은 빈도로 실행됩니다(초 또는 분 단위)
- 프로세스 생성 요청이 있을 때 동작합니다
- 메모리 자원 상황을 고려하여 결정합니다

**목표**
- 적절한 프로세스 믹스 유지
- CPU 활용률과 처리량 최적화
- 시스템 과부하 방지

**중기 스케줄러(Medium-term Scheduler)**

**정의**
- Swapper라고도 불립니다
- 메모리에 있는 프로세스 중 일부를 디스크로 스왑 아웃합니다
- Ready 또는 Blocked 상태에서 Suspended 상태로 전환합니다

**역할**
- 메모리 부족 시 일부 프로세스를 스왑 영역으로 이동시킵니다
- 다중 프로그래밍 정도를 동적으로 조절합니다
- 메모리 사용률을 최적화합니다
- 나중에 필요시 다시 메모리로 스왑 인합니다

**스왑 아웃 대상 선택**
- 오랫동안 대기 중인 프로세스
- 우선순위가 낮은 프로세스
- I/O 대기 중인 프로세스
- 사용자 프로세스(시스템 프로세스 보호)

**실행 빈도**
- 중간 빈도로 실행됩니다(초 단위)
- 메모리 압박 상황에서 동작합니다
- 시스템 성능 유지를 위해 필요시 실행

**목표**
- 메모리 공간 확보
- 시스템 응답성 유지
- 스래싱(thrashing) 방지

**단기 스케줄러(Short-term Scheduler)**

**정의**
- CPU Scheduler 또는 Dispatcher라고 불립니다
- Ready 큐에 있는 프로세스 중 다음에 실행할 것을 선택합니다
- Ready 상태에서 Running 상태로의 전환을 제어합니다

**역할**
- CPU를 할당받을 프로세스를 결정합니다
- 컨텍스트 스위칭을 수행합니다
- 스케줄링 알고리즘을 실행합니다
- CPU 이용률을 최대화합니다

**스케줄링 알고리즘**
- FCFS (First-Come, First-Served)
- SJF (Shortest Job First)
- Priority Scheduling
- Round Robin
- Multi-level Queue
- Multi-level Feedback Queue

**실행 빈도**
- 매우 높은 빈도로 실행됩니다(밀리초 단위)
- 타이머 인터럽트마다 실행 가능
- I/O 완료, 시스템 콜 등에서도 실행
- 가장 빈번하게 동작하는 스케줄러

**목표**
- CPU 활용률 최대화
- 응답 시간 최소화
- 처리량 최대화
- 공정성 보장

**프로세스 상태 전이와 스케줄러**

```
[디스크의 프로그램]
        ↓ 장기 스케줄러
      [New]
        ↓
    [Ready] ←─────────┐
        ↓ 단기 스케줄러  │
    [Running] ─────→ [Terminated]
        ↓ I/O 요청
    [Waiting]
        ↓ 중기 스케줄러
    [Suspended]
```

**비교**

**빈도**
- 장기: 가장 낮음(초~분)
- 중기: 중간(초)
- 단기: 가장 높음(밀리초)

**역할**
- 장기: 프로세스 진입 제어
- 중기: 메모리 관리
- 단기: CPU 할당

**상태 전이**
- 장기: New → Ready
- 중기: Ready/Waiting ↔ Suspended
- 단기: Ready → Running

**목표**
- 장기: 적절한 프로세스 믹스
- 중기: 메모리 최적화
- 단기: CPU 효율 최대화

**현대 운영체제에서의 변화**

**장기 스케줄러**
- 대부분의 현대 OS에서 사용하지 않습니다
- 충분한 메모리로 인해 필요성 감소
- 모든 프로세스를 메모리에 유지 가능

**중기 스케줄러**
- 여전히 사용되지만 중요성 감소
- 메모리가 부족할 때만 동작
- 가상 메모리와 페이징으로 대체

**단기 스케줄러**
- 가장 중요하고 활발히 사용됩니다
- 지속적으로 연구 및 개선됩니다
- 멀티코어 환경에서 더욱 복잡해졌습니다

**실무 활용**
클라우드 환경에서는 리소스 관리자가 장기 스케줄러 역할을 수행하여 VM 또는 컨테이너의 시작을 제어합니다. 메모리가 부족한 임베디드 시스템에서는 중기 스케줄러가 여전히 중요한 역할을 합니다.

---

## 31. 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?

**현대 OS의 스케줄러 사용 현황**

**단기 스케줄러(CPU Scheduler)**

**사용 여부: ✓ 적극 사용**
- 모든 현대 운영체제에서 핵심 컴포넌트입니다
- 지속적으로 발전하고 개선되고 있습니다
- 멀티코어, 실시간 시스템에 최적화됩니다

**현대적 구현**
- CFS (Completely Fair Scheduler): 리눅스 기본 스케줄러
- O(1) 스케줄러의 발전형
- 실시간 스케줄러 (SCHED_FIFO, SCHED_RR)
- 데드라인 스케줄러 (SCHED_DEADLINE)

**멀티코어 환경**
- 코어별 실행 큐 관리
- 부하 분산 (Load Balancing)
- 프로세서 친화성 (CPU Affinity) 고려
- NUMA 아키텍처 최적화

**중기 스케줄러(Swapper)**

**사용 여부: △ 제한적 사용**
- 과거보다 중요성이 크게 감소했습니다
- 메모리가 충분한 시스템에서는 거의 동작하지 않습니다
- 메모리 압박 상황에서만 제한적으로 사용됩니다

**현대적 대체 메커니즘**
- 페이지 교체 알고리즘이 주 역할 수행
- 가상 메모리 시스템이 개별 페이지 단위로 관리
- OOM Killer (Out Of Memory Killer)가 극단적 상황 처리
- 프로세스 전체를 스왑하는 대신 페이지 단위로 스왑

**리눅스의 경우**
- swappiness 파라미터로 스와핑 경향 조절
- 메모리 압박 시 페이지를 스왑 공간으로 이동
- 프로세스 전체를 스왑하지는 않음

**모바일/임베디드 시스템**
- 메모리가 제한적이어서 여전히 중요
- Android의 Low Memory Killer
- 백그라운드 앱을 종료하여 메모리 확보

**장기 스케줄러(Job Scheduler)**

**사용 여부: ✗ 거의 사용 안 함**
- 전통적인 의미의 장기 스케줄러는 사용하지 않습니다
- 현대 OS는 생성 요청된 프로세스를 즉시 메모리에 로드합니다
- 메모리가 충분하여 진입 제어가 불필요합니다

**과거 사용 이유**
- 메모리가 부족했던 시대의 산물
- 일괄 처리(batch processing) 시스템에서 중요
- 제한된 메모리에 적절한 프로세스만 선택

**현대적 대체 메커니즘**

**클라우드/컨테이너 환경**
- 쿠버네티스 스케줄러: 파드를 노드에 배치
- 도커 스웜 스케줄러: 컨테이너 배치 결정
- 리소스 쿼터 및 제한 적용
- 이것이 현대판 장기 스케줄러 역할

**리소스 관리 시스템**
- SLURM, PBS: HPC 클러스터의 작업 스케줄링
- 제출된 작업을 큐에 보관하고 자원이 있을 때 실행
- 전통적인 장기 스케줄러 개념과 유사

**프로세스 생성 제한**
- fork bomb 방지를 위한 제한
- ulimit으로 프로세스 수 제한
- cgroup을 통한 리소스 제어
- 하지만 이는 보안 목적이지 스케줄링은 아님

**운영체제별 현황**

**리눅스**
- 단기: CFS, 실시간 스케줄러 등 활발히 사용
- 중기: 페이지 교체와 OOM Killer로 대체
- 장기: 사용 안 함, cgroup으로 리소스 제어

**Windows**
- 단기: Windows Scheduler (우선순위 기반)
- 중기: 메모리 관리자가 페이지 단위로 처리
- 장기: 사용 안 함

**macOS**
- 단기: XNU 커널의 스케줄러
- 중기: 메모리 압축 및 페이징
- 장기: 사용 안 함

**왜 변화했는가?**

**하드웨어 발전**
- 메모리 가격 하락으로 대용량 RAM 보편화
- 64비트 시스템으로 가상 주소 공간 대폭 증가
- SSD 보급으로 스와핑 성능 향상

**시스템 아키텍처 변화**
- 시분할 시스템에서 실시간 반응성 중시로 변화
- 일괄 처리에서 대화형 시스템으로 전환
- 개인용 컴퓨터는 프로세스 진입 제어가 불필요

**가상 메모리 기술**
- 페이징 기법으로 물리 메모리 효율적 관리
- 디맨드 페이징으로 필요한 부분만 로드
- 프로세스 전체 스왑의 필요성 감소

**현대 OS의 초점**

**성능 최적화**
- CPU 스케줄링의 정교화
- 멀티코어 활용 극대화
- 전력 소비 최적화

**실시간 응답성**
- 낮은 레이턴시 보장
- 우선순위 역전 방지
- 예측 가능한 동작

**리소스 격리**
- 컨테이너 기술
- cgroup을 통한 세밀한 제어
- 네임스페이스 분리

**실무 활용**
현대 시스템 관리에서는 CPU 스케줄러 튜닝에 집중합니다. 클라우드 환경에서는 오케스트레이션 도구가 장기 스케줄러 역할을 수행하며, 메모리 관리는 페이지 단위로 이루어집니다.

---

## 32. 프로세스의 스케쥴링 상태에 대해 설명해 주세요.

**기본 프로세스 상태**

**New (생성)**
- 프로세스가 막 생성된 상태입니다
- 아직 메모리에 올라가지 않았거나 초기화 중입니다
- PCB가 생성되고 있습니다
- 운영체제가 프로세스 생성 작업을 수행 중입니다

**전이**
- New → Ready: 프로세스 초기화 완료, 실행 준비 완료

**Ready (준비)**
- 실행 준비가 완료된 상태입니다
- CPU만 할당받으면 즉시 실행 가능합니다
- 메모리에 적재되어 있습니다
- Ready Queue에서 CPU 할당을 기다립니다

**특징**
- 여러 프로세스가 동시에 Ready 상태일 수 있습니다
- 스케줄러가 다음 실행할 프로세스를 선택합니다
- 우선순위에 따라 큐에서 대기합니다

**전이**
- Ready → Running: 스케줄러가 선택하여 CPU 할당(Dispatch)
- Running → Ready: Time Slice 소진, 선점(Preemption)

**Running (실행)**
- CPU를 할당받아 명령어를 실행 중인 상태입니다
- 단일 코어 시스템에서는 한 번에 하나만 Running 상태입니다
- 멀티코어 시스템에서는 코어 수만큼 동시에 Running 가능합니다

**전이**
- Running → Ready: 타이머 인터럽트, 높은 우선순위 프로세스 도착
- Running → Waiting: I/O 요청, 이벤트 대기
- Running → Terminated: 프로세스 종료

**Waiting (대기) / Blocked (차단)**
- I/O 작업이나 이벤트 완료를 기다리는 상태입니다
- CPU를 할당받아도 실행할 수 없습니다
- 대기 중인 이벤트별로 별도의 큐에 존재합니다

**대기 원인**
- 디스크 I/O 완료 대기
- 네트워크 데이터 수신 대기
- 사용자 입력 대기
- 다른 프로세스의 신호 대기
- 자식 프로세스 종료 대기

**전이**
- Waiting → Ready: I/O 완료, 이벤트 발생

**Terminated (종료)**
- 프로세스 실행이 완료된 상태입니다
- 자원을 반환하고 있거나 완전히 제거되기 직전입니다
- 좀비 상태일 수 있습니다(부모가 wait() 호출 전)
- PCB는 아직 존재합니다

**종료 원인**
- 정상 종료: exit() 시스템 콜
- 비정상 종료: 오류, 예외, 시그널
- 부모 프로세스에 의한 강제 종료

**확장 상태 (일부 OS)**

**Suspended Ready (보류 준비)**
- Ready 상태였으나 메모리에서 스왑 아웃된 상태입니다
- 디스크의 스왑 공간에 저장되어 있습니다
- 메모리 압박 시 중기 스케줄러가 이동시킵니다

**전이**
- Ready → Suspended Ready: 중기 스케줄러에 의한 스왑 아웃
- Suspended Ready → Ready: 스왑 인으로 메모리 복귀

**Suspended Waiting (보류 대기)**
- Waiting 상태였으나 메모리에서 스왑 아웃된 상태입니다
- I/O 대기 중이면서 메모리에 없는 상태입니다

**전이**
- Waiting → Suspended Waiting: 스왑 아웃
- Suspended Waiting → Suspended Ready: I/O 완료
- Suspended Waiting → Waiting: 스왑 인

**상태 전이 다이어그램**

```
    [New]
      ↓
   [Ready] ←─────────┐
      ↓ dispatch      │
   [Running] ────────┤ timeout
      ↓ I/O request  │
   [Waiting] ────────┘
      ↓ I/O complete
   [Ready]
      ↓ exit
   [Terminated]
```

**확장 상태 포함 다이어그램**

```
            [New]
              ↓
           [Ready] ←──────┐
          ↓      ↑        │
     [Running]   │   [Waiting]
          ↓      │        ↓
   [Terminated]  │
              Suspend    Suspend
          ↓      ↑    ↓      ↑
   [Suspended  [Suspended
      Ready]      Waiting]
```

**상태별 큐**

**Ready Queue**
- Ready 상태의 프로세스들이 대기
- 스케줄러가 여기서 선택
- 우선순위 큐로 구현 가능

**Device Queue**
- 각 I/O 장치별로 대기 큐 존재
- 디스크 큐, 네트워크 큐 등
- FIFO 또는 우선순위 방식

**Job Queue**
- 시스템의 모든 프로세스 포함
- 전체 프로세스 관리에 사용

**상태 확인 방법**

**리눅스**
- ps aux: 프로세스 목록과 상태
- top/htop: 실시간 프로세스 상태
- /proc/[pid]/stat: 상세 상태 정보

**상태 코드**
- R (Running): 실행 중 또는 Ready
- S (Sleeping): Waiting (인터럽트 가능)
- D (Disk sleep): Waiting (인터럽트 불가능)
- T (Stopped): 일시 중지
- Z (Zombie): 종료되었으나 회수되지 않음

**멀티코어 환경**

**Running 상태**
- 코어 수만큼 동시에 Running 가능
- 각 코어는 독립적으로 프로세스 실행
- 스케줄러는 모든 코어를 관리

**부하 분산**
- 코어 간 프로세스 균등 분배
- 캐시 친화성 고려
- NUMA 노드 고려

**실무 활용**
시스템 모니터링 시 각 상태의 프로세스 수를 확인하여 병목 지점을 파악합니다. D 상태 프로세스가 많으면 I/O 병목, R 상태가 많으면 CPU 병목을 의미합니다.
