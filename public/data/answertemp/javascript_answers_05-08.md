# JavaScript 답변 05-08

## 질문 5: 렉시컬 스코프(Lexical Scope)란 무엇인가요?

**정의:**
렉시컬 스코프는 함수가 선언된 위치에 따라 상위 스코프가 결정되는 스코프 방식입니다. 정적 스코프라고도 하며, 함수를 어디서 호출하는지가 아니라 어디에 선언했는지에 따라 스코프가 정해집니다.

**렉시컬 스코프의 핵심 원리:**
- 함수 선언 시점에 스코프가 확정됩니다. 코드를 작성하는 시점에 스코프 체인이 결정됩니다.
- 실행 시점이 아닌 작성 시점이 중요합니다. 함수를 어디서 호출하든 선언된 위치의 스코프를 참조합니다.
- 외부 렉시컬 환경 참조를 통해 구현됩니다. 함수 객체는 내부 슬롯에 자신이 정의된 환경을 기억합니다.

**동적 스코프와의 차이점:**
- 렉시컬 스코프: 함수 선언 위치에 따라 스코프가 결정됩니다. JavaScript, Python, Java 등 대부분의 언어가 채택합니다.
- 동적 스코프: 함수 호출 위치에 따라 스코프가 결정됩니다. Bash, Perl 일부 등에서 사용됩니다.
- 렉시컬 스코프는 예측 가능하고 안정적입니다. 코드만 보고도 변수 참조를 파악할 수 있습니다.

**클로저와의 관계:**
- 렉시컬 스코프가 클로저의 기반입니다. 함수가 선언될 때의 환경을 기억하기 때문에 클로저가 가능합니다.
- 중첩 함수는 외부 함수의 변수에 접근할 수 있습니다. 외부 함수가 종료되어도 렉시컬 환경을 참조합니다.
- 이를 통해 데이터 은닉과 캡슐화를 구현할 수 있습니다.

**렉시컬 환경의 구성:**
- Environment Record: 현재 스코프의 식별자와 값을 저장합니다.
- Outer Lexical Environment Reference: 외부 렉시컬 환경을 참조합니다. 스코프 체인을 형성합니다.

**실무 활용:**
- 모듈 패턴 구현 시 렉시컬 스코프를 활용하여 private 변수를 만듭니다.
- 콜백 함수나 이벤트 핸들러에서 외부 변수를 안전하게 참조할 수 있습니다.
- 함수형 프로그래밍에서 고차 함수를 구현할 때 필수적입니다.
- 코드의 예측 가능성이 높아져 디버깅과 유지보수가 쉬워집니다.

---

## 질문 6: 클로저(Closure)란 무엇이고 어떻게 활용할 수 있나요?

**정의:**
클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. 함수가 생성될 때의 외부 변수를 기억하고 접근할 수 있는 특성을 말합니다. 외부 함수가 종료된 후에도 외부 함수의 변수에 접근할 수 있습니다.

**클로저의 동작 원리:**
- 내부 함수가 외부 함수의 변수를 참조합니다. 외부 함수의 실행 컨텍스트가 종료되어도 렉시컬 환경은 유지됩니다.
- 가비지 컬렉션에서 제외됩니다. 내부 함수가 참조하는 변수는 메모리에서 해제되지 않습니다.
- 외부 함수를 반환하거나 콜백으로 전달할 때 클로저가 생성됩니다.

**클로저가 생성되는 조건:**
- 중첩된 함수 구조를 가져야 합니다. 외부 함수와 내부 함수가 필요합니다.
- 내부 함수가 외부 함수의 변수를 참조해야 합니다. 단순히 중첩되기만 해서는 클로저가 아닙니다.
- 내부 함수가 외부로 전달되어야 합니다. 반환되거나 다른 곳에 저장되어야 합니다.

**클로저의 장점:**
- 데이터 은닉과 캡슐화가 가능합니다. private 변수를 구현할 수 있습니다.
- 상태를 안전하게 유지할 수 있습니다. 외부에서 직접 접근하지 못하도록 보호합니다.
- 함수 팩토리 패턴을 구현할 수 있습니다. 설정을 기억하는 함수를 생성합니다.

**클로저의 단점과 주의사항:**
- 메모리 누수가 발생할 수 있습니다. 필요 없는 클로저는 명시적으로 해제해야 합니다.
- 과도한 사용은 메모리 사용량을 증가시킵니다. 성능에 영향을 줄 수 있습니다.
- 반복문에서 클로저 사용 시 주의가 필요합니다. 변수가 의도치 않게 공유될 수 있습니다.

**실무 활용 사례:**
- 모듈 패턴으로 private 메서드와 변수를 구현합니다. API를 제한적으로 노출할 수 있습니다.
- 커링과 부분 적용 함수를 만듭니다. 함수의 인자를 미리 설정할 수 있습니다.
- 이벤트 핸들러와 콜백 함수에서 컨텍스트를 유지합니다. 비동기 작업에서 상태를 기억합니다.
- React Hooks의 내부 구현에서 사용됩니다. useState 등이 클로저를 활용합니다.
- 디바운스와 스로틀 함수 구현에 활용됩니다. 타이머 ID를 클로저로 관리합니다.

---

## 질문 7: 호이스팅(Hoisting)은 어떻게 동작하나요?

**정의:**
호이스팅은 변수와 함수 선언이 해당 스코프의 최상단으로 끌어올려지는 JavaScript의 특성입니다. 실제로 코드가 이동하는 것이 아니라 실행 컨텍스트 생성 단계에서 선언이 먼저 처리되는 것입니다.

**호이스팅의 동작 원리:**
- 실행 컨텍스트 생성 단계에서 발생합니다. 코드 실행 전에 선언을 메모리에 저장합니다.
- 선언과 초기화가 분리됩니다. var는 undefined로 초기화되지만 let과 const는 초기화되지 않습니다.
- 스코프 단위로 동작합니다. 전역 스코프나 함수 스코프 내에서 최상단으로 올라갑니다.

**변수 호이스팅의 종류:**
- var 호이스팅: 선언과 동시에 undefined로 초기화됩니다. 선언 전에 접근하면 undefined를 반환합니다. 에러가 발생하지 않아 버그의 원인이 될 수 있습니다.
- let과 const 호이스팅: 선언은 호이스팅되지만 초기화는 되지 않습니다. TDZ에 들어가며 접근 시 ReferenceError가 발생합니다. 더 안전한 코드를 작성할 수 있습니다.

**함수 호이스팅:**
- 함수 선언문: 함수 전체가 호이스팅됩니다. 선언 전에도 호출할 수 있습니다. 함수 이름과 본문 모두 메모리에 저장됩니다.
- 함수 표현식: 변수 선언만 호이스팅됩니다. var로 선언 시 undefined로 초기화되어 호출하면 TypeError가 발생합니다. let이나 const로 선언 시 ReferenceError가 발생합니다.

**호이스팅 우선순위:**
- 변수와 함수 선언이 모두 호이스팅될 때 함수가 우선입니다.
- 같은 이름의 변수와 함수가 있으면 함수 선언이 먼저 처리됩니다.
- 이후 변수 할당은 함수를 덮어씁니다.

**실무에서의 주의사항:**
- var 사용을 피하고 let과 const를 사용합니다. 호이스팅으로 인한 혼란을 줄일 수 있습니다.
- 변수와 함수는 사용 전에 선언합니다. 코드 가독성과 유지보수성이 향상됩니다.
- 함수 선언문보다 함수 표현식 사용을 고려합니다. 호이스팅 동작을 명확히 파악할 수 있습니다.
- 호이스팅을 이해하면 예상치 못한 버그를 방지할 수 있습니다. 특히 반복문이나 조건문 내 선언에 주의합니다.

---

## 질문 8: TDZ(Temporal Dead Zone)에 대해 설명해주세요.

**정의:**
TDZ는 let과 const로 선언된 변수가 선언되기 전까지 접근할 수 없는 구간을 의미합니다. 스코프의 시작 지점부터 변수 선언문까지의 영역이며, 이 구간에서 변수에 접근하면 ReferenceError가 발생합니다.

**TDZ가 존재하는 이유:**
- 변수 사용 전 초기화를 강제합니다. 의도하지 않은 undefined 사용을 방지합니다.
- 코드의 안전성을 높입니다. 선언되지 않은 변수 접근을 컴파일 타임이 아닌 런타임에 감지합니다.
- const의 불변성을 보장합니다. 초기화 없이 선언만 하는 것을 방지합니다.

**TDZ의 동작 방식:**
- 스코프에 진입하면 변수가 생성됩니다. 하지만 초기화는 되지 않습니다.
- 선언문을 만나기 전까지 TDZ에 머뭅니다. 이 시점까지는 변수를 사용할 수 없습니다.
- 선언문을 만나면 TDZ에서 벗어납니다. let은 undefined로, const는 할당된 값으로 초기화됩니다.
- 초기화 이후에는 정상적으로 접근할 수 있습니다.

**TDZ와 호이스팅:**
- let과 const도 호이스팅됩니다. 선언 자체는 스코프 최상단으로 끌어올려집니다.
- var와의 차이는 초기화 시점입니다. var는 선언과 동시에 undefined로 초기화되지만 let과 const는 선언문에서 초기화됩니다.
- 호이스팅되지 않는 것처럼 보이지만 실제로는 호이스팅됩니다. 섀도잉을 통해 확인할 수 있습니다.

**TDZ가 적용되는 경우:**
- let과 const 변수 선언 시 항상 적용됩니다.
- 클래스 선언도 TDZ를 따릅니다. 선언 전 사용 시 에러가 발생합니다.
- 함수의 기본 매개변수에서도 발생합니다. 매개변수는 왼쪽에서 오른쪽 순서로 초기화됩니다.

**실무 활용:**
- 변수는 사용하기 직전에 선언하는 것이 좋습니다. 스코프 최상단에 모든 선언을 모으는 것보다 명확합니다.
- TDZ 에러를 통해 잘못된 변수 참조를 조기에 발견합니다. var의 undefined 반환보다 디버깅이 쉽습니다.
- const를 우선 사용하고 재할당이 필요할 때만 let을 사용합니다. TDZ를 통해 초기화를 강제할 수 있습니다.
- 순환 참조나 의존성 문제를 파악할 수 있습니다. 변수 선언 순서를 명확히 관리합니다.

---
