# Network 답변 모음 (77-80)

## 77. DNS Recursive Query, Iterative Query가 무엇인가요?

**Recursive Query(재귀 쿼리)**와 **Iterative Query(반복 쿼리)**는 DNS 조회를 수행하는 서로 다른 방식입니다.

**Recursive Query (재귀 쿼리):**

**정의:**
클라이언트가 DNS 리졸버에게 "최종 답을 찾아서 알려달라"고 요청하는 방식입니다.

**동작 방식:**
클라이언트가 리졸버에게 한 번만 쿼리를 보냅니다. 리졸버가 모든 조회 과정을 대신 수행합니다. 리졸버가 최종 IP 주소를 찾을 때까지 여러 DNS 서버에 질의합니다. 최종 결과(IP 주소 또는 오류)만 클라이언트에게 반환합니다.

**책임:**
리졸버가 답을 찾을 책임을 집니다. 클라이언트는 단순히 결과만 받습니다.

**장점:**
클라이언트 입장에서 간단하고 편리합니다. 네트워크 트래픽이 클라이언트에서 발생하지 않습니다. 리졸버의 캐시를 활용할 수 있습니다.

**단점:**
리졸버에 부하가 집중됩니다. 리졸버가 다운되면 DNS 조회가 불가능합니다.

**Iterative Query (반복 쿼리):**

**정의:**
DNS 서버가 "전체 답은 모르지만, 다음에 물어볼 곳은 여기야"라고 응답하는 방식입니다.

**동작 방식:**
리졸버가 루트 DNS 서버에 질의합니다. 루트 서버가 "TLD 서버 주소는 이거야"라고 응답합니다(참조 응답). 리졸버가 TLD 서버에 질의합니다. TLD 서버가 "권한 서버 주소는 이거야"라고 응답합니다. 리졸버가 권한 서버에 질의합니다. 권한 서버가 최종 IP 주소를 응답합니다.

**책임:**
각 DNS 서버는 자신이 아는 정보만 제공합니다. 리졸버가 단계별로 조회를 진행합니다.

**장점:**
DNS 서버의 부하가 분산됩니다. 각 서버는 자신의 영역만 관리하면 됩니다. 확장성이 좋습니다.

**단점:**
여러 번의 왕복이 필요하여 시간이 오래 걸립니다.

**실제 DNS 조회 과정:**

**클라이언트 ↔ 리졸버: Recursive Query**
사용자 컴퓨터가 ISP 리졸버(또는 8.8.8.8)에 재귀 쿼리를 보냅니다. "www.example.com의 IP 주소를 찾아주세요." 리졸버가 모든 조회를 대신 수행합니다.

**리졸버 ↔ DNS 서버들: Iterative Query**
리졸버가 루트 서버에 반복 쿼리를 보냅니다. 루트 서버: ".com TLD 서버는 이 주소로 물어보세요" 리졸버가 TLD 서버에 반복 쿼리를 보냅니다. TLD 서버: "example.com 네임서버는 이 주소로 물어보세요" 리졸버가 권한 서버에 쿼리를 보냅니다. 권한 서버: "www.example.com의 IP는 192.0.2.1입니다"

**혼합 사용:**
실무에서는 두 방식이 혼합되어 사용됩니다. 클라이언트 → 리졸버는 재귀 쿼리. 리졸버 → 다른 DNS 서버들은 반복 쿼리.

**상세한 예시:**

**www.example.com 조회:**

**1단계 - 재귀 쿼리:**
사용자 PC → 리졸버(8.8.8.8): "www.example.com의 IP를 알려주세요" (RD=1, Recursion Desired 플래그 설정)

**2단계 - 반복 쿼리 시작:**
리졸버 → 루트 서버: "www.example.com의 IP는?" 루트 서버 → 리졸버: "모르겠지만, .com은 이 TLD 서버에 물어보세요"

**3단계:**
리졸버 → .com TLD 서버: "www.example.com의 IP는?" TLD 서버 → 리졸버: "모르겠지만, example.com은 이 네임서버에 물어보세요"

**4단계:**
리졸버 → example.com 네임서버: "www.example.com의 IP는?" 네임서버 → 리졸버: "192.0.2.1입니다" (최종 응답)

**5단계 - 재귀 응답:**
리졸버 → 사용자 PC: "192.0.2.1입니다"

**DNS 메시지 플래그:**

**RD (Recursion Desired):**
클라이언트가 재귀 쿼리를 요청할 때 설정합니다. "재귀적으로 조회해주세요"

**RA (Recursion Available):**
서버가 재귀 쿼리를 지원하는지 나타냅니다. 리졸버는 RA=1, 권한 서버는 RA=0

**캐싱의 역할:**
리졸버가 이전에 .com TLD 서버 주소를 캐시했다면 루트 서버 조회를 생략합니다. 권한 서버 주소를 캐시했다면 TLD 서버 조회도 생략합니다. 최종 IP를 캐시했다면 모든 조회를 생략하고 즉시 응답합니다.

**비재귀 리졸버:**
일부 DNS 서버는 재귀 쿼리를 지원하지 않습니다. 권한 서버는 일반적으로 반복 쿼리만 응답합니다. 재귀 쿼리는 리졸버의 역할입니다.

**보안 고려사항:**
개방형 재귀 리졸버는 DNS 증폭 공격에 악용될 수 있습니다. 재귀 쿼리는 신뢰할 수 있는 네트워크에서만 허용해야 합니다.

**성능 영향:**
재귀 쿼리는 클라이언트 관점에서 빠릅니다(한 번의 왕복). 반복 쿼리는 여러 번의 왕복이 필요하지만 캐싱으로 완화됩니다.

---

## 78. DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?

DNS는 주로 UDP를 사용하므로 자체적으로 **재전송 메커니즘**을 구현하여 손실을 처리합니다.

**UDP의 비신뢰성:**
UDP는 패킷 손실, 순서 변경, 중복을 보장하지 않습니다. DNS 쿼리나 응답이 네트워크에서 손실될 수 있습니다. 애플리케이션 레벨에서 손실을 감지하고 복구해야 합니다.

**타임아웃 메커니즘:**

**초기 타임아웃:**
클라이언트 또는 리졸버가 쿼리를 보낸 후 일정 시간(일반적으로 2-5초) 대기합니다. 응답을 받지 못하면 타임아웃으로 판단합니다.

**타임아웃 값 설정:**
너무 짧으면 정상 응답을 기다리지 못하고 재전송합니다. 너무 길면 사용자 경험이 나빠집니다. 네트워크 상태에 따라 동적으로 조정하는 구현도 있습니다.

**재전송 전략:**

**1. 같은 서버로 재전송:**
첫 번째 시도가 실패하면 같은 DNS 서버로 쿼리를 다시 보냅니다. 일시적인 네트워크 문제나 서버 부하를 고려합니다.

**2. 다른 서버로 폴오버:**
재전송도 실패하면 대체 DNS 서버로 시도합니다. 대부분의 시스템은 primary와 secondary DNS 서버를 설정합니다. 예: 8.8.8.8 → 8.8.4.4 또는 ISP의 보조 DNS

**3. 지수 백오프(Exponential Backoff):**
재시도 간격을 점진적으로 늘립니다. 첫 시도: 즉시, 첫 재전송: 2초 후, 두 번째 재전송: 4초 후, 세 번째 재전송: 8초 후. 네트워크 혼잡을 악화시키지 않습니다.

**재시도 횟수 제한:**
무한정 재시도하지 않고 일정 횟수(일반적으로 2-3회) 후 포기합니다. 총 대기 시간이 너무 길어지는 것을 방지합니다.

**클라이언트 측 처리:**

**시스템 리졸버:**
운영체제의 DNS 클라이언트가 재전송을 자동으로 처리합니다. resolv.conf(Linux) 또는 레지스트리(Windows)에서 설정을 조정할 수 있습니다.

**애플리케이션:**
브라우저나 애플리케이션은 시스템 리졸버에 의존합니다. 일부는 자체 DNS 캐시와 재시도 로직을 구현합니다.

**DNS 리졸버 측 처리:**

**병렬 쿼리:**
일부 리졸버는 여러 권한 서버에 동시에 쿼리를 보냅니다. 가장 빠른 응답을 사용합니다. 신뢰성과 성능을 동시에 개선합니다.

**캐시 활용:**
이전에 받은 응답을 캐시하여 재쿼리를 피합니다. TTL 내에서는 캐시된 값을 즉시 반환합니다.

**손실 유형별 처리:**

**쿼리 패킷 손실:**
서버가 쿼리를 받지 못하므로 응답하지 않습니다. 클라이언트가 타임아웃 후 재전송합니다.

**응답 패킷 손실:**
서버는 응답을 보냈지만 클라이언트가 받지 못합니다. 클라이언트가 타임아웃 후 쿼리를 재전송합니다. 서버는 같은 쿼리를 다시 받고 응답합니다(멱등성).

**부분 응답 손실:**
UDP는 패킷 전체가 손실되거나 전체가 도착합니다. 부분 손실은 발생하지 않습니다.

**중복 쿼리 처리:**
DNS는 멱등성이 있어 같은 쿼리를 여러 번 처리해도 문제없습니다. 서버는 각 쿼리를 독립적으로 처리합니다.

**쿼리 ID:**
각 DNS 쿼리에는 고유한 ID가 있습니다. 응답의 ID를 확인하여 어떤 쿼리에 대한 응답인지 매칭합니다. 늦게 도착한 응답을 구별할 수 있습니다.

**TCP 폴백:**
UDP로 여러 번 시도해도 실패하면 TCP로 전환합니다. TCP는 신뢰성을 보장하여 손실 문제를 해결합니다.

**DNSSEC와 손실:**
DNSSEC 응답은 크기가 커서 UDP 손실 가능성이 높습니다. TCP 사용 비율이 증가하는 이유 중 하나입니다.

**네트워크 레벨 대응:**
라우터와 방화벽은 DNS 트래픽에 우선순위를 부여할 수 있습니다. QoS 정책으로 DNS 패킷 손실을 최소화합니다.

**실무 권장사항:**
최소 2개의 DNS 서버를 설정합니다. 신뢰할 수 있는 공개 DNS(8.8.8.8, 1.1.1.1)를 백업으로 사용합니다. 로컬 DNS 캐시를 활용하여 재쿼리를 줄입니다.

**모니터링:**
DNS 쿼리 실패율을 모니터링합니다. 비정상적으로 높으면 네트워크나 DNS 서버 문제를 조사합니다.

**최종 실패 처리:**
모든 재시도가 실패하면 애플리케이션에 오류를 반환합니다. 브라우저는 "서버를 찾을 수 없음" 오류를 표시합니다. 애플리케이션은 적절한 에러 처리를 구현해야 합니다.

---

## 79. 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?

캐싱된 DNS가 잘못되는 경우와 이를 **보정하는 방법**은 다양합니다.

**잘못된 캐시 발생 원인:**

**1. DNS 레코드 변경:**
서버 IP 주소가 변경되었지만 캐시가 아직 만료되지 않았습니다. 마이그레이션, 로드 밸런서 변경, 장애 복구 시 발생합니다.

**2. DNS 캐시 포이즈닝:**
공격자가 거짓 DNS 응답을 주입하여 캐시를 오염시킵니다. 사용자가 악의적인 사이트로 리다이렉트됩니다.

**3. 설정 오류:**
DNS 관리자가 잘못된 레코드를 등록했습니다. 오타, 설정 실수, 테스트 데이터를 운영에 적용한 경우입니다.

**4. 오래된 캐시:**
TTL이 너무 길게 설정되어 오래된 정보가 유지됩니다.

**TTL(Time To Live) 기반 자동 보정:**

**TTL의 역할:**
모든 DNS 레코드에는 유효 시간(TTL)이 설정됩니다. TTL이 만료되면 캐시가 자동으로 삭제됩니다. 다음 조회 시 권한 서버에서 최신 정보를 받습니다.

**TTL 설정 전략:**
자주 변경되는 레코드: 짧은 TTL (60초 - 5분). 안정적인 레코드: 긴 TTL (1시간 - 24시간). 변경 예정 시: 사전에 TTL을 짧게 조정합니다.

**수동 캐시 삭제:**

**클라이언트 측:**
Windows: ipconfig /flushdns. Linux: sudo systemd-resolve --flush-caches 또는 sudo service nscd restart. macOS: sudo dscacheutil -flushcache. 브라우저 캐시도 별도로 삭제해야 할 수 있습니다.

**리졸버 측:**
관리자가 DNS 서버의 캐시를 삭제할 수 있습니다. 하지만 모든 사용자의 리졸버를 제어할 수는 없습니다.

**서버 변경 시 Best Practice:**

**1. TTL 사전 단축:**
변경 1-2일 전에 TTL을 짧게 조정합니다(예: 5분). 기존 캐시가 빠르게 만료되도록 합니다.

**2. IP 변경:**
계획된 시간에 DNS 레코드를 변경합니다.

**3. 양쪽 서버 유지:**
TTL 기간 동안 새 서버와 구 서버를 모두 운영합니다. 오래된 캐시로 접속하는 사용자도 서비스를 받을 수 있습니다.

**4. 모니터링:**
새 서버와 구 서버의 트래픽을 모니터링합니다. 구 서버 트래픽이 0에 가까워지면 안전하게 종료합니다.

**5. TTL 복원:**
변경 완료 후 TTL을 원래 값으로 되돌립니다.

**DNS 레코드 다중화:**

**Round Robin DNS:**
여러 IP 주소를 등록하여 부하를 분산합니다. 하나의 서버에 문제가 있어도 다른 서버로 접속할 수 있습니다.

**Health Check:**
GeoDNS나 동적 DNS 서비스는 서버 상태를 확인합니다. 문제가 있는 서버의 IP를 자동으로 제외합니다.

**DNSSEC으로 캐시 포이즈닝 방지:**

**디지털 서명:**
DNSSEC은 DNS 응답에 암호화 서명을 추가합니다. 클라이언트가 서명을 검증하여 위변조를 감지합니다.

**신뢰 체인:**
루트부터 TLD, 권한 서버까지 서명 체인을 검증합니다. 공격자가 거짓 응답을 주입해도 서명이 맞지 않아 거부됩니다.

**애플리케이션 레벨 검증:**

**연결 테스트:**
DNS로 받은 IP에 실제 연결을 시도합니다. 연결 실패, 잘못된 응답, 인증서 불일치를 감지합니다.

**폴백 메커니즘:**
주 서버 연결 실패 시 대체 서버나 IP로 시도합니다. 하드코딩된 IP를 백업으로 사용할 수 있습니다.

**HTTPS 인증서 검증:**
HTTPS 접속 시 서버 인증서의 도메인 이름을 확인합니다. 잘못된 IP로 리다이렉트되면 인증서 오류가 발생합니다.

**사용자 교육:**
브라우저의 보안 경고를 무시하지 않도록 합니다. 민감한 정보 입력 전 URL을 재확인합니다.

**모니터링과 알림:**

**DNS 모니터링:**
정기적으로 외부에서 DNS 조회를 수행합니다. 예상과 다른 응답을 받으면 알림을 보냅니다.

**변경 감지:**
DNS 레코드 변경을 추적하고 승인되지 않은 변경을 감지합니다.

**Anycast DNS:**
여러 위치에서 같은 IP로 DNS 서비스를 제공합니다. 한 지역의 문제가 전체 서비스에 영향을 주지 않습니다.

**캐시 예열(Cache Warming):**
변경 직후 주요 리졸버에 쿼리를 보내 캐시를 업데이트합니다. 대부분의 사용자가 빠르게 새 정보를 받을 수 있습니다.

**실무 권장사항:**
중요한 변경은 점진적으로 수행합니다. 롤백 계획을 준비합니다. TTL을 적절하게 설정합니다(너무 짧으면 부하, 너무 길면 유연성 저하). DNSSEC, DoH, DoT 같은 보안 기술을 도입합니다.

---

## 80. DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.

**A**, **AAAA**, **CNAME** 레코드는 DNS에서 가장 기본적이고 중요한 레코드 타입들입니다.

**A 레코드 (Address Record):**

**정의:**
도메인 이름을 **IPv4 주소**로 매핑하는 레코드입니다.

**형식:**
도메인 → IPv4 주소 (예: example.com → 192.0.2.1)

**예시:**
```
example.com.        IN  A  192.0.2.1
www.example.com.    IN  A  192.0.2.1
mail.example.com.   IN  A  192.0.2.5
```

**특징:**
가장 기본적이고 널리 사용되는 레코드입니다. 하나의 도메인에 여러 A 레코드를 설정할 수 있습니다(Round Robin). 직접 IP 주소를 반환하므로 추가 조회가 필요 없습니다.

**용도:**
웹 서버, 메일 서버, API 서버 등의 IP 주소를 지정합니다. 서브도메인별로 다른 서버를 가리킬 수 있습니다.

**AAAA 레코드 (IPv6 Address Record):**

**정의:**
도메인 이름을 **IPv6 주소**로 매핑하는 레코드입니다. "Quad-A"로 읽습니다.

**형식:**
도메인 → IPv6 주소 (예: example.com → 2001:db8::1)

**예시:**
```
example.com.        IN  AAAA  2001:db8::1
www.example.com.    IN  AAAA  2001:db8::2
```

**특징:**
IPv6가 128비트이므로 A 레코드(32비트)보다 4배 크다는 의미로 AAAA입니다. IPv4 A 레코드와 함께 설정할 수 있습니다(듀얼 스택). 클라이언트가 IPv6를 지원하면 AAAA를 우선 사용합니다.

**용도:**
IPv6 네트워크를 지원하는 서버의 주소를 지정합니다. 미래 대비와 IPv4 고갈 문제 해결을 위해 점점 더 중요해지고 있습니다.

**듀얼 스택 구성:**
```
example.com.        IN  A     192.0.2.1
example.com.        IN  AAAA  2001:db8::1
```
클라이언트가 양쪽을 모두 받아 지원 가능한 프로토콜을 선택합니다.

**CNAME 레코드 (Canonical Name Record):**

**정의:**
도메인 이름을 **다른 도메인 이름**으로 매핑하는 별칭(alias) 레코드입니다.

**형식:**
별칭 도메인 → 정식 도메인 (예: www.example.com → example.com)

**예시:**
```
www.example.com.    IN  CNAME  example.com.
blog.example.com.   IN  CNAME  hosting.provider.com.
cdn.example.com.    IN  CNAME  cdn-network.cloudfront.net.
```

**특징:**
IP 주소가 아닌 다른 도메인을 가리킵니다. 최종적으로 A 또는 AAAA 레코드로 해석됩니다. 여러 단계의 CNAME을 따라갈 수 있습니다(체인).

**장점:**
IP 변경 시 원본 도메인의 A 레코드만 수정하면 됩니다. 여러 도메인이 같은 서버를 가리킬 때 관리가 편리합니다. CDN이나 호스팅 서비스에서 동적으로 최적 서버를 제공할 수 있습니다.

**제약사항:**
루트 도메인(example.com)은 CNAME을 가질 수 없습니다(RFC 제한). CNAME과 다른 레코드(A, MX, TXT)를 동시에 설정할 수 없습니다. 추가 DNS 조회가 필요하여 약간의 지연이 발생합니다.

**주요 차이점:**

**반환 값:**
- **A**: IPv4 주소 (32비트)
- **AAAA**: IPv6 주소 (128비트)
- **CNAME**: 다른 도메인 이름

**용도:**
- **A/AAAA**: 실제 서버의 IP 주소를 지정
- **CNAME**: 도메인 별칭, 서비스 위임, 유연한 관리

**조회 과정:**
- **A/AAAA**: 한 번의 조회로 IP를 얻음
- **CNAME**: CNAME → A/AAAA 두 단계 조회 필요

**사용 예시 비교:**

**Case 1 - A 레코드 사용:**
```
example.com.        IN  A  192.0.2.1
www.example.com.    IN  A  192.0.2.1
```
장점: 빠른 조회. 단점: IP 변경 시 두 곳 수정 필요.

**Case 2 - CNAME 사용:**
```
example.com.        IN  A      192.0.2.1
www.example.com.    IN  CNAME  example.com.
```
장점: IP 변경 시 한 곳만 수정. 단점: 약간의 추가 지연.

**CDN 사용 시:**
```
cdn.example.com.    IN  CNAME  example-com.cdn.provider.net.
```
CDN 제공자가 동적으로 최적 서버를 선택합니다. GeoDNS로 사용자 위치에 따라 다른 IP를 반환합니다.

**실제 조회 예시:**

**A 레코드 조회:**
```
클라이언트 → DNS: "example.com의 A 레코드는?"
DNS → 클라이언트: "192.0.2.1"
```

**CNAME 조회:**
```
클라이언트 → DNS: "www.example.com의 A 레코드는?"
DNS → 클라이언트: "www.example.com은 example.com의 CNAME입니다. example.com의 A는 192.0.2.1입니다"
```

**루트 도메인 CNAME 제약:**
example.com에는 CNAME을 설정할 수 없습니다. MX, SOA, NS 레코드와 충돌하기 때문입니다. 대안으로 ALIAS 레코드(일부 DNS 제공자)나 A/AAAA 레코드를 사용합니다.

**성능 고려:**
A/AAAA 레코드는 직접 IP를 반환하여 가장 빠릅니다. CNAME은 추가 조회로 10-50ms 지연이 발생할 수 있습니다. 하지만 캐싱으로 이후 조회는 빠릅니다.

**선택 기준:**
고정 IP를 가리킬 때: A/AAAA 레코드. 외부 서비스를 가리킬 때: CNAME(CDN, 클라우드 서비스). 여러 별칭이 필요할 때: CNAME. IPv6 지원: AAAA 추가.
