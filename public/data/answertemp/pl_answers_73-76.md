## 질문 73: Python의 데이터 타입과 가변/불변 객체를 설명해주세요.

**정의:**
Python의 데이터 타입은 가변(mutable) 객체와 불변(immutable) 객체로 구분됩니다. 불변 객체는 생성 후 값을 변경할 수 없고, 가변 객체는 내용을 수정할 수 있습니다. 이 구분은 성능, 해싱, 스레드 안전성 등에 영향을 미칩니다.

**특징/원리:**
- 객체 참조: Python의 모든 변수는 객체에 대한 참조를 저장
- 불변성: 불변 객체를 수정하려면 새로운 객체를 생성해야 함
- 가변성: 가변 객체는 동일한 메모리 위치에서 내용을 직접 변경 가능
- 해시 가능성: 불변 객체만 딕셔너리 키나 세트 원소로 사용 가능

**불변 객체:**
- 숫자: int, float, complex는 불변이며 연산 시 새 객체 생성
- 문자열: str은 불변이어서 문자열 조작은 새 문자열 반환
- 튜플: tuple은 불변이지만 내부에 가변 객체를 포함할 수 있음
- frozenset: set의 불변 버전
- bytes: 불변 바이트 시퀀스

**가변 객체:**
- 리스트: list는 가변이어서 append, remove 등으로 직접 수정 가능
- 딕셔너리: dict는 가변이어서 키-값 쌍 추가/삭제 가능
- 세트: set은 가변이어서 원소 추가/제거 가능
- bytearray: 가변 바이트 시퀀스

**가변성의 영향:**
- 함수 인자: 가변 객체를 함수에 전달하면 함수 내에서 수정이 원본에 영향
- 기본 인자: 가변 객체를 기본 인자로 사용하면 모든 호출이 같은 객체 공유
- 복사: 얕은 복사는 가변 객체의 참조를 복사하고, 깊은 복사는 재귀적으로 복사
- 성능: 불변 객체는 수정마다 새 객체 생성으로 오버헤드 발생 가능

**실무 활용:**
- 딕셔너리 키나 세트 원소는 불변 객체만 사용하여 해시 값 일관성 유지
- 함수의 기본 인자로 가변 객체 사용 피하고 None으로 대체
- 불변 객체를 사용하여 스레드 안전성 확보하고 의도치 않은 수정 방지

---

## 질문 74: Python의 얕은 복사와 깊은 복사의 차이점은 무엇인가요?

**정의:**
얕은 복사는 컨테이너의 구조만 복사하고 내부 객체는 참조를 복사하며, 깊은 복사는 중첩된 모든 객체를 재귀적으로 복사하여 완전히 독립적인 복사본을 만듭니다. 가변 객체를 다룰 때 복사 방식에 따라 원본과 복사본의 독립성이 달라집니다.

**특징/원리:**
- 참조 vs 복사: 얕은 복사는 참조만 복사하고, 깊은 복사는 객체 자체를 복사
- 중첩 구조: 중첩된 가변 객체가 있을 때 차이가 명확히 드러남
- 불변 객체: 불변 객체는 복사 방식과 무관하게 안전하게 공유 가능
- copy 모듈: copy.copy()는 얕은 복사, copy.deepcopy()는 깊은 복사 수행

**얕은 복사 방법:**
- 슬라이싱: list[:]나 dict.copy()로 최상위 컨테이너만 복사
- copy.copy(): copy 모듈의 copy() 함수 사용
- 생성자: list(original), dict(original) 등으로 복사
- copy 메서드: 객체의 copy() 메서드 호출

**깊은 복사 방법:**
- copy.deepcopy(): 재귀적으로 모든 중첩 객체 복사
- 순환 참조 처리: deepcopy는 순환 참조를 감지하고 처리
- 커스터마이징: __deepcopy__ 메서드로 깊은 복사 동작 커스터마이징

**복사 시나리오:**
- 중첩 리스트: 얕은 복사는 내부 리스트가 공유되지만, 깊은 복사는 별도로 복사
- 딕셔너리: 값이 가변 객체면 얕은 복사로는 독립성 보장 안 됨
- 사용자 정의 객체: 속성이 가변 객체를 참조하면 깊은 복사 필요

**성능 고려사항:**
- 얕은 복사: 빠르고 메모리 효율적이지만 내부 객체 공유
- 깊은 복사: 느리고 메모리를 많이 사용하지만 완전한 독립성 보장
- 선택 기준: 실제 필요에 따라 적절한 방법 선택

**실무 활용:**
- 설정 객체를 수정할 때 원본을 보존하려면 깊은 복사 사용
- 대용량 데이터는 불필요한 깊은 복사를 피하고 필요한 부분만 복사
- 테스트에서 픽스처를 복사할 때 독립성 필요 여부에 따라 복사 방식 선택

---

## 질문 75: Python의 *args와 **kwargs에 대해 설명해주세요.

**정의:**
*args와 **kwargs는 함수에 가변 개수의 인자를 전달하는 문법입니다. *args는 위치 인자들을 튜플로 수집하고, **kwargs는 키워드 인자들을 딕셔너리로 수집합니다. 이를 통해 유연한 함수 시그니처를 정의할 수 있습니다.

**특징/원리:**
- 언패킹: 별표 연산자로 시퀀스나 매핑을 개별 인자로 펼침
- 수집: 함수 정의에서 여러 인자를 하나의 변수로 모음
- 네이밍: args와 kwargs는 관례적 이름이며 다른 이름 사용 가능
- 순서: 일반 인자, *args, 키워드 전용 인자, **kwargs 순서로 배치

**'*args 사용:**
- 정의: 함수 정의에서 *args로 가변 개수의 위치 인자 받기
- 튜플: 전달된 위치 인자들이 튜플로 수집됨
- 언패킹: 시퀀스 앞에 *를 붙여 개별 인자로 펼침
- 유연성: 인자 개수에 제약 없이 함수 호출 가능

**'**kwargs 사용:**
- 정의: 함수 정의에서 **kwargs로 가변 개수의 키워드 인자 받기
- 딕셔너리: 전달된 키워드 인자들이 딕셔너리로 수집됨
- 언패킹: 딕셔너리 앞에 **를 붙여 키워드 인자로 펼침
- 옵션 전달: 설정 옵션을 유연하게 전달할 때 유용

**매개변수 순서:**
- 위치 매개변수: 필수 위치 인자가 먼저 옴
- *args: 가변 위치 인자
- 키워드 전용 매개변수: *args 뒤의 매개변수는 반드시 키워드로 전달
- **kwargs: 가변 키워드 인자가 마지막
- 기본값: 각 매개변수는 기본값 가질 수 있음

**실무 활용:**
- 데코레이터에서 *args, **kwargs로 원본 함수의 인자를 그대로 전달
- 래퍼 함수나 프록시 함수에서 모든 인자를 다음 함수로 위임
- 설정 옵션이 많은 함수에서 **kwargs로 유연하게 옵션 받기

---

## 질문 76: Python의 데코레이터(Decorator)란 무엇이고 어떻게 동작하나요?

**정의:**
데코레이터는 함수나 클래스를 수정하지 않고 기능을 추가하거나 변경하는 고차 함수입니다. @decorator 문법으로 함수나 클래스 위에 적용하며, 원본 객체를 래핑하여 전후 처리를 추가하거나 동작을 변경합니다.

**특징/원리:**
- 고차 함수: 함수를 인자로 받고 함수를 반환하는 함수
- 문법적 설탕: @decorator는 func = decorator(func)의 간결한 표현
- 클로저: 데코레이터는 클로저를 활용하여 원본 함수를 기억
- 체이닝: 여러 데코레이터를 겹쳐서 적용 가능

**기본 구조:**
- 래퍼 함수: 데코레이터 내부에서 원본 함수를 감싸는 함수 정의
- 원본 호출: 래퍼 함수 내에서 원본 함수 호출
- 반환: 래퍼 함수를 반환하여 원본 함수 대체
- functools.wraps: 원본 함수의 메타데이터 보존

**데코레이터 종류:**
- 함수 데코레이터: 함수에 적용하여 함수 동작 수정
- 클래스 데코레이터: 클래스에 적용하여 클래스 생성 수정
- 메서드 데코레이터: 클래스 메서드에 적용
- 파라미터화 데코레이터: 인자를 받는 데코레이터 팩토리

**파라미터화 데코레이터:**
- 이중 중첩: 데코레이터 팩토리가 실제 데코레이터를 반환
- 설정 전달: 데코레이터의 동작을 인자로 커스터마이징
- 유연성: 같은 데코레이터를 다른 설정으로 재사용

**주요 사용 사례:**
- 로깅: 함수 실행 전후로 로그 기록
- 타이밍: 함수 실행 시간 측정
- 캐싱: 함수 결과를 캐시하여 재사용
- 권한 검사: 함수 실행 전 권한 확인
- 재시도: 실패 시 자동으로 재시도

**내장 데코레이터:**
- @staticmethod: 클래스의 정적 메서드 정의
- @classmethod: 클래스 메서드 정의하며 첫 인자로 클래스 받음
- @property: 메서드를 속성처럼 접근 가능하게 함
- @functools.lru_cache: 함수 결과를 캐싱하여 성능 향상

**실무 활용:**
- Flask/Django에서 @app.route나 @login_required로 라우팅과 인증 처리
- functools.lru_cache로 비용이 큰 함수 결과를 캐싱
- 커스텀 데코레이터로 공통 전처리 로직을 재사용 가능하게 추상화

---
