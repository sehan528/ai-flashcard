## 질문 105: Go의 에러 처리 방식과 모범 사례는 무엇인가요?

**정의:**
Go는 예외(exception) 대신 error 타입을 반환값으로 사용하는 명시적 에러 처리 방식을 채택합니다. 함수는 마지막 반환값으로 error를 반환하고, 호출자는 반드시 에러를 확인하여 처리해야 합니다.

**특징/원리:**
- 명시적: 예외와 달리 에러를 반환값으로 명시적으로 처리
- error 인터페이스: Error() string 메서드만 가진 간단한 인터페이스
- 다중 반환값: 정상 결과와 에러를 함께 반환
- 지역성: 에러 처리 로직이 에러 발생 지점 근처에 위치

**error 인터페이스:**
- 정의: Error() string 메서드만 가진 내장 인터페이스
- errors.New: 간단한 에러 문자열로 에러 생성
- fmt.Errorf: 포맷팅된 에러 메시지 생성
- 커스텀: 구조체에 Error() 메서드 구현하여 풍부한 에러 정보 제공

**에러 체크 패턴:**
- 즉시 확인: 함수 호출 직후 if err != nil로 즉시 확인
- 조기 반환: 에러 발생 시 빠르게 반환하여 중첩 최소화
- 래핑: fmt.Errorf의 %w로 에러를 래핑하여 컨텍스트 추가
- 전파: 에러를 처리하거나 상위 레벨로 전파

**에러 래핑:**
- fmt.Errorf("%w", err): 원본 에러를 래핑하여 컨텍스트 추가
- errors.Unwrap: 래핑된 에러에서 원본 에러 추출
- errors.Is: 에러 체인에서 특정 에러와 일치하는지 확인
- errors.As: 에러 체인에서 특정 타입의 에러 추출

**커스텀 에러:**
- 구조체: 에러 타입을 구조체로 정의하여 추가 정보 포함
- Error() 메서드: 구조체에 Error() 메서드 구현
- 타입 단언: 에러를 특정 타입으로 단언하여 상세 정보 접근
- 센티널 에러: var ErrNotFound = errors.New("not found")처럼 변수로 정의

**모범 사례:**
- 에러 무시 금지: 모든 에러를 확인하고 처리
- 컨텍스트 추가: 에러 발생 위치와 상황을 에러 메시지에 포함
- 에러 래핑: %w로 원본 에러를 보존하면서 컨텍스트 추가
- 에러 타입: 복잡한 에러는 커스텀 타입으로 정의
- 일관성: 패키지 내에서 일관된 에러 처리 패턴 유지

**실무 활용:**
- HTTP 핸들러에서 비즈니스 로직 에러를 적절한 HTTP 상태 코드로 변환
- 에러 래핑으로 호출 스택 정보를 유지하며 디버깅 용이성 향상
- 센티널 에러로 특정 에러 조건을 명시적으로 표현

---

## 질문 106: Go의 컨텍스트(Context) 패키지의 용도와 사용 방법은 무엇인가요?

**정의:**
context 패키지는 요청 범위의 값, 취소 신호, 타임아웃, 데드라인을 고루틴 간에 전파하는 표준 방법을 제공합니다. API 경계를 넘어 요청 수명 주기를 관리하고, 고루틴 트리 전체에 취소 신호를 전파할 수 있습니다.

**특징/원리:**
- 취소 전파: 부모 컨텍스트 취소 시 자식 컨텍스트도 자동 취소
- 타임아웃: 일정 시간 후 자동으로 취소되는 컨텍스트 생성
- 값 전달: 요청 범위의 값을 컨텍스트에 저장하여 전파
- 불변: 컨텍스트는 불변이며 새로운 컨텍스트를 파생하여 사용

**주요 함수:**
- context.Background: 최상위 컨텍스트로 취소되지 않음
- context.TODO: 아직 컨텍스트를 결정하지 못했을 때 사용
- WithCancel: 취소 가능한 컨텍스트와 cancel 함수 반환
- WithTimeout: 타임아웃 후 자동 취소되는 컨텍스트
- WithDeadline: 특정 시각에 취소되는 컨텍스트
- WithValue: 키-값 쌍을 저장하는 컨텍스트

**취소 패턴:**
- cancel 함수: WithCancel이 반환하는 cancel 함수로 명시적 취소
- defer cancel: 함수 반환 시 자동으로 cancel 호출하여 리소스 정리
- Done 채널: ctx.Done() 채널이 닫히면 취소 신호
- select: Done 채널과 작업을 select로 동시 대기

**값 전달:**
- WithValue: 요청 ID, 사용자 정보 등 요청 범위 값 저장
- Value: 키로 값 조회, 없으면 부모 컨텍스트 검색
- 타입 안전: 키는 비교 가능한 타입이며 충돌 방지를 위해 비공개 타입 사용 권장
- 제한적 사용: 값 전달은 요청 범위 데이터에만 사용하고 함수 파라미터로 전달할 데이터는 명시적으로 전달

**타임아웃과 데드라인:**
- WithTimeout: 상대 시간으로 타임아웃 지정
- WithDeadline: 절대 시각으로 데드라인 지정
- 자동 취소: 시간 도래 시 Done 채널이 닫힘
- 조기 취소: cancel 함수로 시간 전에도 취소 가능

**모범 사례:**
- 첫 파라미터: 함수의 첫 번째 파라미터로 Context 전달
- 구조체 금지: Context를 구조체 필드에 저장하지 말고 파라미터로 전달
- cancel 호출: WithCancel, WithTimeout 사용 시 반드시 defer cancel() 호출
- 값 저장 최소화: 컨텍스트 값은 요청 범위 메타데이터에만 사용

**실무 활용:**
- HTTP 핸들러에서 데이터베이스 쿼리나 외부 API 호출에 타임아웃 적용
- gRPC 호출 시 컨텍스트로 취소와 데드라인 전파
- 여러 고루틴을 시작한 후 하나의 cancel로 모두 종료

---

## 질문 107: Go의 sync 패키지의 주요 기능들을 설명해주세요.

**정의:**
sync 패키지는 고루틴 간 동기화를 위한 저수준 프리미티브를 제공합니다. Mutex, RWMutex, WaitGroup, Once, Pool 등으로 공유 자원 보호, 고루틴 조율, 객체 재사용 등을 지원하며, 채널로 해결하기 어려운 문제에 사용합니다.

**특징/원리:**
- 저수준: 채널보다 저수준이지만 더 세밀한 제어 가능
- 성능: 단순 잠금은 채널보다 빠름
- 주의: 잘못 사용하면 데드락이나 경쟁 조건 발생
- 채널 우선: "공유 메모리로 통신하지 말고 통신으로 메모리를 공유" 원칙으로 가능하면 채널 사용

**Mutex:**
- 상호 배제: 한 번에 하나의 고루틴만 임계 영역 실행
- Lock(): 락 획득하며 다른 고루틴이 보유 중이면 대기
- Unlock(): 락 해제하여 다른 고루틴이 획득 가능
- defer: defer mu.Unlock()으로 자동 해제 보장

**RWMutex:**
- 읽기/쓰기 분리: 여러 읽기는 동시 가능하지만 쓰기는 배타적
- RLock/RUnlock: 읽기 락 획득/해제
- Lock/Unlock: 쓰기 락 획득/해제로 모든 접근 차단
- 사용 사례: 읽기가 빈번하고 쓰기가 드문 경우 성능 향상

**WaitGroup:**
- 완료 대기: 여러 고루틴의 완료를 기다림
- Add(n): 대기할 고루틴 개수 증가
- Done(): 고루틴 완료 시 호출 (Add(-1)와 동일)
- Wait(): 모든 고루틴이 Done()을 호출할 때까지 블로킹

**Once:**
- 단 한 번 실행: 여러 고루틴이 호출해도 함수를 단 한 번만 실행
- Do(func()): 첫 호출만 함수 실행하고 이후는 무시
- 초기화: 싱글톤 패턴이나 한 번만 수행할 초기화에 사용
- 스레드 안전: 동시 호출에 안전

**Pool:**
- 객체 재사용: 일시적으로 사용하는 객체를 풀에서 재사용
- Get(): 풀에서 객체 가져오거나 없으면 New 함수로 생성
- Put(x): 객체를 풀에 반환
- GC: 풀의 객체는 언제든 GC될 수 있음
- 사용 사례: 버퍼나 연결 등 생성 비용이 큰 객체 재사용

**실무 활용:**
- Mutex로 카운터나 맵 같은 공유 자원 보호
- WaitGroup으로 워커 고루틴들의 완료를 기다림
- sync.Pool로 JSON 인코더나 버퍼를 재사용하여 GC 부담 감소

---

## 질문 108: Go의 가비지 컬렉션 방식을 설명해주세요.

**정의:**
Go는 동시성 마크-스윕 가비지 컬렉터를 사용하여 사용하지 않는 메모리를 자동으로 회수합니다. 저지연을 목표로 하며 애플리케이션과 병렬로 실행되어 정지 시간을 최소화합니다.

**특징/원리:**
- 동시성: GC가 애플리케이션 고루틴과 동시에 실행
- 마크-스윕: 도달 가능한 객체를 마크하고 나머지를 회수
- 세대별 없음: Go는 세대별 GC를 사용하지 않고 모든 객체를 동일하게 처리
- 삼색 마킹: 흰색(미방문), 회색(방문 중), 검은색(완료)으로 객체 추적

**GC 단계:**
- 마크 설정: GC 시작을 알리고 쓰기 장벽 활성화
- 마크: 루트에서 시작하여 도달 가능한 모든 객체 마크
- 마크 종료: 남은 회색 객체 마크 완료
- 스윕: 마크되지 않은 객체의 메모리 회수

**정지 시간:**
- STW: Stop-The-World 정지는 매우 짧음 (수백 마이크로초)
- 동시 마킹: 대부분의 마킹 작업은 애플리케이션과 동시 실행
- 쓰기 장벽: 포인터 쓰기 시 약간의 오버헤드
- 목표: GC 정지 시간을 수백 마이크로초로 유지

**GC 튜닝:**
- GOGC: 환경 변수로 GC 빈도 조절 (기본 100)
- runtime.GC(): 명시적으로 GC 실행 (일반적으로 권장되지 않음)
- runtime.SetFinalizer: 객체 회수 전 정리 함수 실행
- debug.SetGCPercent: 프로그램 내에서 GOGC 값 변경

**메모리 관리:**
- 힙 할당: 포인터를 반환하거나 인터페이스에 할당되면 힙에 할당
- 스택 할당: 함수 내에서만 사용되는 작은 객체는 스택에 할당
- 탈출 분석: 컴파일러가 객체의 수명을 분석하여 스택/힙 결정
- 메모리 풀: sync.Pool로 객체 재사용하여 GC 부담 감소

**실무 활용:**
- 대부분의 경우 기본 GC 설정이 적합하며 튜닝 불필요
- 지연 시간이 중요한 애플리케이션은 GOGC 조정하여 GC 빈도 제어
- 메모리 프로파일링으로 불필요한 할당 찾아 최적화

---
