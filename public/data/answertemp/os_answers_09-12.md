# OS 답변 9-12

## 9. 인터럽트는 어떻게 처리하나요?

**인터럽트 처리 과정**

**1단계: 인터럽트 감지**
- CPU는 매 명령어 사이클마다 인터럽트 라인을 확인합니다
- 인터럽트 신호가 감지되면 현재 명령어를 완료합니다
- 인터럽트가 마스킹되어 있지 않은지 확인합니다

**2단계: 상태 저장**
- 현재 프로그램 카운터(PC)를 저장합니다
- 프로세서 상태 레지스터(PSW)를 저장합니다
- 필요한 경우 범용 레지스터들을 스택에 저장합니다
- 이 정보들은 나중에 복원하여 중단된 작업을 재개하는 데 사용됩니다

**3단계: 인터럽트 번호 확인**
- 인터럽트 컨트롤러가 어떤 장치에서 인터럽트가 발생했는지 알립니다
- 각 인터럽트는 고유한 번호를 가지고 있습니다
- 우선순위가 높은 인터럽트를 먼저 처리합니다

**4단계: 인터럽트 벡터 조회**
- 인터럽트 벡터 테이블에서 해당 번호의 엔트리를 찾습니다
- 인터럽트 서비스 루틴(ISR)의 주소를 가져옵니다
- 커널 모드로 전환합니다

**5단계: 인터럽트 서비스 루틴 실행**
- ISR이 실제 인터럽트를 처리합니다
- 최소한의 작업만 수행하여 빠르게 완료합니다
- 필요한 경우 하위 절반(Bottom Half) 처리를 스케줄링합니다
- 장치에 인터럽트 처리 완료를 알립니다

**6단계: 상태 복원 및 복귀**
- 저장했던 레지스터와 프로그램 카운터를 복원합니다
- 사용자 모드로 전환합니다
- 인터럽트 복귀 명령어를 실행하여 원래 작업으로 돌아갑니다

**중첩 인터럽트 처리**
- 인터럽트 처리 중 더 높은 우선순위의 인터럽트가 발생할 수 있습니다
- 현재 ISR의 상태를 저장하고 새 인터럽트를 처리합니다
- 우선순위가 낮은 인터럽트는 대기합니다

**상위 절반과 하위 절반**
- 상위 절반(Top Half): 즉시 처리해야 하는 긴급한 작업
- 하위 절반(Bottom Half): 나중에 처리 가능한 지연된 작업
- 이를 통해 ISR의 실행 시간을 최소화합니다

**실무 활용**
리눅스에서는 인터럽트 핸들러를 최대한 짧게 유지하고, 복잡한 처리는 softirq, tasklet, workqueue 등의 메커니즘을 통해 지연 처리합니다. 이는 시스템 응답성을 향상시킵니다.

---

## 10. Polling 방식에 대해 설명해 주세요.

**정의**
폴링(Polling)은 CPU가 주기적으로 장치의 상태를 확인하여 데이터가 준비되었는지 검사하는 방식입니다. 인터럽트 방식과 대조되는 I/O 처리 기법입니다.

**동작 방식**
- CPU가 반복문을 통해 장치의 상태 레지스터를 지속적으로 확인합니다
- 데이터가 준비되었는지 또는 작업이 완료되었는지 검사합니다
- 준비될 때까지 계속 확인하는 busy waiting 상태가 됩니다
- 조건이 만족되면 데이터를 처리하고 다음 작업으로 진행합니다

**장점**
- 구현이 단순하고 이해하기 쉽습니다
- 인터럽트 처리에 따른 오버헤드가 없습니다
- 매우 빠른 응답이 필요한 경우 유리합니다
- 인터럽트 컨텍스트 스위칭 비용이 없습니다
- 예측 가능한 타이밍을 제공합니다

**단점**
- CPU 시간을 낭비합니다
- 대기 중에도 CPU가 계속 동작하여 전력을 소비합니다
- 다른 작업을 수행할 수 없어 시스템 효율성이 떨어집니다
- 여러 장치를 동시에 관리하기 어렵습니다
- 확장성이 제한적입니다

**적합한 사용 사례**
- 이벤트 발생이 매우 빈번한 경우
- 응답 시간이 극도로 중요한 실시간 시스템
- 인터럽트 처리보다 폴링 오버헤드가 작은 경우
- 단순한 임베디드 시스템
- 매우 짧은 대기 시간이 예상되는 경우

**인터럽트 방식과의 비교**
- 폴링: CPU가 능동적으로 확인, CPU 낭비 있음, 구현 간단
- 인터럽트: 장치가 CPU에 알림, CPU 효율적 사용, 복잡한 처리 필요

**하이브리드 접근**
- 일부 시스템은 폴링과 인터럽트를 결합합니다
- 높은 부하 시 폴링 모드로 전환하여 인터럽트 오버헤드를 줄입니다
- 낮은 부하 시 인터럽트 모드로 전환하여 CPU를 절약합니다
- 네트워크 카드의 NAPI(New API)가 대표적인 예입니다

**실무 활용**
고성능 네트워크 장비에서는 패킷 처리율이 매우 높을 때 폴링 방식을 사용하여 인터럽트 스톰을 방지합니다. 반면 일반적인 서버 환경에서는 에너지 효율을 위해 인터럽트 방식을 선호합니다.

---

## 11. HW / SW 인터럽트에 대해 설명해 주세요.

**하드웨어 인터럽트(Hardware Interrupt)**

**정의**
외부 하드웨어 장치가 CPU에 신호를 보내 발생시키는 인터럽트입니다.

**특징**
- 비동기적으로 발생합니다
- 프로그램 실행 흐름과 무관하게 발생합니다
- 인터럽트 라인을 통해 물리적 신호로 전달됩니다
- 언제 발생할지 예측할 수 없습니다

**발생 원인**
- I/O 장치 완료: 디스크 읽기/쓰기 완료, 네트워크 패킷 도착
- 타이머 인터럽트: 일정 시간마다 발생하여 스케줄링에 활용
- 키보드/마우스 입력: 사용자 입력 처리
- 전원 관련 이벤트: 배터리 부족, 전원 버튼 누름
- 하드웨어 오류: 메모리 오류, 과열 등

**처리 방식**
- 인터럽트 컨트롤러가 여러 장치의 인터럽트를 관리합니다
- 우선순위에 따라 처리 순서를 결정합니다
- 마스킹을 통해 일시적으로 비활성화할 수 있습니다

**소프트웨어 인터럽트(Software Interrupt)**

**정의**
프로그램 실행 중 특정 명령어에 의해 의도적으로 발생시키는 인터럽트입니다.

**특징**
- 동기적으로 발생합니다
- 프로그램에서 명시적으로 호출합니다
- 예측 가능하고 제어 가능합니다
- 특정 명령어 실행 결과입니다

**종류**

**1. 트랩(Trap)**
- 의도적으로 발생시키는 소프트웨어 인터럽트입니다
- 시스템 콜이 대표적인 예입니다
- 디버깅을 위한 브레이크포인트도 포함됩니다

**2. 예외(Exception)**
- 프로그램 실행 중 오류로 인해 발생합니다
- 0으로 나누기, 오버플로우, 언더플로우
- 잘못된 메모리 접근(페이지 폴트, 세그먼테이션 폴트)
- 잘못된 명령어 실행

**발생 원인**
- 시스템 콜 호출
- 프로그램 오류 및 예외 상황
- 디버거의 브레이크포인트
- 프로세스 간 통신 신호

**비교**

**시점**
- HW 인터럽트: 비동기적, 예측 불가
- SW 인터럽트: 동기적, 예측 가능

**발생 원인**
- HW 인터럽트: 외부 하드웨어 이벤트
- SW 인터럽트: 프로그램 명령어 또는 오류

**마스킹**
- HW 인터럽트: 대부분 마스킹 가능(NMI 제외)
- SW 인터럽트: 마스킹 불가능

**처리 우선순위**
- HW 인터럽트: 일반적으로 높은 우선순위
- SW 인터럽트: 상대적으로 낮은 우선순위

**실무 활용**
운영체제는 두 가지 인터럽트를 모두 활용하여 효율적인 시스템을 구현합니다. 하드웨어 인터럽트는 외부 이벤트 처리에, 소프트웨어 인터럽트는 시스템 콜과 예외 처리에 사용됩니다.

---

## 12. 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

**우선순위 기반 처리**

**인터럽트 우선순위**
- 각 인터럽트에는 미리 정의된 우선순위가 있습니다
- 전원 오류 > 하드웨어 오류 > 타이머 > I/O 장치 > 소프트웨어 인터럽트 순입니다
- 우선순위가 높은 인터럽트를 먼저 처리합니다
- 시스템 안정성과 응답성을 보장합니다

**동시 발생 시 처리**
- 인터럽트 컨트롤러가 여러 인터럽트를 받으면 우선순위를 비교합니다
- 가장 높은 우선순위의 인터럽트 번호를 CPU에 전달합니다
- 나머지 인터럽트는 대기 큐에 보관됩니다
- 현재 인터럽트 처리가 끝나면 다음 우선순위 인터럽트를 처리합니다

**중첩 인터럽트(Nested Interrupt)**

**개념**
- 인터럽트 처리 중에 더 높은 우선순위의 인터럽트가 발생하는 상황입니다
- 현재 처리 중인 인터럽트를 일시 중단하고 새 인터럽트를 처리합니다

**처리 과정**
1. 인터럽트 A 처리 중
2. 더 높은 우선순위의 인터럽트 B 발생
3. 인터럽트 A의 상태를 저장
4. 인터럽트 B를 처리
5. 인터럽트 A의 상태를 복원
6. 인터럽트 A 처리 재개

**제약**
- 낮은 우선순위의 인터럽트는 높은 우선순위 인터럽트를 중단할 수 없습니다
- 무한 중첩을 방지하기 위해 깊이 제한이 있습니다
- 일부 시스템은 중첩을 허용하지 않습니다

**인터럽트 마스킹**

**선택적 비활성화**
- 중요한 작업 수행 중 특정 인터럽트를 일시적으로 차단합니다
- 크리티컬 섹션 보호에 사용됩니다
- 처리가 완료되면 다시 활성화합니다

**전역 인터럽트 비활성화**
- 모든 인터럽트를 일시적으로 차단합니다
- 매우 짧은 시간 동안만 사용해야 합니다
- 시스템 응답성에 영향을 줄 수 있습니다

**인터럽트 대기 큐**
- 처리되지 못한 인터럽트는 큐에 저장됩니다
- 우선순위 순으로 정렬되어 관리됩니다
- 인터럽트가 활성화되면 큐에서 꺼내어 처리합니다

**실시간 시스템에서의 고려사항**
- 최악의 경우 응답 시간을 보장해야 합니다
- 인터럽트 처리 시간을 최소화합니다
- 우선순위를 신중하게 설정합니다
- 인터럽트 지연 시간을 모니터링합니다

**인터럽트 컨트롤러의 역할**
- 다중 인터럽트 소스를 관리합니다
- 우선순위를 결정하고 CPU에 알립니다
- 인터럽트 마스킹을 지원합니다
- 예: Intel 8259 PIC, APIC, ARM GIC

**실무 활용**
리눅스 커널은 인터럽트 핸들러를 매우 짧게 유지하고, 복잡한 처리는 지연시킵니다. 이를 통해 높은 우선순위의 인터럽트가 신속하게 처리될 수 있도록 보장합니다. 실시간 시스템에서는 인터럽트 우선순위와 처리 시간이 시스템 성능의 핵심 요소입니다.
