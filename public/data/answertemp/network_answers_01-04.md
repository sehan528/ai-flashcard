# Network 답변 01-04

## 질문 1: 쿠키와 세션의 차이에 대해 설명해 주세요.

쿠키와 세션은 모두 HTTP의 Stateless 특성을 보완하여 사용자의 상태 정보를 유지하기 위한 기술입니다. 하지만 저장 위치와 보안성, 생명주기에서 중요한 차이가 있습니다.

**쿠키(Cookie)의 특징:**

첫째, 클라이언트 측에 저장됩니다. 사용자의 브라우저에 텍스트 파일 형태로 저장됩니다. 브라우저가 종료되어도 유지될 수 있습니다. 사용자가 직접 삭제하거나 만료 시간이 지나면 사라집니다.

둘째, 용량 제한이 있습니다. 하나의 쿠키는 최대 4KB까지 저장할 수 있습니다. 하나의 도메인에는 보통 20개 정도의 쿠키를 저장할 수 있습니다. 브라우저 전체로는 약 300개 정도의 쿠키가 제한됩니다.

셋째, 자동으로 전송됩니다. 해당 도메인에 HTTP 요청을 보낼 때마다 쿠키가 자동으로 포함됩니다. 매 요청마다 네트워크 트래픽이 발생합니다. 불필요한 쿠키도 함께 전송될 수 있습니다.

넷째, 보안에 취약합니다. 클라이언트에 저장되므로 사용자가 조작할 수 있습니다. 중요한 정보를 평문으로 저장하면 위험합니다. XSS 공격에 노출될 수 있습니다. HttpOnly와 Secure 플래그로 보안을 강화할 수 있습니다.

다섯째, 만료 시간을 설정할 수 있습니다. Expires나 Max-Age 속성으로 지정합니다. 설정하지 않으면 세션 쿠키가 되어 브라우저 종료 시 삭제됩니다. 장기간 유지되는 영구 쿠키를 만들 수 있습니다.

**세션(Session)의 특징:**

첫째, 서버 측에 저장됩니다. 서버의 메모리나 데이터베이스에 저장됩니다. 클라이언트는 세션 ID만 가지고 있습니다. 실제 데이터는 서버에서 안전하게 관리됩니다.

둘째, 용량 제한이 거의 없습니다. 서버의 메모리가 허용하는 만큼 저장할 수 있습니다. 쿠키보다 많은 정보를 저장할 수 있습니다. 하지만 너무 많이 저장하면 서버 메모리 부담이 증가합니다.

셋째, 세션 ID만 전송됩니다. 클라이언트는 세션 ID를 쿠키에 저장합니다. 매 요청마다 세션 ID만 전송되므로 트래픽이 적습니다. 서버는 세션 ID로 실제 데이터를 조회합니다.

넷째, 상대적으로 보안이 우수합니다. 실제 데이터는 서버에 있어 클라이언트가 조작할 수 없습니다. 세션 ID가 탈취되면 위험하지만, ID 자체는 의미 없는 값입니다. 세션 하이재킹을 방지하기 위한 추가 조치가 필요합니다.

다섯째, 서버 부담이 있습니다. 모든 사용자의 세션 데이터를 서버가 관리해야 합니다. 사용자가 많아지면 메모리 사용량이 증가합니다. 서버가 여러 대인 경우 세션 공유 문제가 발생합니다.

**주요 차이점 비교:**

저장 위치는 쿠키가 클라이언트, 세션이 서버입니다. 보안성은 세션이 더 우수합니다. 서버 부담은 쿠키가 없고 세션은 있습니다. 속도는 쿠키가 더 빠릅니다. 서버 조회가 불필요하기 때문입니다. 용량은 세션이 더 큽니다.

**사용 사례:**

쿠키는 자동 로그인 정보, 장바구니 정보, 사용자 설정, 광고 추적 등에 사용됩니다. 덜 민감한 정보를 저장합니다.

세션은 로그인 상태 유지, 인증 정보, 장바구니(중요한 경우), 임시 데이터 등에 사용됩니다. 보안이 중요한 정보를 저장합니다.

**함께 사용:**

실제로는 쿠키와 세션을 함께 사용합니다. 세션 ID를 쿠키에 저장합니다. 클라이언트는 세션 ID 쿠키를 전송하고, 서버는 이를 통해 세션 데이터를 조회합니다. 이 방식이 가장 일반적입니다.

**대안 기술:**

최근에는 JWT(JSON Web Token)도 많이 사용됩니다. Stateless 방식으로 서버 부담이 없습니다. 토큰에 정보를 담아 전송합니다. 하지만 토큰 크기가 커질 수 있고, 토큰 폐기가 어렵다는 단점이 있습니다.

쿠키와 세션은 각각 장단점이 명확하므로, 상황에 맞게 적절히 선택하거나 조합하여 사용해야 합니다.

## 질문 2: 세션 방식의 로그인 과정에 대해 설명해 주세요.

세션 기반 인증은 전통적이고 널리 사용되는 방식으로, 서버가 사용자의 인증 상태를 기억하는 방법입니다.

**로그인 과정:**

첫째, 사용자가 로그인 폼을 제출합니다. 아이디와 비밀번호를 입력합니다. POST 요청으로 서버에 전송합니다. HTTPS를 사용하여 암호화된 통신을 합니다.

둘째, 서버가 인증 정보를 검증합니다. 데이터베이스에서 사용자 정보를 조회합니다. 저장된 비밀번호 해시와 입력된 비밀번호를 비교합니다. bcrypt, scrypt 같은 단방향 해시 함수를 사용합니다. 솔트(salt)를 함께 사용하여 보안을 강화합니다.

셋째, 인증이 성공하면 세션을 생성합니다. 서버 메모리나 세션 저장소에 세션 데이터를 저장합니다. 고유한 세션 ID를 생성합니다. 랜덤하고 예측 불가능한 값이어야 합니다. UUID나 암호학적으로 안전한 난수를 사용합니다.

넷째, 세션에 사용자 정보를 저장합니다. 사용자 ID, 권한, 로그인 시간 등을 저장합니다. 필요한 최소한의 정보만 저장합니다. 비밀번호 같은 민감한 정보는 저장하지 않습니다.

다섯째, 세션 ID를 클라이언트에 전달합니다. Set-Cookie 헤더로 세션 ID를 쿠키에 저장합니다. 쿠키 이름은 보통 JSESSIONID, PHPSESSID 등입니다. HttpOnly 플래그를 설정하여 JavaScript 접근을 차단합니다. Secure 플래그를 설정하여 HTTPS에서만 전송되도록 합니다. SameSite 속성으로 CSRF 공격을 방지합니다.

여섯째, 클라이언트가 세션 ID를 저장합니다. 브라우저가 쿠키에 세션 ID를 저장합니다. 이후 모든 요청에 자동으로 포함됩니다.

**이후 요청 과정:**

첫째, 클라이언트가 요청을 보냅니다. 자동으로 세션 ID 쿠키가 함께 전송됩니다. Cookie 헤더에 포함됩니다.

둘째, 서버가 세션 ID를 확인합니다. 쿠키에서 세션 ID를 추출합니다. 세션 저장소에서 해당 세션을 조회합니다.

셋째, 세션이 유효한지 검증합니다. 세션이 존재하는지 확인합니다. 만료 시간이 지나지 않았는지 확인합니다. IP 주소나 User-Agent를 검증할 수도 있습니다.

넷째, 세션 데이터를 사용합니다. 세션에서 사용자 정보를 가져옵니다. 권한을 확인하여 접근 제어를 수행합니다. 요청을 처리합니다.

다섯째, 응답을 반환합니다. 필요한 데이터를 응답으로 보냅니다. 세션의 만료 시간을 갱신할 수 있습니다.

**로그아웃 과정:**

첫째, 사용자가 로그아웃을 요청합니다. 로그아웃 버튼을 클릭하거나 엔드포인트를 호출합니다.

둘째, 서버가 세션을 삭제합니다. 세션 저장소에서 해당 세션을 제거합니다. 메모리나 데이터베이스에서 삭제합니다.

셋째, 클라이언트의 쿠키를 삭제합니다. Set-Cookie 헤더로 만료 시간을 과거로 설정합니다. 브라우저가 쿠키를 삭제합니다.

넷째, 로그인 페이지로 리다이렉트합니다. 사용자는 로그아웃 상태가 됩니다.

**세션 만료:**

세션은 일정 시간 후 자동으로 만료됩니다. 보안과 리소스 관리를 위해 필요합니다. 보통 30분에서 1시간 정도로 설정합니다. 활동이 있을 때마다 만료 시간을 연장할 수 있습니다. 완전히 만료되면 다시 로그인해야 합니다.

**보안 고려사항:**

세션 ID는 예측 불가능해야 합니다. 충분히 길고 랜덤한 값을 사용합니다. 최소 128비트 이상의 엔트로피가 권장됩니다.

세션 고정 공격을 방지해야 합니다. 로그인 성공 시 새로운 세션 ID를 발급합니다. 기존 세션 ID를 무효화합니다.

세션 하이재킹을 방지해야 합니다. HTTPS를 사용하여 세션 ID 탈취를 방지합니다. IP 주소나 User-Agent를 추가로 검증합니다. 하지만 이는 동적 IP 환경에서 문제가 될 수 있습니다.

**세션 저장소:**

메모리에 저장하는 것이 가장 빠릅니다. 하지만 서버 재시작 시 모두 사라집니다. 서버가 여러 대면 공유가 어렵습니다.

데이터베이스에 저장하면 영구적입니다. 하지만 매 요청마다 조회하므로 느릴 수 있습니다.

Redis 같은 인메모리 DB를 많이 사용합니다. 빠르면서도 영구적입니다. 여러 서버가 공유할 수 있습니다. TTL을 설정하여 자동 만료가 가능합니다.

**확장성 문제:**

서버가 여러 대일 때 세션 공유가 필요합니다. Sticky Session으로 같은 서버로 라우팅할 수 있습니다. 하지만 로드 밸런싱이 비효율적입니다. Session Clustering으로 모든 서버가 세션을 공유합니다. 중앙 세션 저장소를 사용하는 것이 일반적입니다.

세션 방식은 구현이 간단하고 검증된 방법입니다. 하지만 서버 부담과 확장성 문제가 있어 최근에는 JWT 같은 대안도 함께 고려됩니다.

## 질문 3: HTTP의 특성인 Stateless에 대해 설명해 주세요.

Stateless는 HTTP 프로토콜의 핵심 특성으로, 서버가 클라이언트의 상태를 유지하지 않는다는 의미입니다.

**Stateless의 정의:**

첫째, 각 요청이 독립적입니다. 이전 요청과 다음 요청 간에 연관성이 없습니다. 서버는 과거의 요청을 기억하지 않습니다. 모든 요청은 그 자체로 완전해야 합니다.

둘째, 서버가 상태를 저장하지 않습니다. 클라이언트의 세션 정보를 서버에 저장하지 않습니다. 요청을 처리한 후 그 정보를 버립니다. 다음 요청에서 이전 정보를 사용하지 않습니다.

셋째, 필요한 모든 정보를 요청에 포함해야 합니다. 클라이언트가 컨텍스트를 제공해야 합니다. 헤더, 바디, 쿼리 파라미터 등에 모든 정보를 담습니다. 서버는 요청만 보고 처리할 수 있어야 합니다.

**Stateless의 장점:**

첫째, 확장성이 뛰어납니다. 어떤 서버든 요청을 처리할 수 있습니다. 서버 간 상태 동기화가 불필요합니다. 로드 밸런서가 자유롭게 요청을 분산할 수 있습니다. 서버를 쉽게 추가하거나 제거할 수 있습니다.

둘째, 서버가 단순해집니다. 상태 관리 로직이 필요 없습니다. 메모리 사용량이 줄어듭니다. 복잡도가 낮아집니다. 버그가 줄어듭니다.

셋째, 장애 복구가 쉽습니다. 서버가 다운되어도 다른 서버가 대신 처리합니다. 상태 정보가 없어 복구가 빠릅니다. 무중단 배포가 용이합니다.

넷째, 캐싱이 효율적입니다. 같은 요청은 같은 응답을 반환합니다. 프록시 서버나 CDN에서 캐싱하기 좋습니다. 네트워크 효율성이 높아집니다.

**Stateless의 단점:**

첫째, 매번 인증이 필요합니다. 사용자 식별 정보를 매 요청에 포함해야 합니다. 토큰이나 세션 ID를 계속 전송해야 합니다. 네트워크 오버헤드가 발생합니다.

둘째, 요청이 커질 수 있습니다. 모든 컨텍스트 정보를 포함해야 하므로 크기가 증가합니다. 반복적인 정보를 계속 전송합니다.

셋째, 사용자 경험 유지가 어렵습니다. 로그인 상태, 장바구니, 세션 등을 구현하기 복잡합니다. 추가적인 메커니즘이 필요합니다.

**Stateless를 보완하는 방법:**

쿠키를 사용합니다. 클라이언트가 상태 정보를 저장합니다. 매 요청에 자동으로 포함됩니다. 서버는 여전히 Stateless를 유지합니다.

세션을 사용합니다. 엄밀히는 Stateful 방식입니다. 하지만 세션 ID만 주고받으므로 부분적으로 Stateless 특성을 유지합니다.

토큰을 사용합니다. JWT 같은 토큰에 상태 정보를 담습니다. 클라이언트가 토큰을 저장하고 전송합니다. 서버는 토큰을 검증만 하고 저장하지 않습니다. 완전한 Stateless를 유지합니다.

**Stateful과의 비교:**

Stateful 프로토콜은 연결을 유지합니다. FTP, Telnet 등이 해당합니다. 서버가 클라이언트 상태를 기억합니다. 연결이 끊기면 상태가 사라집니다.

Stateless는 연결과 무관합니다. 매 요청이 새로운 연결입니다. 또는 연결을 재사용해도 상태는 유지하지 않습니다.

**HTTP/1.1의 Keep-Alive:**

TCP 연결을 재사용하는 기능입니다. 하지만 이는 성능 최적화일 뿐입니다. HTTP 자체는 여전히 Stateless입니다. 연결은 유지되지만 상태는 유지되지 않습니다.

**RESTful API와 Stateless:**

REST 아키텍처의 핵심 제약 조건입니다. 서버는 클라이언트 상태를 저장하지 않아야 합니다. 각 요청은 자체 완결적이어야 합니다. 이를 통해 확장성과 신뢰성을 얻습니다.

**실무에서의 적용:**

완전한 Stateless를 유지하기는 어렵습니다. 대부분 세션이나 캐시를 사용합니다. 하지만 가능한 한 Stateless에 가깝게 설계합니다. 상태 정보를 최소화하고, 클라이언트가 많은 정보를 관리하도록 합니다.

마이크로서비스 아키텍처에서는 Stateless가 특히 중요합니다. 각 서비스가 독립적이어야 하기 때문입니다.

Stateless는 HTTP의 단순함과 확장성을 가능하게 하는 핵심 설계 철학입니다.

## 질문 4: Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

이 질문은 HTTP의 Stateless 원칙과 세션 기반 인증의 모순을 지적하는 통찰력 있는 질문입니다.

**세션이 Stateless 원칙에 위배되는 이유:**

첫째, 서버가 상태를 저장합니다. 세션 데이터를 서버 메모리나 저장소에 보관합니다. 클라이언트의 로그인 상태, 권한 등을 기억합니다. 이는 명백히 Stateful 방식입니다.

둘째, 요청 간 연관성이 생깁니다. 세션 ID로 이전 상태를 참조합니다. 첫 로그인 요청과 이후 요청이 연결됩니다. 독립적이지 않습니다.

셋째, 서버 의존성이 생깁니다. 세션을 생성한 서버만 해당 세션을 알고 있을 수 있습니다. Sticky Session이 필요할 수 있습니다. 완전한 수평 확장이 어렵습니다.

**그럼에도 세션을 사용하는 이유:**

첫째, 현실적인 필요 때문입니다. 사용자 인증 상태를 유지해야 합니다. 매 요청마다 아이디와 비밀번호를 보낼 수 없습니다. 보안상 위험하고 사용자 경험이 나쁩니다. 어떤 형태로든 상태 유지가 필요합니다.

둘째, 보안성이 우수합니다. 중요한 정보를 서버에 저장합니다. 클라이언트가 조작할 수 없습니다. 세션 ID만 탈취되면 대응이 가능합니다.

셋째, 즉시 무효화가 가능합니다. 로그아웃 시 세션을 바로 삭제할 수 있습니다. 계정 정지 시 모든 세션을 무효화할 수 있습니다. 토큰 방식에서는 어렵습니다.

넷째, 검증된 방법입니다. 오랜 기간 사용되어 왔습니다. 구현이 간단하고 안정적입니다. 많은 프레임워크가 기본 지원합니다.

**Stateless를 유지하는 대안:**

JWT(JSON Web Token)를 사용합니다. 모든 정보를 토큰에 담습니다. 서버는 토큰을 저장하지 않습니다. 서명을 검증하여 위변조를 방지합니다. 완전한 Stateless를 유지합니다.

하지만 JWT에도 단점이 있습니다. 토큰 크기가 큽니다. 매 요청에 전송되어 네트워크 부담이 있습니다. 토큰을 즉시 무효화하기 어렵습니다. 만료 전까지는 유효합니다. 블랙리스트를 유지하면 결국 Stateful이 됩니다.

**절충안:**

실무에서는 완전한 Stateless를 추구하기보다 실용성을 택합니다. 세션을 사용하되 확장성을 고려합니다. Redis 같은 공유 세션 저장소를 사용합니다. 모든 서버가 세션에 접근할 수 있습니다.

또는 JWT와 세션을 혼용합니다. JWT로 기본 인증을 하고, 중요한 작업에만 추가 검증을 합니다.

**Stateless의 재해석:**

엄밀히 말하면 HTTP 프로토콜 자체는 Stateless를 유지합니다. 각 HTTP 요청과 응답은 독립적입니다. 프로토콜 레벨에서는 상태를 저장하지 않습니다.

애플리케이션 레벨에서 세션을 사용하는 것은 다른 문제입니다. HTTP 위에 Stateful한 애플리케이션을 구축하는 것입니다. 이는 HTTP 프로토콜의 Stateless 원칙을 위반하는 것이 아닙니다.

**트레이드오프:**

완전한 Stateless는 이상적이지만 현실적으로 어렵습니다. 세션은 Stateful하지만 실용적입니다. 각 방식의 장단점을 이해하고 상황에 맞게 선택해야 합니다.

확장성이 최우선이면 JWT 같은 Stateless 방식을 선택합니다. 보안과 제어가 중요하면 세션을 선택합니다. 대부분의 경우 세션 방식으로 충분합니다.

**마이크로서비스 환경:**

서비스 간 통신에서는 Stateless가 중요합니다. JWT를 많이 사용합니다. 각 서비스가 독립적으로 토큰을 검증합니다. 중앙 세션 저장소에 의존하지 않습니다.

하지만 클라이언트와의 첫 인증은 세션을 사용할 수 있습니다. 내부 서비스 호출은 JWT를 사용합니다. 하이브리드 방식입니다.

**결론:**

세션은 HTTP의 Stateless 원칙에는 어긋나지만, 웹 애플리케이션의 실제 요구사항을 만족시키는 실용적인 방법입니다. 적절하지 않다기보다는, 필요에 따라 Stateless 원칙을 유연하게 적용한 것입니다. 중요한 것은 각 방식의 트레이드오프를 이해하고, 시스템의 요구사항에 맞는 선택을 하는 것입니다.
