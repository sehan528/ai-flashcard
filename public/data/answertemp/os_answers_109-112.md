# OS 답변 109-112

## 109. 동기화를 구현하기 위한 하드웨어적인 해결 방법에 대해 설명해 주세요.

**기본 개념**

소프트웨어만으로는 완벽한 동기화를 구현하기 어렵습니다. 하드웨어가 제공하는 원자적 명령어가 동기화의 기초가 되며, 이를 바탕으로 락, 세마포어, 뮤텍스 등을 구현합니다.

**Test-and-Set**

TAS는 가장 기본적인 원자적 명령어입니다. 메모리 값을 읽고, 1로 설정하고, 이전 값을 반환하는 작업을 원자적으로 수행합니다. 중간에 인터럽트되거나 다른 프로세서가 개입할 수 없습니다. 스핀락 구현에 직접 사용되며, 이전 값이 0이면 락 획득 성공, 1이면 실패입니다. 루프에서 반복 시도하여 락이 해제될 때까지 대기합니다.

**Compare-and-Swap**

CAS는 더 유연한 원자적 명령어입니다. 메모리 값을 예상 값과 비교하여, 일치하면 새 값으로 교체하고 성공을 반환합니다. 일치하지 않으면 교체하지 않고 실패를 반환합니다. 락 프리 자료구조의 핵심이며, 포인터를 원자적으로 교체하는 데 사용됩니다. x86의 CMPXCHG, ARM의 LDREX/STREX가 이를 제공합니다.

**Fetch-and-Add**

FAA는 메모리 값을 읽고, 지정된 수를 더하고, 이전 값을 반환하는 원자적 연산입니다. 카운터 증가에 이상적이며, 락 없이 안전하게 수행할 수 있습니다. 티켓 락 구현에 사용되어, 공정한 락 획득 순서를 보장합니다. x86의 XADD 명령어가 이를 지원합니다.

**Load-Linked / Store-Conditional**

LL/SC는 ARM과 RISC-V에서 사용하는 쌍 명령어입니다. LL은 메모리를 읽고 모니터링을 시작합니다. SC는 모니터링 기간 동안 다른 프로세서가 수정하지 않았으면 쓰기를 성공시키고, 수정되었으면 실패합니다. CAS와 유사하지만 더 유연하며, ABA 문제를 자연스럽게 해결합니다. 루프에서 재시도하여 원자성을 보장합니다.

**메모리 배리어**

원자적 연산만으로는 부족하고, 메모리 순서 보장이 필요합니다. 컴파일러와 CPU는 최적화를 위해 명령어 순서를 바꿀 수 있습니다. 메모리 배리어는 특정 순서를 강제하는 명령어입니다. Acquire 배리어는 이후 연산이 앞으로 이동하지 못하게 하고, Release 배리어는 이전 연산이 뒤로 이동하지 못하게 합니다. Full 배리어는 양방향 모두 차단합니다.

**원자적 변수**

C++의 std::atomic, Java의 AtomicInteger는 원자적 연산을 제공합니다. 내부적으로 하드웨어 원자적 명령어를 사용합니다. 읽기, 쓰기, 증가, CAS 등을 원자적으로 수행할 수 있습니다. 메모리 순서도 지정하여 필요한 수준의 동기화를 선택합니다. 락보다 가볍고 빠르지만, 복잡한 연산에는 부적합합니다.

**트랜잭셔널 메모리**

Intel TSX나 IBM Power의 HTM은 하드웨어 트랜잭셔널 메모리를 제공합니다. 트랜잭션 블록 내 연산을 원자적으로 수행하고, 충돌 시 자동 롤백합니다. 명시적 락 없이 복잡한 동기화를 구현할 수 있습니다. 하지만 용량 제한과 예측 불가능성으로 아직 널리 사용되지 않습니다.

**실무 활용**

뮤텍스와 세마포어는 내부적으로 이런 원자적 명령어를 사용합니다. 운영체제 커널의 스핀락은 TAS나 CAS로 구현됩니다. 락 프리 큐는 CAS로 헤드와 테일을 원자적으로 업데이트합니다. 원자적 카운터는 FAA로 구현되어 락 오버헤드 없이 동작합니다. 하드웨어 지원은 효율적인 동기화의 필수 요소입니다.

---

## 110. volatile 키워드는 어떤 의미가 있나요?

**기본 개념**

volatile은 컴파일러에게 특정 변수가 예상치 못하게 변경될 수 있음을 알리는 키워드입니다. 컴파일러 최적화를 억제하여 매번 메모리에서 값을 읽고 쓰도록 강제합니다.

**컴파일러 최적화 문제**

컴파일러는 변수를 레지스터에 캐시하여 반복 접근을 최적화합니다. 루프에서 변수를 읽으면, 첫 번째만 메모리에서 읽고 이후는 레지스터를 사용합니다. 하지만 멀티스레드 환경에서 다른 스레드가 변수를 변경하면, 레지스터 값은 최신이 아닙니다. volatile은 매번 메모리를 읽도록 하여 최신 값을 보장합니다.

**volatile의 동작**

volatile 변수에 접근할 때마다 실제 메모리를 읽고 씁니다. 컴파일러는 해당 변수를 레지스터에 캐시하거나, 접근을 제거하거나, 순서를 바꿀 수 없습니다. 코드에 나타난 순서대로 메모리 연산이 수행됩니다. 이는 외부 변경을 감지하고 반영하는 데 중요합니다.

**멀티스레드에서의 한계**

volatile만으로는 스레드 안전성을 보장할 수 없습니다. 읽기와 쓰기가 원자적이 아니며, 증가 연산 같은 복합 연산도 안전하지 않습니다. 64비트 변수는 32비트 시스템에서 두 번의 연산으로 나뉘어 중간 상태가 보일 수 있습니다. 메모리 배리어를 제공하지 않아 순서 문제도 해결하지 못합니다.

**올바른 사용 사례**

하드웨어 레지스터 접근에 사용됩니다. MMIO로 매핑된 디바이스 레지스터는 하드웨어가 비동기적으로 변경하므로 volatile이 필수입니다. 시그널 핸들러에서 설정하는 플래그도 volatile로 선언합니다. 메인 루프가 플래그를 확인할 때 최신 값을 읽도록 보장합니다.

**잘못된 사용**

멀티스레드 동기화에 volatile을 사용하는 것은 잘못되었습니다. 원자성과 메모리 순서를 보장하지 않아 경쟁 조건이 발생합니다. 대신 atomic 변수나 뮤텍스를 사용해야 합니다. C++의 std::atomic은 volatile의 기능에 원자성과 메모리 순서를 추가합니다.

**Java의 volatile**

Java의 volatile은 C/C++보다 강한 보장을 제공합니다. happens-before 관계를 수립하여 메모리 배리어 역할을 합니다. volatile 쓰기 전 연산이 모두 완료되고, volatile 읽기 후 연산이 시작됩니다. 이는 제한적이지만 유효한 동기화 메커니즘입니다. 하지만 복합 연산은 여전히 unsafe합니다.

**C/C++에서의 대안**

원자적 변수를 사용하는 것이 더 안전합니다. C11의 _Atomic, C++11의 std::atomic이 적절한 선택입니다. 메모리 순서를 명시하여 필요한 수준의 동기화를 선택할 수 있습니다. 복잡한 동기화는 뮤텍스나 세마포어를 사용합니다.

**실무 권장사항**

volatile은 매우 제한적인 상황에서만 사용합니다. 디바이스 드라이버에서 MMIO 접근이 대표적입니다. 일반 애플리케이션 코드에서는 거의 필요 없습니다. 멀티스레드 동기화는 올바른 도구를 사용해야 하며, volatile은 충분하지 않습니다. 컴파일러 최적화를 이해하고 적절한 메커니즘을 선택하는 것이 중요합니다.

---

## 111. 싱글코어가 아니라 멀티코어라면, 어떻게 동기화가 이뤄질까요?

**기본 개념**

멀티코어 시스템에서 동기화는 싱글코어보다 훨씬 복잡합니다. 각 코어가 독립적으로 실행되고 자체 캐시를 가지므로, 추가적인 메커니즘이 필요합니다.

**원자적 명령어와 캐시 일관성**

멀티코어에서 원자적 명령어는 버스 잠금이나 캐시 일관성 프로토콜과 함께 동작합니다. CAS 명령어 실행 시 해당 캐시 라인을 배타적으로 획득합니다. 다른 코어가 같은 라인에 접근하지 못하도록 차단합니다. MESI 프로토콜로 다른 코어의 복사본을 무효화합니다. 연산 완료 후 락을 해제하고, 다른 코어가 접근할 수 있게 합니다.

**메모리 일관성 모델**

각 아키텍처는 메모리 일관성 모델을 정의합니다. x86은 강한 순서를 제공하여 대부분의 연산이 순서대로 관찰됩니다. ARM은 약한 순서로 성능을 위해 재배치를 허용하지만, 명시적 배리어가 필요합니다. 메모리 배리어 명령어로 특정 순서를 강제하여 동기화를 구현합니다.

**캐시 라인 경쟁**

여러 코어가 같은 캐시 라인을 수정하려 하면 핑퐁 현상이 발생합니다. 소유권이 코어 간 이동하며 성능이 저하됩니다. False Sharing은 실제로는 다른 변수인데 같은 캐시 라인에 있어서 발생합니다. 이를 방지하려면 변수를 캐시 라인 경계에 맞춰 배치합니다. 패딩을 추가하여 독립적인 변수가 라인을 공유하지 않도록 합니다.

**락의 확장성 문제**

하나의 뮤텍스를 여러 코어가 경쟁하면 확장성이 떨어집니다. 락을 획득한 코어만 진행하고 나머지는 대기합니다. 스핀락은 CPU를 낭비하고, 블로킹 락은 컨텍스트 스위칭 오버헤드가 큽니다. 락 분할로 여러 락을 사용하여 경쟁을 줄입니다. 락 프리 알고리즘으로 락 없이 동기화합니다.

**락 프리 자료구조**

CAS를 사용하여 포인터를 원자적으로 교체합니다. 스택은 헤드 포인터를 CAS로 업데이트하여 push와 pop을 구현합니다. 큐는 헤드와 테일 포인터를 독립적으로 관리하여 병렬성을 높입니다. 재시도 루프로 충돌 시 다시 시도합니다. 락 경쟁이 없어 확장성이 우수하지만, 구현이 매우 어렵습니다.

**NUMA 고려사항**

대규모 시스템은 NUMA 아키텍처를 사용합니다. 각 소켓마다 로컬 메모리가 있어서, 로컬 접근이 원격보다 빠릅니다. 동기화 데이터를 적절한 노드에 배치하여 성능을 최적화합니다. 원격 원자적 연산은 로컬보다 훨씬 느리므로, 지역성을 고려한 설계가 필요합니다.

**소프트웨어 트랜잭셔널 메모리**

STM은 트랜잭션으로 동기화를 추상화합니다. 여러 변수 업데이트를 트랜잭션으로 묶어 원자적으로 수행합니다. 충돌 감지 후 롤백과 재시도로 일관성을 보장합니다. 명시적 락 없이 동기화할 수 있지만, 오버헤드와 성능 예측 어려움이 있습니다.

**실무 전략**

락 경쟁을 최소화하도록 설계합니다. 읽기 전용 데이터는 락 없이 공유합니다. 쓰기는 로컬 버퍼에 모았다가 배치 처리합니다. 작업을 분할하여 각 코어가 독립적으로 처리하도록 합니다. 프로파일러로 락 경쟁과 캐시 일관성 미스를 측정합니다. 멀티코어 확장성은 알고리즘과 자료구조 설계에서부터 고려해야 합니다.

---

## 112. 페이지 교체 알고리즘에 대해 설명해 주세요.

**기본 개념**

페이지 교체 알고리즘은 물리 메모리가 부족할 때 어느 페이지를 스왑 아웃할지 결정하는 정책입니다. 목표는 페이지 폴트율을 최소화하여 성능을 높이는 것입니다.

**FIFO**

First-In-First-Out은 가장 오래 전에 로드된 페이지를 교체합니다. 큐로 구현하여 새 페이지는 뒤에 추가하고, 교체할 때는 앞에서 제거합니다. 구현이 매우 간단하지만 성능은 좋지 않습니다. 자주 사용되는 페이지도 오래되었다는 이유로 교체될 수 있습니다. Belady's Anomaly로 프레임 수를 늘려도 폴트가 증가할 수 있습니다.

**LRU**

Least Recently Used는 가장 오랫동안 사용되지 않은 페이지를 교체합니다. 시간적 지역성에 기반하여, 최근에 사용된 페이지는 곧 다시 사용될 가능성이 높다고 가정합니다. 이론적으로 최적에 가까운 성능을 제공하지만, 구현이 복잡하고 비용이 큽니다. 각 페이지의 마지막 접근 시간을 추적해야 하며, 이는 하드웨어 지원 없이 어렵습니다.

**LRU 근사 - Clock 알고리즘**

Reference 비트를 사용한 간단한 LRU 근사입니다. 페이지 접근 시 하드웨어가 Reference 비트를 1로 설정합니다. 교체 필요 시 원형 리스트를 순회하며 Reference 비트를 확인합니다. 1이면 0으로 바꾸고 넘어가고, 0이면 해당 페이지를 교체합니다. 한 바퀴 돌면 모든 비트가 0이 되어 다음 페이지가 선택됩니다. 하드웨어 지원이 최소화되고 성능도 괜찮습니다.

**Second Chance**

FIFO에 Reference 비트를 추가한 개선 버전입니다. FIFO 순서로 페이지를 확인하되, Reference 비트가 1이면 0으로 바꾸고 큐의 뒤로 이동시킵니다. 0이면 즉시 교체합니다. 최근 사용된 페이지는 두 번째 기회를 얻습니다. Clock 알고리즘과 유사하지만 큐 기반 구현입니다.

**Enhanced Second Chance**

Reference 비트와 Dirty 비트를 모두 사용합니다. 네 가지 클래스로 페이지를 분류합니다. 최근 사용되지 않고 깨끗한 페이지가 최우선 교체 대상입니다. 다음은 최근 사용되지 않았지만 수정된 페이지입니다. 최근 사용되었고 깨끗한 페이지, 최근 사용되고 수정된 페이지 순입니다. Dirty 페이지는 디스크 쓰기가 필요하므로 비용이 크기 때문입니다.

**LFU**

Least Frequently Used는 가장 적게 사용된 페이지를 교체합니다. 각 페이지의 참조 횟수를 카운트하여 가장 낮은 것을 선택합니다. 초기에 많이 사용되었지만 이후 사용되지 않는 페이지가 남는 문제가 있습니다. 구현도 복잡하여 실제로는 거의 사용되지 않습니다.

**MRU**

Most Recently Used는 가장 최근에 사용된 페이지를 교체합니다. 일반적으로는 역효과이지만, 특정 접근 패턴에서 유리할 수 있습니다. 순차 스캔처럼 한 번 사용한 페이지를 다시 사용하지 않는 경우입니다. 데이터베이스 테이블 스캔에서 제한적으로 사용됩니다.

**Optimal 알고리즘**

미래에 가장 오랫동안 사용되지 않을 페이지를 교체합니다. 이론적으로 최소 페이지 폴트를 보장하지만, 미래를 알 수 없어 구현 불가능합니다. 다른 알고리즘의 성능을 평가하는 기준으로 사용됩니다. 시뮬레이션에서 접근 기록을 역순으로 분석하여 구현할 수 있습니다.

**실무 선택**

리눅스는 LRU 변형인 Active/Inactive 리스트를 사용합니다. 페이지를 Active와 Inactive 리스트로 나누어 관리합니다. Clock 알고리즘 기반으로 효율적으로 동작합니다. 윈도우도 유사한 Clock 변형을 사용합니다. 실제 시스템은 간단하면서도 효과적인 알고리즘을 선호하며, LRU의 복잡한 완전 구현은 피합니다.
