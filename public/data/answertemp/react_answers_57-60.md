# React 답변 57-60

## 질문 57: Reconciliation 알고리즘이란 무엇인가요?

**정의:**
Reconciliation은 React가 Virtual DOM의 변경사항을 실제 DOM에 효율적으로 반영하는 알고리즘입니다. 이전 트리와 새 트리를 비교하여 최소한의 DOM 조작으로 업데이트를 수행합니다.

**Reconciliation의 필요성:**
- DOM 조작은 비용이 비쌉니다. 최소화해야 합니다.
- 전체 트리를 비교하면 O(n³) 복잡도입니다. 매우 느립니다.
- 효율적인 알고리즘으로 O(n)으로 줄입니다.
- 빠른 업데이트로 좋은 사용자 경험을 제공합니다.

**Diffing 알고리즘:**
- 두 가지 가정을 기반으로 합니다.
- 다른 타입의 요소는 다른 트리를 생성합니다.
- key prop으로 자식 요소를 식별합니다.
- 이 휴리스틱으로 성능과 정확성의 균형을 맞춥니다.

**요소 타입 비교:**
- 타입이 다르면 이전 트리를 파괴하고 새로 만듭니다.
- componentWillUnmount가 호출됩니다.
- 새 DOM 노드가 삽입됩니다.
- componentDidMount가 호출됩니다.
- state도 모두 사라집니다.

**같은 타입의 DOM 요소:**
- 속성만 업데이트합니다.
- className이나 style 등의 변경만 적용합니다.
- 자식 요소를 재귀적으로 처리합니다.
- DOM 노드는 유지됩니다.

**같은 타입의 컴포넌트:**
- 인스턴스는 유지되어 state가 보존됩니다.
- props를 업데이트합니다.
- componentDidUpdate가 호출됩니다.
- render를 호출하여 새 결과를 얻습니다.
- 재귀적으로 하위를 비교합니다.

**자식 요소 재조정:**
- 기본적으로 순서대로 비교합니다.
- 끝에 추가하는 것은 효율적입니다.
- 앞에 추가하면 모든 자식을 다시 만듭니다.
- key가 없으면 비효율적입니다.

**key의 역할:**
- 자식을 고유하게 식별합니다.
- key가 같으면 같은 요소로 인식합니다.
- 위치가 바뀌어도 재사용할 수 있습니다.
- 효율적인 리스트 업데이트가 가능합니다.
- 안정적이고 예측 가능해야 합니다.

**최적화 전략:**
- shouldComponentUpdate로 불필요한 비교를 건너뜁니다.
- PureComponent는 얕은 비교를 수행합니다.
- React.memo로 함수형 컴포넌트를 최적화합니다.
- key를 올바르게 사용합니다.

**Fiber와의 관계:**
- Fiber는 Reconciliation의 새로운 구현입니다.
- 작업을 중단하고 재개할 수 있습니다.
- 우선순위를 설정할 수 있습니다.
- 더 유연하고 강력합니다.

**실무 활용:**
- 컴포넌트 타입을 안정적으로 유지합니다.
- key를 올바르게 사용하여 성능을 최적화합니다.
- 불필요한 리렌더링을 방지합니다.
- React가 내부적으로 처리하므로 대부분 신경 쓸 필요 없습니다.
- 성능 문제가 있을 때만 깊이 이해하면 됩니다.

---

## 질문 58: React Fiber 아키텍처란 무엇인가요?

**정의:**
React Fiber는 React 16에서 도입된 새로운 재조정 엔진입니다. 렌더링 작업을 작은 단위로 나누고 우선순위를 지정하여 중단하고 재개할 수 있게 만듭니다.

**Fiber 이전의 문제:**
- 동기적 렌더링으로 한번 시작하면 멈출 수 없었습니다.
- 큰 컴포넌트 트리는 메인 스레드를 블로킹했습니다.
- 애니메이션이 끊기고 입력이 지연되었습니다.
- 우선순위를 조정할 수 없었습니다.
- 사용자 경험이 저하되었습니다.

**Fiber의 핵심 개념:**
- 작업을 작은 단위로 분할합니다. Fiber 노드 단위입니다.
- 우선순위를 할당할 수 있습니다.
- 작업을 중단하고 나중에 재개할 수 있습니다.
- 완료된 작업을 재사용할 수 있습니다.
- 다른 타입의 업데이트에 다른 우선순위를 줍니다.

**Fiber 노드:**
- 각 컴포넌트나 요소마다 하나의 Fiber가 있습니다.
- Virtual DOM의 노드와 유사합니다.
- 작업 단위로 기능합니다.
- 추가 정보를 저장합니다. 우선순위, 상태 등입니다.

**두 단계 렌더링:**
- Render Phase: Virtual DOM을 생성하고 변경사항을 계산합니다. 중단 가능합니다.
- Commit Phase: 실제 DOM에 변경사항을 적용합니다. 중단 불가능합니다.
- 분리로 유연성이 생깁니다.

**우선순위 스케줄링:**
- 사용자 인터랙션이 가장 높은 우선순위입니다.
- 애니메이션이 다음 우선순위입니다.
- 데이터 페칭은 낮은 우선순위입니다.
- 긴급한 작업을 먼저 처리합니다.
- 부드러운 사용자 경험을 제공합니다.

**시간 분할:**
- 브라우저에 제어권을 주기적으로 돌려줍니다.
- requestIdleCallback을 활용합니다.
- 메인 스레드를 블로킹하지 않습니다.
- 60fps를 유지할 수 있습니다.

**Concurrent 기능:**
- Fiber가 Concurrent Mode의 기반입니다.
- 여러 업데이트를 동시에 준비할 수 있습니다.
- 더 중요한 업데이트로 전환할 수 있습니다.
- 사용자 경험이 크게 향상됩니다.

**개발자 관점:**
- 대부분 투명하게 작동합니다.
- API 변경이 거의 없었습니다.
- 기존 코드가 그대로 작동합니다.
- 성능 향상을 자동으로 얻습니다.
- 새로운 기능의 기반이 됩니다.

**실무 영향:**
- React 16 이상을 사용하면 자동으로 적용됩니다.
- 대부분의 경우 직접 다룰 필요가 없습니다.
- Concurrent 기능을 사용하면 더 큰 이점을 얻습니다.
- 성능 개선이 눈에 띄게 나타납니다.
- 미래 React 기능의 토대입니다.

---

## 질문 59: Suspense는 무엇이고 어떻게 사용하나요?

**정의:**
Suspense는 컴포넌트가 렌더링할 준비가 될 때까지 기다리고 그동안 폴백 UI를 보여주는 React 컴포넌트입니다. 비동기 작업의 로딩 상태를 선언적으로 처리합니다.

**Suspense의 목적:**
- 로딩 상태를 선언적으로 처리합니다.
- 여러 컴포넌트의 로딩을 조율할 수 있습니다.
- 코드 스플리팅을 쉽게 만듭니다.
- 데이터 페칭을 우아하게 처리합니다.
- 사용자 경험을 향상시킵니다.

**기본 사용법:**
- Suspense로 컴포넌트를 감쌉니다.
- fallback prop에 로딩 UI를 지정합니다.
- 자식이 준비될 때까지 fallback을 보여줍니다.
- 준비되면 자식을 렌더링합니다.

**코드 스플리팅과 함께:**
- React.lazy와 함께 사용합니다.
- 동적 import로 컴포넌트를 로드합니다.
- 로딩 중에 스피너를 보여줍니다.
- 번들 크기를 줄일 수 있습니다.
- 필요할 때만 코드를 로드합니다.

**중첩 Suspense:**
- 여러 Suspense를 중첩할 수 있습니다.
- 세밀한 로딩 상태 제어가 가능합니다.
- 가장 가까운 Suspense가 활성화됩니다.
- 부분적 로딩을 구현할 수 있습니다.

**데이터 페칭:**
- Suspense for Data Fetching은 실험적 기능입니다.
- Relay나 React Query와 통합됩니다.
- Promise를 throw하면 Suspense가 잡습니다.
- 데이터가 준비되면 컴포넌트를 렌더링합니다.
- 선언적 데이터 로딩이 가능해집니다.

**Error Boundary와 조합:**
- 에러 처리와 로딩 처리를 분리합니다.
- Suspense는 로딩을 Error Boundary는 에러를 처리합니다.
- 함께 사용하면 강력합니다.
- 포괄적인 비동기 처리가 가능합니다.

**SSR과 Suspense:**
- React 18에서 SSR Suspense를 지원합니다.
- 선택적 hydration이 가능합니다.
- 스트리밍 SSR을 구현할 수 있습니다.
- 페이지 일부를 먼저 보여줄 수 있습니다.

**현재 상태와 미래:**
- 코드 스플리팅은 안정적입니다.
- 데이터 페칭은 실험적입니다.
- React 18에서 많은 개선이 있었습니다.
- 점진적으로 더 많은 기능이 추가됩니다.

**실무 활용:**
- 라우트 레벨 코드 스플리팅에 사용합니다.
- 무거운 컴포넌트를 지연 로딩합니다.
- 로딩 상태를 일관되게 처리합니다.
- React Query나 Relay와 함께 사용합니다.
- 안정적인 기능부터 도입합니다.

---

## 질문 60: Concurrent Mode(동시성 모드)란 무엇인가요?

**정의:**
Concurrent Mode는 React 18의 핵심 기능으로, 여러 작업을 동시에 준비하고 우선순위에 따라 전환할 수 있게 하는 렌더링 모드입니다. 사용자 경험을 크게 향상시키는 강력한 기능입니다.

**Concurrent의 의미:**
- 여러 작업을 번갈아 수행합니다.
- 병렬 처리가 아닌 동시성입니다.
- 중요한 작업을 우선 처리합니다.
- 덜 중요한 작업을 중단하고 나중에 재개합니다.
- 메인 스레드를 효율적으로 사용합니다.

**주요 이점:**
- 앱이 더 반응적입니다. 입력이 즉시 반영됩니다.
- 긴 렌더링이 UI를 블로킹하지 않습니다.
- 부드러운 애니메이션을 유지합니다.
- 우선순위에 따라 작업을 조절합니다.
- 사용자 경험이 크게 향상됩니다.

**핵심 기능들:**
- useTransition: 덜 긴급한 업데이트를 표시합니다.
- useDeferredValue: 값 업데이트를 지연시킵니다.
- Suspense: 로딩 상태를 선언적으로 처리합니다.
- Automatic Batching: 모든 업데이트를 자동 배치합니다.
- startTransition: 비긴급 업데이트를 표시합니다.

**useTransition:**
- 상태 업데이트를 transition으로 표시합니다.
- isPending으로 로딩 상태를 알 수 있습니다.
- 긴급한 업데이트가 있으면 중단됩니다.
- 검색이나 필터링에 유용합니다.
- UI를 차단하지 않습니다.

**useDeferredValue:**
- 값의 업데이트를 지연시킵니다.
- 이전 값을 유지하다가 시간이 되면 업데이트합니다.
- 무거운 컴포넌트 렌더링을 지연시킵니다.
- 입력 응답성을 유지합니다.
- Throttling이나 Debouncing의 선언적 대안입니다.

**Automatic Batching:**
- 여러 상태 업데이트를 자동으로 묶습니다.
- 이벤트 핸들러뿐 아니라 모든 곳에서 작동합니다.
- Promise, setTimeout에서도 배치됩니다.
- 리렌더링 횟수가 줄어듭니다.
- 성능이 자동으로 향상됩니다.

**사용 시나리오:**
- 큰 리스트 필터링: 입력은 즉시 반응하고 리스트는 천천히 업데이트됩니다.
- 탭 전환: 새 탭 내용을 준비하면서 이전 탭을 유지합니다.
- 검색: 타이핑은 빠르게 반응하고 결과는 지연 표시됩니다.
- 복잡한 렌더링: 우선순위가 높은 UI를 먼저 처리합니다.

**활성화 방법:**
- React 18의 createRoot를 사용합니다.
- 별도 모드 설정이 필요 없습니다.
- 자동으로 활성화됩니다.
- 새로운 Hook을 사용하여 기능을 활용합니다.

**하위 호환성:**
- 기존 코드는 그대로 작동합니다.
- 점진적으로 새 기능을 도입할 수 있습니다.
- 필요한 곳에서만 사용하면 됩니다.
- 파괴적 변경이 거의 없습니다.

**실무 활용:**
- React 18로 업그레이드합니다.
- createRoot를 사용하여 Concurrent 기능을 활성화합니다.
- 검색이나 필터에 useTransition을 적용합니다.
- 무거운 렌더링에 useDeferredValue를 사용합니다.
- 사용자 경험 개선이 눈에 띄게 나타납니다.

---
