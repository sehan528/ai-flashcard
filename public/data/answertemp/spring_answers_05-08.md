# Spring 답변 5-8

## 질문 5: JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?

아니요, JVM과 그 내부에서 실행되는 자바 프로그램은 전통적인 부모-자식 프로세스 관계가 아닙니다.

운영체제 관점에서 보면 JVM 자체가 하나의 프로세스입니다. 자바 애플리케이션을 실행하면 JVM 프로세스가 시작되고, 자바 프로그램은 이 JVM 프로세스 내부에서 스레드로 실행됩니다. 따라서 자바 프로그램은 별도의 프로세스가 아니라 JVM 프로세스 안의 스레드입니다.

부모-자식 프로세스 관계는 운영체제에서 fork나 CreateProcess 같은 시스템 콜로 새로운 프로세스를 생성할 때 발생합니다. 이 경우 각 프로세스는 독립적인 메모리 공간을 가지며, 프로세스 간 통신(IPC)을 통해서만 데이터를 주고받을 수 있습니다.

반면 JVM과 자바 프로그램의 관계는 호스트-게스트 관계에 가깝습니다. JVM은 자바 프로그램을 실행하는 런타임 환경을 제공하고, 자바 프로그램은 JVM이 제공하는 메모리 공간과 서비스를 사용합니다. 자바 프로그램의 모든 스레드는 같은 힙 메모리를 공유하며, 이는 하나의 프로세스 내에서 동작하기 때문입니다.

자바에서 Runtime.exec()이나 ProcessBuilder를 사용하여 외부 프로그램을 실행하면 그때 비로소 새로운 프로세스가 생성되며, 이 경우 JVM 프로세스가 부모 프로세스가 되고 실행된 외부 프로그램이 자식 프로세스가 됩니다. 하지만 일반적인 자바 애플리케이션 실행은 이와 다릅니다.

따라서 정확히 말하면 JVM은 프로세스이고, 자바 프로그램은 그 프로세스 내의 스레드 집합입니다.

## 질문 6: final 키워드를 사용하면, 어떤 이점이 있나요?

final 키워드는 변수, 메서드, 클래스에 사용할 수 있으며, 각각 다양한 이점을 제공합니다.

**변수에 사용할 때:**

불변성을 보장합니다. final 변수는 한 번만 초기화할 수 있고 이후 값을 변경할 수 없습니다. 이는 코드의 안전성을 높이고 예측 가능성을 향상시킵니다. 특히 멀티스레드 환경에서 스레드 안전성을 제공하는 데 도움이 됩니다.

의도를 명확히 표현합니다. final로 선언된 변수는 개발자의 의도가 "이 값은 변경되지 않아야 한다"는 것을 명시적으로 나타냅니다. 코드를 읽는 사람이 해당 변수가 상수임을 즉시 파악할 수 있습니다.

실수를 방지합니다. final 변수에 값을 재할당하려고 하면 컴파일 에러가 발생하므로, 의도하지 않은 값 변경을 미리 막을 수 있습니다.

**메서드에 사용할 때:**

오버라이딩을 방지합니다. final 메서드는 하위 클래스에서 재정의할 수 없습니다. 이는 특정 메서드의 동작이 변경되지 않아야 할 때 유용하며, 설계 의도를 보호합니다.

API 설계의 안정성을 제공합니다. 라이브러리나 프레임워크에서 핵심 동작을 final로 선언하면 사용자가 잘못된 방식으로 확장하는 것을 막을 수 있습니다.

**클래스에 사용할 때:**

상속을 방지합니다. final 클래스는 확장할 수 없어 불변 클래스를 만들 때 유용합니다. String 클래스가 대표적인 예입니다.

보안을 강화합니다. 상속을 통한 악의적인 동작 변경을 원천적으로 차단할 수 있습니다.

설계 의도를 명확히 합니다. 이 클래스는 완결된 구현이며 확장을 의도하지 않았다는 것을 나타냅니다.

**성능 측면:**

과거에는 final을 사용하면 JVM이 인라이닝 같은 최적화를 더 쉽게 할 수 있다고 여겨졌지만, 현대 JVM은 final이 없어도 충분히 최적화를 수행합니다. 따라서 성능보다는 코드의 안전성과 의도 표현이 더 중요한 이점입니다.

## 질문 7: 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?

네, final 키워드는 컴파일 과정에서 특별하게 취급되며, 바이트코드 레벨과 런타임에서도 차이가 있습니다.

**컴파일 타임 검증:**

컴파일러는 final 변수에 값이 정확히 한 번만 할당되는지 검증합니다. 초기화되지 않았거나 두 번 이상 할당되면 컴파일 에러가 발생합니다. 이는 컴파일 타임에 불변성을 보장하는 강력한 안전장치입니다.

final 메서드가 오버라이드되려고 하면 컴파일 에러가 발생합니다. final 클래스를 상속하려고 해도 마찬가지입니다.

**상수 폴딩(Constant Folding):**

기본 타입이나 String의 final 변수가 컴파일 타임 상수로 초기화되면, 컴파일러가 상수 폴딩을 수행합니다. 즉, 해당 변수를 사용하는 모든 곳에 직접 상수 값을 삽입합니다.

예를 들어, final int MAX = 100 이 있고 코드에서 MAX를 사용하면, 바이트코드에는 변수 참조가 아닌 상수 100이 직접 들어갑니다. 이는 성능을 약간 향상시키고 클래스 로딩 의존성을 줄일 수 있습니다.

**바이트코드 레벨:**

final 키워드는 바이트코드의 액세스 플래그(access flag)에 ACC_FINAL로 표시됩니다. 이는 클래스, 필드, 메서드 각각에 적용됩니다.

JVM은 이 플래그를 보고 런타임에 적절한 제약을 강제합니다.

**최적화:**

JVM은 final 메서드와 final 클래스의 메서드에 대해 더 공격적인 인라이닝을 수행할 수 있습니다. 오버라이드 가능성을 확인할 필요가 없기 때문입니다.

final 필드는 특정 조건에서 메모리 배리어 최적화에 도움이 됩니다. Java Memory Model에서 final 필드는 객체가 완전히 생성된 후 다른 스레드에서 안전하게 읽을 수 있도록 보장합니다.

**effectively final:**

Java 8부터는 명시적으로 final을 선언하지 않아도 실질적으로 final인 변수(effectively final)를 람다나 익명 클래스에서 사용할 수 있습니다. 컴파일러가 변수가 한 번만 할당되는지 분석하여 판단합니다.

따라서 final 키워드는 단순한 힌트가 아니라 컴파일러와 JVM이 적극적으로 활용하는 의미 있는 정보입니다.

## 질문 8: 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.

인터페이스와 추상 클래스는 모두 추상화를 제공하지만, 설계 의도와 사용 방식에서 중요한 차이가 있습니다.

**상속 관계:**

추상 클래스는 단일 상속만 가능합니다. 자바는 클래스 다중 상속을 지원하지 않으므로 한 클래스는 하나의 추상 클래스만 상속할 수 있습니다.

인터페이스는 다중 구현이 가능합니다. 한 클래스가 여러 인터페이스를 동시에 구현할 수 있어 유연한 설계가 가능합니다.

**멤버 변수:**

추상 클래스는 인스턴스 변수를 가질 수 있습니다. 상태를 저장할 수 있으며, 접근 제어자(private, protected, public)를 자유롭게 사용할 수 있습니다.

인터페이스는 기본적으로 상수만 가질 수 있습니다. 모든 필드는 자동으로 public static final이 됩니다.

**메서드:**

추상 클래스는 추상 메서드와 구체 메서드를 모두 가질 수 있습니다. 공통 기능을 구현하여 하위 클래스가 재사용할 수 있도록 할 수 있습니다. 메서드에 다양한 접근 제어자를 사용할 수 있습니다.

인터페이스는 전통적으로 추상 메서드만 가졌지만, Java 8부터 default 메서드와 static 메서드를 가질 수 있게 되었습니다. Java 9에서는 private 메서드도 추가되었습니다. 하지만 여전히 인스턴스 필드는 가질 수 없습니다.

**생성자:**

추상 클래스는 생성자를 가질 수 있습니다. 하위 클래스가 생성될 때 추상 클래스의 생성자가 호출되어 공통 초기화 로직을 수행할 수 있습니다.

인터페이스는 생성자를 가질 수 없습니다.

**설계 의도:**

추상 클래스는 "is-a" 관계를 나타냅니다. 공통된 특성과 동작을 가진 객체들의 기본 틀을 제공합니다. 예를 들어 Animal 추상 클래스를 Dog와 Cat이 상속하는 것은 "Dog는 Animal이다"라는 관계입니다.

인터페이스는 "can-do" 또는 "has-a capability" 관계를 나타냅니다. 특정 기능이나 역할을 정의합니다. 예를 들어 Flyable 인터페이스는 "날 수 있는 능력"을 나타내며, Bird와 Airplane이 모두 구현할 수 있습니다.

**사용 시나리오:**

추상 클래스는 관련된 클래스들 사이에 코드를 공유하고 싶을 때 사용합니다. 공통된 상태와 동작이 있고, 하위 클래스들이 강한 연관성을 가질 때 적합합니다.

인터페이스는 서로 관련 없는 클래스들이 같은 동작을 구현하도록 할 때 사용합니다. 다형성을 제공하고, 느슨한 결합을 유지하며, 여러 타입 역할을 동시에 수행하도록 할 때 적합합니다.

**진화 가능성:**

추상 클래스에 새로운 메서드를 추가하면 기본 구현을 제공할 수 있어 기존 하위 클래스가 영향을 받지 않습니다.

인터페이스는 default 메서드 덕분에 이전보다 진화가 쉬워졌지만, 여전히 추상 메서드를 추가하면 모든 구현 클래스를 수정해야 합니다.

현대 자바 설계에서는 일반적으로 인터페이스를 먼저 고려하고, 공통 구현이나 상태 공유가 필요할 때 추상 클래스를 사용하는 것이 권장됩니다.
