# OS 답변 45-48

## 45. 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?

**기본 개념**

스케줄링 알고리즘을 "프로세스 스케줄링"이라고 부르지만, 실제로는 스레드 단위로 스케줄링이 이루어집니다. 현대 운영체제는 스레드를 스케줄링의 기본 단위로 사용합니다.

**스레드 스케줄링의 특징**

운영체제 커널은 실제로 프로세스가 아닌 스레드를 스케줄링합니다. 각 스레드는 독립적인 실행 단위이며, CPU 코어에 할당되어 실행됩니다. 프로세스는 단지 자원의 소유 단위일 뿐이고, 실제 실행 단위는 스레드입니다.

**사용자 수준 스레드와 커널 수준 스레드**

스레드는 구현 방식에 따라 사용자 수준 스레드와 커널 수준 스레드로 나뉩니다. 사용자 수준 스레드는 커널이 인지하지 못하며, 사용자 공간의 스레드 라이브러리가 스케줄링합니다. 반면 커널 수준 스레드는 커널이 직접 관리하고 스케줄링합니다.

**실무 활용**

리눅스의 경우 NPTL을 통해 커널 수준 스레드를 지원하며, 각 스레드는 task_struct 구조체로 관리됩니다. 이는 프로세스와 동일한 구조체이며, 스케줄러는 프로세스와 스레드를 구분하지 않고 동일하게 스케줄링합니다. 윈도우도 마찬가지로 스레드를 기본 스케줄링 단위로 사용합니다.

**장점**

스레드 단위 스케줄링은 멀티코어 환경에서 동일 프로세스의 여러 스레드를 병렬로 실행할 수 있어 성능이 향상됩니다. 또한 컨텍스트 스위칭 오버헤드가 프로세스 스위칭보다 작습니다.

---

## 46. 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

**기본 개념**

유저 스레드와 커널 스레드는 관리 주체가 다르기 때문에 스케줄링 알고리즘도 다르게 적용됩니다. 각각의 특성에 맞는 스케줄링 방식이 사용됩니다.

**유저 스레드 스케줄링**

유저 스레드는 커널이 인지하지 못하며, 사용자 공간의 스레드 라이브러리가 스케줄링을 담당합니다. 라이브러리는 자체적인 스케줄러를 구현하여 협력적 멀티태스킹이나 우선순위 기반 스케줄링 등을 사용할 수 있습니다. 커널의 개입 없이 빠르게 스레드를 전환할 수 있지만, 한 스레드가 블로킹되면 전체 프로세스가 블로킹되는 문제가 있습니다.

**커널 스레드 스케줄링**

커널 스레드는 운영체제 커널이 직접 관리하며, 시스템 전체의 스케줄링 정책을 따릅니다. 리눅스의 CFS, 윈도우의 우선순위 기반 선점형 스케줄링 등 운영체제가 제공하는 스케줄링 알고리즘이 그대로 적용됩니다. 커널 스레드는 각각 독립적으로 스케줄링되어 멀티코어 환경에서 병렬 실행이 가능합니다.

**매핑 모델의 영향**

다대일 모델에서는 여러 유저 스레드가 하나의 커널 스레드에 매핑되어, 유저 레벨 스케줄러가 주도적 역할을 합니다. 일대일 모델에서는 각 유저 스레드가 커널 스레드에 매핑되어 커널 스케줄러가 직접 관리합니다. 다대다 모델은 두 가지 스케줄링이 모두 작용합니다.

**실무 활용**

현대 운영체제는 대부분 일대일 모델을 채택하여 커널 스케줄링 알고리즘을 직접 활용합니다. 이는 멀티코어 활용도를 높이고 블로킹 문제를 해결합니다. 일부 고성능 애플리케이션은 유저 레벨 스레드 라이브러리를 사용하여 특수한 스케줄링 정책을 구현하기도 합니다.

---

## 47. 뮤텍스와 세마포어의 차이점은 무엇인가요?

**기본 개념**

뮤텍스와 세마포어는 모두 프로세스 또는 스레드 간 동기화를 위한 도구이지만, 사용 목적과 동작 방식에 차이가 있습니다.

**뮤텍스의 특징**

뮤텍스는 상호 배제를 위한 도구로, 공유 자원에 대한 접근을 한 번에 하나의 스레드만 허용합니다. 뮤텍스는 소유권 개념이 있어서, 락을 획득한 스레드만 락을 해제할 수 있습니다. 주로 임계 영역 보호에 사용되며, 락과 언락이 반드시 쌍을 이루어야 합니다.

**세마포어의 특징**

세마포어는 카운팅 메커니즘을 사용하는 신호 전달 도구입니다. 내부 카운터 값을 통해 여러 스레드가 동시에 자원에 접근할 수 있도록 제어합니다. 세마포어는 소유권 개념이 없어서, 한 스레드가 시그널을 보내고 다른 스레드가 대기를 해제할 수 있습니다. 주로 자원 개수 관리나 스레드 간 신호 전달에 사용됩니다.

**주요 차이점**

뮤텍스는 이진 상태만 가지지만, 세마포어는 0 이상의 정수 값을 가집니다. 뮤텍스는 락을 획득한 스레드만 해제할 수 있지만, 세마포어는 다른 스레드가 시그널을 보낼 수 있습니다. 뮤텍스는 상호 배제가 목적이고, 세마포어는 동기화와 자원 관리가 목적입니다.

**실무 활용**

데이터베이스 연결 풀에서 동시에 접근할 수 있는 연결 개수를 제한할 때 세마포어를 사용합니다. 공유 메모리나 파일에 대한 배타적 접근을 보장할 때는 뮤텍스를 사용합니다. 생산자-소비자 문제에서는 세마포어가 적합하고, 단순한 임계 영역 보호에는 뮤텍스가 적합합니다.

**장단점**

뮤텍스는 소유권을 통해 데드락 방지와 우선순위 역전 문제 해결이 용이하지만, 단일 자원 보호에만 적합합니다. 세마포어는 여러 자원 관리와 복잡한 동기화가 가능하지만, 잘못 사용하면 데드락이나 경쟁 조건이 발생하기 쉽습니다.

---

## 48. 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.

**기본 개념**

이진 세마포어는 0과 1의 두 가지 값만 가지는 세마포어로, 겉보기에는 뮤텍스와 유사해 보이지만 중요한 차이점들이 있습니다.

**소유권의 차이**

뮤텍스는 소유권 개념이 있어서, 락을 획득한 스레드만 락을 해제할 수 있습니다. 반면 이진 세마포어는 소유권 개념이 없어서, 한 스레드가 대기 상태로 만들고 다른 스레드가 신호를 보내 깨울 수 있습니다. 이는 스레드 간 신호 전달에 유용하지만, 잘못 사용하면 예기치 않은 동작을 일으킬 수 있습니다.

**우선순위 상속**

뮤텍스는 우선순위 역전 문제를 해결하기 위해 우선순위 상속 프로토콜을 지원합니다. 낮은 우선순위 스레드가 뮤텍스를 소유하고 있을 때, 높은 우선순위 스레드가 대기하면 일시적으로 우선순위를 상속받습니다. 이진 세마포어는 소유권이 없어서 우선순위 상속을 지원하지 않습니다.

**재귀적 락**

뮤텍스는 재귀적 뮤텍스를 제공하여, 같은 스레드가 여러 번 락을 획득할 수 있습니다. 이는 재귀 함수나 중첩된 함수 호출에서 유용합니다. 이진 세마포어는 재귀적 락을 지원하지 않으며, 같은 스레드가 다시 대기하면 데드락이 발생할 수 있습니다.

**사용 목적**

뮤텍스는 공유 자원에 대한 상호 배제가 주 목적이며, 임계 영역 보호에 최적화되어 있습니다. 이진 세마포어는 스레드 간 신호 전달이나 이벤트 알림에 더 적합합니다. 예를 들어, 한 스레드가 작업을 완료했음을 다른 스레드에게 알릴 때 이진 세마포어를 사용합니다.

**실무 활용**

POSIX 시스템에서 pthread_mutex는 명확한 뮤텍스 구현체이고, sem_t는 세마포어 구현체입니다. 임계 영역 보호가 필요하면 뮤텍스를 사용하고, 스레드 간 순서 보장이나 이벤트 통지가 필요하면 세마포어를 사용합니다. 뮤텍스는 더 안전하고 예측 가능한 동작을 제공합니다.

**장단점**

뮤텍스는 소유권을 통해 안전성과 디버깅이 용이하지만, 용도가 제한적입니다. 이진 세마포어는 유연한 신호 전달이 가능하지만, 잘못 사용하면 동기화 문제가 발생하기 쉽고 우선순위 역전 문제를 해결할 수 없습니다.
