# JavaScript 답변 57-60

## 질문 57: 에러 처리(try-catch-finally)와 에러 전파에 대해 설명해주세요.

**정의:**
try-catch-finally는 JavaScript에서 런타임 에러를 처리하는 구문입니다. try 블록에서 발생한 에러를 catch로 잡아 처리하고, finally는 결과와 관계없이 항상 실행됩니다.

**try-catch의 기본 동작:**
- try 블록에서 코드를 실행합니다. 에러가 발생할 수 있는 코드를 감쌉니다.
- 에러가 발생하면 즉시 catch 블록으로 이동합니다. 나머지 try 코드는 실행되지 않습니다.
- catch는 에러 객체를 매개변수로 받습니다. 에러 정보를 담고 있습니다.
- 에러가 없으면 catch는 건너뜁니다.

**finally 블록:**
- 에러 발생 여부와 무관하게 항상 실행됩니다.
- 리소스 정리에 사용합니다. 파일 닫기, 연결 해제 등입니다.
- return문이 있어도 finally가 먼저 실행됩니다.
- try나 catch에서 return해도 finally는 실행됩니다.

**에러 객체:**
- Error 객체는 name과 message 속성을 가집니다.
- stack 속성으로 호출 스택을 확인할 수 있습니다.
- 다양한 에러 타입이 있습니다. SyntaxError, TypeError, ReferenceError 등입니다.
- 커스텀 에러를 만들 수도 있습니다. Error를 상속합니다.

**에러 던지기:**
- throw 문으로 에러를 발생시킵니다. 어떤 값이든 던질 수 있습니다.
- Error 객체를 던지는 것이 권장됩니다. 스택 트레이스를 포함합니다.
- 조건부로 에러를 발생시켜 예외 상황을 알립니다.
- 함수 내에서 throw하면 호출자에게 전파됩니다.

**에러 전파:**
- catch하지 않은 에러는 호출 스택을 따라 올라갑니다.
- 최상위까지 처리되지 않으면 프로그램이 종료됩니다.
- 중간에 catch하면 그곳에서 처리됩니다.
- catch 후 다시 throw하여 전파를 계속할 수 있습니다.

**에러 타입별 처리:**
- catch에서 에러 타입을 확인할 수 있습니다. instanceof로 타입을 검사합니다.
- 타입에 따라 다른 처리를 수행합니다.
- 처리할 수 없는 에러는 다시 throw합니다.
- 세밀한 에러 처리가 가능합니다.

**비동기 코드의 에러 처리:**
- setTimeout이나 콜백의 에러는 try-catch로 잡을 수 없습니다. 다른 실행 컨텍스트에서 발생하기 때문입니다.
- Promise는 catch 메서드로 처리합니다.
- async/await는 try-catch를 사용할 수 있습니다. 동기 코드처럼 처리됩니다.
- 에러 처리 방식이 통일되어 편리합니다.

**전역 에러 핸들러:**
- window.onerror로 처리되지 않은 에러를 잡습니다.
- Promise의 unhandled rejection도 감지할 수 있습니다.
- 로깅이나 모니터링에 활용합니다.
- 사용자에게 친화적인 에러 메시지를 표시합니다.

**실무 권장사항:**
- 예상 가능한 에러는 미리 검증합니다. try-catch는 예외적인 상황에 사용합니다.
- 에러 메시지는 명확하고 구체적으로 작성합니다.
- 민감한 정보를 에러 메시지에 포함하지 않습니다.
- 에러를 적절히 로깅합니다. 디버깅에 도움이 됩니다.
- 사용자에게는 이해하기 쉬운 메시지를 보여줍니다.

---

## 질문 58: Symbol의 용도와 사용 방법은 무엇인가요?

**정의:**
Symbol은 ES6에서 추가된 원시 타입으로, 고유하고 변경 불가능한 값을 생성합니다. 주로 객체의 유일한 프로퍼티 키를 만들거나 메타프로그래밍에 사용됩니다.

**Symbol의 특징:**
- 항상 고유한 값입니다. 같은 설명으로 만들어도 다른 Symbol입니다.
- 불변입니다. 생성 후 변경할 수 없습니다.
- new 연산자를 사용할 수 없습니다. 원시 타입이기 때문입니다.
- 설명 문자열을 선택적으로 제공할 수 있습니다. 디버깅에 도움이 됩니다.

**고유 프로퍼티 키:**
- 객체의 프로퍼티 키로 사용할 수 있습니다.
- 다른 코드와 충돌하지 않습니다. 완전히 고유합니다.
- 숨겨진 프로퍼티처럼 동작합니다. 일반적인 순회에 나타나지 않습니다.
- private 프로퍼티를 흉내낼 수 있습니다.

**Well-known Symbols:**
- JavaScript 내장 Symbol들입니다. 언어 동작을 커스터마이징합니다.
- Symbol.iterator는 이터러블 구현에 사용됩니다.
- Symbol.toStringTag는 Object.prototype.toString 결과를 변경합니다.
- Symbol.hasInstance는 instanceof 동작을 재정의합니다.
- Symbol.toPrimitive는 타입 변환을 제어합니다.

**전역 Symbol 레지스트리:**
- Symbol.for로 전역 Symbol을 생성하거나 가져옵니다.
- 같은 키로 호출하면 같은 Symbol을 반환합니다.
- Symbol.keyFor로 전역 Symbol의 키를 얻습니다.
- 코드 간에 Symbol을 공유할 때 사용합니다.

**Symbol과 프로퍼티 열거:**
- for-in 루프에 나타나지 않습니다.
- Object.keys에도 포함되지 않습니다.
- Object.getOwnPropertySymbols로만 가져올 수 있습니다.
- Reflect.ownKeys는 Symbol도 포함합니다.

**사용 사례:**
- 프라이빗 프로퍼티 흉내: 외부에서 쉽게 접근할 수 없습니다. 완벽하지는 않지만 효과적입니다.
- 메타데이터 저장: 객체에 추가 정보를 붙입니다. 원본 구조를 해치지 않습니다.
- 프로토콜 구현: 이터레이터, 비동기 이터레이터 등을 만듭니다.
- 열거형 값: 고유한 상수가 필요할 때 사용합니다.

**Symbol vs String 키:**
- String 키는 충돌 가능성이 있습니다. 같은 이름을 사용하면 덮어씁니다.
- Symbol은 절대 충돌하지 않습니다.
- String 키는 열거됩니다. 일반적인 순회에 포함됩니다.
- Symbol 키는 숨겨집니다. 의도적으로 찾지 않으면 보이지 않습니다.

**JSON 직렬화:**
- Symbol 키는 JSON.stringify에서 무시됩니다.
- 직렬화가 필요하면 String 키를 사용해야 합니다.
- 전송이 필요 없는 내부 데이터에만 Symbol을 사용합니다.

**실무 활용:**
- 라이브러리에서 내부 프로퍼티를 안전하게 저장합니다.
- 프레임워크의 메타데이터 시스템에 활용됩니다.
- 이터러블 프로토콜을 구현합니다.
- 상수를 정의할 때 고유성을 보장합니다.
- React 등에서 내부적으로 Symbol을 사용합니다.

---

## 질문 59: Template Literal의 특징과 활용 방법은 무엇인가요?

**정의:**
Template Literal은 백틱으로 감싸는 문자열 리터럴로, 문자열 보간과 여러 줄 문자열을 쉽게 만들 수 있습니다. 표현식 삽입과 태그 함수로 강력한 기능을 제공합니다.

**기본 기능:**
- 백틱으로 문자열을 감쌉니다. 일반 따옴표 대신 사용합니다.
- 여러 줄 문자열을 자연스럽게 작성할 수 있습니다. 줄바꿈이 그대로 유지됩니다.
- 이스케이프 문자 없이 줄바꿈합니다.
- 백틱 자체를 사용하려면 이스케이프합니다.

**문자열 보간:**
- 달러 기호와 중괄호로 표현식을 삽입합니다.
- 변수, 연산, 함수 호출 등 모든 표현식이 가능합니다.
- 결과가 자동으로 문자열로 변환됩니다.
- 중첩도 가능합니다. 템플릿 내부에 템플릿을 넣을 수 있습니다.

**일반 문자열과의 차이:**
- 일반 문자열은 연결 연산자가 필요합니다. 가독성이 떨어집니다.
- Template Literal은 자연스럽고 읽기 쉽습니다.
- HTML이나 다중 줄 텍스트 작성이 편리합니다.

**Tagged Template:**
- 함수로 템플릿을 처리할 수 있습니다.
- 첫 번째 인수는 문자열 배열입니다. 표현식으로 나뉜 부분들입니다.
- 나머지 인수는 표현식의 값들입니다.
- 커스텀 처리 로직을 적용할 수 있습니다.

**Tagged Template 활용:**
- 국제화: 문자열을 번역하는 함수로 처리합니다.
- 이스케이핑: XSS를 방지하는 HTML 이스케이프를 적용합니다.
- 쿼리 빌더: SQL 인젝션을 방지하는 쿼리를 생성합니다.
- 스타일: styled-components에서 CSS를 작성합니다.

**Raw 문자열:**
- String.raw는 이스케이프를 처리하지 않습니다.
- 백슬래시를 그대로 유지합니다.
- 정규표현식이나 파일 경로에 유용합니다.

**중첩 구조:**
- 배열이나 객체를 렌더링할 때 유용합니다.
- map과 함께 사용하여 리스트를 만듭니다.
- 조건부 렌더링도 가능합니다. 삼항 연산자를 활용합니다.

**실무 활용:**
- HTML 템플릿 생성: DOM을 동적으로 만듭니다.
- API URL 구성: 변수를 포함한 엔드포인트를 만듭니다.
- 로그 메시지: 변수를 포함한 로그를 작성합니다.
- SQL 쿼리: 파라미터화된 쿼리를 안전하게 만듭니다.
- styled-components: CSS-in-JS를 구현합니다.
- GraphQL: 쿼리 문자열을 작성합니다.

---

## 질문 60: 불변성(Immutability)을 유지하는 것이 왜 중요한가요?

**정의:**
불변성은 데이터를 직접 변경하지 않고 새로운 데이터를 생성하는 원칙입니다. 예측 가능하고 안전한 코드를 작성하는 데 핵심적인 개념입니다.

**불변성의 중요성:**
- 예측 가능성이 높아집니다. 데이터가 언제 어디서 변경되는지 명확합니다.
- 부수 효과를 방지합니다. 함수가 외부 상태를 변경하지 않습니다.
- 디버깅이 쉬워집니다. 상태 변화를 추적하기 쉽습니다.
- 시간 여행 디버깅이 가능합니다. 이전 상태를 보존할 수 있습니다.

**React에서의 불변성:**
- 상태 변경을 감지합니다. 참조 비교로 빠르게 확인합니다.
- 리렌더링을 최적화합니다. 변경되지 않은 컴포넌트는 건너뜁니다.
- PureComponent와 React.memo가 제대로 작동합니다.
- 상태 업데이트가 명확해집니다. 언제 무엇이 바뀌는지 알 수 있습니다.

**불변성 유지 방법:**
- 원시 값은 자동으로 불변입니다.
- 객체는 스프레드 연산자로 복사합니다. 새 객체를 만듭니다.
- 배열은 map, filter, concat 등을 사용합니다. 새 배열을 반환합니다.
- push, splice, sort 같은 가변 메서드는 피합니다.

**중첩 객체의 불변 업데이트:**
- 중첩된 각 레벨을 새로 만들어야 합니다.
- 스프레드를 중첩하여 사용합니다. 코드가 복잡해질 수 있습니다.
- Immer 같은 라이브러리를 활용합니다. 가변 문법으로 불변 업데이트를 구현합니다.

**함수형 프로그래밍:**
- 불변성은 함수형 프로그래밍의 핵심입니다.
- 순수 함수를 만들 수 있습니다. 같은 입력은 항상 같은 출력을 보장합니다.
- 함수 합성이 안전해집니다. 예상치 못한 부작용이 없습니다.
- 테스트하기 쉬워집니다. 입출력만 확인하면 됩니다.

**성능 고려사항:**
- 복사 비용이 발생합니다. 큰 객체는 메모리와 시간이 소요됩니다.
- 하지만 참조 비교가 빠릅니다. 깊은 비교보다 훨씬 효율적입니다.
- 구조적 공유로 최적화할 수 있습니다. 변경되지 않은 부분은 재사용합니다.
- 대부분의 경우 성능 문제는 미미합니다.

**불변 데이터 구조:**
- Immutable.js는 특화된 자료구조를 제공합니다.
- 구조적 공유로 메모리를 절약합니다.
- 대량의 데이터를 다룰 때 유용합니다.
- 하지만 학습 곡선과 번들 크기가 단점입니다.

**Undo/Redo 구현:**
- 이전 상태를 배열에 저장합니다.
- 불변성 덕분에 안전하게 보관할 수 있습니다.
- 시간 여행 기능을 쉽게 만듭니다.
- Redux DevTools가 이를 활용합니다.

**실무 권장사항:**
- 상태 관리에서 불변성을 항상 유지합니다.
- 복잡한 업데이트는 Immer를 사용합니다.
- 불변 메서드를 기본으로 사용합니다. map, filter, concat 등입니다.
- ESLint 규칙으로 가변 메서드 사용을 경고합니다.
- TypeScript의 readonly로 타입 레벨에서 강제합니다.

---
