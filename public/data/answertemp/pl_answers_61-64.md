## 질문 61: Generator 함수와 Iterator의 동작 원리를 설명해주세요.

**정의:**
Generator는 실행을 일시 중지하고 재개할 수 있는 특수한 함수로, Iterator를 쉽게 생성하는 방법을 제공합니다. Iterator는 next() 메서드를 가진 객체로 순차적으로 값을 반환하며, Generator 함수는 function* 문법으로 정의하고 yield로 값을 생성합니다.

**특징/원리:**
- 지연 평가: 필요할 때만 값을 생성하여 메모리 효율적
- 상태 유지: 함수 실행이 중지된 위치와 지역 변수 상태를 기억
- 양방향 통신: next()로 값을 전달받고 yield로 값을 반환하는 양방향 통신 가능
- 이터러블 프로토콜: Generator 객체는 이터러블이자 이터레이터

**Generator 함수:**
- function* 문법: 별표로 Generator 함수임을 표시
- yield: 값을 생성하고 함수 실행을 일시 중지
- return: Generator를 종료하고 마지막 값 반환
- yield*: 다른 Generator나 이터러블에 위임

**Iterator 프로토콜:**
- next() 메서드: {value, done} 형태의 객체 반환
- value: 현재 생성된 값
- done: Iterator가 완료되었는지 나타내는 불리언
- Symbol.iterator: 객체를 이터러블로 만드는 메서드

**Generator 메서드:**
- next(value): Generator를 재개하고 value를 yield 표현식의 결과로 전달
- return(value): Generator를 종료하고 value를 반환
- throw(error): Generator 내부에서 예외를 발생시킴

**사용 사례:**
- 무한 시퀀스: 피보나치 수열, ID 생성기 등 무한히 값을 생성
- 대용량 데이터: 메모리를 절약하면서 큰 데이터셋을 순회
- 비동기 흐름 제어: co 라이브러리처럼 Generator로 비동기 코드를 동기식으로 작성
- 상태 머신: 복잡한 상태 전이를 Generator로 깔끔하게 표현

**실무 활용:**
- 페이지네이션 데이터를 Generator로 구현하여 필요한 만큼만 로드
- Redux-Saga에서 Generator로 복잡한 비동기 로직을 선언적으로 표현
- 대용량 파일을 청크 단위로 읽는 Generator 구현

---

## 질문 62: 모듈 시스템(CommonJS, ES6 Module)의 차이점은 무엇인가요?

**정의:**
CommonJS와 ES6 Module은 JavaScript 코드를 모듈화하는 두 가지 주요 방식입니다. CommonJS는 Node.js에서 사용하는 동기적 모듈 시스템이고, ES6 Module은 ECMAScript 표준의 정적 모듈 시스템으로 브라우저와 Node.js 모두에서 지원됩니다.

**특징/원리:**
- 로딩 방식: CommonJS는 런타임에 동기적으로 로드하고, ES6 Module은 컴파일 타임에 정적으로 분석
- 값 전달: CommonJS는 값의 복사본을 내보내고, ES6 Module은 값에 대한 라이브 바인딩
- 최적화: ES6 Module은 정적 분석이 가능하여 트리 쉐이킹과 같은 최적화 가능
- 환경: CommonJS는 Node.js 전용이었지만, ES6 Module은 브라우저와 Node.js 모두 지원

**CommonJS:**
- require(): 동기적으로 모듈을 로드하고 객체를 반환
- module.exports: 모듈에서 내보낼 값을 할당
- exports 단축: exports 객체에 속성을 추가하여 여러 값 내보내기
- 동적 로딩: 조건문 안에서도 require() 사용 가능
- 런타임 결정: 어떤 모듈을 로드할지 런타임에 결정 가능

**ES6 Module:**
- import: 정적으로 모듈을 가져오며 호이스팅됨
- export: 모듈에서 내보낼 값을 선언
- export default: 모듈의 기본 내보내기 정의
- 정적 구조: import/export는 최상위 레벨에만 위치하며 동적 사용 불가
- import(): 동적 import를 위한 함수로 Promise 반환

**주요 차이점:**
- 구문: CommonJS는 할당 기반, ES6는 선언적 구문
- 타이밍: CommonJS는 런타임 로딩, ES6는 파싱 타임 분석
- 트리 쉐이킹: ES6 Module은 정적 분석으로 사용하지 않는 코드 제거 가능
- this: CommonJS 모듈의 this는 exports 객체, ES6 Module의 this는 undefined
- 순환 참조: 처리 방식이 다르며 ES6가 더 예측 가능

**상호 운용성:**
- Node.js: package.json의 type 필드로 모듈 시스템 지정
- 번들러: Webpack, Rollup 등이 두 시스템을 모두 처리하여 변환
- 혼용: ES6에서 CommonJS를 import 가능하지만 반대는 제한적

**실무 활용:**
- 새로운 프로젝트는 ES6 Module을 사용하여 표준을 따르고 최적화 이점 활용
- Node.js 라이브러리는 CommonJS와 ES6 Module 둘 다 제공하여 호환성 확보
- 브라우저 환경에서는 ES6 Module을 기본으로 사용하고 번들러로 빌드

---

## 질문 63: TypeScript의 타입 시스템에 대해 설명해주세요.

**정의:**
TypeScript는 JavaScript에 정적 타입 시스템을 추가한 슈퍼셋 언어로, 컴파일 타임에 타입 검사를 수행하여 런타임 오류를 사전에 방지합니다. 구조적 타입 시스템을 사용하며 타입 추론, 제네릭, 유니온/인터섹션 타입 등 강력한 타입 기능을 제공합니다.

**특징/원리:**
- 정적 타입: 변수, 함수 파라미터, 반환값 등에 타입을 명시하여 컴파일 타임에 검증
- 구조적 타이핑: 이름이 아닌 구조(속성과 메서드)로 타입 호환성 판단
- 타입 추론: 명시하지 않아도 값으로부터 타입을 자동으로 추론
- 점진적 타입: JavaScript 코드에 점진적으로 타입을 추가 가능하며 any로 타입 검사 생략 가능

**기본 타입:**
- 원시 타입: number, string, boolean, null, undefined, symbol, bigint
- 배열: number[], Array<number> 형태로 표현
- 튜플: 고정된 길이와 타입의 배열로 각 위치마다 다른 타입 가능
- enum: 관련된 상수 집합을 정의
- any: 모든 타입 허용하며 타입 검사 비활성화
- unknown: any보다 안전한 최상위 타입으로 사용 전 타입 체크 필요
- void: 반환값이 없는 함수의 반환 타입
- never: 절대 발생하지 않는 값의 타입

**고급 타입:**
- 유니온 타입: 여러 타입 중 하나일 수 있음을 표현
- 인터섹션 타입: 여러 타입을 모두 만족하는 타입 생성
- 리터럴 타입: 특정 값만 허용하는 타입
- 타입 별칭: type 키워드로 복잡한 타입에 이름 부여
- 인터페이스: 객체의 구조를 정의하며 확장과 구현 가능

**타입 추론:**
- 초기화: 변수 선언 시 초기값으로부터 타입 추론
- 반환값: 함수 본문으로부터 반환 타입 추론
- 문맥적 타이핑: 표현식의 위치로부터 타입 추론
- Best common type: 여러 타입을 고려하여 가장 적합한 타입 선택

**실무 활용:**
- 대규모 프로젝트에서 TypeScript로 타입 안전성 확보하여 리팩토링과 유지보수 용이
- IDE의 자동완성과 타입 체크로 개발 생산성 향상
- 명시적 타입 정의로 코드 자체가 문서 역할 수행

---

## 질문 64: TypeScript의 제네릭(Generic) 사용 방법과 제약사항은 무엇인가요?

**정의:**
제네릭은 타입을 파라미터화하여 재사용 가능한 컴포넌트를 만드는 기능입니다. 함수, 클래스, 인터페이스에서 사용할 타입을 호출 시점에 결정하여 타입 안전성을 유지하면서도 유연한 코드를 작성할 수 있습니다.

**특징/원리:**
- 타입 파라미터: 꺾쇠 괄호 안에 타입 변수를 선언하여 타입을 매개변수화
- 타입 안전성: 특정 타입으로 제한하지 않으면서도 타입 체크 유지
- 재사용성: 동일한 로직을 다양한 타입에 적용 가능
- 타입 추론: 대부분의 경우 타입 인자를 명시하지 않아도 자동 추론

**제네릭 함수:**
- 선언: 함수명 뒤에 타입 파라미터 선언
- 사용: 함수 파라미터나 반환 타입에 타입 변수 사용
- 호출: 타입 인자를 명시하거나 추론에 맡김
- 다중 타입 파라미터: 여러 타입 변수를 쉼표로 구분하여 선언

**제네릭 클래스:**
- 선언: 클래스명 뒤에 타입 파라미터 선언
- 인스턴스 생성: new 키워드로 인스턴스 생성 시 타입 인자 전달
- static 멤버: static 멤버에서는 클래스의 타입 파라미터 사용 불가
- 상속: 제네릭 클래스를 상속할 때 타입 인자 전달하거나 새로운 타입 파라미터 사용

**제약 조건:**
- extends: 타입 파라미터가 특정 타입을 확장하도록 제약
- 인터페이스 제약: 타입이 특정 속성이나 메서드를 가지도록 보장
- 타입 파라미터 제약: 한 타입 파라미터가 다른 타입 파라미터를 확장
- keyof: 객체 타입의 키로 타입 파라미터 제약

**유틸리티 타입:**
- Partial: 모든 속성을 선택적으로 만듦
- Required: 모든 속성을 필수로 만듦
- Pick: 특정 속성만 선택하여 타입 생성
- Omit: 특정 속성을 제외하고 타입 생성
- Record: 키-값 쌍의 타입 생성

**실무 활용:**
- API 응답 타입을 제네릭으로 정의하여 다양한 데이터 타입에 재사용
- 컨테이너 컴포넌트를 제네릭으로 구현하여 여러 타입의 아이템 관리
- 유틸리티 함수를 제네릭으로 작성하여 타입 안전성과 재사용성 확보

---
