## 질문 21: volatile 키워드의 의미와 사용 시나리오는 무엇인가요?

**정의:**
volatile은 변수가 여러 스레드에 의해 동시에 접근될 때 메인 메모리로부터 직접 읽고 쓰도록 강제하는 키워드입니다. CPU 캐시가 아닌 메인 메모리를 사용하여 모든 스레드가 항상 최신 값을 볼 수 있도록 가시성을 보장합니다.

**특징/원리:**
- 가시성 보장: 한 스레드가 volatile 변수를 수정하면 다른 모든 스레드에게 즉시 보임
- 캐시 무효화: volatile 변수 읽기/쓰기 시 CPU 캐시를 거치지 않고 메인 메모리에 직접 접근
- Happens-Before 관계: volatile 쓰기 이전의 모든 쓰기 작업이 volatile 읽기 이후의 모든 읽기 작업보다 먼저 발생
- 재배치 방지: 컴파일러와 CPU의 명령어 재배치를 제한하여 프로그램 순서 보장

**원자성과 한계:**
- 읽기/쓰기 원자성: 64비트 변수(long, double)도 원자적으로 읽고 쓸 수 있음
- 복합 연산 비원자성: 증가(count++), 감소(count--) 같은 읽기-수정-쓰기 연산은 원자성 보장 안 됨
- synchronized 대비: volatile은 가벼운 동기화로 락 오버헤드가 없지만 기능이 제한적
- 경쟁 조건: 여러 스레드가 동시에 수정하는 경우 여전히 경쟁 조건 발생 가능

**사용 시나리오:**
- 상태 플래그: 작업 완료, 중단 요청 등의 boolean 플래그를 여러 스레드가 확인하는 경우
- 싱글톤 DCL: Double-Checked Locking 패턴에서 인스턴스 변수를 volatile로 선언하여 안전성 확보
- 읽기 주체: 하나의 스레드만 쓰고 여러 스레드가 읽는 상황에서 최신 값 보장
- 이벤트 발행: 한 스레드가 이벤트를 발행하고 다른 스레드들이 감지하는 패턴

**실무 활용:**
- 스레드 종료 플래그를 volatile boolean으로 선언하여 작업 스레드에게 종료 신호 전달
- 캐시 값의 갱신 여부를 나타내는 플래그로 사용하여 다른 스레드들이 갱신 시점 감지
- AtomicReference와 함께 사용하여 불변 객체의 참조를 안전하게 교체

---

## 질문 22: Java Memory Model에 대해 설명해주세요.

**정의:**
Java Memory Model(JMM)은 멀티스레드 환경에서 공유 변수에 대한 읽기/쓰기 작업의 가시성과 순서를 정의하는 명세입니다. JMM은 스레드 간 메모리 접근 규칙을 정의하여 플랫폼에 독립적인 동시성 프로그래밍을 가능하게 합니다.

**특징/원리:**
- 추상 모델: 실제 하드웨어 메모리 구조와 무관하게 스레드가 메모리를 어떻게 보는지 정의
- Happens-Before 관계: 한 작업의 결과가 다른 작업에게 보이는 순서를 정의하는 핵심 개념
- 메모리 가시성: 한 스레드의 변경사항이 다른 스레드에게 언제 보이는지 규정
- 재배치 제한: 컴파일러와 프로세서의 최적화로 인한 명령어 재배치를 제어

**Happens-Before 규칙:**
- 프로그램 순서 규칙: 한 스레드 내에서 앞의 작업이 뒤의 작업보다 먼저 발생
- 모니터 잠금 규칙: 락 해제가 같은 락의 획득보다 먼저 발생
- volatile 변수 규칙: volatile 변수 쓰기가 같은 변수의 읽기보다 먼저 발생
- 스레드 시작 규칙: Thread.start() 호출이 시작된 스레드의 모든 작업보다 먼저 발생
- 스레드 종료 규칙: 스레드의 모든 작업이 Thread.join() 리턴보다 먼저 발생

**메모리 일관성 문제:**
- 캐시 일관성: 각 스레드가 자신의 CPU 캐시를 가져 메인 메모리와 값이 다를 수 있음
- 명령어 재배치: 성능 최적화를 위해 컴파일러나 CPU가 명령어 순서를 변경할 수 있음
- 가시성 문제: 한 스레드의 변경이 다른 스레드에게 즉시 보이지 않을 수 있음
- 원자성 부족: 복합 연산이 중간에 중단되어 일관성 없는 상태 발생 가능

**실무 활용:**
- synchronized, volatile, Lock 등의 동기화 메커니즘을 이해하고 올바르게 사용
- 불변 객체를 활용하여 안전한 발행(safe publication) 패턴 구현
- Happens-Before 규칙을 이해하여 불필요한 동기화를 피하고 성능 최적화

---

## 질문 23: ThreadLocal의 동작 원리와 주의사항은 무엇인가요?

**정의:**
ThreadLocal은 각 스레드가 독립적인 변수 복사본을 가질 수 있도록 하는 클래스입니다. 같은 ThreadLocal 인스턴스를 여러 스레드가 접근해도 각 스레드는 자신만의 값을 저장하고 읽을 수 있어 스레드 간 격리를 제공합니다.

**특징/원리:**
- 스레드별 저장소: 각 스레드는 자신만의 ThreadLocalMap을 가지며 이곳에 ThreadLocal 변수 저장
- 참조 구조: Thread 객체가 ThreadLocalMap을 필드로 가지고, ThreadLocal 객체가 키 역할을 함
- 격리성: 스레드 간 데이터 공유가 없어 동기화 불필요하며 경쟁 조건 발생하지 않음
- 상속 가능: InheritableThreadLocal을 사용하면 부모 스레드의 값을 자식 스레드가 상속 가능

**동작 메커니즘:**
- set() 메서드: 현재 스레드의 ThreadLocalMap에 값을 저장
- get() 메서드: 현재 스레드의 ThreadLocalMap에서 값을 조회하며, 없으면 initialValue() 호출
- remove() 메서드: 현재 스레드의 ThreadLocalMap에서 값을 제거
- WeakReference: ThreadLocalMap의 키는 WeakReference로 ThreadLocal이 GC되면 자동 제거

**주의사항:**
- 메모리 누수: 스레드 풀 환경에서 ThreadLocal 값을 remove()하지 않으면 스레드가 재사용되면서 이전 값이 남아있어 메모리 누수 발생
- 명시적 정리: 사용 후 반드시 remove()를 호출하여 값을 제거해야 하며 finally 블록 활용 권장
- 상속 문제: InheritableThreadLocal은 스레드 생성 시점의 값만 복사하며 이후 변경은 반영 안 됨
- 컨텍스트 전환: 비동기 작업이나 스레드 풀 사용 시 컨텍스트가 유실될 수 있어 주의 필요

**실무 활용:**
- Spring Security의 SecurityContextHolder가 ThreadLocal로 인증 정보를 스레드별로 관리
- 트랜잭션 컨텍스트나 데이터베이스 연결을 스레드별로 관리하여 격리 보장
- 웹 요청별 사용자 정보나 추적 ID를 저장하여 전역적으로 접근 가능하면서도 스레드 안전성 확보

---

## 질문 24: Executor Framework와 Thread Pool에 대해 설명해주세요.

**정의:**
Executor Framework는 Java에서 스레드의 생성, 관리, 실행을 추상화한 고수준 동시성 API입니다. Thread Pool은 미리 생성된 스레드들을 재사용하여 작업을 처리하는 패턴으로, 스레드 생성/소멸 비용을 줄이고 시스템 리소스를 효율적으로 관리합니다.

**특징/원리:**
- 작업과 실행 분리: Runnable/Callable 작업과 실제 실행을 분리하여 유연성 제공
- 스레드 재사용: 스레드를 미리 생성하여 풀에 보관하고 작업이 들어오면 할당하여 재사용
- 큐 기반 처리: 작업을 BlockingQueue에 저장하고 가용 스레드가 순차적으로 처리
- 생명주기 관리: 스레드 풀의 시작, 종료, 셧다운 등을 체계적으로 관리

**주요 인터페이스와 클래스:**
- Executor: execute() 메서드만 제공하는 가장 단순한 인터페이스
- ExecutorService: 작업 제출, 종료 관리, Future 반환 등 확장된 기능 제공
- ScheduledExecutorService: 지연 실행이나 주기적 실행을 지원하는 인터페이스
- ThreadPoolExecutor: 스레드 풀의 핵심 구현 클래스로 세밀한 설정 가능
- Executors: 다양한 유형의 스레드 풀을 생성하는 팩토리 메서드 제공

**주요 Thread Pool 유형:**
- newFixedThreadPool: 고정된 개수의 스레드를 가진 풀로 안정적이지만 큐가 무제한 증가 가능
- newCachedThreadPool: 필요에 따라 스레드를 생성하고 60초간 유휴 상태면 제거하며 단기 비동기 작업에 적합
- newSingleThreadExecutor: 단일 스레드로 작업을 순차 처리하며 작업 순서 보장
- newScheduledThreadPool: 지연 실행이나 주기적 실행이 필요한 작업에 사용

**실무 활용:**
- 웹 서버에서 클라이언트 요청을 처리하는 스레드 풀을 구성하여 동시 접속 처리
- 배치 작업이나 대량 데이터 처리 시 적절한 크기의 스레드 풀로 병렬 처리하여 성능 향상
- Executors 대신 ThreadPoolExecutor를 직접 생성하여 코어 스레드, 최대 스레드, 큐 크기 등을 상황에 맞게 튜닝

---
