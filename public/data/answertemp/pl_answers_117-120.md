## 질문 117: Race Condition과 Deadlock에 대해 설명해주세요.

**정의:**
Race Condition은 여러 스레드나 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상황이고, Deadlock은 두 개 이상의 작업이 서로가 점유한 자원을 기다리며 무한히 대기하는 상태입니다. 둘 다 동시성 프로그래밍의 주요 문제입니다.

**특징/원리:**
- 비결정적: 실행 타이밍에 따라 결과가 달라져 재현과 디버깅이 어려움
- 동시성 버그: 멀티스레드나 멀티프로세스 환경에서 발생
- 데이터 손상: 잘못된 동기화로 데이터 무결성 깨짐
- 시스템 마비: Deadlock은 프로그램을 멈추게 할 수 있음

**Race Condition:**
- 발생 조건: 공유 자원에 대한 동시 접근과 최소 하나의 쓰기 연산
- 예시: 카운터 증가, 계좌 잔액 업데이트, 리스트 추가
- 증상: 예상과 다른 결과, 데이터 손실, 일관성 없는 상태
- 검출: 어려우며 특정 타이밍에만 나타날 수 있음

**Deadlock:**
- 필요 조건 (네 가지 모두 만족):
  - 상호 배제: 자원은 한 번에 하나의 작업만 사용 가능
  - 점유와 대기: 자원을 점유한 채 다른 자원 대기
  - 비선점: 자원을 강제로 빼앗을 수 없음
  - 순환 대기: 자원 대기가 순환 구조 형성
- 예시: 두 스레드가 서로 다른 락을 점유하고 상대방 락을 기다림

**Race Condition 방지:**
- 동기화: Mutex, Semaphore, Lock으로 임계 영역 보호
- 원자적 연산: Atomic 변수나 CAS 연산 사용
- 불변 데이터: 공유 데이터를 읽기 전용으로 만듦
- 메시지 전달: 공유 메모리 대신 메시지로 통신
- 스레드 로컬: 각 스레드가 독립적인 데이터 사용

**Deadlock 방지:**
- 락 순서: 모든 스레드가 동일한 순서로 락 획득
- 타임아웃: 락 획득 시 타임아웃 설정하여 무한 대기 방지
- 락 계층: 락에 순서를 부여하여 낮은 순서부터 획득
- 자원 할당 그래프: 순환 대기를 감지하고 방지

**Deadlock 탐지 및 복구:**
- 데드락 탐지: 자원 할당 그래프에서 순환 검출
- 복구: 프로세스 종료, 자원 선점, 체크포인트 롤백
- 회피: Banker's 알고리즘으로 안전한 상태만 허용

**실무 활용:**
- 데이터베이스 트랜잭션의 락 순서를 일관되게 유지하여 데드락 방지
- 멀티스레드 프로그램에서 공유 자원 접근 시 적절한 동기화 메커니즘 사용
- 락 대신 불변 데이터나 메시지 전달로 동시성 문제 근본적으로 해결

---

## 질문 118: 동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?

**정의:**
동기는 작업을 순차적으로 실행하며 이전 작업이 완료될 때까지 기다리는 방식이고, 비동기는 작업을 시작하고 완료를 기다리지 않고 다음 작업을 진행하는 방식입니다. 각각 장단점이 있어 상황에 맞게 선택해야 합니다.

**특징/원리:**
- 동기: 호출한 함수가 결과를 반환할 때까지 대기
- 비동기: 함수를 호출하고 즉시 다음 코드 실행, 결과는 나중에 처리
- 블로킹: 동기는 보통 블로킹, 비동기는 논블로킹과 함께 사용
- 제어 흐름: 동기는 순차적이고 예측 가능, 비동기는 복잡하지만 효율적

**동기(Synchronous):**
- 순차 실행: 코드가 작성된 순서대로 실행
- 대기: 함수 호출 후 결과를 받을 때까지 다음 코드 실행 안 됨
- 간단함: 코드 흐름이 직관적이고 이해하기 쉬움
- 비효율: I/O 대기 중 CPU가 유휴 상태로 낭비
- 예시: 일반 함수 호출, 파일 읽기 (동기 API)

**비동기(Asynchronous):**
- 병행 실행: 작업을 시작하고 완료를 기다리지 않고 계속 진행
- 콜백: 작업 완료 시 콜백 함수 호출하여 결과 처리
- 효율성: I/O 대기 중 다른 작업 수행하여 시간 절약
- 복잡성: 콜백 지옥, 에러 처리가 복잡해질 수 있음
- 예시: AJAX 요청, setTimeout, Promise, async/await

**구현 패턴:**
- 콜백: 작업 완료 시 실행할 함수를 인자로 전달
- Promise: 비동기 작업의 최종 결과를 나타내는 객체
- async/await: Promise를 동기 코드처럼 작성할 수 있는 문법
- 이벤트: 이벤트 리스너로 비동기 결과 처리

**사용 사례:**
- 동기: 계산 집약적 작업, 순서가 중요한 작업, 간단한 스크립트
- 비동기: 네트워크 요청, 파일 I/O, 타이머, 이벤트 처리
- 혼합: 비동기로 데이터를 가져와 동기로 처리

**장단점:**
- 동기 장점: 코드 이해 쉬움, 디버깅 용이, 에러 처리 간단
- 동기 단점: I/O 대기 중 블로킹, 응답성 저하
- 비동기 장점: 효율적 자원 활용, 높은 처리량, 응답성 향상
- 비동기 단점: 복잡한 코드, 디버깅 어려움, 에러 처리 복잡

**실무 활용:**
- 웹 프론트엔드에서 API 호출을 비동기로 처리하여 UI 블로킹 방지
- Node.js에서 비동기 I/O로 높은 동시성 달성
- 계산 로직은 동기로 명확하게, I/O는 비동기로 효율적으로 처리

---

## 질문 119: 블로킹(Blocking)과 논블로킹(Non-blocking)의 차이점은 무엇인가요?

**정의:**
블로킹은 함수 호출 시 제어권이 넘어가 완료될 때까지 대기하는 방식이고, 논블로킹은 함수를 호출해도 즉시 제어권이 반환되어 다른 작업을 계속할 수 있는 방식입니다. 동기/비동기와 다른 개념으로 독립적으로 조합 가능합니다.

**특징/원리:**
- 블로킹: 호출된 함수가 완료될 때까지 호출자가 대기
- 논블로킹: 함수가 즉시 반환되어 호출자가 다른 작업 수행 가능
- 제어권: 누가 제어권을 가지고 있는가에 관한 개념
- 조합: 동기/비동기와 블로킹/논블로킹은 독립적으로 조합 가능

**블로킹(Blocking):**
- 대기: 함수 호출 후 결과를 받을 때까지 멈춤
- 단순: 코드 흐름이 직선적이어서 이해하기 쉬움
- 비효율: 대기 중 CPU를 활용하지 못함
- 예시: 동기 파일 읽기, 일반 네트워크 소켓 읽기

**논블로킹(Non-blocking):**
- 즉시 반환: 함수가 즉시 제어권을 반환
- 폴링: 주기적으로 완료 여부 확인 필요
- 효율: 대기하지 않고 다른 작업 수행 가능
- 예시: 논블로킹 소켓, 비동기 I/O

**동기/비동기 vs 블로킹/논블로킹:**
- 동기/비동기: 작업 완료를 누가 신경 쓰는가 (호출자 vs 호출된 함수)
- 블로킹/논블로킹: 제어권을 즉시 반환하는가
- 동기 블로킹: 일반적인 함수 호출, 완료까지 대기
- 동기 논블로킹: 폴링 방식, 즉시 반환하지만 호출자가 완료 확인
- 비동기 블로킹: 드물며 비효율적
- 비동기 논블로킹: 즉시 반환하고 완료 시 콜백, 가장 효율적

**I/O 모델:**
- Blocking I/O: 읽기/쓰기가 완료될 때까지 대기
- Non-blocking I/O: 즉시 반환하고 데이터 없으면 에러나 부분 결과 반환
- I/O Multiplexing: select/poll/epoll로 여러 I/O를 동시 모니터링
- Asynchronous I/O: 완료 시 시스템이 알림

**실무 활용:**
- 웹 서버에서 논블로킹 I/O로 많은 연결을 동시에 처리
- Node.js의 논블로킹 이벤트 루프로 높은 동시성 달성
- 게임 렌더링 루프는 논블로킹으로 입력을 처리하면서 화면 갱신

---

## 질문 120: 컴파일 언어와 인터프리터 언어의 차이점은 무엇인가요?

**정의:**
컴파일 언어는 소스 코드를 실행 전에 기계어로 변환하는 언어이고, 인터프리터 언어는 소스 코드를 한 줄씩 해석하며 실행하는 언어입니다. 각각 실행 속도, 개발 편의성, 이식성 등에서 장단점이 있습니다.

**특징/원리:**
- 컴파일: 전체 소스를 한 번에 기계어로 변환 후 실행
- 인터프리터: 소스를 한 줄씩 읽으며 즉시 실행
- 하이브리드: Java, Python 등은 중간 표현으로 컴파일 후 VM에서 해석
- JIT: Just-In-Time 컴파일로 두 방식의 장점 결합

**컴파일 언어:**
- 예시: C, C++, Go, Rust
- 과정: 소스 코드 → 컴파일러 → 기계어 → 실행
- 실행 속도: 빠름, 이미 기계어로 변환되어 있음
- 개발 시간: 느림, 컴파일 시간 필요
- 에러 검출: 컴파일 타임에 문법 및 타입 오류 검출
- 이식성: 낮음, 플랫폼별로 재컴파일 필요
- 최적화: 컴파일 타임에 다양한 최적화 수행

**인터프리터 언어:**
- 예시: Python, Ruby, JavaScript (초기)
- 과정: 소스 코드 → 인터프리터 → 한 줄씩 실행
- 실행 속도: 느림, 실행 중 해석 과정 필요
- 개발 시간: 빠름, 즉시 실행하여 테스트 가능
- 에러 검출: 런타임에 해당 줄 실행 시 검출
- 이식성: 높음, 인터프리터만 있으면 어디서든 실행
- REPL: 대화형 실행 환경 제공

**하이브리드 방식:**
- Java: 바이트코드로 컴파일 후 JVM에서 해석/JIT 컴파일
- Python: 바이트코드(.pyc)로 컴파일 후 인터프리터 실행
- C#: IL(중간 언어)로 컴파일 후 CLR에서 JIT 컴파일
- JavaScript: 현대 엔진은 JIT 컴파일로 성능 향상

**JIT 컴파일:**
- 개념: 실행 시점에 자주 실행되는 코드를 기계어로 컴파일
- 장점: 인터프리터의 유연성과 컴파일의 속도를 결합
- 최적화: 런타임 정보로 더 공격적인 최적화 가능
- 예시: HotSpot JVM, V8 JavaScript 엔진

**선택 기준:**
- 성능 중요: 컴파일 언어 선택 (C, C++, Rust, Go)
- 개발 속도: 인터프리터 언어로 빠른 프로토타이핑 (Python, Ruby)
- 이식성: 하이브리드 방식으로 플랫폼 독립성 (Java, C#)
- 현대 언어: JIT 컴파일로 성능과 생산성 모두 추구

**실무 활용:**
- 시스템 프로그래밍은 C/C++/Rust로 최고 성능 추구
- 웹 백엔드는 다양한 언어 선택 가능 (Go, Java, Python, Node.js)
- 스크립팅이나 데이터 분석은 Python으로 빠른 개발

---
