# Spring 답변 85-86

## 질문 85: RestTemplate과 WebClient의 차이점 및 사용 사례에 대해 설명해주세요.

RestTemplate과 WebClient는 모두 Spring에서 HTTP 클라이언트로 사용되는 도구입니다. RestTemplate은 전통적인 동기 블로킹 방식이고, WebClient는 현대적인 비동기 논블로킹 방식입니다.

**RestTemplate의 특징:**

첫째, 동기 블로킹 방식입니다. HTTP 요청을 보내고 응답을 받을 때까지 스레드가 블로킹됩니다. 응답이 올 때까지 다른 작업을 할 수 없습니다. 간단하고 직관적인 프로그래밍 모델입니다.

둘째, Spring 3.0부터 제공되었습니다. 오래되고 안정적인 API입니다. 많은 프로젝트에서 사용되어 왔습니다.

셋째, 명령형 스타일입니다. 순차적으로 코드를 작성합니다. 결과를 직접 받아 처리합니다.

넷째, 메서드가 직관적입니다. getForObject, postForObject, exchange 등의 메서드가 있습니다. HTTP 메서드별로 편리한 메서드를 제공합니다.

다섯째, 유지보수 모드입니다. Spring 5.0부터 유지보수 모드로 전환되었습니다. 새로운 기능이 추가되지 않습니다. WebClient 사용이 권장됩니다.

**WebClient의 특징:**

첫째, 비동기 논블로킹 방식입니다. Reactive Streams를 기반으로 합니다. 스레드가 블로킹되지 않습니다. 적은 스레드로 많은 요청을 처리할 수 있습니다.

둘째, Spring 5.0에서 도입되었습니다. Spring WebFlux의 일부입니다. 현대적인 API 설계입니다.

셋째, 함수형 스타일입니다. Fluent API를 제공합니다. 메서드 체이닝으로 요청을 구성합니다. 선언적으로 작성합니다.

넷째, Mono와 Flux를 반환합니다. 비동기 결과를 표현합니다. subscribe나 block으로 결과를 받습니다. 리액티브 파이프라인을 구성할 수 있습니다.

다섯째, MVC 환경에서도 사용 가능합니다. WebFlux가 아니어도 사용할 수 있습니다. 외부 API 호출을 논블로킹으로 처리합니다.

**주요 차이점:**

첫째, 동시성 모델입니다. RestTemplate은 요청당 스레드가 필요합니다. 많은 요청을 처리하려면 많은 스레드가 필요합니다. WebClient는 적은 스레드로 많은 요청을 처리합니다. 이벤트 루프 방식으로 동작합니다.

둘째, 성능입니다. RestTemplate은 블로킹되어 스레드를 점유합니다. 많은 동시 요청에서는 비효율적입니다. WebClient는 논블로킹으로 효율적입니다. I/O 대기 시간 동안 다른 작업을 처리합니다.

셋째, API 스타일입니다. RestTemplate은 명령형입니다. 간단하고 이해하기 쉽습니다. WebClient는 선언형입니다. 함수형 프로그래밍 스타일입니다. 처음에는 복잡해 보일 수 있습니다.

넷째, 확장성입니다. RestTemplate은 스레드 풀 크기에 제한됩니다. WebClient는 더 높은 확장성을 제공합니다.

다섯째, 유지보수 상태입니다. RestTemplate은 유지보수 모드입니다. WebClient는 활발히 개발되고 있습니다. 새로운 기능이 계속 추가됩니다.

**RestTemplate 사용 예시:**

간단한 GET 요청은 getForObject를 사용합니다. URL과 응답 타입을 지정합니다. 직접 객체를 반환받습니다.

POST 요청은 postForObject를 사용합니다. 요청 바디와 응답 타입을 지정합니다.

더 세밀한 제어가 필요하면 exchange를 사용합니다. HttpEntity로 헤더와 바디를 설정합니다. ResponseEntity로 상태 코드와 헤더를 받을 수 있습니다.

**WebClient 사용 예시:**

WebClient 인스턴스를 생성합니다. 빌더로 기본 URL, 헤더, 타임아웃 등을 설정합니다.

GET 요청은 get 메서드로 시작합니다. uri로 경로를 지정합니다. retrieve로 응답을 받습니다. bodyToMono나 bodyToFlux로 바디를 변환합니다.

POST 요청은 post 메서드로 시작합니다. bodyValue나 body로 요청 바디를 설정합니다.

block을 호출하면 동기 방식처럼 사용할 수 있습니다. 하지만 이는 WebClient의 이점을 살리지 못합니다. subscribe로 비동기로 처리하는 것이 좋습니다.

**에러 처리:**

RestTemplate은 예외를 던집니다. HttpClientErrorException, HttpServerErrorException 등을 catch합니다. try-catch로 처리합니다.

WebClient는 onStatus로 에러 처리를 정의합니다. 상태 코드에 따라 예외를 매핑합니다. onErrorResume으로 fallback을 제공합니다. 리액티브 스트림의 에러 처리 메커니즘을 사용합니다.

**타임아웃 설정:**

RestTemplate은 ClientHttpRequestFactory를 커스터마이징합니다. 연결 타임아웃과 읽기 타임아웃을 설정합니다.

WebClient는 빌더에서 타임아웃을 설정합니다. responseTimeout으로 전체 응답 타임아웃을 지정합니다. HttpClient를 커스터마이징하여 세밀하게 제어할 수 있습니다.

**인터셉터와 필터:**

RestTemplate은 ClientHttpRequestInterceptor를 사용합니다. 요청과 응답을 가로챕니다. 헤더 추가, 로깅 등을 수행합니다.

WebClient는 ExchangeFilterFunction을 사용합니다. 함수형 스타일로 필터를 정의합니다. 요청과 응답을 변환하거나 로깅합니다.

**재시도 로직:**

RestTemplate은 수동으로 재시도 로직을 구현해야 합니다. 루프나 재귀로 처리합니다.

WebClient는 retry 연산자를 사용합니다. 선언적으로 재시도를 정의합니다. 백오프 전략을 쉽게 적용할 수 있습니다. Reactor의 retry 기능을 활용합니다.

**병렬 요청:**

RestTemplate은 CompletableFuture나 병렬 스트림을 사용해야 합니다. 수동으로 스레드를 관리합니다.

WebClient는 Flux로 여러 요청을 쉽게 병렬 처리합니다. flatMap으로 동시 요청을 보냅니다. 결과를 스트림으로 조합합니다.

**사용 시나리오:**

RestTemplate을 사용하는 경우는 다음과 같습니다. 레거시 프로젝트에서 이미 사용 중입니다. 간단한 HTTP 호출만 필요합니다. 팀이 동기 방식에 익숙합니다. 블로킹이 문제가 되지 않는 환경입니다. 빠른 마이그레이션이 어려운 경우입니다.

WebClient를 사용하는 경우는 다음과 같습니다. 새로운 프로젝트를 시작합니다. 많은 외부 API 호출이 필요합니다. 성능과 확장성이 중요합니다. 비동기 처리가 필요합니다. WebFlux 환경입니다. 여러 API를 병렬로 호출해야 합니다.

**마이그레이션:**

RestTemplate에서 WebClient로 전환할 때 점진적으로 진행합니다. 중요하지 않은 부분부터 시작합니다. block을 사용하여 동기 방식처럼 사용할 수 있습니다. 점차 리액티브 스타일로 전환합니다.

**성능 비교:**

단일 요청에서는 차이가 크지 않습니다. 많은 동시 요청에서 WebClient가 우수합니다. I/O 바운드 작업에서 WebClient의 이점이 큽니다. CPU 바운드 작업에서는 차이가 적습니다.

**권장사항:**

새로운 개발에는 WebClient를 사용합니다. RestTemplate은 유지보수 모드입니다. Spring 팀도 WebClient를 권장합니다. 초기 학습 비용이 있지만 장기적으로 이득입니다. 외부 API 호출이 많은 경우 특히 유용합니다.

**결론:**

RestTemplate은 간단하지만 제한적입니다. WebClient는 현대적이고 강력합니다. 프로젝트 요구사항에 맞게 선택해야 합니다. 가능하면 WebClient로 전환하는 것이 좋습니다.

## 질문 86: @Scheduled 애노테이션을 사용한 스케줄링 작업 구현 방법은 무엇인가요?

@Scheduled는 Spring에서 정기적으로 반복 실행되는 작업을 간단하게 구현할 수 있게 하는 어노테이션입니다. Cron 표현식, 고정 지연, 고정 속도 등 다양한 방식으로 스케줄링할 수 있습니다.

**스케줄링이 필요한 경우:**

첫째, 주기적인 데이터 처리입니다. 매시간 통계를 집계합니다. 매일 리포트를 생성합니다. 정기적으로 데이터를 동기화합니다.

둘째, 정리 작업입니다. 오래된 데이터를 삭제합니다. 임시 파일을 정리합니다. 캐시를 갱신합니다.

셋째, 모니터링과 헬스 체크입니다. 시스템 상태를 주기적으로 확인합니다. 외부 서비스의 가용성을 체크합니다. 알림을 전송합니다.

넷째, 배치 작업입니다. 대량의 데이터를 처리합니다. ETL 작업을 수행합니다. 정산 작업을 실행합니다.

**기본 설정:**

첫째, @EnableScheduling을 활성화합니다. 설정 클래스나 메인 클래스에 어노테이션을 붙입니다. Spring이 @Scheduled를 인식하기 시작합니다.

둘째, @Scheduled를 메서드에 붙입니다. 해당 메서드가 정기적으로 실행됩니다. 메서드는 void 반환 타입이어야 합니다. 파라미터를 가질 수 없습니다.

셋째, 스케줄링 방식을 선택합니다. fixedDelay, fixedRate, cron 중 하나를 사용합니다.

**fixedDelay:**

이전 실행이 완료된 후 지정된 시간이 지나면 다시 실행됩니다. 밀리초 단위로 지정합니다. 이전 작업이 오래 걸려도 겹치지 않습니다. 작업 간 일정한 간격을 보장합니다.

예를 들어 fixedDelay=5000이면 작업 완료 후 5초 후에 다시 실행됩니다. 작업이 10초 걸리면 15초마다 실행됩니다.

**fixedRate:**

이전 실행이 시작된 시점부터 지정된 시간마다 실행됩니다. 밀리초 단위로 지정합니다. 이전 작업이 완료되지 않아도 시작할 수 있습니다. 일정한 주기를 유지하려 합니다.

예를 들어 fixedRate=5000이면 5초마다 실행을 시도합니다. 작업이 3초 걸리면 매 5초마다 실행됩니다.

주의점은 작업이 주기보다 오래 걸리면 겹칠 수 있습니다. 동시 실행 문제를 고려해야 합니다.

**initialDelay:**

애플리케이션 시작 후 첫 실행까지의 지연 시간입니다. fixedDelay나 fixedRate와 함께 사용합니다. 밀리초 단위로 지정합니다. 초기화 시간을 주거나 모든 작업이 동시에 시작되는 것을 방지합니다.

**cron 표현식:**

더 복잡한 스케줄링을 위해 사용합니다. Unix cron과 유사한 문법입니다. 초, 분, 시, 일, 월, 요일을 지정합니다.

형식은 "초 분 시 일 월 요일"입니다. 각 필드는 숫자, 범위, 리스트, 와일드카드 등을 사용할 수 있습니다.

별표는 모든 값을 의미합니다. 예를 들어 "0 0 * * * *"는 매시간 정각입니다.

슬래시는 간격을 의미합니다. "0 */10 * * * *"는 10분마다입니다.

하이픈은 범위를 의미합니다. "0 0 9-17 * * MON-FRI"는 평일 9시부터 17시까지 매시간입니다.

쉼표는 리스트를 의미합니다. "0 0 0 1,15 * *"는 매월 1일과 15일 자정입니다.

**zone 속성:**

cron 표현식은 기본적으로 서버의 타임존을 사용합니다. zone 속성으로 특정 타임존을 지정할 수 있습니다. 예를 들어 zone="Asia/Seoul"로 지정합니다.

**동적 스케줄링:**

@Scheduled는 정적입니다. 애플리케이션 시작 시 고정됩니다. 런타임에 변경할 수 없습니다.

동적으로 변경하려면 ScheduledTaskRegistrar를 사용합니다. SchedulingConfigurer를 구현합니다. 프로그래밍 방식으로 작업을 등록합니다. 데이터베이스에서 스케줄 정보를 읽어 적용할 수 있습니다.

**TaskScheduler 설정:**

@Scheduled는 기본 TaskScheduler를 사용합니다. 단일 스레드로 동작합니다. 여러 스케줄 작업이 있으면 순차적으로 실행됩니다.

커스텀 TaskScheduler를 정의하는 것이 좋습니다. ThreadPoolTaskScheduler를 Bean으로 등록합니다. 풀 크기를 설정하여 병렬 실행을 허용합니다.

SchedulingConfigurer를 구현하여 Scheduler를 커스터마이징합니다.

**비동기 실행:**

@Scheduled와 @Async를 함께 사용할 수 있습니다. 스케줄 작업이 비동기로 실행됩니다. 이전 실행이 완료되지 않아도 다음 실행이 시작될 수 있습니다.

주의점은 동시 실행 문제입니다. 같은 작업이 중복 실행될 수 있습니다. 멱등성을 보장하거나 락을 사용해야 합니다.

**예외 처리:**

스케줄 작업에서 예외가 발생하면 로그만 남고 계속 실행됩니다. 다음 스케줄은 정상적으로 실행됩니다.

try-catch로 예외를 처리하는 것이 좋습니다. 에러를 로깅하고 알림을 전송합니다. 중요한 작업은 재시도 로직을 구현합니다.

**분산 환경에서의 스케줄링:**

여러 인스턴스가 있으면 모든 인스턴스에서 스케줄 작업이 실행됩니다. 중복 실행 문제가 발생합니다.

해결 방법은 여러 가지입니다.

첫째, 분산 락을 사용합니다. Redis나 데이터베이스로 락을 구현합니다. 한 인스턴스만 작업을 실행하도록 합니다. ShedLock 라이브러리가 유용합니다.

둘째, 하나의 인스턴스만 스케줄러를 활성화합니다. 리더 선출 메커니즘을 사용합니다. Kubernetes에서는 StatefulSet을 활용할 수 있습니다.

셋째, 별도의 스케줄러 서버를 운영합니다. 배치 작업만 전담하는 서버를 둡니다. 웹 서버와 분리합니다.

**Spring Batch와의 통합:**

복잡한 배치 작업은 Spring Batch를 사용합니다. @Scheduled로 Job을 트리거합니다. JobLauncher로 Job을 실행합니다. 트랜잭션, 재시도, 스킵 등의 기능을 활용합니다.

**Quartz와 비교:**

@Scheduled는 간단한 스케줄링에 적합합니다. 설정이 간단하고 Spring과 잘 통합됩니다. 대부분의 경우 충분합니다.

Quartz는 복잡한 스케줄링에 적합합니다. 작업 영속성을 지원합니다. 클러스터링을 기본으로 지원합니다. 동적 스케줄링이 쉽습니다. 미스파이어 처리 등 고급 기능이 있습니다.

**모니터링:**

스케줄 작업의 실행 여부를 모니터링해야 합니다. 마지막 실행 시간을 기록합니다. 실행 실패를 추적합니다. Actuator 엔드포인트로 상태를 노출할 수 있습니다.

**테스트:**

스케줄 작업을 테스트하기 어렵습니다. 시간을 기다려야 합니다.

해결 방법은 비즈니스 로직을 별도 메서드로 분리하는 것입니다. @Scheduled 메서드는 단순히 비즈니스 메서드를 호출합니다. 비즈니스 메서드를 직접 테스트합니다.

Awaitility 라이브러리로 스케줄 실행을 기다릴 수 있습니다.

**실무 팁:**

스케줄 작업은 가볍게 유지합니다. 무거운 작업은 비동기로 처리합니다. 멱등성을 보장합니다. 같은 작업이 중복 실행되어도 문제없도록 합니다. 로깅을 충분히 합니다. 실행 시작, 종료, 에러를 기록합니다. 알림을 설정합니다. 중요한 작업이 실패하면 즉시 알립니다.

**주의사항:**

너무 많은 스케줄 작업은 시스템 부하를 증가시킵니다. 필요한 것만 유지합니다. 너무 짧은 주기는 피합니다. 시스템에 과부하를 줄 수 있습니다. 작업이 주기보다 오래 걸리지 않도록 합니다. 겹치는 실행을 방지합니다.

**property로 설정 외부화:**

fixedDelayString과 fixedRateString을 사용합니다. ${} 표현식으로 프로퍼티 값을 참조합니다. application.properties에서 값을 변경할 수 있습니다. 환경별로 다른 주기를 설정할 수 있습니다.

cron도 문자열로 외부화할 수 있습니다.

**조건부 스케줄링:**

@ConditionalOnProperty로 조건부로 활성화합니다. 특정 프로파일에서만 실행되도록 합니다. 개발 환경에서는 비활성화하고 프로덕션에서만 활성화할 수 있습니다.

**결론:**

@Scheduled는 간단한 스케줄링을 쉽게 구현할 수 있게 합니다. 정기적인 작업을 자동화하는 데 유용합니다. 적절히 사용하면 시스템 운영을 효율적으로 만들 수 있습니다. 분산 환경과 예외 처리를 신중하게 고려해야 합니다.
