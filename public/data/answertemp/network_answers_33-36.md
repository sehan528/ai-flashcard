# Network 답변 모음 (33-36)

## 33. TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.

**TCP 혼잡 제어(Congestion Control)**는 네트워크의 혼잡을 방지하고 효율적인 대역폭 사용을 위해 전송 속도를 조절하는 메커니즘입니다.

**혼잡 윈도우(Congestion Window, cwnd):**
송신자가 ACK를 받지 않고 전송할 수 있는 데이터의 양을 나타냅니다. 실제 전송량은 혼잡 윈도우와 수신 윈도우 중 작은 값으로 결정됩니다.

**Slow Start(느린 시작):**
연결 초기에 cwnd를 작은 값(일반적으로 1-10 MSS)에서 시작하여 지수적으로 증가시킵니다. ACK를 받을 때마다 cwnd를 1 MSS씩 증가시켜, 매 RTT마다 윈도우가 2배로 증가합니다. ssthresh(slow start threshold) 값에 도달하거나 패킷 손실이 발생할 때까지 계속됩니다.

**Congestion Avoidance(혼잡 회피):**
cwnd가 ssthresh에 도달하면 선형적으로 증가합니다. 매 RTT마다 cwnd를 1 MSS씩만 증가시켜 조심스럽게 탐색합니다. 네트워크 용량에 근접하면서도 혼잡을 피하기 위한 단계입니다.

**Fast Retransmit(빠른 재전송):**
3개의 중복 ACK를 받으면 타임아웃을 기다리지 않고 즉시 손실된 세그먼트를 재전송합니다. 타임아웃보다 빠르게 손실을 감지하여 효율성을 높입니다.

**Fast Recovery(빠른 회복):**
Fast Retransmit 후 Slow Start로 돌아가지 않고 혼잡 회피 단계로 진입합니다. ssthresh를 현재 cwnd의 절반으로 설정하고, cwnd를 ssthresh 값으로 설정합니다. 중복 ACK는 패킷이 네트워크를 빠져나갔다는 증거이므로 완전한 혼잡 상태는 아니라고 판단합니다.

**타임아웃 발생 시:**
가장 심각한 혼잡 신호로 간주합니다. ssthresh를 현재 cwnd의 절반으로 설정하고, cwnd를 초기값(1 MSS)으로 줄입니다. Slow Start부터 다시 시작합니다.

**혼잡 제어 알고리즘 변형:**
- **Tahoe**: Fast Retransmit 후 Slow Start로 돌아갑니다
- **Reno**: Fast Recovery를 도입하여 효율성을 개선했습니다
- **New Reno**: 여러 패킷 손실을 더 잘 처리합니다
- **CUBIC**: 대역폭이 큰 환경에서 효율적이며, 리눅스의 기본 알고리즘입니다
- **BBR**: Google이 개발한 알고리즘으로, RTT와 대역폭을 기반으로 최적화합니다

**CUBIC의 특징:**
윈도우 크기를 3차 함수로 조정하여 고속 네트워크에서 더 빠르게 대역폭을 활용합니다. 손실 이벤트 시점을 기준으로 윈도우를 조정합니다.

**BBR의 접근:**
패킷 손실이 아닌 RTT와 전송률을 측정하여 네트워크의 실제 용량을 파악합니다. 버퍼 bloat 문제를 해결하고 더 낮은 지연과 높은 처리량을 제공합니다.

**ECN(Explicit Congestion Notification):**
라우터가 혼잡을 감지하면 패킷을 폐기하지 않고 IP 헤더에 표시합니다. 수신자는 이를 ACK에 표시하여 송신자에게 알립니다. 패킷 손실 없이 혼잡을 조기에 감지할 수 있습니다.

**공평성(Fairness):**
여러 TCP 연결이 같은 병목 링크를 공유할 때 대역폭을 공평하게 분배하도록 설계되었습니다. AIMD(Additive Increase Multiplicative Decrease) 방식이 이를 보장합니다.

**실무적 의미:**
혼잡 제어는 인터넷 전체의 안정성을 유지하는 핵심 메커니즘입니다. 모든 호스트가 협력하여 네트워크 붕괴를 방지합니다.

---

## 34. 왜 HTTP는 TCP를 사용하나요?

HTTP가 TCP를 사용하는 이유는 **신뢰성 있는 데이터 전송**이 필요하기 때문입니다.

**데이터 무결성 보장:**
웹 페이지의 HTML, CSS, JavaScript, 이미지 등은 정확하게 전달되어야 합니다. 하나의 바이트라도 손실되거나 순서가 바뀌면 페이지가 깨지거나 스크립트가 오작동할 수 있습니다.

**순서 보장의 중요성:**
HTTP 응답은 순서대로 조립되어야 의미가 있습니다. HTML 파일의 앞부분이 뒷부분보다 나중에 도착하면 브라우저가 올바르게 렌더링할 수 없습니다.

**완전한 전송 보장:**
파일 다운로드, 폼 제출, API 요청 등은 모든 데이터가 완전히 전달되어야 합니다. 일부만 전달되면 작업이 실패하거나 잘못된 결과를 초래합니다.

**TCP의 재전송 메커니즘:**
네트워크 상황이 좋지 않아 패킷이 손실되어도 TCP가 자동으로 재전송하여 복구합니다. 애플리케이션 레벨에서 별도로 처리할 필요가 없습니다.

**흐름 제어:**
서버와 클라이언트의 처리 속도가 다를 때 TCP의 흐름 제어로 수신자가 감당할 수 있는 속도로 전송합니다. 버퍼 오버플로우를 방지합니다.

**혼잡 제어:**
네트워크가 혼잡할 때 전송 속도를 자동으로 조절하여 네트워크 붕괴를 방지합니다. 전체 인터넷의 안정성에 기여합니다.

**연결 지향 특성:**
HTTP/1.1 이전에는 요청마다 연결을 새로 만들었지만, HTTP/1.1부터는 Keep-Alive로 연결을 재사용합니다. TCP의 연결 개념이 이를 자연스럽게 지원합니다.

**포트 기반 서비스 식별:**
TCP의 포트 번호로 여러 서비스를 구분할 수 있습니다. HTTP는 80번, HTTPS는 443번 포트를 사용하여 명확하게 식별됩니다.

**보안 계층 통합:**
HTTPS는 TLS/SSL 보안 계층을 TCP 위에 구축합니다. TCP의 연결 지향 특성이 보안 핸드셰이크와 잘 맞습니다.

**방화벽 통과:**
TCP 80/443 포트는 거의 모든 방화벽에서 허용됩니다. 기업 환경에서도 문제없이 동작합니다.

**UDP를 사용하지 않는 이유:**
UDP는 빠르지만 신뢰성이 없습니다. 웹 페이지의 일부가 누락되는 것은 허용될 수 없으므로 UDP는 부적합합니다. 애플리케이션 레벨에서 신뢰성을 구현하는 것은 복잡하고 비효율적입니다.

**역사적 배경:**
HTTP가 설계될 당시(1990년대 초) TCP는 이미 성숙한 프로토콜이었고, 신뢰성 있는 전송의 표준이었습니다. 새로운 프로토콜을 만들 필요가 없었습니다.

**멀티플렉싱의 발전:**
HTTP/2는 TCP 위에서 멀티플렉싱을 구현하여 성능을 개선했습니다. TCP의 신뢰성을 유지하면서도 병렬 처리가 가능해졌습니다.

**예외 사례 - HTTP/3:**
HTTP/3는 QUIC(UDP 기반)을 사용하지만, 이는 QUIC이 TCP의 신뢰성 기능을 모두 재구현했기 때문입니다. 여전히 신뢰성 있는 전송이 필요합니다.

---

## 35. 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?

HTTP/3가 UDP를 사용하는 이유는 **TCP의 한계를 극복**하기 위함이며, QUIC 프로토콜이 UDP 위에서 TCP의 모든 신뢰성 기능을 재구현했습니다.

**TCP의 근본적 한계:**
TCP는 운영체제 커널에 구현되어 있어 프로토콜 개선이 어렵습니다. 새로운 기능을 추가하려면 모든 서버와 클라이언트의 운영체제를 업데이트해야 하는데, 이는 수년이 걸리거나 불가능합니다.

**HOL Blocking 문제:**
TCP는 패킷 손실 시 순서를 보장하기 위해 모든 스트림이 대기해야 합니다. HTTP/2는 애플리케이션 레벨 멀티플렉싱을 구현했지만, TCP 레벨의 HOL Blocking은 해결하지 못했습니다.

**느린 연결 수립:**
TCP 핸드셰이크(1-RTT)와 TLS 핸드셰이크(1-2 RTT)를 순차적으로 수행하여 총 2-3 RTT가 필요합니다. 모바일 환경에서는 지연이 크게 느껴집니다.

**연결 마이그레이션 불가:**
TCP는 연결을 IP 주소와 포트로 식별하므로, Wi-Fi에서 모바일로 전환 시 연결이 끊어집니다. 사용자 경험이 저하됩니다.

**UDP를 선택한 이유:**
UDP는 최소한의 기능만 제공하는 단순한 프로토콜입니다. 이를 기반으로 사용자 공간에서 필요한 기능을 자유롭게 구현할 수 있습니다. 운영체제 업데이트 없이 애플리케이션 업데이트만으로 프로토콜을 개선할 수 있습니다.

**QUIC의 신뢰성 구현:**
QUIC은 UDP 위에서 다음 기능들을 구현하여 TCP의 신뢰성을 완전히 재현했습니다:
- **순서 보장**: 스트림별 독립적인 순서 보장
- **재전송**: 패킷 손실 감지 및 재전송
- **흐름 제어**: 스트림별, 연결별 흐름 제어
- **혼잡 제어**: TCP와 유사한 혼잡 제어 알고리즘

**스트림별 독립성:**
QUIC은 각 스트림이 독립적으로 동작하여, 하나의 스트림에서 패킷 손실이 발생해도 다른 스트림은 영향을 받지 않습니다. 이로써 TCP의 HOL Blocking을 완전히 해결했습니다.

**0-RTT 연결:**
이전에 연결했던 서버라면 핸드셰이크 없이 즉시 데이터를 전송할 수 있습니다. 첫 패킷부터 실제 데이터를 포함할 수 있어 지연이 최소화됩니다.

**연결 ID 사용:**
IP 주소와 포트 대신 Connection ID로 연결을 식별하여, 네트워크가 변경되어도 연결이 유지됩니다. 모바일 환경에서 끊김 없는 경험을 제공합니다.

**내장된 암호화:**
QUIC은 TLS 1.3을 기본으로 통합하여 항상 암호화된 통신을 제공합니다. 별도의 핸드셰이크 단계가 필요 없어 지연이 줄어듭니다.

**향상된 손실 복구:**
각 패킷에 고유 번호를 부여하여 재전송 패킷과 원본 패킷을 명확히 구분합니다. RTT 측정이 정확해지고 재전송 효율이 향상됩니다.

**유연한 발전:**
사용자 공간 구현으로 새로운 기능을 빠르게 추가할 수 있습니다. 혼잡 제어 알고리즘 개선, 새로운 기능 추가 등이 용이합니다.

**UDP의 문제 해결:**
QUIC은 UDP의 모든 단점(신뢰성 없음, 순서 없음, 흐름제어 없음)을 애플리케이션 레벨에서 해결했습니다. UDP의 장점(유연성, 낮은 오버헤드)만 활용했습니다.

**결론:**
HTTP/3는 UDP를 직접 사용하는 것이 아니라, UDP 위에 구축된 QUIC이라는 완전한 전송 프로토콜을 사용합니다. QUIC은 TCP의 모든 신뢰성과 UDP의 유연성을 결합한 차세대 프로토콜입니다.

---

## 36. 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?

브라우저는 여러 메커니즘을 통해 서버가 지원하는 프로토콜을 **협상(Negotiation)**하고 감지합니다.

**Alt-Svc 헤더(Alternative Service):**
HTTP/2를 사용하는 서버는 응답에 Alt-Svc 헤더를 포함하여 HTTP/3를 지원함을 알립니다. 예를 들어, "h3=\":443\""는 동일한 443 포트에서 HTTP/3(QUIC)을 지원한다는 의미입니다. 브라우저는 이 정보를 캐싱하여 다음 연결부터 HTTP/3를 시도합니다.

**초기 연결 과정:**
처음 방문하는 사이트의 경우, 브라우저는 먼저 전통적인 TCP 기반 HTTP/1.1 또는 HTTP/2로 연결합니다. 서버가 Alt-Svc 헤더를 보내면, 브라우저는 다음 요청부터 HTTP/3를 시도합니다.

**DNS HTTPS 레코드:**
DNS에 HTTPS 레코드를 설정하여 해당 도메인이 지원하는 프로토콜 정보를 제공할 수 있습니다. 브라우저는 DNS 조회 시점에 HTTP/3 지원 여부를 미리 알 수 있어 첫 연결부터 최적의 프로토콜을 선택할 수 있습니다.

**Happy Eyeballs 알고리즘:**
브라우저는 TCP와 QUIC(UDP) 연결을 동시에 시도하는 경우가 있습니다. 먼저 성공하는 연결을 사용하고 다른 연결은 취소합니다. 이를 통해 빠른 연결과 폴백을 동시에 보장합니다.

**연결 캐싱:**
브라우저는 성공한 프로토콜 정보를 캐싱합니다. 같은 도메인에 다시 접속할 때 마지막으로 성공한 프로토콜을 우선 시도합니다.

**QUIC 버전 협상:**
클라이언트가 QUIC 연결을 시도할 때 지원하는 QUIC 버전 목록을 보냅니다. 서버가 지원하지 않는 버전이면 Version Negotiation 패킷으로 지원 버전을 알립니다.

**폴백 메커니즘:**
HTTP/3(QUIC) 연결이 실패하면 자동으로 HTTP/2(TCP)로 폴백합니다. 일부 방화벽이 UDP를 차단하는 경우를 대비한 안전장치입니다.

**UDP 차단 감지:**
브라우저는 QUIC 연결 시도가 타임아웃되면 해당 네트워크에서 UDP가 차단되었다고 판단합니다. 이 정보를 저장하여 다음 연결부터는 TCP만 시도합니다.

**프로토콜 우선순위:**
현대 브라우저의 기본 전략은 HTTP/3 → HTTP/2 → HTTP/1.1 순서로 시도합니다. 가장 최신이고 빠른 프로토콜을 우선합니다.

**TLS ALPN(Application-Layer Protocol Negotiation):**
TLS 핸드셰이크 시 클라이언트가 지원하는 프로토콜 목록을 보내고, 서버가 선택한 프로토콜을 응답합니다. HTTP/2는 이 방식으로 협상됩니다.

**포트 번호:**
일반적으로 HTTP/3도 443 포트를 사용하지만, Alt-Svc 헤더로 다른 포트를 지정할 수 있습니다. 브라우저는 이 정보를 따릅니다.

**실제 동작 예시:**
사용자가 처음 사이트에 접속하면 TCP/443으로 HTTP/2 연결을 합니다. 서버가 Alt-Svc 헤더를 보내면 브라우저가 캐싱합니다. 다음 방문 시 UDP/443으로 HTTP/3를 시도하며, 실패하면 TCP로 폴백합니다.

**개발자 도구:**
브라우저 개발자 도구의 Network 탭에서 사용된 프로토콜(h2, h3 등)을 확인할 수 있습니다. 실제 어떤 프로토콜이 협상되었는지 투명하게 보여줍니다.

**점진적 도입:**
이러한 협상 메커니즘 덕분에 HTTP/3를 점진적으로 도입할 수 있습니다. 지원하는 클라이언트는 HTTP/3를 사용하고, 지원하지 않는 클라이언트는 이전 버전을 사용합니다.
