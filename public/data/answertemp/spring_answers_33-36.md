# Spring 답변 33-36

## 질문 33: equals()와 hashcode()에 대해 설명해 주세요.

equals와 hashCode는 Object 클래스에 정의된 메서드로, 객체의 동등성 비교와 해시 기반 컬렉션에서 사용됩니다.

**equals 메서드:**

equals는 두 객체가 논리적으로 같은지 판단합니다. Object의 기본 구현은 참조 동등성을 비교합니다. 즉 같은 메모리 주소를 가리키는지 확인합니다.

대부분의 클래스는 equals를 오버라이드하여 내용 기반 동등성을 구현합니다. String, Integer 같은 클래스들이 그렇습니다. 두 객체의 필드 값이 같으면 동등하다고 판단합니다.

equals의 규약은 반사성, 대칭성, 추이성, 일관성, null과의 비교를 따라야 합니다. 반사성은 x.equals(x)가 항상 true여야 합니다. 대칭성은 x.equals(y)가 true면 y.equals(x)도 true여야 합니다. 추이성은 x.equals(y)와 y.equals(z)가 true면 x.equals(z)도 true여야 합니다. 일관성은 변경되지 않는 한 반복 호출해도 같은 결과여야 합니다. null과 비교하면 항상 false여야 합니다.

**hashCode 메서드:**

hashCode는 객체의 해시 코드를 정수로 반환합니다. 해시 기반 컬렉션(HashMap, HashSet, Hashtable)에서 객체를 빠르게 찾기 위해 사용됩니다.

해시 코드는 객체를 해시 테이블의 버킷에 배치하는 데 사용됩니다. 좋은 해시 함수는 객체들을 고르게 분산시켜 충돌을 최소화합니다.

**equals와 hashCode의 계약:**

가장 중요한 규칙은 equals로 같다고 판단된 두 객체는 반드시 같은 hashCode를 반환해야 한다는 것입니다. 이를 위반하면 HashMap 같은 컬렉션이 정상 작동하지 않습니다.

역은 성립하지 않아도 됩니다. hashCode가 같아도 equals는 false일 수 있습니다. 이를 해시 충돌이라고 합니다.

equals를 오버라이드하면 반드시 hashCode도 함께 오버라이드해야 합니다. 그렇지 않으면 HashMap에서 객체를 찾을 수 없는 버그가 발생합니다.

**HashMap에서의 동작:**

HashMap에 객체를 넣을 때 먼저 hashCode로 버킷을 찾습니다. 그 버킷 내에서 equals로 정확한 객체를 찾습니다. get 할 때도 동일한 과정을 거칩니다.

hashCode가 다르면 다른 버킷에 저장되어 equals 비교조차 하지 않습니다. hashCode가 같으면 같은 버킷에서 equals로 비교합니다.

**성능 고려사항:**

hashCode는 자주 호출되므로 빨라야 합니다. 복잡한 계산은 피하고 캐싱을 고려합니다. equals도 빠르게 실행되어야 하지만 정확성이 더 중요합니다.

**불변 객체에서의 구현:**

불변 객체는 hashCode를 생성 시점에 계산하고 캐싱할 수 있습니다. String이 이렇게 구현되어 있습니다. 성능이 크게 향상됩니다.

**IDE와 라이브러리 지원:**

대부분의 IDE는 equals와 hashCode를 자동 생성해줍니다. Lombok의 @EqualsAndHashCode도 편리합니다. Objects.equals와 Objects.hash 유틸리티를 사용하면 안전하게 구현할 수 있습니다.

**주의사항:**

가변 필드로 hashCode를 계산하면 문제가 생깁니다. 객체를 HashMap에 넣은 후 필드를 변경하면 찾을 수 없게 됩니다. equals와 hashCode에는 불변 필드만 사용하는 것이 안전합니다.

## 질문 34: 본인이 hashcode()를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?

hashCode를 구현할 때는 정확성, 성능, 분산성을 고려해야 합니다.

**1. equals 계약 준수:**

가장 중요한 원칙은 equals로 같다고 판단된 객체는 반드시 같은 hashCode를 반환해야 한다는 것입니다. equals에 사용된 필드들을 hashCode 계산에도 포함시켜야 합니다. equals와 같은 필드 집합을 사용하는 것이 안전합니다.

**2. 좋은 분산성:**

해시 코드가 고르게 분산되어야 합니다. 충돌이 적을수록 HashMap의 성능이 좋습니다. 객체의 다양한 필드를 조합하여 계산합니다.

서로 다른 객체가 가능한 한 다른 hashCode를 가지도록 합니다. 완벽하게 유일할 필요는 없지만 충돌을 최소화해야 합니다.

**3. 일관성:**

equals에 사용되지 않는 필드는 hashCode에도 사용하지 않습니다. 같은 객체에 대해 반복 호출하면 항상 같은 값을 반환해야 합니다. 불변 필드만 사용하는 것이 이상적입니다.

**4. 구현 방법:**

Objects.hash 유틸리티를 사용하는 것이 가장 간단합니다. 여러 필드를 넘기면 자동으로 조합해줍니다. 간편하고 안전합니다.

수동으로 구현할 때는 전통적인 방법을 사용합니다. 초기값을 17 같은 소수로 시작합니다. 각 필드에 대해 result = 31 * result + field.hashCode() 를 수행합니다. 31은 소수이면서 곱셈을 시프트 연산으로 최적화할 수 있어 많이 사용됩니다.

**5. 필드별 처리:**

기본 타입은 래퍼 클래스의 hashCode를 사용합니다. Integer.hashCode(intValue)처럼 처리합니다.

객체 참조는 null 체크 후 hashCode를 호출합니다. Objects.hashCode를 사용하면 null을 안전하게 처리합니다.

배열은 Arrays.hashCode를 사용합니다. 요소들의 해시를 조합해줍니다.

**6. 성능 최적화:**

hashCode는 자주 호출되므로 빨라야 합니다. 복잡한 계산이나 I/O는 피합니다.

불변 객체는 lazy initialization으로 캐싱합니다. 처음 호출 시 계산하고 저장한 후 재사용합니다. String이 이 방식을 사용합니다.

**7. 피해야 할 실수:**

equals를 오버라이드하고 hashCode를 오버라이드하지 않는 것은 심각한 버그입니다.

가변 필드로 hashCode를 계산하면 HashMap에 넣은 후 찾을 수 없게 됩니다.

모든 객체에 같은 hashCode를 반환하는 것은 합법이지만 성능이 매우 나쁩니다. HashMap이 연결 리스트처럼 동작합니다.

**8. 도구 활용:**

IDE의 자동 생성 기능을 활용합니다. Lombok의 @EqualsAndHashCode를 사용합니다. 직접 구현할 때는 Objects 유틸리티를 활용합니다.

**9. 테스트:**

같은 객체는 같은 hashCode를 반환하는지 확인합니다. equals가 true인 객체들의 hashCode가 같은지 확인합니다. 다양한 입력에 대해 분산이 잘 되는지 확인합니다.

**권장 구현:**

현대 자바에서는 Objects.hash를 사용하는 것이 가장 안전하고 간단합니다. 성능이 크리티컬하거나 특수한 요구사항이 있을 때만 수동으로 구현합니다.

## 질문 35: 그렇다면 equals()를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.

equals를 재정의할 때는 정확성, 규약 준수, 안전성을 고려해야 합니다.

**1. equals 계약 준수:**

반사성(Reflexivity)을 만족해야 합니다. null이 아닌 x에 대해 x.equals(x)는 항상 true입니다.

대칭성(Symmetry)을 만족해야 합니다. x.equals(y)가 true면 y.equals(x)도 true여야 합니다. 서로 다른 타입 간 비교 시 주의가 필요합니다.

추이성(Transitivity)을 만족해야 합니다. x.equals(y)와 y.equals(z)가 true면 x.equals(z)도 true여야 합니다. 상속 관계에서 특히 주의해야 합니다.

일관성(Consistency)을 만족해야 합니다. 객체가 변경되지 않으면 반복 호출해도 같은 결과여야 합니다. equals에 사용되는 필드가 변경되지 않아야 합니다.

null과의 비교는 항상 false여야 합니다. x.equals(null)은 false를 반환해야 합니다.

**2. 구현 패턴:**

먼저 자기 자신과의 비교를 최적화합니다. if (this == other) return true로 시작합니다.

null 체크를 수행합니다. if (other == null) return false를 확인합니다.

타입 체크를 수행합니다. if (getClass() != other.getClass()) return false로 검사합니다. instanceof를 사용할 수도 있지만 주의가 필요합니다.

타입 캐스팅 후 필드를 비교합니다. 중요한 필드부터 비교하여 조기 리턴합니다. Objects.equals를 사용하여 null을 안전하게 처리합니다.

**3. getClass vs instanceof:**

getClass를 사용하면 정확한 타입만 동등하다고 판단합니다. 상속 관계에서 안전하고 대칭성을 쉽게 유지합니다.

instanceof를 사용하면 하위 타입도 동등할 수 있습니다. 하지만 대칭성과 추이성을 위반하기 쉽습니다. Liskov 치환 원칙을 고려해야 합니다.

일반적으로 getClass가 더 안전하고 권장됩니다.

**4. 필드 비교:**

기본 타입은 ==로 비교합니다. float와 double은 Float.compare, Double.compare를 사용합니다. 부동소수점의 특수값(NaN, Infinity)을 올바르게 처리합니다.

객체 참조는 Objects.equals를 사용합니다. null을 안전하게 처리해줍니다.

배열은 Arrays.equals를 사용합니다. 다차원 배열은 Arrays.deepEquals를 사용합니다.

**5. 성능 최적화:**

비교 비용이 낮은 필드부터 비교합니다. 다를 가능성이 높은 필드를 먼저 비교합니다. 조기 리턴으로 불필요한 비교를 피합니다.

파생 필드는 포함시키지 않습니다. equals에 영향을 주는 핵심 필드만 비교합니다.

**6. hashCode 함께 재정의:**

equals를 재정의하면 반드시 hashCode도 재정의해야 합니다. 같은 필드 집합을 사용합니다. 이는 가장 중요한 규칙입니다.

**7. 불변 필드 사용:**

가능하면 불변 필드로만 equals를 구현합니다. 가변 필드를 사용하면 컬렉션에서 문제가 생길 수 있습니다.

**8. 상속 관계 처리:**

final 클래스가 아니라면 상속을 고려해야 합니다. 추상 클래스에서 equals를 정의할 때는 canEqual 패턴을 고려합니다. 일반적으로 equals를 올바르게 구현하면서 상속을 허용하기는 매우 어렵습니다.

**9. 도구 활용:**

IDE의 자동 생성을 활용합니다. Lombok의 @EqualsAndHashCode를 사용합니다. Objects.equals, Arrays.equals 유틸리티를 활용합니다.

**10. 테스트:**

반사성, 대칭성, 추이성을 테스트합니다. null과의 비교를 테스트합니다. hashCode와의 일관성을 테스트합니다. 다양한 경우의 수를 확인합니다.

**일반적인 실수:**

타입 체크를 하지 않거나 캐스팅 전 체크하지 않으면 ClassCastException이 발생합니다. null을 체크하지 않으면 NullPointerException이 발생합니다. hashCode를 함께 재정의하지 않으면 HashMap에서 동작하지 않습니다. 대칭성을 위반하면 예측 불가능한 동작이 발생합니다.

equals 재정의는 신중해야 하며, 꼭 필요한 경우에만 하고 도구를 활용하는 것이 안전합니다.

## 질문 36: IoC와 DI에 대해 설명해 주세요.

IoC(Inversion of Control)와 DI(Dependency Injection)는 Spring 프레임워크의 핵심 개념으로, 객체 간 결합도를 낮추고 유연성을 높이는 설계 원칙입니다.

**IoC (Inversion of Control):**

IoC는 제어의 역전을 의미합니다. 전통적인 프로그래밍에서는 개발자가 작성한 코드가 라이브러리를 호출하고 객체의 생명주기를 직접 관리합니다. IoC에서는 프레임워크가 객체의 생명주기와 흐름을 제어합니다.

제어권이 역전되어 프레임워크가 개발자의 코드를 호출합니다. 이를 Hollywood 원칙이라고도 합니다. "우리가 당신을 호출할 것이니, 당신이 우리를 호출하지 마세요."

Spring에서는 IoC 컨테이너가 객체의 생성, 초기화, 소멸을 관리합니다. ApplicationContext와 BeanFactory가 IoC 컨테이너 역할을 합니다.

**DI (Dependency Injection):**

DI는 IoC를 구현하는 구체적인 방법입니다. 의존성 주입은 객체가 필요로 하는 의존 객체를 외부에서 주입받는 패턴입니다.

객체가 직접 의존 객체를 생성하지 않습니다. 외부(컨테이너)에서 의존 객체를 생성하고 주입해줍니다. 객체는 인터페이스나 추상 타입에만 의존하고 구체적인 구현은 알 필요가 없습니다.

**DI의 세 가지 방법:**

생성자 주입은 생성자를 통해 의존성을 받습니다. 가장 권장되는 방법입니다. 의존성이 불변이며 필수적임을 명확히 합니다. 순환 의존성을 컴파일 시점에 발견할 수 있습니다. final 필드로 선언하여 불변성을 보장합니다.

세터 주입은 setter 메서드를 통해 의존성을 받습니다. 선택적 의존성이나 변경 가능한 의존성에 사용됩니다. 객체 생성 후 나중에 주입할 수 있습니다.

필드 주입은 필드에 직접 주입합니다. @Autowired를 필드에 붙입니다. 코드가 간결하지만 테스트가 어렵고 불변성을 보장할 수 없어 권장되지 않습니다.

**장점:**

결합도가 낮아집니다. 구체적인 구현이 아닌 인터페이스에 의존합니다. 코드 변경 없이 구현체를 교체할 수 있습니다.

테스트가 용이합니다. Mock 객체를 주입하여 단위 테스트를 쉽게 작성할 수 있습니다. 의존성을 격리하여 테스트할 수 있습니다.

재사용성이 높아집니다. 같은 클래스를 다른 컨텍스트에서 다른 의존성과 함께 사용할 수 있습니다.

관심사의 분리가 명확해집니다. 객체 생성과 비즈니스 로직이 분리됩니다. 각 클래스는 자신의 책임에만 집중합니다.

**Spring에서의 구현:**

@Component, @Service, @Repository, @Controller 어노테이션으로 빈을 등록합니다. @Autowired, @Inject로 의존성을 주입받습니다. Java Config로 @Configuration과 @Bean을 사용하여 명시적으로 빈을 정의합니다.

Spring 컨테이너가 애플리케이션 시작 시 빈을 생성하고 의존 관계를 설정합니다. 싱글톤 스코프가 기본이며 애플리케이션 전체에서 하나의 인스턴스를 공유합니다.

**핵심 원칙:**

객체는 자신의 의존성을 직접 생성하지 않습니다. 의존성은 외부에서 주입받습니다. 인터페이스에 의존하여 구현체와 분리합니다. 컨테이너가 객체의 생명주기를 관리합니다.

IoC와 DI는 SOLID 원칙 중 의존성 역전 원칙(DIP)을 실현하는 메커니즘이며, 유연하고 테스트 가능한 애플리케이션을 만드는 핵심입니다.
