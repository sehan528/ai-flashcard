# Spring 답변 13-16

## 질문 13: static class와 static method를 비교해 주세요.

static class와 static method는 모두 static 키워드를 사용하지만, 의미와 사용 방식이 다릅니다.

**static method:**

static method는 클래스 레벨의 메서드입니다. 인스턴스를 생성하지 않고도 클래스 이름으로 직접 호출할 수 있습니다. 인스턴스 변수나 인스턴스 메서드에 접근할 수 없고, 오직 static 멤버만 사용할 수 있습니다.

static method는 객체의 상태와 무관한 유틸리티 기능을 제공할 때 사용됩니다. Math.max, Collections.sort, Integer.parseInt 같은 메서드들이 대표적입니다.

메모리에서 메서드 영역에 저장되며, 모든 인스턴스가 공유합니다. 인스턴스를 만들지 않아도 메모리에 로드됩니다.

**static nested class (static class):**

자바에서 static class는 정확히는 static nested class를 의미합니다. 일반적인 톱레벨 클래스는 static으로 선언할 수 없고, 다른 클래스 내부에 중첩된 클래스만 static으로 선언할 수 있습니다.

static nested class는 외부 클래스의 인스턴스와 독립적입니다. 외부 클래스의 인스턴스 멤버에 직접 접근할 수 없고, static 멤버에만 접근할 수 있습니다. 외부 클래스의 인스턴스 없이도 생성할 수 있습니다.

논스태틱 내부 클래스(inner class)와 대조됩니다. inner class는 외부 클래스의 인스턴스에 대한 암묵적 참조를 가지며, 외부 클래스의 모든 멤버에 접근할 수 있습니다. 하지만 이 참조로 인해 메모리 누수가 발생할 수 있습니다.

static nested class는 Builder 패턴 구현, 관련 클래스를 그룹화, 헬퍼 클래스 정의 등에 사용됩니다.

**주요 차이점:**

적용 대상이 다릅니다. static method는 메서드에, static class는 중첩 클래스에 적용됩니다.

독립성 측면에서 static method는 인스턴스 상태와 독립적이고, static nested class는 외부 클래스 인스턴스와 독립적입니다.

메모리 관점에서 static method는 메서드 영역에 하나만 존재하고, static nested class는 일반 클래스처럼 인스턴스를 여러 개 만들 수 있지만 외부 클래스 참조를 가지지 않아 메모리를 절약합니다.

**공통점:**

모두 클래스 이름으로 접근합니다. 인스턴스를 만들지 않고도 사용할 수 있습니다. 외부 클래스의 static 멤버에는 접근 가능하지만 인스턴스 멤버에는 직접 접근할 수 없습니다.

## 질문 14: static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?

static을 사용하면 다양한 이점과 제약이 있습니다.

**이점:**

첫째, 메모리 효율성이 높아집니다. static 멤버는 클래스당 하나만 존재하므로, 인스턴스를 수백 개 만들어도 static 변수는 하나만 메모리를 차지합니다. 모든 인스턴스가 공유하는 데이터에 적합합니다.

둘째, 인스턴스 없이 접근 가능합니다. 객체를 생성하는 비용 없이 클래스 이름만으로 메서드나 변수를 사용할 수 있습니다. 유틸리티 메서드에 매우 유용합니다.

셋째, 전역적인 접근점을 제공합니다. 애플리케이션 전체에서 공유해야 하는 설정값이나 카운터 같은 데이터를 관리할 수 있습니다.

넷째, 싱글톤 패턴 구현에 활용됩니다. static을 사용하여 인스턴스를 하나만 유지하고 전역 접근을 제공할 수 있습니다.

다섯째, 성능상 이점이 있습니다. 인스턴스 메서드는 동적 디스패치가 필요하지만 static 메서드는 컴파일 타임에 결정되어 약간 더 빠릅니다. 가상 테이블 검색이 필요 없습니다.

여섯째, 네임스페이스 역할을 합니다. 관련된 유틸리티 메서드들을 클래스로 그룹화하여 코드 구조를 명확히 할 수 있습니다.

**제약:**

첫째, 객체 지향 원칙 위배 가능성이 있습니다. static은 절차적 프로그래밍 스타일에 가까워 캡슐화와 다형성을 해칠 수 있습니다. 오버라이딩이 불가능합니다.

둘째, 테스트가 어렵습니다. static 메서드는 모킹하기 어렵고, static 상태는 테스트 간 격리를 방해합니다. 한 테스트가 static 변수를 변경하면 다른 테스트에 영향을 줄 수 있습니다.

셋째, 멀티스레드 환경에서 동기화가 필요합니다. static 변수는 모든 스레드가 공유하므로 동시성 문제가 발생할 수 있습니다. 적절한 동기화 없이는 데이터 경합이 일어납니다.

넷째, 인스턴스 멤버에 접근할 수 없습니다. static 메서드는 인스턴스 변수나 인스턴스 메서드를 사용할 수 없어 유연성이 떨어집니다.

다섯째, 클래스 로딩 시점에 초기화됩니다. 애플리케이션 시작 시간이 길어질 수 있고, 사용하지 않는 static 멤버도 메모리를 차지합니다.

여섯째, 강한 결합을 만듭니다. static 메서드나 변수를 직접 참조하면 의존성 주입이 어렵고 코드 결합도가 높아집니다.

일곱째, 상속과 다형성을 활용할 수 없습니다. static 메서드는 오버라이딩이 안 되고, 인터페이스의 일부로 사용할 수 없습니다.

**권장 사용 사례:**

상태가 없는 순수 유틸리티 메서드, 상수 정의, 팩토리 메서드, 자주 사용되는 싱글톤 인스턴스 등에 적합합니다. 하지만 가능하면 의존성 주입과 인스턴스 메서드를 우선 고려하는 것이 좋습니다.

## 질문 15: 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.

static은 컴파일 과정과 런타임에서 특별하게 처리됩니다.

**컴파일 타임 처리:**

첫째, 정적 바인딩이 수행됩니다. static 메서드 호출은 컴파일 타임에 어떤 메서드를 호출할지 결정됩니다. 인스턴스 메서드의 동적 디스패치와 달리, 컴파일러가 직접 메서드 참조를 바이트코드에 포함시킵니다.

둘째, 바이트코드에 특별한 플래그가 추가됩니다. static 멤버는 ACC_STATIC 플래그로 표시됩니다. 이는 클래스 파일의 constant pool과 메서드 테이블에 기록됩니다.

셋째, 메서드 호출 명령어가 다릅니다. 인스턴스 메서드는 invokevirtual이나 invokeinterface를 사용하지만, static 메서드는 invokestatic 명령어를 사용합니다. 이 명령어는 객체 참조 없이 직접 메서드를 호출합니다.

넷째, 컴파일러가 접근 제약을 검증합니다. static 메서드 내에서 인스턴스 멤버에 접근하려고 하면 컴파일 에러가 발생합니다. this 키워드도 사용할 수 없습니다.

**클래스 로딩 시 처리:**

첫째, 클래스가 처음 사용될 때 로딩됩니다. JVM의 클래스 로더가 클래스 파일을 읽어와 메모리에 적재합니다.

둘째, 링킹 과정에서 검증, 준비, 해석이 일어납니다. 준비 단계에서 static 변수를 위한 메모리가 메서드 영역(Method Area)에 할당되고 기본값으로 초기화됩니다. 숫자는 0, 객체 참조는 null로 설정됩니다.

셋째, 초기화 단계에서 static 초기화 블록과 static 변수의 명시적 초기화가 실행됩니다. 클래스에 선언된 순서대로 처리되며, 이는 클래스당 정확히 한 번만 실행됩니다. JVM이 스레드 안전성을 보장합니다.

**런타임 메모리 구조:**

static 멤버는 힙이 아닌 메서드 영역(Java 8 이전의 Permanent Generation, Java 8 이후의 Metaspace)에 저장됩니다. 이 영역은 클래스별로 하나씩 존재하며 모든 스레드가 공유합니다.

인스턴스 멤버는 각 객체마다 힙에 별도로 저장되지만, static 멤버는 클래스당 하나만 존재하여 메모리를 절약합니다.

**최적화:**

JVM은 static 메서드에 대해 인라이닝을 더 공격적으로 수행할 수 있습니다. 오버라이딩 가능성을 확인할 필요가 없기 때문입니다.

static final 상수는 컴파일 타임 상수 폴딩의 대상이 될 수 있습니다. 코드에서 사용되는 곳에 직접 값이 삽입됩니다.

**초기화 순서:**

부모 클래스의 static 초기화가 먼저 실행되고, 그 다음 자식 클래스의 static 초기화가 실행됩니다. static 블록은 클래스의 생성자보다 먼저 실행됩니다.

여러 스레드가 동시에 클래스를 초기화하려고 해도 JVM이 동기화를 처리하여 정확히 한 번만 초기화됩니다.

## 질문 16: Java의 Exception에 대해 설명해 주세요.

Java의 Exception은 프로그램 실행 중에 발생하는 예외적인 상황을 나타내는 객체입니다. 정상적인 프로그램 흐름을 방해하는 이벤트를 처리하는 메커니즘을 제공합니다.

**예외 계층 구조:**

최상위에 Throwable 클래스가 있으며, 이는 Error와 Exception으로 나뉩니다.

Error는 시스템 레벨의 심각한 문제를 나타냅니다. OutOfMemoryError, StackOverflowError 같은 것들로, 일반적으로 애플리케이션에서 처리할 수 없고 처리해서도 안 됩니다. JVM 자체의 문제나 리소스 고갈을 의미합니다.

Exception은 애플리케이션에서 처리 가능한 예외입니다. 다시 Checked Exception과 Unchecked Exception으로 구분됩니다.

**Checked Exception:**

컴파일러가 처리를 강제하는 예외입니다. IOException, SQLException, ClassNotFoundException 등이 있습니다. 메서드가 이러한 예외를 던질 수 있으면 throws 절에 명시해야 하고, 호출하는 쪽에서 try-catch로 처리하거나 다시 throws해야 합니다.

복구 가능한 상황에 사용됩니다. 파일이 없으면 다른 경로를 시도하거나, 네트워크 연결이 실패하면 재시도할 수 있습니다.

**Unchecked Exception:**

RuntimeException과 그 하위 클래스들입니다. NullPointerException, IllegalArgumentException, ArrayIndexOutOfBoundsException 등이 있습니다. 컴파일러가 처리를 강제하지 않으므로 명시적으로 선언하지 않아도 됩니다.

주로 프로그래밍 오류를 나타냅니다. null 체크 누락, 잘못된 인덱스 접근, 부적절한 인자 전달 등 개발자가 예방할 수 있는 문제입니다.

**예외의 구성 요소:**

모든 예외는 메시지를 포함할 수 있습니다. 예외가 발생한 이유를 설명하는 문자열입니다.

스택 트레이스를 제공합니다. 예외가 발생한 지점부터 호출 스택을 역순으로 보여줘서 디버깅에 필수적입니다.

원인 예외(cause)를 포함할 수 있습니다. 예외를 감싸서 더 높은 레벨의 예외로 변환할 때 원래 예외 정보를 보존합니다.

**예외 처리의 장점:**

오류 처리 코드와 정상 로직을 분리합니다. 코드 가독성이 향상되고 정상 흐름이 명확해집니다.

오류를 호출 스택 위로 전파할 수 있습니다. 오류를 처리하기 적절한 레벨에서 처리할 수 있습니다.

오류 타입별로 다른 처리가 가능합니다. 다양한 catch 블록으로 예외 타입에 따라 적절히 대응할 수 있습니다.

finally 블록으로 리소스 정리를 보장합니다. 예외 발생 여부와 관계없이 반드시 실행되어야 하는 코드를 작성할 수 있습니다.

**모던 자바의 개선:**

Java 7부터 try-with-resources가 도입되어 AutoCloseable 리소스를 자동으로 닫아줍니다. Java 7에서 multi-catch도 추가되어 여러 예외를 한 번에 처리할 수 있습니다.

예외는 프로그램의 안정성과 견고성을 높이는 중요한 메커니즘이지만, 과도한 사용은 성능 저하와 코드 복잡도 증가를 초래할 수 있으므로 적절히 사용해야 합니다.
