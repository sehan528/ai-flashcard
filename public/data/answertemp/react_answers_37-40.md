# React 답변 37-40

## 질문 37: Context API는 무엇이고 언제 사용하나요?

**정의:**
Context API는 컴포넌트 트리 전체에 데이터를 전달하는 React의 내장 기능입니다. Props를 중간 컴포넌트마다 전달하지 않고도 깊은 레벨의 컴포넌트에 데이터를 제공할 수 있습니다.

**Context API의 구성 요소:**
- createContext: Context 객체를 생성합니다.
- Provider: 값을 제공하는 컴포넌트입니다. value prop으로 데이터를 전달합니다.
- Consumer: 값을 소비하는 방법입니다. 현재는 useContext를 주로 사용합니다.
- useContext: Hook으로 Context 값을 읽습니다.

**Context가 필요한 상황:**
- Props drilling 문제를 해결할 때입니다. 여러 레벨을 거쳐 전달해야 하는 데이터입니다.
- 전역적으로 공유되는 데이터가 있을 때입니다. 테마 언어 사용자 인증 정보 등입니다.
- 여러 컴포넌트에서 같은 데이터를 사용할 때입니다.
- 컴포넌트 트리의 깊은 곳에 데이터를 전달할 때입니다.

**일반적인 사용 사례:**
- 테마 관리: 다크 모드 라이트 모드 전환입니다.
- 인증 정보: 로그인한 사용자 데이터와 권한입니다.
- 언어 설정: 다국어 지원을 위한 로케일 정보입니다.
- UI 상태: 모달이나 사이드바의 열림 닫힘 상태입니다.
- 설정: 앱 전체 설정값입니다.

**Context 생성과 사용:**
- createContext로 Context를 만듭니다. 기본값을 제공할 수 있습니다.
- Provider로 컴포넌트 트리를 감쌉니다.
- value prop에 공유할 데이터를 전달합니다.
- 하위 컴포넌트에서 useContext로 값을 읽습니다.

**Provider 패턴:**
- 별도의 Provider 컴포넌트를 만듭니다.
- 내부에서 state를 관리합니다.
- Context.Provider로 감싸서 반환합니다.
- 로직을 캡슐화하여 재사용성을 높입니다.

**Context의 장점:**
- Props drilling을 제거합니다.
- 코드가 깔끔해집니다.
- React 내장 기능이라 별도 라이브러리가 필요 없습니다.
- 간단한 전역 상태 관리가 가능합니다.
- 컴포넌트 재사용성이 향상될 수 있습니다.

**Context의 단점과 한계:**
- 성능 문제가 있을 수 있습니다. value가 바뀌면 모든 소비자가 리렌더링됩니다.
- 컴포넌트 재사용성이 떨어질 수 있습니다. Context에 의존하게 됩니다.
- 디버깅이 어려울 수 있습니다.
- 복잡한 상태 관리에는 부적합합니다.
- Redux 같은 전문 라이브러리가 더 나을 수 있습니다.

**언제 Context를 사용하지 말아야 할까:**
- 자주 변경되는 상태에는 적합하지 않습니다.
- Props가 2-3 레벨만 전달되면 그냥 전달하는 게 낫습니다.
- 복잡한 비즈니스 로직이 있으면 상태 관리 라이브러리를 고려합니다.
- 성능이 중요한 부분에서는 신중해야 합니다.

**실무 활용:**
- 앱 전체 테마를 Context로 관리합니다.
- 인증 상태를 Context에 저장합니다.
- 여러 Context를 조합하여 사용합니다.
- 성능을 위해 Context를 분리합니다.
- 상황에 맞는 도구를 선택합니다.

---

## 질문 38: Provider와 Consumer의 역할은 무엇인가요?

**정의:**
Provider는 Context 값을 제공하는 컴포넌트이고, Consumer는 그 값을 소비하는 컴포넌트입니다. Provider가 감싼 트리 내의 모든 Consumer가 Provider의 value에 접근할 수 있습니다.

**Provider의 역할:**
- Context 값을 하위 트리에 제공합니다.
- value prop으로 전달할 데이터를 받습니다.
- value가 변경되면 모든 구독자에게 알립니다.
- 여러 Provider를 중첩할 수 있습니다.
- 가장 가까운 Provider의 값이 사용됩니다.

**Provider 사용 방법:**
- Context.Provider로 컴포넌트를 감쌉니다.
- value prop에 공유할 데이터를 전달합니다.
- children을 렌더링합니다.
- 보통 앱의 최상위나 필요한 부분에 배치합니다.

**Provider value 최적화:**
- value가 객체면 메모이제이션해야 합니다.
- 렌더링마다 새 객체를 만들면 모든 구독자가 리렌더링됩니다.
- useMemo로 value를 메모이제이션합니다.
- 의존성이 변경될 때만 새 객체를 생성합니다.

**Consumer의 역할:**
- Provider가 제공한 값을 읽습니다.
- 가장 가까운 Provider의 값을 사용합니다.
- Provider가 없으면 createContext의 기본값을 사용합니다.
- value가 변경되면 자동으로 리렌더링됩니다.

**Consumer 사용 방법:**
- Context.Consumer를 사용합니다.
- children으로 함수를 전달합니다. Render Props 패턴입니다.
- 함수가 현재 Context 값을 인자로 받습니다.
- 함수가 JSX를 반환합니다.
- 클래스 컴포넌트에서 주로 사용됩니다.

**useContext Hook:**
- Consumer를 대체하는 더 간단한 방법입니다.
- 함수형 컴포넌트에서 사용합니다.
- Context 객체를 인자로 받습니다.
- 현재 Context 값을 직접 반환합니다.
- Consumer보다 코드가 깔끔합니다.

**Provider 중첩:**
- 여러 Context를 사용할 수 있습니다.
- Provider를 중첩하여 여러 값을 제공합니다.
- 각 Context는 독립적입니다.
- 같은 Context의 Provider를 중첩하면 가장 가까운 것이 우선입니다.

**기본값의 역할:**
- createContext의 인자로 전달합니다.
- Provider가 없을 때 사용됩니다.
- 컴포넌트를 독립적으로 테스트할 때 유용합니다.
- 실제 앱에서는 Provider를 항상 사용하는 것이 좋습니다.

**다중 Provider 패턴:**
- 여러 Provider를 조합합니다.
- 관심사별로 Context를 분리합니다.
- Provider 컴포넌트를 만들어 중첩을 추상화합니다.
- 코드 가독성이 향상됩니다.

**실무 활용:**
- AuthProvider로 인증 정보를 제공합니다.
- ThemeProvider로 테마를 제공합니다.
- 각 Provider는 관련 로직을 캡슐화합니다.
- useContext로 값을 읽어 사용합니다.
- value를 항상 메모이제이션하여 성능을 보장합니다.

---

## 질문 39: Context API의 성능 문제와 해결 방법은 무엇인가요?

**정의:**
Context API의 주요 성능 문제는 Provider의 value가 변경되면 해당 Context를 구독하는 모든 컴포넌트가 리렌더링된다는 것입니다. 이를 해결하기 위한 여러 최적화 기법이 있습니다.

**주요 성능 문제:**
- value 변경 시 모든 구독자가 리렌더링됩니다.
- 필요하지 않은 컴포넌트도 리렌더링될 수 있습니다.
- 자주 변경되는 값에는 적합하지 않습니다.
- 중간 컴포넌트의 최적화를 무시합니다.
- 큰 앱에서 성능 병목이 될 수 있습니다.

**해결 방법 1: Context 분리:**
- 자주 변경되는 값과 그렇지 않은 값을 분리합니다.
- 여러 개의 작은 Context를 만듭니다.
- 각 컴포넌트는 필요한 Context만 구독합니다.
- 변경 영향 범위를 최소화합니다.

**해결 방법 2: value 메모이제이션:**
- useMemo로 Provider value를 메모이제이션합니다.
- 의존성이 변경될 때만 새 객체를 생성합니다.
- 불필요한 리렌더링을 방지합니다.
- 반드시 적용해야 하는 기본 최적화입니다.

**해결 방법 3: 컴포넌트 최적화:**
- React.memo로 구독 컴포넌트를 감쌉니다.
- props가 변경되지 않으면 리렌더링을 건너뜁니다.
- Context 값 외의 리렌더링을 방지합니다.
- 선택적으로 적용합니다.

**해결 방법 4: Composition 활용:**
- children을 Provider 외부에서 생성합니다.
- Provider가 리렌더링되어도 children은 영향받지 않습니다.
- 구조를 잘 설계하면 많은 최적화가 자동으로 됩니다.

**해결 방법 5: Selector 패턴:**
- Context에서 필요한 부분만 선택하는 함수를 만듭니다.
- 선택한 값이 변경될 때만 리렌더링합니다.
- use-context-selector 같은 라이브러리를 사용합니다.
- Redux의 useSelector와 유사한 방식입니다.

**해결 방법 6: 상태 관리 라이브러리 사용:**
- 복잡한 전역 상태는 Redux Zustand Recoil을 고려합니다.
- 선택적 구독이 가능합니다.
- 성능 최적화가 내장되어 있습니다.
- 개발자 도구가 풍부합니다.

**측정과 프로파일링:**
- React DevTools Profiler로 리렌더링을 분석합니다.
- 실제로 문제가 있는지 확인합니다.
- 추측하지 말고 측정합니다.
- 병목 지점을 찾아 집중적으로 최적화합니다.

**언제 최적화할까:**
- 성능 문제가 실제로 관찰될 때입니다.
- 많은 컴포넌트가 같은 Context를 구독할 때입니다.
- Context 값이 자주 변경될 때입니다.
- 사용자 경험에 영향을 줄 때입니다.

**실무 활용:**
- 테마 Context는 거의 변경되지 않아 최적화가 덜 필요합니다.
- 폼 상태 Context는 자주 변경되어 분리가 필요합니다.
- value를 항상 메모이제이션합니다.
- Context 수를 적절히 분리합니다.
- 필요하면 전문 상태 관리 라이브러리로 전환합니다.

---

## 질문 40: Ref는 언제 사용하나요?

**정의:**
Ref는 렌더링에 필요하지 않은 값을 저장하거나 DOM 요소에 직접 접근하기 위한 React의 기능입니다. useRef Hook이나 createRef로 생성하며, 변경해도 리렌더링을 유발하지 않습니다.

**Ref의 주요 용도:**
- DOM 요소에 직접 접근합니다. input에 포커스를 주거나 스크롤 위치를 제어합니다.
- 렌더링과 무관한 값을 저장합니다. 타이머 ID 이전 값 등입니다.
- 인스턴스 변수처럼 사용합니다. 클래스의 this.x와 유사합니다.
- 변경 가능한 값이 필요하지만 리렌더링은 원하지 않을 때 사용합니다.

**DOM 접근 사례:**
- input이나 textarea에 포커스를 설정합니다.
- 스크롤 위치를 읽거나 설정합니다.
- 요소의 크기나 위치를 측정합니다.
- 비디오나 오디오를 제어합니다.
- 캔버스에 그림을 그립니다.
- 애니메이션을 직접 제어합니다.

**값 저장 사례:**
- setInterval이나 setTimeout의 ID를 저장합니다.
- WebSocket 연결 객체를 보관합니다.
- 이전 props나 state 값을 추적합니다.
- 렌더링 횟수를 카운트합니다.
- 외부 라이브러리 인스턴스를 저장합니다.

**useRef vs useState:**
- useRef는 변경 시 리렌더링하지 않습니다. useState는 리렌더링합니다.
- useRef는 동기적으로 즉시 업데이트됩니다. useState는 비동기입니다.
- useRef는 렌더링과 무관한 값용입니다. useState는 화면에 보이는 데이터용입니다.
- useRef.current는 직접 수정 가능합니다. state는 불변성을 지켜야 합니다.

**Ref 사용 시 주의사항:**
- 렌더링 중에 ref.current를 읽거나 쓰면 안 됩니다. 순수성을 해칩니다.
- 이벤트 핸들러나 useEffect에서만 사용합니다.
- Ref 변경으로 리렌더링을 유발하고 싶다면 state를 사용해야 합니다.
- DOM 조작은 최소화하고 선언적 방식을 우선합니다.

**forwardRef와 함께 사용:**
- 부모가 자식의 DOM 노드에 접근해야 할 때 사용합니다.
- 자식 컴포넌트를 forwardRef로 감쌉니다.
- ref를 두 번째 인자로 받습니다.
- DOM 요소에 ref를 연결합니다.
- 재사용 가능한 컴포넌트 라이브러리에서 필수입니다.

**callback ref:**
- 함수를 ref prop에 전달할 수 있습니다.
- DOM 노드가 마운트되면 함수가 호출됩니다.
- 언마운트되면 null로 호출됩니다.
- 동적인 ref 관리가 필요할 때 유용합니다.

**실무 활용:**
- 폼 제출 시 첫 번째 에러 필드로 포커스를 이동합니다.
- 무한 스크롤을 구현할 때 스크롤 위치를 추적합니다.
- 차트 라이브러리를 초기화하고 인스턴스를 저장합니다.
- 디바운스 타이머 ID를 저장하여 정리합니다.
- 선언적 방식으로 해결 안 되는 경우에만 사용합니다.

---
