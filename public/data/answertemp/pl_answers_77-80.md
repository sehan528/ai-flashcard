## 질문 77: Python의 제너레이터(Generator)와 이터레이터(Iterator)를 설명해주세요.

**정의:**
이터레이터는 next() 메서드를 구현하여 순차적으로 값을 반환하는 객체이며, 제너레이터는 yield 문을 사용하여 이터레이터를 쉽게 생성하는 함수입니다. 제너레이터는 함수의 실행 상태를 저장하고 재개할 수 있어 메모리 효율적인 데이터 생성이 가능합니다.

**특징/원리:**
- 지연 평가: 값을 미리 모두 생성하지 않고 필요할 때만 생성
- 메모리 효율: 대용량 데이터셋을 메모리에 모두 올리지 않고 순차 처리
- 상태 유지: 함수의 실행 상태와 지역 변수를 보존
- 일회용: 한 번 소진되면 재사용 불가능

**이터레이터 프로토콜:**
- __iter__(): 이터레이터 객체 자신을 반환
- __next__(): 다음 값을 반환하며, 더 이상 값이 없으면 StopIteration 예외 발생
- 이터러블: __iter__()를 구현한 객체로 for 루프에서 사용 가능
- 내장 이터러블: list, tuple, str, dict 등이 이터러블 객체

**제너레이터 함수:**
- yield 문: 값을 생성하고 함수 실행을 일시 중지
- 자동 이터레이터: yield를 포함한 함수는 자동으로 이터레이터 프로토콜 구현
- 여러 yield: 함수 내에 여러 yield 문을 가질 수 있음
- return: 제너레이터를 종료하고 StopIteration에 값을 포함

**제너레이터 표현식:**
- 문법: 리스트 컴프리헨션과 유사하지만 괄호 사용
- 메모리 효율: 모든 값을 메모리에 생성하지 않고 필요시 생성
- 단일 반복: 한 번만 순회 가능하고 재사용 불가

**제너레이터 메서드:**
- send(): 제너레이터에 값을 전달하여 yield 표현식의 결과로 사용
- throw(): 제너레이터 내부에서 예외 발생
- close(): 제너레이터를 종료하고 GeneratorExit 예외 발생

**실무 활용:**
- 대용량 파일을 한 줄씩 읽어 처리하여 메모리 절약
- 무한 시퀀스를 제너레이터로 구현하여 필요한 만큼만 생성
- 데이터 파이프라인을 여러 제너레이터로 체이닝하여 단계별 처리

---

## 질문 78: Python의 컨텍스트 매니저(Context Manager)란 무엇인가요?

**정의:**
컨텍스트 매니저는 with 문과 함께 사용되어 리소스의 획득과 해제를 자동으로 관리하는 객체입니다. __enter__()와 __exit__() 메서드를 구현하여 설정과 정리 작업을 보장하며, 예외 발생 시에도 안전하게 리소스를 정리합니다.

**특징/원리:**
- 자동 정리: with 블록을 벗어날 때 자동으로 리소스 해제
- 예외 안전: 예외 발생 시에도 __exit__()가 반드시 호출됨
- 가독성: 설정과 정리 코드를 명시적으로 구조화
- 재사용성: 공통 패턴을 컨텍스트 매니저로 추상화하여 재사용

**프로토콜:**
- __enter__(): with 문 진입 시 호출되며 리소스를 획득하고 반환
- __exit__(exc_type, exc_value, traceback): with 블록 종료 시 호출되며 리소스 해제 및 예외 처리
- 반환값: __exit__()가 True를 반환하면 예외를 억제
- as 절: __enter__()의 반환값이 as 뒤의 변수에 할당

**내장 컨텍스트 매니저:**
- 파일 객체: open()으로 생성된 파일은 자동으로 닫힘
- 락 객체: threading.Lock의 with 사용으로 자동 획득/해제
- 데이터베이스 연결: 트랜잭션을 자동으로 커밋하거나 롤백

**contextlib 모듈:**
- @contextmanager: 제너레이터 함수를 컨텍스트 매니저로 변환하는 데코레이터
- yield: 설정 코드 실행 후 yield로 제어를 넘기고, 블록 종료 후 정리 코드 실행
- suppress(): 특정 예외를 억제하는 컨텍스트 매니저
- closing(): close() 메서드를 가진 객체를 자동으로 닫음

**클래스 기반 구현:**
- __enter__(): 리소스 획득 로직 구현하고 사용할 객체 반환
- __exit__(): 정리 로직 구현하고 예외 처리 여부 결정
- 재사용: 여러 번 with 문에서 사용 가능한 재사용 가능 객체 생성

**실무 활용:**
- 파일, 네트워크 연결, 데이터베이스 커넥션 등 리소스를 with로 안전하게 관리
- 타이머 컨텍스트 매니저로 코드 블록 실행 시간 자동 측정
- 임시 디렉토리 변경이나 환경 변수 설정을 컨텍스트 매니저로 구현하여 자동 복원

---

## 질문 79: Python의 리스트 컴프리헨션과 제너레이터 표현식의 차이점은 무엇인가요?

**정의:**
리스트 컴프리헨션은 리스트를 생성하는 간결한 문법이고, 제너레이터 표현식은 제너레이터를 생성하는 유사한 문법입니다. 리스트 컴프리헨션은 모든 값을 메모리에 즉시 생성하지만, 제너레이터 표현식은 값을 지연 평가하여 메모리 효율적입니다.

**특징/원리:**
- 즉시 vs 지연: 리스트 컴프리헨션은 즉시 모든 요소 생성, 제너레이터는 필요시 생성
- 메모리: 리스트는 모든 요소를 메모리에 저장, 제너레이터는 상태만 저장
- 재사용: 리스트는 여러 번 순회 가능, 제너레이터는 일회용
- 성능: 작은 데이터는 리스트가 빠르지만, 대용량은 제너레이터가 효율적

**리스트 컴프리헨션:**
- 문법: 대괄호 사용하여 [expression for item in iterable if condition]
- 즉시 평가: 모든 요소를 즉시 계산하여 리스트로 반환
- 인덱싱: 리스트이므로 인덱스 접근, 슬라이싱, len() 사용 가능
- 중첩: 2D 리스트 생성이나 복잡한 변환에 유용

**제너레이터 표현식:**
- 문법: 괄호 사용하여 (expression for item in iterable if condition)
- 지연 평가: next()나 for 루프로 요청할 때마다 하나씩 생성
- 메모리 효율: 큰 데이터셋도 메모리 부담 없이 처리
- 파이프라인: 여러 제너레이터를 체이닝하여 데이터 처리 파이프라인 구성

**선택 기준:**
- 크기: 결과가 작으면 리스트 컴프리헨션, 크면 제너레이터 표현식
- 재사용: 여러 번 순회 필요하면 리스트, 한 번만 사용하면 제너레이터
- 즉시 필요: 모든 값이 즉시 필요하면 리스트, 순차 처리면 제너레이터
- 성능: 전체를 빠르게 생성하려면 리스트, 첫 값을 빠르게 얻으려면 제너레이터

**실무 활용:**
- 대용량 파일 처리는 제너레이터 표현식으로 메모리 절약
- UI에 표시할 작은 결과 집합은 리스트 컴프리헨션으로 즉시 생성
- sum(), max() 등 집계 함수에 전달할 때는 제너레이터 표현식으로 메모리 효율화

---

## 질문 80: Python의 람다 함수의 특징과 제한사항은 무엇인가요?

**정의:**
람다 함수는 lambda 키워드로 정의하는 익명의 간단한 함수로, 한 줄로 표현 가능한 단순한 함수를 간결하게 작성합니다. 이름이 없고 단일 표현식만 가질 수 있어, 주로 고차 함수의 인자로 사용됩니다.

**특징/원리:**
- 익명 함수: 이름 없이 정의되며 변수에 할당하거나 인자로 전달
- 단일 표현식: 하나의 표현식만 포함하며 그 결과를 자동으로 반환
- 간결성: def 문보다 짧고 간단하게 함수 정의
- 일급 객체: 변수에 할당, 함수 인자로 전달, 함수에서 반환 가능

**문법:**
- 기본 형식: lambda parameters: expression
- 매개변수: 쉼표로 구분된 매개변수 목록
- 표현식: 단일 표현식이며 return 문 없이 결과 자동 반환
- 타입 힌트: 람다 함수에는 타입 힌트 사용 불가

**제한사항:**
- 단일 표현식: 여러 문장이나 복잡한 로직 작성 불가
- 문 사용 불가: if 문, for 문, while 문 등 사용 불가하며 표현식만 가능
- 어노테이션 불가: 타입 힌트나 데코레이터 사용 불가
- 문서화 어려움: docstring을 추가할 수 없어 의도 설명 어려움
- 디버깅: 이름이 없어 스택 트레이스에서 식별 어려움

**사용 사례:**
- 정렬 키: sorted()나 list.sort()의 key 인자로 간단한 정렬 기준 제공
- 필터링: filter() 함수의 조건으로 사용
- 매핑: map() 함수의 변환 함수로 사용
- 고차 함수: functools.reduce() 등의 인자로 사용

**일반 함수 vs 람다:**
- 복잡성: 복잡한 로직은 def로 정의하고 이름 부여
- 재사용성: 여러 곳에서 사용할 함수는 def로 정의
- 가독성: 람다가 복잡해지면 가독성이 떨어지므로 def 사용
- 일회용: 한 번만 사용하고 간단한 경우 람다 사용

**실무 활용:**
- 리스트의 딕셔너리를 특정 키로 정렬할 때 lambda로 키 함수 제공
- filter와 map을 사용한 간단한 데이터 변환 파이프라인
- GUI 프레임워크에서 간단한 이벤트 핸들러를 람다로 정의

---
