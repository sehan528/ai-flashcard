## 질문 97: Go의 고루틴(Goroutine)과 스레드의 차이점은 무엇인가요?

**정의:**
고루틴은 Go 런타임이 관리하는 경량 스레드로, 매우 적은 메모리로 시작하고 필요에 따라 스택이 증가합니다. OS 스레드보다 훨씬 가볍고 빠르게 생성되어, 수천에서 수백만 개의 고루틴을 동시에 실행할 수 있습니다.

**특징/원리:**
- 경량: 고루틴은 2KB 정도로 시작하지만 OS 스레드는 1-2MB 필요
- M:N 스케줄링: 여러 고루틴이 적은 수의 OS 스레드에서 멀티플렉싱
- 협력적 스케줄링: 고루틴이 명시적으로 양보하거나 블로킹 시 스케줄링
- 동적 스택: 스택이 필요에 따라 자동으로 증가하고 감소

**고루틴 vs OS 스레드:**
- 생성 비용: 고루틴은 마이크로초, 스레드는 밀리초 수준
- 메모리: 고루틴은 KB 단위, 스레드는 MB 단위
- 컨텍스트 전환: 고루틴은 사용자 공간에서 처리되어 매우 빠름
- 수량: 고루틴은 수백만 개 가능, 스레드는 수천 개 정도가 한계
- 스케줄링: 고루틴은 Go 런타임이, 스레드는 OS가 스케줄링

**Go 스케줄러:**
- G-M-P 모델: G(Goroutine), M(Machine/OS thread), P(Processor)로 구성
- Work Stealing: 유휴 P가 다른 P의 고루틴을 가져와 처리
- 시스템 콜 처리: 블로킹 시스템 콜 시 M을 분리하여 다른 고루틴 계속 실행
- 비선점형: Go 1.14부터 비동기 선점형 스케줄링 도입

**고루틴 생성:**
- go 키워드: go func()로 함수를 고루틴으로 실행
- 익명 함수: go func() { }()로 즉시 실행
- 클로저: 외부 변수를 캡처하는 클로저로 고루틴 생성 가능
- 메인 종료: main 함수 종료 시 모든 고루틴도 강제 종료

**동기화:**
- WaitGroup: 여러 고루틴의 완료를 기다림
- 채널: 고루틴 간 안전한 통신과 동기화
- Mutex: 공유 자원에 대한 배타적 접근
- Context: 타임아웃, 취소 신호 전파

**실무 활용:**
- 웹 서버에서 각 요청을 별도 고루틴으로 처리하여 높은 동시성 달성
- 배치 처리 시 고루틴 풀을 만들어 작업을 병렬로 처리
- 이벤트 처리, 로그 수집 등 백그라운드 작업을 고루틴으로 실행

---

## 질문 98: Go의 채널(Channel)의 동작 원리와 사용 방법을 설명해주세요.

**정의:**
채널은 고루틴 간 안전하게 데이터를 주고받는 통신 메커니즘입니다. 타입 안전한 큐처럼 동작하며, 보내는 쪽과 받는 쪽을 동기화하여 고루틴 간 협력을 가능하게 합니다. "공유 메모리로 통신하지 말고, 통신으로 메모리를 공유하라"는 Go의 철학을 구현합니다.

**특징/원리:**
- 타입 안전: 특정 타입의 데이터만 전송 가능
- 동기화: 송신과 수신이 만날 때까지 블로킹되어 동기화 제공
- FIFO: 먼저 보낸 데이터가 먼저 수신됨
- 양방향: 기본적으로 양방향이지만 단방향으로 제약 가능

**채널 종류:**
- 버퍼 없는 채널: make(chan T)로 생성하며 송수신이 동시에 일어나야 함
- 버퍼 있는 채널: make(chan T, capacity)로 생성하며 버퍼가 찰 때까지 블로킹 안 됨
- 단방향 채널: chan<- T는 송신 전용, <-chan T는 수신 전용으로 타입 안전성 향상

**기본 연산:**
- 송신: ch <- value로 채널에 값 전송
- 수신: value := <-ch로 채널에서 값 수신
- 닫기: close(ch)로 채널 닫기, 닫힌 채널에서 수신 시 제로값과 false 반환
- 수신 확인: value, ok := <-ch로 채널이 열려있는지 확인

**select 문:**
- 다중 채널: 여러 채널 중 준비된 것 선택
- 비블로킹: default 케이스로 블로킹 없이 즉시 반환
- 타임아웃: time.After와 함께 사용하여 타임아웃 구현
- 임의 선택: 여러 케이스가 준비되면 무작위로 하나 선택

**패턴:**
- 팬아웃: 하나의 입력을 여러 고루틴에 분배
- 팬인: 여러 고루틴의 출력을 하나로 합침
- 파이프라인: 채널로 고루틴을 연결하여 데이터 처리 파이프라인 구성
- Done 채널: 빈 struct 채널로 완료 신호 전파

**주의사항:**
- 데드락: 송수신이 짝을 이루지 않으면 데드락 발생
- 닫힌 채널: 닫힌 채널에 송신 시 패닉 발생
- nil 채널: nil 채널에 송수신 시 영구 블로킹
- 채널 방향: 함수 시그니처에 채널 방향 명시하여 오용 방지

**실무 활용:**
- 워커 풀 패턴으로 작업을 채널로 분배하고 결과를 수집
- 타임아웃이 있는 RPC 호출을 select로 구현
- 이벤트 브로드캐스팅이나 pub-sub 패턴을 채널로 구현

---

## 질문 99: Go의 select 문의 동작 원리를 설명해주세요.

**정의:**
select 문은 여러 채널 연산 중 준비된 것을 선택하여 실행하는 제어 구조입니다. switch 문과 유사한 문법이지만 채널 연산만 케이스로 사용하며, 여러 고루틴의 통신을 조율하는 핵심 도구입니다.

**특징/원리:**
- 동시 대기: 모든 채널 연산을 동시에 대기
- 즉시 실행: 준비된 케이스를 즉시 실행
- 무작위 선택: 여러 케이스가 준비되면 무작위로 하나 선택하여 공정성 보장
- 블로킹: 준비된 케이스가 없으면 하나라도 준비될 때까지 블로킹

**기본 문법:**
- case: 각 case는 채널 송신이나 수신 연산
- default: 준비된 케이스가 없을 때 즉시 실행되는 비블로킹 옵션
- 실행: 준비된 케이스의 통신이 실행되고 해당 블록 실행
- 반복: select 자체는 한 번만 실행되므로 반복하려면 for 루프 사용

**사용 패턴:**
- 타임아웃: time.After 채널과 함께 사용하여 타임아웃 구현
- 비블로킹 수신: default 케이스로 채널에 값이 없어도 즉시 반환
- 여러 입력: 여러 소스로부터 데이터를 받아 처리
- Done 신호: done 채널로 고루틴 종료 신호 감지

**타임아웃 구현:**
- time.After: 지정된 시간 후 현재 시각을 보내는 채널 반환
- Context: context.WithTimeout으로 타임아웃 있는 컨텍스트 생성
- Ticker: 주기적인 이벤트 처리

**주의사항:**
- 빈 select: case가 없는 select는 영구 블로킹
- nil 채널: nil 채널은 절대 준비되지 않아 해당 case 무시됨
- 송신 케이스: 채널이 닫히지 않았고 버퍼에 공간이 있어야 준비됨
- 공정성: Go 런타임이 무작위 선택으로 기아 상태 방지

**실무 활용:**
- HTTP 요청에 타임아웃을 적용하여 무한 대기 방지
- 여러 워커의 결과를 먼저 도착하는 순서대로 처리
- 주기적인 작업과 이벤트 처리를 하나의 select로 통합

---

## 질문 100: Go의 인터페이스(Interface)와 타입 시스템에 대해 설명해주세요.

**정의:**
Go의 인터페이스는 메서드 시그니처의 집합으로, 명시적 선언 없이 메서드만 구현하면 자동으로 인터페이스를 만족하는 구조적 타입 시스템을 사용합니다. "작은 인터페이스가 좋은 인터페이스"라는 철학으로 간결하고 조합 가능한 추상화를 제공합니다.

**특징/원리:**
- 암묵적 구현: implements 키워드 없이 메서드만 구현하면 인터페이스 만족
- 구조적 타이핑: 타입의 이름이 아니라 구조로 호환성 판단
- 빈 인터페이스: interface{}는 모든 타입을 받을 수 있는 최상위 타입
- 다형성: 인터페이스 타입으로 다양한 구체 타입을 추상화

**인터페이스 정의:**
- 메서드 집합: 타입이 구현해야 할 메서드 시그니처 나열
- 임베딩: 다른 인터페이스를 임베딩하여 합성 가능
- 컨벤션: 메서드가 하나면 -er로 끝나는 이름 사용 (Reader, Writer)

**타입 단언:**
- 단언: value.(Type)으로 인터페이스의 구체 타입 추출
- 안전 단언: value, ok := interfaceValue.(Type)으로 패닉 방지
- 타입 스위치: 여러 타입을 한 번에 처리

**빈 인터페이스:**
- interface{}: 메서드가 없어 모든 타입이 만족
- 제네릭 대용: 제네릭 추가 전에는 빈 인터페이스로 범용 코드 작성
- 타입 안전성 부족: 런타임에 타입 단언 필요하여 오류 가능성

**인터페이스 값:**
- 동적 타입: 인터페이스 값은 동적 타입과 동적 값을 저장
- nil 인터페이스: 동적 타입과 값이 모두 nil일 때만 nil
- 비교: 동적 타입이 같고 값이 같으면 동일

**실무 활용:**
- io.Reader, io.Writer로 다양한 입출력 소스를 추상화
- 작은 인터페이스를 정의하여 테스트 가능하고 확장 가능한 코드 작성
- 덕 타이핑으로 외부 라이브러리 타입도 인터페이스로 추상화

---
