# JavaScript 답변 17-20

## 질문 17: 프로토타입 기반 상속은 어떻게 구현하나요?

**정의:**
프로토타입 기반 상속은 객체가 다른 객체의 속성과 메서드를 프로토타입 체인을 통해 물려받는 JavaScript의 상속 메커니즘입니다. 클래스 기반 상속과 달리 객체가 직접 다른 객체를 상속받습니다.

**생성자 함수를 이용한 상속:**
- 부모 생성자를 자식 생성자 내에서 호출합니다. call이나 apply를 사용하여 this를 전달합니다.
- 자식 생성자의 prototype을 부모 생성자의 인스턴스로 설정합니다. 프로토타입 체인이 연결됩니다.
- constructor 프로퍼티를 다시 자식 생성자로 설정합니다. 덮어쓴 constructor를 복원합니다.
- 이 방법은 프로토타입 체인과 인스턴스 속성을 모두 상속받습니다.

**Object.create를 이용한 상속:**
- Object.create로 프로토타입을 지정한 객체를 생성합니다. 더 직접적이고 명확한 방법입니다.
- 부모 prototype을 자식 prototype의 프로토타입으로 설정합니다.
- 불필요한 인스턴스 생성 없이 프로토타입만 연결합니다.
- 생성자 함수 방식보다 깔끔하고 이해하기 쉽습니다.

**ES6 Class 문법:**
- extends 키워드로 상속을 선언합니다. 문법이 간결하고 직관적입니다.
- super 키워드로 부모 생성자와 메서드를 호출합니다.
- 내부적으로는 프로토타입 기반 상속을 사용합니다. 문법적 설탕에 불과합니다.
- constructor에서 반드시 super를 먼저 호출해야 합니다.

**상속 구현 시 주의사항:**
- prototype을 직접 할당하면 constructor가 사라집니다. 반드시 복원해야 합니다.
- 부모 생성자를 호출하지 않으면 인스턴스 속성이 상속되지 않습니다.
- 프로토타입 체인이 올바르게 연결되었는지 확인해야 합니다.
- Object.create(null)로 만든 객체는 프로토타입이 없습니다.

**다중 상속과 믹스인:**
- JavaScript는 단일 상속만 지원합니다. 프로토타입 체인은 하나만 가질 수 있습니다.
- 다중 상속이 필요하면 믹스인 패턴을 사용합니다. Object.assign으로 여러 객체의 속성을 복사합니다.
- 하지만 믹스인은 진정한 상속이 아닙니다. 프로토타입 체인에 연결되지 않습니다.

**실무 활용:**
- 공통 기능을 부모 클래스에 정의하고 자식 클래스에서 확장합니다.
- 프레임워크나 라이브러리의 기본 클래스를 상속받아 커스터마이징합니다.
- 프로토타입 체인을 이해하면 instanceof와 타입 체크를 올바르게 사용할 수 있습니다.
- 현대적인 코드에서는 ES6 클래스 문법을 주로 사용하지만 내부 동작 원리를 이해해야 합니다.

---

## 질문 18: Object.create()의 동작 원리와 사용 사례는 무엇인가요?

**정의:**
Object.create는 지정된 프로토타입 객체와 속성을 가지는 새 객체를 생성하는 메서드입니다. 프로토타입을 명시적으로 지정할 수 있어 상속 구조를 명확하게 만들 수 있습니다.

**동작 원리:**
- 첫 번째 인수로 프로토타입이 될 객체를 받습니다. 새 객체의 내부 프로토타입 참조가 이 객체를 가리킵니다.
- 두 번째 인수로 속성 디스크립터 객체를 받습니다. Object.defineProperties와 같은 형식입니다.
- 빈 객체를 생성하고 프로토타입을 연결합니다.
- 프로토타입 없는 객체도 만들 수 있습니다. null을 전달하면 됩니다.

**프로토타입 없는 객체 생성:**
- Object.create(null)로 완전히 빈 객체를 만듭니다.
- Object.prototype의 메서드도 가지지 않습니다. toString, hasOwnProperty 등이 없습니다.
- 순수한 데이터 저장소로 사용하기 좋습니다.
- 프로토타입 오염 공격을 방지할 수 있습니다.
- Map처럼 키-값 저장에 안전합니다.

**상속 구현에서의 활용:**
- 생성자 함수의 prototype을 설정할 때 사용합니다.
- 부모의 인스턴스를 만들지 않고 프로토타입만 연결합니다.
- 불필요한 속성 초기화를 피할 수 있습니다.
- 더 효율적이고 명확한 상속 구조를 만듭니다.

**객체 복제와 확장:**
- 기존 객체를 프로토타입으로 하는 새 객체를 만듭니다.
- 원본 객체를 변경하지 않고 확장할 수 있습니다.
- 프로토타입 체인을 통한 위임 패턴을 구현합니다.

**Object.create vs 생성자 함수:**
- Object.create는 프로토타입을 직접 지정합니다. 더 명시적입니다.
- 생성자 함수는 초기화 로직을 실행합니다. 속성 설정이 자동화됩니다.
- Object.create는 간단한 상속에 적합합니다.
- 생성자 함수는 복잡한 초기화가 필요할 때 적합합니다.

**실무 활용 사례:**
- 프로토타입 체인을 명확히 제어해야 할 때 사용합니다.
- 설정 객체나 옵션 객체의 기본값을 프로토타입으로 설정합니다. 사용자 설정으로 오버라이드할 수 있습니다.
- 순수 사전 객체가 필요할 때 Object.create(null)을 사용합니다.
- 팩토리 패턴 구현 시 활용합니다. 동일한 프로토타입을 가진 객체를 대량 생성합니다.
- Polyfill이나 레거시 브라우저 지원에서 중요합니다.

---

## 질문 19: Object.assign()과 얕은 복사에 대해 설명해주세요.

**정의:**
Object.assign은 하나 이상의 소스 객체로부터 대상 객체로 속성을 복사하는 메서드입니다. 얕은 복사를 수행하므로 중첩된 객체는 참조가 복사됩니다.

**Object.assign의 동작:**
- 첫 번째 인수가 대상 객체입니다. 이 객체에 속성이 추가되고 변경됩니다.
- 두 번째 이후 인수들이 소스 객체들입니다. 이들의 속성이 대상 객체로 복사됩니다.
- 열거 가능한 속성만 복사됩니다. enumerable이 true인 속성만 해당됩니다.
- 같은 키가 있으면 나중 소스의 값으로 덮어씁니다. 뒤쪽 인수가 우선순위가 높습니다.
- 대상 객체를 반환합니다. 원본 대상 객체가 변경됩니다.

**얕은 복사의 의미:**
- 최상위 레벨의 속성만 복사됩니다. 원시값은 값이 복사되고 객체는 참조가 복사됩니다.
- 중첩된 객체는 같은 참조를 공유합니다. 원본과 복사본이 같은 내부 객체를 가리킵니다.
- 내부 객체를 수정하면 원본도 영향을 받습니다.
- 완전한 복사가 아닌 부분적인 복사입니다.

**깊은 복사와의 차이:**
- 얕은 복사: 한 단계만 복사하고 내부 객체는 참조를 공유합니다.
- 깊은 복사: 모든 중첩 객체를 재귀적으로 복사합니다. 완전히 독립적인 복사본을 만듭니다.
- JSON.stringify와 JSON.parse로 간단히 깊은 복사를 할 수 있습니다. 하지만 함수, undefined, Symbol은 복사되지 않습니다.
- structuredClone을 사용하면 더 완전한 깊은 복사가 가능합니다.

**Object.assign의 활용:**
- 객체 병합에 사용합니다. 여러 설정 객체를 하나로 합칠 수 있습니다.
- 객체 복제에 사용합니다. 빈 객체를 대상으로 하여 복사본을 만듭니다.
- 기본값 설정에 활용합니다. 기본 옵션과 사용자 옵션을 병합합니다.
- 불변성 유지에 사용합니다. 원본을 변경하지 않고 새 객체를 만듭니다.

**주의사항:**
- 대상 객체가 변경됩니다. 불변성을 유지하려면 빈 객체를 대상으로 사용합니다.
- 심볼 속성도 복사됩니다. 하지만 프로토타입 체인의 속성은 복사되지 않습니다.
- getter는 실행되고 그 결과가 복사됩니다. setter는 대상 객체에서 호출됩니다.
- 순환 참조가 있으면 무한 루프가 발생하지 않습니다. 얕은 복사이기 때문입니다.

**실무 활용:**
- React나 Redux에서 상태를 불변하게 업데이트할 때 사용합니다.
- 스프레드 문법으로 대체할 수 있습니다. 더 간결하고 가독성이 좋습니다.
- 설정 객체나 옵션 객체를 병합할 때 유용합니다.
- 얕은 복사의 한계를 이해하고 필요 시 깊은 복사를 구현해야 합니다.

---

## 질문 20: Object.freeze()와 Object.seal()의 차이점은 무엇인가요?

**정의:**
Object.freeze와 Object.seal은 객체의 변경을 제한하는 메서드입니다. 둘 다 객체를 불변하게 만들지만 제한의 정도가 다릅니다.

**Object.freeze의 특징:**
- 객체를 완전히 동결합니다. 가장 강력한 불변성을 제공합니다.
- 속성 추가가 불가능합니다. 새로운 속성을 추가할 수 없습니다.
- 속성 삭제가 불가능합니다. 기존 속성을 제거할 수 없습니다.
- 속성 값 변경이 불가능합니다. 기존 속성의 값을 수정할 수 없습니다.
- 속성 설명자 변경이 불가능합니다. writable, enumerable, configurable을 변경할 수 없습니다.
- 읽기 전용 객체가 됩니다. 모든 쓰기 작업이 차단됩니다.

**Object.seal의 특징:**
- 객체를 봉인합니다. freeze보다는 약한 제한입니다.
- 속성 추가가 불가능합니다. 새로운 속성을 추가할 수 없습니다.
- 속성 삭제가 불가능합니다. 기존 속성을 제거할 수 없습니다.
- 속성 값 변경은 가능합니다. 기존 속성의 값은 수정할 수 있습니다.
- 속성 설명자 변경이 부분적으로 불가능합니다. configurable이 false가 되지만 writable은 변경 가능합니다.

**Object.preventExtensions:**
- 가장 약한 제한입니다. 확장만 방지합니다.
- 속성 추가만 불가능합니다. 새로운 속성을 추가할 수 없습니다.
- 속성 삭제는 가능합니다. 기존 속성을 제거할 수 있습니다.
- 속성 값 변경은 가능합니다. 기존 속성의 값을 수정할 수 있습니다.

**제한 수준 비교:**
- preventExtensions: 확장 방지만. 삭제와 변경은 가능합니다.
- seal: 확장과 삭제 방지. 값 변경은 가능합니다.
- freeze: 모든 변경 방지. 완전한 불변입니다.

**얕은 동결의 한계:**
- 중첩된 객체는 동결되지 않습니다. 내부 객체는 여전히 변경 가능합니다.
- 깊은 동결이 필요하면 재귀적으로 freeze를 적용해야 합니다.
- 배열의 요소가 객체라면 해당 객체는 변경 가능합니다.

**확인 메서드:**
- Object.isFrozen으로 동결 상태를 확인합니다.
- Object.isSealed로 봉인 상태를 확인합니다.
- Object.isExtensible로 확장 가능 여부를 확인합니다.

**엄격 모드와의 관계:**
- 비엄격 모드에서는 변경이 조용히 실패합니다. 에러가 발생하지 않고 무시됩니다.
- 엄격 모드에서는 TypeError가 발생합니다. 문제를 조기에 발견할 수 있습니다.

**실무 활용:**
- 상수 객체나 설정 객체를 보호할 때 사용합니다. 실수로 변경되는 것을 방지합니다.
- 불변 데이터 구조를 구현할 때 활용합니다. 함수형 프로그래밍에서 유용합니다.
- API 응답이나 설정을 동결하여 안정성을 높입니다.
- 성능에 영향을 줄 수 있으므로 꼭 필요한 경우에만 사용합니다.
- TypeScript의 readonly나 Immutable.js 같은 라이브러리도 대안이 될 수 있습니다.

---
