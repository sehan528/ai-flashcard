## 질문 125: 메모리 누수(Memory Leak)가 발생하는 원인과 방지 방법은 무엇인가요?

**정의:**
메모리 누수는 프로그램이 더 이상 사용하지 않는 메모리를 해제하지 않아 가용 메모리가 점점 감소하는 현상입니다. 시간이 지남에 따라 시스템 성능 저하나 프로그램 크래시를 유발할 수 있어, 장기 실행 애플리케이션에서 특히 중요한 문제입니다.

**특징/원리:**
- 점진적 악화: 시간이 지날수록 메모리 사용량이 계속 증가
- 자원 고갈: 결국 사용 가능한 메모리가 부족해져 프로그램이나 시스템 중단
- 은밀함: 즉시 드러나지 않고 서서히 나타나 발견이 어려움
- 누적: 작은 누수도 반복되면 심각한 문제가 됨

**발생 원인:**
- 참조 유지: 더 이상 필요 없는 객체에 대한 참조를 계속 보유
- 리소스 미해제: 파일, 소켓, 데이터베이스 연결 등을 닫지 않음
- 이벤트 리스너: 등록한 리스너를 제거하지 않아 객체가 GC되지 않음
- 캐시: 무한정 증가하는 캐시로 메모리 소진
- 순환 참조: 가비지 컬렉터가 처리 못하는 순환 참조 (구형 언어)

**언어별 특징:**
- C/C++: 수동 메모리 관리로 malloc/new 후 free/delete 누락 시 누수
- Java: GC가 있지만 static 컬렉션, ThreadLocal, 리스너 등으로 누수 가능
- JavaScript: 클로저, DOM 참조, 타이머 등으로 누수 발생
- Python: 순환 참조나 C 확장 모듈에서 누수 가능
- Go: defer 누락, 고루틴 누수, 큰 슬라이스 참조

**일반적 패턴:**
- 전역 컬렉션: 전역 리스트나 맵에 계속 추가만 하고 제거 안 함
- 클로저: 클로저가 큰 객체를 캡처하여 GC 방해
- 타이머: setInterval이나 setTimeout을 정리하지 않음
- 이벤트: addEventListener 후 removeEventListener 안 함
- 캐시: LRU 같은 제한 없이 캐시가 무한정 증가

**탐지 방법:**
- 메모리 프로파일링: 힙 덤프나 메모리 사용량 추이 분석
- 도구 사용: Valgrind(C/C++), VisualVM(Java), Chrome DevTools(JavaScript)
- 모니터링: 운영 환경에서 메모리 사용량을 지속적으로 모니터링
- 부하 테스트: 장시간 실행하며 메모리 증가 확인

**방지 방법:**
- 명시적 정리: try-finally나 defer로 리소스 해제 보장
- 약한 참조: WeakMap, WeakSet으로 GC를 방해하지 않는 참조
- 크기 제한: 캐시나 컬렉션에 최대 크기 설정
- 리스너 제거: 더 이상 필요 없는 이벤트 리스너 제거
- 자동 관리: RAII 패턴, with 문, defer 등으로 자동 정리

**언어별 방지책:**
- Java: WeakHashMap 사용, ThreadLocal.remove() 호출, 리스너 등록 해제
- JavaScript: WeakMap/WeakSet 사용, clearInterval/clearTimeout, removeEventListener
- Python: 약한 참조(weakref) 사용, with 문으로 리소스 관리
- C++: 스마트 포인터(unique_ptr, shared_ptr) 사용, RAII 패턴
- Go: defer로 리소스 정리, 컨텍스트로 고루틴 종료

**실무 활용:**
- 웹 서버에서 요청 처리 후 반드시 데이터베이스 연결이나 파일 닫기
- SPA에서 컴포넌트 언마운트 시 타이머와 이벤트 리스너 정리
- 장기 실행 프로세스는 정기적으로 메모리 사용량 모니터링하고 프로파일링
- 코드 리뷰에서 리소스 정리 누락 여부를 체크리스트로 확인

---
