# OS 답변 49-52

## 49. Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?

**기본 개념**

스핀락은 락을 획득할 때까지 반복문을 돌면서 계속 확인하는 busy-waiting 방식의 동기화 기법입니다. 락이 해제될 때까지 CPU를 점유하면서 지속적으로 락의 상태를 확인합니다.

**스핀락의 장점**

스핀락의 가장 큰 장점은 컨텍스트 스위칭이 발생하지 않는다는 것입니다. 스레드가 대기 상태로 전환되지 않고 계속 실행 상태를 유지하므로, 락이 짧은 시간 내에 해제될 경우 빠르게 획득할 수 있습니다. 컨텍스트 스위칭과 스케줄링 오버헤드가 없어서 임계 영역이 매우 짧을 때 효율적입니다. 또한 인터럽트 핸들러나 커널 내부에서 사용하기 적합합니다.

**스핀락의 단점**

CPU를 낭비한다는 것이 가장 큰 단점입니다. 락을 기다리는 동안 계속 루프를 돌면서 CPU 사이클을 소모하므로, 다른 유용한 작업에 CPU를 사용할 수 없습니다. 임계 영역이 길거나 락 경쟁이 심한 경우 성능이 크게 저하됩니다. 싱글 코어 시스템에서는 락을 가진 스레드가 실행될 수 없어 데드락 상황이 발생할 수 있습니다.

**단점 해결 방법**

적응적 스핀락을 사용하여 일정 시간 스핀한 후 블로킹으로 전환하는 하이브리드 방식을 채택할 수 있습니다. 락의 소유자가 실행 중인지 확인하여, 실행 중이면 스핀하고 대기 중이면 바로 블로킹하는 방식도 효과적입니다. 백오프 알고리즘을 적용하여 스핀 간격을 점진적으로 늘려 CPU 부하를 줄일 수 있습니다.

**실무 활용**

리눅스 커널의 spinlock_t는 멀티프로세서 환경에서 짧은 임계 영역 보호에 사용됩니다. Java의 synchronized 블록은 적응적 스핀락을 먼저 시도한 후 모니터 락으로 전환합니다. 데이터베이스의 래치 구현에서도 스핀락이 활용되며, 락 경쟁이 적고 임계 영역이 짧을 때 뮤텍스보다 성능이 우수합니다.

---

## 50. 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

**기본 개념**

커널이 관리하는 동기화 도구는 락 획득과 해제 시 시스템 콜을 호출하여 유저 모드에서 커널 모드로 전환이 발생합니다. 이는 동기화의 정확성을 보장하지만 성능 오버헤드를 발생시킵니다.

**장점**

커널이 관리하므로 프로세스 간 동기화가 가능하고, 스케줄러와 통합되어 효율적인 대기 관리가 이루어집니다. 우선순위 역전 문제를 해결할 수 있으며, 시스템 전체적으로 일관된 동기화 메커니즘을 제공합니다. 또한 커널이 데드락 감지와 같은 고급 기능을 제공할 수 있습니다.

**단점**

시스템 콜 호출은 비용이 큽니다. 유저 모드에서 커널 모드로 전환하는 과정에서 레지스터 저장, 권한 검사, 컨텍스트 스위칭 등의 오버헤드가 발생합니다. 락 경쟁이 없는 상황에서도 시스템 콜 비용을 지불해야 하므로, 짧은 임계 영역에서는 비효율적입니다.

**해결 방법 - Futex**

리눅스의 Futex는 Fast Userspace Mutex의 약자로, 락 경쟁이 없을 때는 유저 공간에서 원자적 연산만으로 처리하고, 경쟁이 있을 때만 커널에 도움을 요청합니다. 이는 빠른 경로와 느린 경로를 분리하여 대부분의 경우 시스템 콜을 회피합니다.

**해결 방법 - 유저 레벨 락**

스핀락, TAS, CAS와 같은 원자적 명령어를 활용한 유저 레벨 락을 사용할 수 있습니다. 이는 커널의 개입 없이 동기화를 수행하지만, 프로세스 간 동기화는 지원하지 않습니다. Read-Write Lock의 경우 읽기 작업은 유저 레벨에서 처리하고 쓰기 작업만 커널 개입을 요청하는 최적화가 가능합니다.

**실무 활용**

POSIX pthread_mutex는 내부적으로 Futex를 사용하여 성능을 최적화합니다. Java의 synchronized는 경량 락과 무거운 락을 구분하여, 경쟁이 없으면 CAS 연산만으로 처리합니다. C++11의 std::mutex도 플랫폼별로 Futex나 유사한 메커니즘을 활용하여 시스템 콜 오버헤드를 최소화합니다.

---

## 51. Deadlock 에 대해 설명해 주세요.

**기본 개념**

데드락은 두 개 이상의 프로세스나 스레드가 서로가 가진 자원을 기다리면서 무한정 대기하는 상태입니다. 각 프로세스는 자신이 보유한 자원을 해제하지 않고 다른 프로세스의 자원을 요구하여, 어느 프로세스도 진행할 수 없는 교착 상태에 빠집니다.

**데드락의 예시**

프로세스 A가 자원 X를 보유하고 자원 Y를 요청하고, 동시에 프로세스 B가 자원 Y를 보유하고 자원 X를 요청하는 상황입니다. 두 프로세스 모두 상대방이 가진 자원을 기다리지만, 자신의 자원을 먼저 해제하지 않으므로 영원히 대기하게 됩니다. 데이터베이스에서 트랜잭션 간 락 경쟁, 운영체제의 자원 할당, 네트워크 통신에서도 발생할 수 있습니다.

**데드락의 특징**

데드락은 시스템의 처리량을 감소시키고, 관련된 프로세스들이 완전히 정지되어 시스템 자원을 낭비합니다. 자동으로 해결되지 않으며, 외부 개입이 필요합니다. 멀티스레드 프로그래밍에서 흔히 발생하는 문제이며, 디버깅이 매우 어렵습니다.

**데드락 처리 방법**

예방은 데드락 발생 조건 중 하나를 원천적으로 차단하는 방법입니다. 회피는 자원 할당 시 안전 상태를 유지하도록 동적으로 검사합니다. 탐지는 데드락 발생을 허용하되 주기적으로 검사하여 발견 시 복구합니다. 무시는 데드락을 처리하지 않고 시스템이 재시작되길 기다리는 방법으로, 현대 운영체제가 주로 채택합니다.

**실무 활용**

데이터베이스 시스템은 데드락 탐지 기능을 제공하며, 발견 시 희생자 트랜잭션을 선택하여 롤백시킵니다. Java에서는 락 순서를 일관되게 유지하거나 tryLock을 사용하여 타임아웃을 설정하는 방식으로 예방합니다. 분산 시스템에서는 타임스탬프 기반 순서 지정이나 선점 기법을 활용합니다.

**데드락과 라이브락의 차이**

데드락은 프로세스들이 완전히 정지된 상태이지만, 라이브락은 프로세스들이 상태를 계속 변경하면서도 진전이 없는 상태입니다. 두 경우 모두 시스템 진행을 방해하지만, 라이브락은 CPU를 계속 소모한다는 점에서 차이가 있습니다.

---

## 52. Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.

**기본 개념**

데드락이 발생하기 위해서는 네 가지 필요조건이 동시에 충족되어야 합니다. 이를 Coffman 조건이라고 하며, 하나라도 성립하지 않으면 데드락은 발생하지 않습니다.

**상호 배제**

자원은 한 번에 하나의 프로세스만 사용할 수 있어야 합니다. 자원을 동시에 여러 프로세스가 공유할 수 없으며, 한 프로세스가 사용 중인 자원은 다른 프로세스가 사용할 수 없습니다. 프린터, 데이터베이스 레코드, 파일 쓰기 권한 등이 상호 배제 자원의 예시입니다. 이 조건은 대부분의 시스템에서 기본적으로 만족됩니다.

**점유와 대기**

프로세스가 최소한 하나의 자원을 보유한 상태에서 다른 프로세스가 보유한 자원을 추가로 얻기 위해 대기하는 상황입니다. 이미 할당받은 자원을 놓지 않은 채 새로운 자원을 요청합니다. 예를 들어, 프로세스가 파일 A를 열어둔 상태에서 파일 B를 열려고 대기하는 경우입니다.

**비선점**

프로세스가 보유한 자원은 강제로 빼앗을 수 없으며, 프로세스가 자발적으로 해제할 때까지 기다려야 합니다. 운영체제나 다른 프로세스가 강제로 자원을 회수할 수 없습니다. CPU는 선점 가능하지만, 뮤텍스나 세마포어는 비선점 자원입니다. 이 조건이 없으면 시스템이 자원을 강제로 회수하여 데드락을 방지할 수 있습니다.

**순환 대기**

프로세스 집합에서 각 프로세스가 순환적으로 다음 프로세스가 보유한 자원을 대기하는 상황입니다. P0는 P1의 자원을 대기하고, P1은 P2의 자원을 대기하며, 최종적으로 Pn은 P0의 자원을 대기하는 순환 구조가 형성됩니다. 자원 할당 그래프에서 사이클이 존재하는 상태입니다.

**조건의 활용**

데드락 예방은 네 가지 조건 중 하나를 원천적으로 차단하는 방법입니다. 상호 배제는 제거하기 어렵지만, 점유와 대기는 자원을 한꺼번에 요청하도록 하여 제거할 수 있습니다. 비선점은 타임아웃이나 강제 회수를 통해 제거 가능하며, 순환 대기는 자원에 순서를 부여하여 방지할 수 있습니다.

**실무 적용**

데이터베이스는 락 순서를 정의하여 순환 대기를 방지합니다. 멀티스레드 프로그래밍에서는 모든 스레드가 동일한 순서로 락을 획득하도록 규칙을 정합니다. 운영체제는 은행원 알고리즘을 사용하여 안전 상태만 허용함으로써 데드락을 회피합니다. 네 가지 조건을 이해하면 데드락을 사전에 방지하거나 탐지할 수 있습니다.
