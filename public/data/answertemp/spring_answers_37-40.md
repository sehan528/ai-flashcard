# Spring 답변 37-40

## 질문 37: 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?

특정 기능을 하는 구현 클래스가 하나뿐이어도 Spring Bean으로 관리하는 것은 여러 중요한 이점이 있습니다.

**1. 생명주기 관리:**

Spring 컨테이너가 객체의 생성, 초기화, 소멸을 관리합니다. @PostConstruct, @PreDestroy 같은 생명주기 콜백을 활용할 수 있습니다. 리소스 초기화와 정리를 일관되게 처리할 수 있습니다.

직접 new로 생성하면 초기화 로직을 매번 작성해야 하고, 소멸 시 정리도 직접 해야 합니다.

**2. 의존성 주입의 일관성:**

Bean으로 관리하면 다른 Bean들과 동일한 방식으로 주입받을 수 있습니다. 의존성 그래프를 Spring이 자동으로 해결합니다. 순환 의존성 같은 문제를 프레임워크가 감지하고 처리합니다.

**3. 싱글톤 패턴 자동 적용:**

Spring은 기본적으로 Bean을 싱글톤으로 관리합니다. 메모리 효율적이며 상태를 공유할 수 있습니다. 직접 싱글톤을 구현할 필요가 없고, 스레드 안전성도 보장됩니다.

**4. AOP 적용 가능:**

Bean으로 관리되어야 트랜잭션, 보안, 로깅 같은 횡단 관심사를 AOP로 적용할 수 있습니다. @Transactional, @Cacheable, @Async 같은 어노테이션이 동작하려면 Bean이어야 합니다. 프록시 기반으로 부가 기능을 추가할 수 있습니다.

직접 new로 생성한 객체는 AOP가 적용되지 않아 이러한 기능을 사용할 수 없습니다.

**5. 테스트 용이성:**

Bean으로 관리하면 테스트 시 Mock이나 Stub으로 쉽게 교체할 수 있습니다. @MockBean으로 특정 Bean만 테스트용으로 변경할 수 있습니다. 통합 테스트에서 Spring Context를 활용할 수 있습니다.

**6. 설정 외부화:**

Bean 설정을 통해 동작을 외부에서 제어할 수 있습니다. application.properties나 환경 변수로 설정을 주입받을 수 있습니다. 코드 변경 없이 동작을 변경할 수 있습니다.

**7. 미래의 확장성:**

현재는 구현이 하나지만 미래에 여러 구현이 필요할 수 있습니다. 처음부터 Bean으로 관리하면 나중에 쉽게 확장할 수 있습니다. 인터페이스를 추출하고 여러 구현체 중 선택하는 것이 간단해집니다.

코드를 변경 없이 설정만으로 구현체를 교체할 수 있습니다.

**8. Spring 생태계 통합:**

Spring Boot의 자동 구성, Spring Data의 리포지토리, Spring Security의 인증 등 다양한 기능이 Bean 기반으로 동작합니다. Bean으로 관리해야 이러한 기능들과 자연스럽게 통합됩니다.

**9. 프로파일과 조건부 등록:**

@Profile로 환경별로 다른 Bean을 등록할 수 있습니다. @Conditional로 특정 조건에 따라 Bean 등록 여부를 결정할 수 있습니다. 개발, 테스트, 운영 환경에서 다른 구현을 사용할 수 있습니다.

**10. 관찰 가능성:**

Bean으로 관리되면 Spring Actuator로 모니터링할 수 있습니다. Bean의 상태와 의존 관계를 추적할 수 있습니다. 문제 진단과 디버깅이 쉬워집니다.

**일관성과 유지보수성:**

애플리케이션의 모든 컴포넌트를 동일한 방식으로 관리하면 코드가 일관되고 이해하기 쉬워집니다. 새로운 개발자가 프로젝트에 참여해도 Spring의 표준 방식을 따르므로 빠르게 적응할 수 있습니다.

일부는 Bean으로, 일부는 직접 생성하면 혼란스럽고 유지보수가 어려워집니다.

따라서 구현이 하나뿐이어도 Spring Bean으로 관리하는 것이 장기적으로 더 유연하고 유지보수하기 좋은 코드를 만듭니다.

## 질문 38: Spring의 Bean 생성 주기에 대해 설명해 주세요.

Spring Bean의 생명주기는 생성부터 소멸까지 여러 단계를 거치며, Spring 컨테이너가 이를 관리합니다.

**1. 컨테이너 초기화:**

ApplicationContext가 생성되면서 Bean 정의를 읽습니다. @Component 스캔, Java Config, XML 설정 등에서 Bean 메타데이터를 수집합니다. BeanDefinition 객체로 Bean 정보를 저장합니다.

**2. Bean 인스턴스 생성:**

Spring은 리플렉션을 사용하여 Bean 인스턴스를 생성합니다. 기본 생성자 또는 명시된 생성자를 호출합니다. 이 시점에는 아직 의존성이 주입되지 않은 상태입니다.

**3. 의존성 주입:**

생성자 주입은 인스턴스 생성 시 함께 이루어집니다. 필드 주입과 세터 주입은 인스턴스 생성 후에 수행됩니다. BeanPostProcessor를 통해 @Autowired 같은 어노테이션이 처리됩니다.

**4. Bean 이름 설정:**

BeanNameAware 인터페이스를 구현한 경우 setBeanName 메서드가 호출됩니다. Bean이 컨테이너 내에서 자신의 이름을 알 수 있게 됩니다.

**5. Bean Factory 설정:**

BeanFactoryAware 인터페이스를 구현한 경우 setBeanFactory 메서드가 호출됩니다. Bean이 자신을 생성한 Factory에 접근할 수 있게 됩니다.

**6. Application Context 설정:**

ApplicationContextAware 인터페이스를 구현한 경우 setApplicationContext 메서드가 호출됩니다. Bean이 ApplicationContext에 접근할 수 있게 됩니다.

**7. BeanPostProcessor의 전처리:**

모든 BeanPostProcessor의 postProcessBeforeInitialization 메서드가 호출됩니다. @PostConstruct 어노테이션이 이 단계에서 처리됩니다. 커스텀 초기화 로직을 추가할 수 있습니다.

**8. 초기화 콜백:**

@PostConstruct 어노테이션이 붙은 메서드가 실행됩니다. InitializingBean 인터페이스의 afterPropertiesSet 메서드가 호출됩니다. @Bean의 initMethod로 지정된 메서드가 실행됩니다.

이 단계에서 리소스 초기화, 연결 설정, 데이터 로딩 등을 수행합니다.

**9. BeanPostProcessor의 후처리:**

모든 BeanPostProcessor의 postProcessAfterInitialization 메서드가 호출됩니다. AOP 프록시가 이 단계에서 생성됩니다. Bean이 완전히 초기화되어 사용 가능한 상태가 됩니다.

**10. Bean 사용:**

Bean이 컨테이너에 등록되고 애플리케이션에서 사용됩니다. 기본적으로 싱글톤이므로 같은 인스턴스가 재사용됩니다.

**11. 소멸 전 콜백:**

컨테이너가 종료될 때 Bean을 소멸시킵니다. @PreDestroy 어노테이션이 붙은 메서드가 실행됩니다. DisposableBean 인터페이스의 destroy 메서드가 호출됩니다. @Bean의 destroyMethod로 지정된 메서드가 실행됩니다.

이 단계에서 리소스 해제, 연결 종료, 정리 작업 등을 수행합니다.

**12. Bean 소멸:**

Bean 인스턴스가 GC 대상이 됩니다.

**생명주기 제어 방법:**

어노테이션 방식은 @PostConstruct와 @PreDestroy를 사용합니다. 가장 간단하고 권장되는 방식입니다.

인터페이스 방식은 InitializingBean과 DisposableBean을 구현합니다. Spring에 의존적이므로 권장되지 않습니다.

설정 방식은 @Bean의 initMethod와 destroyMethod 속성을 사용합니다. 외부 라이브러리의 클래스에 유용합니다.

**프로토타입 스코프의 차이:**

프로토타입 Bean은 매번 새로운 인스턴스가 생성됩니다. 소멸 콜백이 자동으로 호출되지 않습니다. 개발자가 직접 정리 해야 합니다.

**중요한 점:**

생성자에서는 의존성이 완전히 주입되지 않았을 수 있습니다. 초기화 로직은 @PostConstruct나 afterPropertiesSet에서 수행해야 합니다. 순환 의존성이 있으면 생성 과정에서 예외가 발생할 수 있습니다.

## 질문 39: 프로토타입 빈은 무엇인가요?

프로토타입 빈(Prototype Bean)은 Spring에서 요청할 때마다 새로운 인스턴스를 생성하는 스코프입니다.

**기본 개념:**

일반적인 Spring Bean은 싱글톤 스코프가 기본입니다. 싱글톤은 컨테이너에 단 하나의 인스턴스만 존재하며 모든 곳에서 같은 객체를 공유합니다.

프로토타입 빈은 getBean이나 주입을 요청할 때마다 새로운 인스턴스를 생성합니다. 각 요청자가 독립적인 객체를 받습니다.

**선언 방법:**

@Scope("prototype") 또는 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)를 클래스에 붙입니다. XML 설정에서는 scope="prototype"으로 지정합니다.

**생명주기:**

Spring 컨테이너는 프로토타입 빈을 생성하고 의존성을 주입하며 초기화 콜백까지만 관리합니다. 생성 후에는 클라이언트에게 전달하고 더 이상 관리하지 않습니다.

소멸 콜백이 자동으로 호출되지 않습니다. @PreDestroy나 destroy 메서드가 실행되지 않습니다. 클라이언트가 직접 정리해야 합니다.

**사용 사례:**

상태를 가진 객체가 필요할 때 유용합니다. 각 요청이나 작업마다 독립적인 상태를 유지해야 하는 경우에 적합합니다.

Command 패턴의 커맨드 객체, 사용자별 세션 데이터, 일회용 작업 객체 등에 사용됩니다.

동시성 문제를 피하기 위해 스레드마다 다른 인스턴스가 필요한 경우에 적합합니다.

**싱글톤 빈과 프로토타입 빈의 조합 문제:**

싱글톤 빈이 프로토타입 빈을 의존성으로 주입받으면 문제가 발생합니다. 싱글톤은 한 번만 생성되므로 프로토타입도 한 번만 주입됩니다. 이후에는 같은 프로토타입 인스턴스를 계속 사용하게 되어 의도와 다릅니다.

**해결 방법:**

Provider나 ObjectFactory를 사용합니다. 필요할 때마다 getObject를 호출하여 새 인스턴스를 얻습니다.

@Lookup 어노테이션을 사용합니다. Spring이 메서드를 오버라이드하여 매번 새로운 프로토타입 인스턴스를 반환하도록 합니다.

ApplicationContext를 주입받아 직접 getBean을 호출합니다. 하지만 이는 Spring에 강하게 결합되어 권장되지 않습니다.

**성능 고려사항:**

매번 새로운 객체를 생성하므로 오버헤드가 있습니다. 객체 생성 비용이 크거나 빈번하게 생성되면 성능에 영향을 줄 수 있습니다. GC 압력도 증가합니다.

정말 필요한 경우에만 사용하고, 가능하면 싱글톤으로 불변 객체를 만드는 것이 좋습니다.

**다른 스코프:**

Request 스코프는 HTTP 요청마다 인스턴스를 생성합니다. 웹 애플리케이션에서 사용됩니다.

Session 스코프는 HTTP 세션마다 인스턴스를 생성합니다. 사용자별 데이터를 유지할 때 사용됩니다.

Application 스코프는 ServletContext 생명주기와 같습니다.

WebSocket 스코프는 WebSocket 세션마다 인스턴스를 생성합니다.

프로토타입 빈은 특수한 상황에서 유용하지만, 대부분의 경우 싱글톤 빈으로 충분하며 더 효율적입니다.

## 질문 40: AOP에 대해 설명해 주세요.

AOP(Aspect-Oriented Programming)는 관점 지향 프로그래밍으로, 횡단 관심사(cross-cutting concerns)를 모듈화하는 프로그래밍 패러다임입니다.

**핵심 개념:**

횡단 관심사는 여러 모듈에 걸쳐 공통적으로 나타나는 기능입니다. 로깅, 보안, 트랜잭션 관리, 예외 처리, 성능 측정 등이 대표적입니다. 이런 기능들은 비즈니스 로직과 섞이면 코드가 복잡해지고 중복이 발생합니다.

AOP는 이러한 횡단 관심사를 별도의 모듈(Aspect)로 분리합니다. 핵심 비즈니스 로직과 부가 기능을 분리하여 코드의 가독성과 유지보수성을 높입니다.

**주요 용어:**

Aspect는 횡단 관심사를 모듈화한 것입니다. 여러 객체에 공통으로 적용되는 기능을 정의합니다. @Aspect 어노테이션으로 선언합니다.

Join Point는 Aspect를 적용할 수 있는 지점입니다. 메서드 실행, 객체 생성, 필드 접근 등이 해당됩니다. Spring AOP에서는 메서드 실행만 지원합니다.

Advice는 Aspect가 Join Point에서 수행할 동작입니다. 언제 무엇을 할지 정의합니다. Before, After, Around 등의 타입이 있습니다.

Pointcut은 Advice를 적용할 Join Point를 선택하는 표현식입니다. 어떤 메서드에 Advice를 적용할지 지정합니다.

Target은 Advice가 적용되는 대상 객체입니다. 비즈니스 로직을 가진 실제 객체입니다.

Proxy는 Target을 감싸서 Advice를 적용하는 객체입니다. Spring은 JDK 동적 프록시나 CGLIB을 사용합니다.

Weaving은 Aspect를 Target에 적용하여 Proxy를 생성하는 과정입니다.

**Advice 타입:**

@Before는 메서드 실행 전에 동작합니다. 인증, 로깅, 입력 검증 등에 사용됩니다.

@AfterReturning은 메서드가 정상적으로 반환된 후에 동작합니다. 반환값을 로깅하거나 후처리할 때 사용됩니다.

@AfterThrowing은 메서드에서 예외가 발생한 후에 동작합니다. 예외 로깅, 알림 등에 사용됩니다.

@After는 메서드 실행 후 항상 동작합니다. finally 블록처럼 성공 여부와 관계없이 실행됩니다.

@Around는 메서드 실행 전후를 모두 제어합니다. 가장 강력하며 실행 자체를 제어할 수 있습니다. ProceedingJoinPoint.proceed()로 실제 메서드를 호출합니다. 트랜잭션, 성능 측정, 캐싱 등에 사용됩니다.

**Pointcut 표현식:**

execution은 메서드 실행 Join Point를 매칭합니다. 가장 많이 사용됩니다.

within은 특정 타입 내의 모든 메서드를 매칭합니다.

bean은 Spring Bean 이름으로 매칭합니다.

@annotation은 특정 어노테이션이 붙은 메서드를 매칭합니다.

args는 인자 타입으로 매칭합니다.

**동작 원리:**

Spring AOP는 프록시 기반으로 동작합니다. Bean이 생성될 때 Pointcut에 매칭되면 프록시를 생성합니다. 인터페이스가 있으면 JDK 동적 프록시를, 없으면 CGLIB 프록시를 사용합니다.

클라이언트는 실제 Target이 아닌 Proxy를 호출합니다. Proxy는 Advice를 실행한 후 실제 메서드를 호출합니다.

**장점:**

코드 중복을 제거합니다. 횡단 관심사를 한 곳에서 관리할 수 있습니다.

핵심 로직과 부가 기능을 분리합니다. 비즈니스 로직이 깔끔해지고 가독성이 높아집니다.

유지보수가 쉬워집니다. 부가 기능을 변경할 때 한 곳만 수정하면 됩니다.

재사용성이 높아집니다. 같은 Aspect를 여러 곳에 적용할 수 있습니다.

**주의사항:**

프록시 기반이므로 내부 메서드 호출에는 AOP가 적용되지 않습니다. 같은 클래스 내에서 this로 메서드를 호출하면 프록시를 거치지 않습니다.

public 메서드에만 적용됩니다. private이나 protected 메서드는 AOP가 적용되지 않습니다.

성능 오버헤드가 있습니다. 프록시를 거치므로 약간의 성능 저하가 있습니다.

**사용 예시:**

@Transactional은 AOP로 구현되어 있습니다. @Cacheable, @Async, @Secured도 AOP를 활용합니다. 커스텀 로깅, 성능 모니터링, 감사(auditing) 등을 AOP로 구현할 수 있습니다.

AOP는 관심사의 분리를 통해 깔끔하고 유지보수하기 쉬운 코드를 만드는 강력한 도구입니다.
