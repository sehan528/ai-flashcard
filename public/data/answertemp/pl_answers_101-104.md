## 질문 101: Go의 포인터와 값 타입의 차이점은 무엇인가요?

**정의:**
Go는 값 타입과 포인터 타입을 명확히 구분하며, 값 타입은 데이터를 복사하고 포인터 타입은 메모리 주소를 전달합니다. 함수 호출이나 할당 시 어느 방식을 사용하느냐에 따라 성능과 동작이 달라집니다.

**특징/원리:**
- 값 전달: 기본적으로 값 타입은 복사되어 전달됨
- 포인터: 메모리 주소를 전달하여 원본 데이터에 직접 접근
- 명시적: &로 주소 획득, *로 역참조하여 명시적으로 포인터 사용
- 안전성: 포인터 연산 불가능하여 C보다 안전

**값 타입 특징:**
- 복사: 할당이나 함수 호출 시 값 전체가 복사됨
- 독립성: 복사본은 원본과 독립적이어서 수정해도 원본에 영향 없음
- 성능: 작은 구조체는 복사가 빠르지만 큰 구조체는 비효율적
- 스택: 작은 값은 스택에 할당되어 빠름

**포인터 타입 특징:**
- 참조: 메모리 주소만 복사되어 동일한 데이터를 가리킴
- 수정: 포인터를 통해 원본 데이터 수정 가능
- 효율성: 큰 구조체를 전달할 때 주소만 복사하여 효율적
- 힙: 포인터가 가리키는 데이터는 힙에 할당될 수 있음

**메서드 리시버:**
- 값 리시버: 메서드가 복사본에 작동하여 원본 수정 불가
- 포인터 리시버: 메서드가 원본을 수정할 수 있음
- 관례: 큰 구조체나 수정이 필요하면 포인터 리시버 사용
- 일관성: 하나의 타입에는 값이나 포인터 리시버 중 하나로 통일

**nil 포인터:**
- nil: 포인터의 제로값은 nil이며 유효한 주소를 가리키지 않음
- 패닉: nil 포인터를 역참조하면 패닉 발생
- 검사: 사용 전 nil 검사 필요

**실무 활용:**
- 큰 구조체는 포인터로 전달하여 복사 비용 절감
- 함수에서 구조체를 수정해야 하면 포인터 파라미터 사용
- 슬라이스, 맵, 채널은 이미 참조 타입처럼 동작하므로 포인터로 전달할 필요 없음

---

## 질문 102: Go의 슬라이스(Slice)와 배열(Array)의 차이점을 설명해주세요.

**정의:**
배열은 고정 크기의 연속된 메모리 블록이고, 슬라이스는 배열의 일부를 참조하는 동적 크기의 뷰입니다. 배열은 값 타입이지만 슬라이스는 참조 타입처럼 동작하여 Go에서는 주로 슬라이스를 사용합니다.

**특징/원리:**
- 배열: 크기가 타입의 일부이며 변경 불가능
- 슬라이스: 동적 크기로 필요에 따라 증가 가능
- 복사: 배열은 전체가 복사되지만 슬라이스는 헤더만 복사되어 같은 배열 참조
- 효율성: 대부분의 경우 슬라이스가 더 유연하고 효율적

**배열 특징:**
- 고정 크기: [5]int처럼 크기가 타입의 일부
- 값 타입: 할당 시 전체 복사됨
- 스택 할당: 작은 배열은 스택에 할당
- 제한: 크기를 변경할 수 없어 유연성 부족

**슬라이스 구조:**
- 헤더: 포인터(배열 주소), len(길이), cap(용량)으로 구성
- 동적 크기: len은 현재 길이, cap은 최대 길이
- 확장: append로 요소 추가 시 cap 초과하면 새 배열 할당하고 복사

**슬라이스 연산:**
- 생성: make([]T, len, cap)으로 생성하거나 리터럴 사용
- 슬라이싱: slice[low:high]로 부분 슬라이스 생성
- append: 요소 추가하며 필요시 재할당
- copy: 슬라이스 간 복사
- nil 슬라이스: 제로값은 nil이며 길이와 용량 0

**용량과 재할당:**
- 용량 부족: append 시 cap 초과하면 새 배열 할당 (보통 2배 증가)
- 성능: 재할당은 비용이 크므로 예상 크기로 make 사용
- 공유: 여러 슬라이스가 같은 배열 참조 가능하여 수정 시 주의

**실무 활용:**
- 거의 모든 경우 배열 대신 슬라이스 사용하여 유연성 확보
- 예상 크기를 알면 make로 용량 지정하여 재할당 방지
- 슬라이싱 시 원본 배열이 변경될 수 있음을 주의

---

## 질문 103: Go의 맵(Map)의 내부 구조와 동작 원리는 무엇인가요?

**정의:**
맵은 키-값 쌍을 저장하는 해시 테이블 기반 자료구조로, 키를 사용하여 빠르게 값을 조회, 삽입, 삭제할 수 있습니다. 참조 타입처럼 동작하며 동적으로 크기가 증가합니다.

**특징/원리:**
- 해시 테이블: 내부적으로 해시 테이블로 구현되어 평균 O(1) 성능
- 참조 타입: 맵 변수는 헤더를 가리키는 포인터로 동작
- 동적 크기: 요소 추가 시 자동으로 확장
- 비순서: 키의 순서가 보장되지 않음

**맵 연산:**
- 생성: make(map[K]V)로 생성하거나 리터럴 사용
- 삽입/수정: m[key] = value로 키-값 쌍 저장
- 조회: value := m[key]로 값 조회, 없으면 제로값 반환
- 안전 조회: value, ok := m[key]로 존재 여부 확인
- 삭제: delete(m, key)로 키-값 쌍 제거
- 길이: len(m)으로 요소 개수 확인

**nil 맵:**
- nil 맵: var m map[K]V는 nil 맵으로 읽기는 가능하지만 쓰기 시 패닉
- 초기화: make로 초기화해야 쓰기 가능
- 검사: 사용 전 nil 확인 필요

**동시성:**
- 비안전: 맵은 동시성 안전하지 않아 여러 고루틴에서 동시 접근 시 경쟁 조건
- sync.Map: 동시성 안전한 맵 구현체
- sync.RWMutex: 맵을 뮤텍스로 보호하여 동시성 제어

**순회:**
- for range: for key, value := range m으로 순회
- 무작위 순서: 순회 순서는 보장되지 않으며 실행마다 달라질 수 있음
- 안전한 삭제: 순회 중 요소 삭제 가능

**실무 활용:**
- 설정 값이나 캐시를 맵으로 저장하여 빠른 조회
- 중복 제거나 집합 연산에 맵의 키만 사용
- 멀티스레드 환경에서는 sync.Map 사용하거나 뮤텍스로 보호

---

## 질문 104: Go의 defer, panic, recover에 대해 설명해주세요.

**정의:**
defer는 함수 종료 시 실행될 코드를 예약하고, panic은 프로그램 실행을 중단시키며, recover는 panic을 복구합니다. 이 세 가지는 Go의 에러 처리와 리소스 정리 메커니즘의 핵심입니다.

**특징/원리:**
- defer: 함수 반환 직전에 실행되어 리소스 정리 보장
- panic: 복구 불가능한 에러 시 프로그램 중단
- recover: defer 함수 내에서만 panic 복구 가능
- 스택 해제: panic 발생 시 defer 함수들을 실행하며 스택 해제

**defer 특징:**
- LIFO 순서: 여러 defer는 스택처럼 역순으로 실행
- 인자 평가: defer 문 실행 시점에 인자 평가되지만 실행은 나중
- 반환값 수정: 명명된 반환값을 defer에서 수정 가능
- 리소스 정리: 파일 닫기, 락 해제 등에 활용

**panic 특징:**
- 프로그램 중단: 호출 스택을 거슬러 올라가며 프로그램 종료
- defer 실행: panic 중에도 defer 함수는 실행됨
- 명시적 호출: panic(value)로 명시적으로 발생 가능
- 런타임 에러: 배열 인덱스 초과, nil 포인터 역참조 등도 panic 발생

**recover 특징:**
- defer 내부: defer 함수 안에서만 호출 의미 있음
- panic 복구: recover()가 nil이 아니면 panic 발생 중
- 반환값: panic에 전달된 값을 반환
- 재panic: recover 후 다시 panic 호출 가능

**에러 처리 철학:**
- 일반 에러: error 타입으로 반환하고 호출자가 처리
- 치명적 에러: 복구 불가능한 상황만 panic 사용
- 라이브러리: 라이브러리는 panic 대신 error 반환 권장
- 경계: 패키지 경계에서 panic 복구하여 error로 변환

**실무 활용:**
- 파일이나 락을 열었을 때 defer로 자동 해제하여 누수 방지
- 웹 서버에서 핸들러의 panic을 복구하여 서버 다운 방지
- 설정 로딩 실패 같은 치명적 에러는 panic으로 빠른 실패

---
