# OS 답변 121-122

## 121. I/O 멀티플렉싱에 대해 설명해 주세요.

**기본 개념**

I/O 멀티플렉싱은 단일 스레드로 여러 개의 I/O 채널을 동시에 모니터링하고 처리하는 기법입니다. 여러 파일 디스크립터 중 준비된 것만 선택하여 블로킹 없이 효율적으로 I/O를 수행합니다.

**필요성**

전통적인 블로킹 I/O에서는 하나의 소켓이나 파일을 읽을 때 데이터가 올 때까지 대기합니다. 여러 클라이언트를 처리하려면 각각 스레드를 만들어야 하는데, 스레드 생성 비용과 컨텍스트 스위칭 오버헤드가 큽니다. 수천 개의 연결을 처리하려면 수천 개의 스레드가 필요하여 비효율적입니다. I/O 멀티플렉싱은 하나의 스레드로 많은 연결을 처리하여 자원을 절약합니다.

**select 시스템 콜**

가장 오래된 I/O 멀티플렉싱 메커니즘입니다. 관심 있는 파일 디스크립터 집합을 비트맵으로 전달합니다. 읽기, 쓰기, 예외 상황별로 세 개의 FD 집합을 제공합니다. select는 하나 이상의 FD가 준비될 때까지 블로킹합니다. 준비된 FD만 비트맵에 설정되어 반환되며, 호출자는 이를 확인하여 I/O를 수행합니다. 간단하지만 FD 수에 제한이 있고, 큰 FD 집합은 비효율적입니다.

**poll 시스템 콜**

select의 개선 버전으로, FD 배열을 사용합니다. FD 수 제한이 없고, 이벤트 타입을 더 세밀하게 지정할 수 있습니다. pollfd 구조체에 FD와 관심 이벤트를 설정하고, 결과 이벤트를 받습니다. select보다 확장성이 좋지만, 여전히 선형 스캔이 필요하여 많은 FD에서는 느립니다.

**epoll**

리눅스의 고성능 I/O 멀티플렉싱 메커니즘입니다. epoll_create로 epoll 인스턴스를 생성하고, epoll_ctl로 관심 FD를 등록합니다. epoll_wait로 준비된 FD를 효율적으로 가져옵니다. 커널이 활성 FD만 반환하여, FD 수와 무관하게 성능이 일정합니다. Edge-triggered와 Level-triggered 모드를 지원하여 유연합니다. 수만 개의 연결도 효율적으로 처리할 수 있습니다.

**kqueue**

BSD와 macOS의 이벤트 알림 메커니즘입니다. 파일 I/O, 소켓, 프로세스, 타이머 등 다양한 이벤트를 통합 처리합니다. epoll과 유사한 성능을 제공하며, 더 일반화된 인터페이스입니다. kevent 구조체로 이벤트를 등록하고 조회합니다.

**IOCP**

윈도우의 I/O Completion Port는 다른 접근 방식을 사용합니다. 비동기 I/O를 시작하고, 완료 포트를 통해 결과를 받습니다. 스레드 풀과 통합되어 자동으로 부하 분산합니다. 높은 성능과 확장성을 제공하지만, 프로그래밍 모델이 다릅니다.

**Reactor 패턴**

I/O 멀티플렉싱을 구조화하는 디자인 패턴입니다. 이벤트 루프가 epoll이나 select로 이벤트를 기다립니다. 이벤트 발생 시 등록된 핸들러를 호출하여 처리합니다. 비블로킹 I/O와 함께 사용하여 단일 스레드로 높은 동시성을 달성합니다. Node.js, Redis, Nginx가 이 패턴을 사용합니다.

**장점과 단점**

적은 스레드로 많은 연결을 처리하여 메모리와 컨텍스트 스위칭 비용을 절약합니다. CPU 집약적 작업에는 부적합하며, 이벤트 루프를 블로킹하면 모든 연결이 영향받습니다. 비동기 프로그래밍 복잡도가 증가하고, 디버깅이 어려워집니다. I/O 위주 서버에 이상적이지만, 모든 상황에 적합하지는 않습니다.

**실무 활용**

웹 서버와 프록시는 I/O 멀티플렉싱으로 수천 개의 동시 연결을 처리합니다. 채팅 서버는 많은 클라이언트를 단일 스레드로 관리합니다. 데이터베이스 연결 풀은 여러 연결을 효율적으로 다룹니다. 고성능 네트워크 애플리케이션의 필수 기술이며, 현대 서버 아키텍처의 기반입니다.

---

## 122. 논블로킹 I/O를 수행한다고 하면, 그 결과를 어떻게 수신할 수 있나요?

**기본 개념**

논블로킹 I/O는 즉시 반환하므로, 작업이 완료되지 않았을 수 있습니다. 결과를 얻는 방법은 폴링, I/O 멀티플렉싱, 비동기 콜백, 시그널 등 여러 가지가 있습니다.

**폴링 방식**

주기적으로 상태를 확인하여 완료 여부를 판단합니다. read를 반복 호출하여 EAGAIN이 아닌 실제 데이터를 받을 때까지 시도합니다. 간단하지만 CPU를 낭비하고 응답성이 폴링 주기에 의존합니다. 바쁜 대기 루프는 피하고, 적절한 간격으로 폴링해야 합니다. 다른 방법이 없을 때의 최후 수단입니다.

**I/O 멀티플렉싱**

select, poll, epoll로 FD의 준비 상태를 모니터링합니다. 여러 FD를 등록하고, 하나라도 준비되면 통지받습니다. 준비된 FD에 대해서만 논블로킹 I/O를 수행하여 즉시 완료됩니다. 효율적이고 확장 가능하며, 서버 애플리케이션의 표준 방식입니다. 이벤트 기반 프로그래밍과 자연스럽게 결합됩니다.

**비동기 I/O와 콜백**

aio나 io_uring 같은 비동기 I/O 인터페이스를 사용합니다. I/O를 시작할 때 콜백 함수나 완료 큐를 등록합니다. 작업이 완료되면 커널이 콜백을 호출하거나 완료 큐에 결과를 넣습니다. 프로그램은 이벤트 루프에서 완료를 처리합니다. 진정한 비동기로 커널이 I/O를 대신 수행하는 동안 다른 작업을 할 수 있습니다.

**시그널 기반 I/O**

SIGIO 시그널로 I/O 준비를 통지받습니다. FD를 비동기 모드로 설정하고, 시그널 핸들러를 등록합니다. 데이터가 도착하면 시그널이 발생하고, 핸들러에서 I/O를 수행합니다. 유닉스 전통적 방법이지만, 시그널의 제약과 복잡성으로 현대에는 덜 사용됩니다. epoll이나 비동기 I/O가 더 나은 대안입니다.

**완료 포트 - IOCP**

윈도우의 I/O Completion Port는 완료 기반 모델입니다. 비동기 I/O를 시작하고, 완료 포트에서 결과를 가져옵니다. GetQueuedCompletionStatus로 완료된 I/O를 효율적으로 수집합니다. 스레드 풀과 통합되어 자동 부하 분산을 제공합니다. 윈도우에서 고성능 서버를 구현하는 표준 방법입니다.

**io_uring**

리눅스의 최신 비동기 I/O 인터페이스로, 높은 성능을 제공합니다. 제출 큐에 I/O 요청을 넣고, 완료 큐에서 결과를 가져옵니다. 시스템 콜을 최소화하여 오버헤드를 줄입니다. 링 버퍼로 커널과 효율적으로 통신합니다. 차세대 고성능 I/O의 표준으로 자리잡고 있습니다.

**퓨처와 프로미스**

고수준 언어는 퓨처나 프로미스 객체를 반환합니다. 비동기 작업을 시작하고, 퓨처 객체를 받습니다. 퓨처를 대기하거나, then으로 콜백을 체인합니다. 작업 완료 시 퓨처가 resolve되고, 결과를 얻거나 콜백이 실행됩니다. JavaScript Promise, Java Future, Rust Future가 이를 제공합니다.

**async/await 문법**

비동기 코드를 동기처럼 작성하는 문법적 설탕입니다. async 함수는 백그라운드에서 실행되고, await로 결과를 기다립니다. 컴파일러나 런타임이 이를 콜백이나 상태 머신으로 변환합니다. 코드 가독성이 크게 향상되고, 에러 처리도 자연스럽습니다. Python asyncio, JavaScript, C#, Rust가 지원합니다.

**실무 선택**

서버 애플리케이션은 epoll이나 io_uring with 이벤트 루프를 사용합니다. 고수준 언어는 async/await로 비동기 코드를 작성합니다. 라이브러리가 내부적으로 멀티플렉싱이나 비동기 I/O를 처리합니다. 프로그래머는 논리에 집중하고, 프레임워크가 효율적인 I/O를 제공합니다. 각 플랫폼과 언어에 맞는 도구를 활용하는 것이 중요합니다.

**결론**

논블로킹 I/O의 결과는 폴링, 멀티플렉싱, 콜백, 완료 큐 등 다양한 방법으로 수신할 수 있습니다. I/O 멀티플렉싱이 가장 일반적이고 효율적인 방법입니다. 비동기 I/O와 async/await는 현대적이고 고수준 접근입니다. 상황에 맞는 메커니즘을 선택하여 효율적이고 확장 가능한 프로그램을 작성할 수 있습니다.
