# JavaScript 답변 49-52

## 질문 49: ==와 ===의 차이점은 무엇인가요?

**정의:**
이중 등호는 값의 동등성을 비교하며 타입 변환을 수행합니다. 삼중 등호는 엄격한 동등성을 비교하며 타입 변환 없이 타입과 값 모두를 검사합니다.

**이중 등호의 동작:**
- 타입이 다르면 타입 변환을 시도합니다. 암묵적 변환이 발생합니다.
- 변환 규칙이 복잡하고 예측하기 어렵습니다.
- 숫자와 문자열을 비교하면 문자열을 숫자로 변환합니다.
- null과 undefined는 서로 같다고 판단합니다.

**삼중 등호의 동작:**
- 타입 변환을 하지 않습니다. 타입이 다르면 즉시 false를 반환합니다.
- 타입과 값이 모두 같아야 true입니다.
- 예측 가능하고 명확합니다.
- 대부분의 상황에서 권장되는 비교 연산자입니다.

**이중 등호의 변환 규칙:**
- 숫자와 문자열: 문자열을 숫자로 변환합니다.
- 불리언과 다른 타입: 불리언을 숫자로 먼저 변환합니다.
- 객체와 원시 타입: 객체를 원시 값으로 변환합니다. valueOf나 toString을 호출합니다.
- null과 undefined: 서로에 대해서만 true입니다. 다른 값과는 false입니다.

**특이한 경우들:**
- 빈 문자열과 0은 같습니다. 문자열이 숫자로 변환되기 때문입니다.
- false와 0은 같습니다. 불리언이 숫자로 변환됩니다.
- 빈 배열과 0도 같을 수 있습니다. 객체가 원시 값으로 변환됩니다.
- NaN은 자기 자신과도 같지 않습니다. 유일한 예외입니다.

**null과 undefined:**
- 이중 등호로는 서로 같습니다. null과 undefined만 이런 관계입니다.
- 삼중 등호로는 다릅니다. 타입이 다르기 때문입니다.
- null이나 undefined 체크 시 이중 등호를 사용할 수 있습니다.
- 하지만 명시적으로 비교하는 것이 더 명확합니다.

**Object.is:**
- ES6에서 추가된 비교 메서드입니다.
- 삼중 등호와 거의 같지만 두 가지 차이가 있습니다.
- 더하기 0과 빼기 0을 다르게 취급합니다.
- NaN과 NaN을 같다고 판단합니다.
- 더 정확하지만 특수한 경우에만 필요합니다.

**실무 권장사항:**
- 기본적으로 삼중 등호를 사용합니다. 일관되고 예측 가능합니다.
- 이중 등호는 사용하지 않는 것이 좋습니다. 버그의 원인이 될 수 있습니다.
- null이나 undefined 체크도 명시적으로 합니다.
- ESLint의 eqeqeq 규칙으로 이중 등호 사용을 금지할 수 있습니다.
- TypeScript를 사용하면 타입 체크로 많은 문제를 사전에 방지합니다.

---

## 질문 50: typeof 연산자의 특이한 동작들은 무엇인가요?

**정의:**
typeof는 값의 타입을 문자열로 반환하는 단항 연산자입니다. 대부분의 경우 예상대로 동작하지만 몇 가지 특이한 경우가 있습니다.

**기본 동작:**
- 원시 타입에 대해서는 정확히 동작합니다. number, string, boolean, undefined, symbol, bigint를 반환합니다.
- 함수에 대해서는 function을 반환합니다. Function은 객체지만 구분됩니다.
- 나머지 모든 객체는 object를 반환합니다.

**null의 특이한 동작:**
- typeof null은 object를 반환합니다. JavaScript의 오래된 버그입니다.
- 초기 구현의 실수가 하위 호환성 때문에 유지되고 있습니다.
- null을 체크하려면 명시적으로 비교해야 합니다.
- 엄격한 동등 비교로 null인지 확인합니다.

**배열과 객체:**
- 배열도 object를 반환합니다. 배열을 구분할 수 없습니다.
- Array.isArray로 배열을 확인해야 합니다.
- 일반 객체와 배열을 구분하려면 별도 체크가 필요합니다.

**선언되지 않은 변수:**
- 선언되지 않은 변수에 typeof를 사용하면 undefined를 반환합니다.
- 에러가 발생하지 않습니다. 유일하게 안전한 참조 방법입니다.
- 전역 변수 존재 여부를 확인할 때 유용합니다.
- window 객체 확인 등에 사용됩니다.

**함수 구분:**
- 일반 함수와 화살표 함수 모두 function을 반환합니다.
- 클래스도 function을 반환합니다. 내부적으로 함수이기 때문입니다.
- async 함수도 function을 반환합니다.
- Generator 함수도 function을 반환합니다.

**특수 객체들:**
- Date, RegExp, Error 등 모두 object를 반환합니다.
- Map, Set, WeakMap, WeakSet도 object입니다.
- Promise도 object를 반환합니다.
- 구체적인 타입을 확인하려면 instanceof나 constructor를 사용해야 합니다.

**대안적인 타입 체크 방법:**
- Array.isArray로 배열을 확인합니다.
- instanceof로 생성자를 확인합니다. 프로토타입 체인을 검사합니다.
- Object.prototype.toString.call로 정확한 타입을 얻을 수 있습니다.
- constructor 프로퍼티를 확인할 수도 있습니다.

**실무 활용:**
- 원시 타입 체크에는 typeof를 사용합니다.
- 객체의 구체적인 타입은 다른 방법을 사용합니다.
- null 체크는 명시적 비교로 합니다.
- TypeScript를 사용하면 컴파일 타임에 타입을 확인할 수 있습니다.
- 타입 가드 함수를 만들어 재사용합니다.

---

## 질문 51: instanceof의 동작 원리와 제한사항은 무엇인가요?

**정의:**
instanceof는 객체의 프로토타입 체인에 생성자의 prototype이 존재하는지 확인하는 연산자입니다. 객체가 특정 클래스의 인스턴스인지 판별합니다.

**동작 원리:**
- 왼쪽 피연산자의 프로토타입 체인을 검색합니다.
- 오른쪽 피연산자의 prototype과 일치하는지 확인합니다.
- 체인을 따라 올라가며 검사합니다.
- 일치하면 true, Object.prototype까지 가도 없으면 false를 반환합니다.

**상속과의 관계:**
- 부모 클래스에 대해서도 true를 반환합니다.
- 프로토타입 체인의 어디든 있으면 true입니다.
- 직접적인 인스턴스뿐 아니라 자손도 포함합니다.

**원시 타입의 제한:**
- 원시 타입은 객체가 아니므로 instanceof를 사용할 수 없습니다.
- 문자열, 숫자, 불리언 리터럴은 false를 반환합니다.
- 래퍼 객체로 생성된 경우에만 true입니다.
- new String, new Number 등으로 만든 객체만 해당됩니다.

**프로토타입 변경의 문제:**
- 생성자의 prototype을 변경하면 결과가 달라질 수 있습니다.
- 이미 생성된 인스턴스도 영향을 받습니다.
- 동적으로 프로토타입을 조작하면 신뢰할 수 없습니다.

**다른 컨텍스트의 문제:**
- iframe이나 여러 window 객체가 있을 때 문제가 됩니다.
- 각 컨텍스트마다 별도의 Array, Object 생성자를 가집니다.
- 다른 컨텍스트의 배열은 instanceof Array가 false일 수 있습니다.
- Array.isArray는 이 문제를 해결합니다.

**Symbol.hasInstance:**
- instanceof의 동작을 커스터마이징할 수 있습니다.
- 클래스에 정적 메서드로 정의합니다.
- 커스텀 타입 체크 로직을 구현할 수 있습니다.

**대안적인 타입 체크:**
- Array.isArray로 배열을 체크합니다. 더 안전합니다.
- Object.prototype.toString.call로 정확한 타입을 얻습니다.
- constructor 프로퍼티를 확인할 수 있습니다. 하지만 변경될 수 있어 주의가 필요합니다.
- duck typing으로 필요한 속성이나 메서드의 존재를 확인합니다.

**실무 활용:**
- 클래스 인스턴스 확인에 사용합니다.
- 에러 처리에서 에러 타입을 구분합니다.
- 타입 가드 함수를 만들 때 활용합니다.
- 다형성을 구현할 때 타입 확인에 사용합니다.
- TypeScript에서는 타입 가드와 함께 사용하여 타입을 좁힙니다.

---

## 질문 52: 이벤트 버블링(Event Bubbling)과 이벤트 캡처링(Event Capturing)의 차이점은 무엇인가요?

**정의:**
이벤트 버블링은 이벤트가 발생한 요소에서 상위 요소로 전파되는 현상입니다. 이벤트 캡처링은 반대로 최상위 요소에서 이벤트 타겟으로 전파됩니다.

**이벤트 전파의 3단계:**
- 캡처링 단계: 최상위에서 타겟으로 내려갑니다. window에서 시작해 이벤트 타겟까지 진행합니다.
- 타겟 단계: 실제 이벤트가 발생한 요소에 도달합니다.
- 버블링 단계: 타겟에서 최상위로 올라갑니다. 부모 요소들에게 차례로 전파됩니다.

**버블링의 특징:**
- 기본 동작입니다. addEventListener의 기본값입니다.
- 자식에서 부모로 전파됩니다.
- 대부분의 이벤트가 버블링됩니다.
- focus, blur, load 등 일부 이벤트는 버블링되지 않습니다.

**캡처링의 특징:**
- 명시적으로 활성화해야 합니다. addEventListener의 세 번째 인수를 true로 설정합니다.
- 부모에서 자식으로 전파됩니다.
- 버블링보다 먼저 발생합니다.
- 특수한 경우에만 사용됩니다.

**이벤트 객체 속성:**
- target: 실제 이벤트가 발생한 요소입니다. 변하지 않습니다.
- currentTarget: 현재 이벤트 핸들러가 등록된 요소입니다. 전파되면서 변경됩니다.
- eventPhase: 현재 전파 단계를 나타냅니다. 1은 캡처링, 2는 타겟, 3은 버블링입니다.

**전파 제어:**
- stopPropagation: 이벤트 전파를 중단합니다. 상위나 하위 요소로 전파되지 않습니다.
- stopImmediatePropagation: 같은 요소의 다른 핸들러도 실행하지 않습니다.
- 기본 동작과는 무관합니다. 전파만 제어합니다.

**기본 동작 제어:**
- preventDefault: 브라우저의 기본 동작을 취소합니다.
- 링크 클릭, 폼 제출 등을 막습니다.
- 이벤트 전파와는 독립적입니다.
- return false는 jQuery에서 두 가지를 모두 수행합니다.

**이벤트 위임과의 관계:**
- 버블링을 활용하여 이벤트 위임을 구현합니다.
- 부모 요소에 핸들러를 등록하여 자식 이벤트를 처리합니다.
- target으로 실제 클릭된 요소를 확인합니다.
- 동적으로 추가되는 요소도 처리할 수 있습니다.

**실무 활용:**
- 대부분 버블링 단계에서 이벤트를 처리합니다.
- 이벤트 위임으로 많은 요소의 이벤트를 효율적으로 관리합니다.
- 모달이나 드롭다운 닫기에 활용합니다. 외부 클릭을 감지합니다.
- 캡처링은 이벤트를 가로채야 할 때 사용합니다. 버블링 전에 처리합니다.
- React의 합성 이벤트는 버블링을 사용하지만 내부적으로 다르게 구현됩니다.

---
