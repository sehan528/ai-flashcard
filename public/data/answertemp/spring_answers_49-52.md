# Spring 답변 49-52

## 질문 49: N + 1 문제에 대해 설명해 주세요.

N+1 문제는 ORM에서 발생하는 대표적인 성능 문제로, 연관된 엔티티를 조회할 때 예상보다 많은 쿼리가 실행되는 현상입니다.

**문제 발생 메커니즘:**

부모 엔티티 N개를 조회하는 쿼리가 1번 실행됩니다. 각 부모 엔티티마다 연관된 자식 엔티티를 조회하는 쿼리가 N번 추가로 실행됩니다. 결과적으로 총 N+1번의 쿼리가 발생합니다.

예를 들어 Team 100개를 조회하고 각 Team의 Member를 접근하면, Team 조회 쿼리 1번과 Member 조회 쿼리 100번이 실행되어 총 101번의 쿼리가 발생합니다.

**발생 원인:**

지연 로딩(Lazy Loading)이 주요 원인입니다. 연관 엔티티가 지연 로딩으로 설정되면 프록시 객체가 반환됩니다. 실제로 연관 엔티티에 접근할 때 각각 별도의 쿼리가 실행됩니다.

즉시 로딩(Eager Loading)에서도 발생할 수 있습니다. 일대다 관계에서 즉시 로딩은 카테시안 곱을 만들거나 여러 쿼리를 실행할 수 있습니다.

**성능 영향:**

데이터베이스 왕복 횟수가 급증합니다. 네트워크 레이턴시가 누적되어 전체 응답 시간이 크게 증가합니다. 데이터베이스 부하가 증가하여 다른 작업에도 영향을 줍니다.

특히 루프 안에서 연관 엔티티에 접근하면 심각한 성능 저하가 발생합니다.

**해결 방법 1: Fetch Join:**

JPQL에서 join fetch를 사용합니다. 한 번의 쿼리로 연관 엔티티를 함께 조회합니다. INNER JOIN이나 LEFT JOIN으로 데이터를 가져옵니다.

장점은 쿼리 한 번으로 모든 데이터를 가져옵니다. 즉시 로딩으로 동작하여 추가 쿼리가 없습니다.

단점은 페이징 처리가 어렵습니다. 일대다 Fetch Join에서 페이징을 하면 메모리에서 처리되어 위험합니다. 여러 컬렉션을 Fetch Join 할 수 없습니다. MultipleBagFetchException이 발생할 수 있습니다.

**해결 방법 2: @EntityGraph:**

Spring Data JPA에서 @EntityGraph를 사용합니다. 특정 쿼리에만 Fetch Join을 적용할 수 있습니다. attributePaths로 가져올 연관 엔티티를 지정합니다.

type을 FETCH로 설정하면 지정된 속성은 즉시 로딩, 나머지는 지연 로딩됩니다. type을 LOAD로 설정하면 기본 Fetch 전략을 따르면서 지정된 속성만 즉시 로딩합니다.

**해결 방법 3: Batch Size:**

@BatchSize 어노테이션이나 hibernate.default_batch_fetch_size 설정을 사용합니다. 지연 로딩 시 한 번에 여러 엔티티를 IN 절로 조회합니다.

N+1이 아닌 N/M + 1로 줄어듭니다. 예를 들어 batch size가 10이면 100개의 엔티티를 10번의 쿼리로 조회합니다.

완전히 해결하지는 못하지만 큰 개선 효과가 있습니다. 설정이 간단하고 기존 코드 변경이 적습니다.

**해결 방법 4: Projection과 DTO:**

필요한 데이터만 선택하여 DTO로 조회합니다. JPQL의 new 연산자나 QueryDSL의 Projections를 사용합니다. 연관 관계를 끊고 필요한 컬럼만 조인하여 가져옵니다.

엔티티가 아니므로 영속성 컨텍스트 관리가 없습니다. 쿼리가 명확하고 최적화하기 쉽습니다.

**해결 방법 5: 즉시 로딩으로 변경:**

연관 엔티티를 EAGER로 설정합니다. 항상 함께 조회되어야 하는 경우에만 사용합니다.

하지만 즉시 로딩은 예측 불가능한 쿼리를 발생시킬 수 있습니다. 사용하지 않는 경우에도 항상 조회되어 낭비가 발생합니다. 일반적으로 권장되지 않습니다.

**해결 방법 6: 서브쿼리나 EXISTS:**

exists 절이나 서브쿼리로 연관 데이터를 확인합니다. 실제 데이터를 가져오지 않고 존재 여부만 확인할 때 유용합니다.

**모니터링과 감지:**

hibernate.show_sql이나 p6spy로 실제 실행되는 쿼리를 확인합니다. 쿼리 수가 비정상적으로 많으면 N+1을 의심합니다.

Spring Boot Actuator나 APM 도구로 성능 병목을 찾습니다.

**예방책:**

기본적으로 모든 연관 관계를 지연 로딩으로 설정합니다. 필요한 경우에만 Fetch Join이나 Entity Graph로 즉시 로딩합니다. 쿼리를 설계할 때 연관 데이터 접근 패턴을 미리 고려합니다.

개발 단계에서 쿼리 로그를 항상 확인하는 습관을 들입니다.

**트레이드오프:**

Fetch Join은 쿼리 수를 줄이지만 데이터 중복을 가져올 수 있습니다. 일대다 조인은 데이터 row가 증가합니다. Batch Size는 완벽하지 않지만 설정이 간단합니다.

상황에 따라 적절한 방법을 선택해야 합니다.

N+1 문제는 ORM 사용 시 반드시 주의해야 하는 성능 이슈이며, 여러 해결 방법을 조합하여 최적화할 수 있습니다.

## 질문 50: @Transactional은 어떤 기능을 하나요?

@Transactional은 Spring에서 선언적 트랜잭션 관리를 제공하는 어노테이션으로, 메서드나 클래스에 트랜잭션 경계를 설정합니다.

**기본 기능:**

메서드 실행 전에 트랜잭션을 시작합니다. 메서드가 정상적으로 완료되면 트랜잭션을 커밋합니다. 예외가 발생하면 트랜잭션을 롤백합니다. 모든 데이터베이스 작업을 하나의 원자적 단위로 묶습니다.

**동작 원리:**

Spring AOP를 기반으로 동작합니다. @Transactional이 붙은 Bean은 프록시로 감싸집니다. 프록시가 실제 메서드 호출 전후에 트랜잭션 처리를 수행합니다.

PlatformTransactionManager를 사용하여 트랜잭션을 관리합니다. DataSourceTransactionManager, JpaTransactionManager 등 다양한 구현체가 있습니다.

**트랜잭션 전파(Propagation):**

REQUIRED가 기본값입니다. 기존 트랜잭션이 있으면 참여하고, 없으면 새로 생성합니다. 가장 일반적으로 사용됩니다.

REQUIRES_NEW는 항상 새로운 트랜잭션을 생성합니다. 기존 트랜잭션은 일시 중단됩니다. 독립적인 트랜잭션이 필요할 때 사용합니다.

NESTED는 중첩 트랜잭션을 생성합니다. 부모 트랜잭션에 영향을 받지만 독립적으로 롤백할 수 있습니다.

SUPPORTS는 트랜잭션이 있으면 참여하고 없으면 없이 실행합니다. MANDATORY는 반드시 기존 트랜잭션이 있어야 합니다. NOT_SUPPORTED는 트랜잭션 없이 실행하며 기존 트랜잭션을 일시 중단합니다. NEVER는 트랜잭션이 있으면 예외를 발생시킵니다.

**격리 수준(Isolation):**

DEFAULT는 데이터베이스의 기본 격리 수준을 사용합니다. READ_UNCOMMITTED는 커밋되지 않은 데이터를 읽을 수 있습니다. Dirty Read가 발생할 수 있습니다.

READ_COMMITTED는 커밋된 데이터만 읽습니다. 대부분의 DB 기본값입니다. Non-Repeatable Read가 발생할 수 있습니다.

REPEATABLE_READ는 같은 데이터를 반복 읽어도 같은 값을 보장합니다. Phantom Read가 발생할 수 있습니다.

SERIALIZABLE은 가장 높은 격리 수준입니다. 완전히 격리되지만 성능이 가장 낮습니다.

**롤백 규칙:**

기본적으로 RuntimeException과 Error에 대해 롤백합니다. Checked Exception은 롤백하지 않습니다.

rollbackFor 속성으로 롤백할 예외를 지정할 수 있습니다. noRollbackFor로 롤백하지 않을 예외를 지정할 수 있습니다.

예외를 catch하여 처리하면 롤백이 발생하지 않을 수 있으므로 주의가 필요합니다.

**타임아웃:**

timeout 속성으로 트랜잭션 제한 시간을 설정합니다. 초 단위로 지정하며 기본값은 -1(무제한)입니다. 시간 초과 시 TransactionTimedOutException이 발생하고 롤백됩니다.

긴 트랜잭션을 방지하여 리소스를 보호합니다.

**읽기 전용:**

readOnly 속성을 true로 설정하면 읽기 전용 트랜잭션이 됩니다. 데이터 변경이 없음을 명시하여 최적화가 가능합니다. JPA는 변경 감지를 하지 않아 성능이 향상됩니다. 일부 데이터베이스는 읽기 전용 모드로 최적화합니다.

**적용 위치:**

클래스 레벨에 붙이면 모든 public 메서드에 적용됩니다. 메서드 레벨에 붙이면 해당 메서드만 적용됩니다. 메서드 레벨이 클래스 레벨보다 우선합니다.

인터페이스나 구현 클래스에 붙일 수 있지만, 구현 클래스에 붙이는 것이 권장됩니다.

**주의사항:**

프록시 기반이므로 내부 메서드 호출에는 적용되지 않습니다. 같은 클래스 내에서 this로 호출하면 트랜잭션이 동작하지 않습니다.

public 메서드에만 적용됩니다. private이나 protected 메서드는 트랜잭션이 적용되지 않습니다.

Spring Bean으로 관리되어야 합니다. new로 직접 생성한 객체는 트랜잭션이 적용되지 않습니다.

**영속성 컨텍스트와의 관계:**

JPA에서는 트랜잭션과 영속성 컨텍스트의 생명주기가 같습니다. @Transactional이 시작되면 영속성 컨텍스트도 생성됩니다. 트랜잭션이 끝나면 영속성 컨텍스트도 종료되고 변경사항이 DB에 반영됩니다.

**테스트에서의 사용:**

@Transactional을 테스트 메서드에 붙이면 자동으로 롤백됩니다. 테스트 데이터가 DB에 남지 않아 테스트 격리가 보장됩니다. @Commit이나 @Rollback(false)로 커밋할 수도 있습니다.

@Transactional은 복잡한 트랜잭션 관리를 선언적으로 간단하게 처리할 수 있게 하여, 데이터 일관성을 보장하고 코드를 깔끔하게 유지할 수 있게 합니다.

## 질문 51: @Transactional(readonly=true)는 어떤 기능인가요? 이게 도움이 되나요?

@Transactional(readOnly=true)는 읽기 전용 트랜잭션을 명시하는 설정으로, 데이터 변경이 없음을 선언하여 다양한 최적화를 가능하게 합니다.

**주요 기능:**

첫째, JPA 최적화입니다. 영속성 컨텍스트가 변경 감지(Dirty Checking)를 수행하지 않습니다. 스냅샷을 저장하지 않아 메모리 사용량이 줄어듭니다. flush를 호출해도 실제로 flush가 발생하지 않습니다.

둘째, 데이터베이스 최적화입니다. 일부 데이터베이스는 읽기 전용 트랜잭션을 인식하여 최적화합니다. MySQL InnoDB는 트랜잭션 ID를 할당하지 않을 수 있습니다. PostgreSQL은 읽기 전용 트랜잭션에 대해 특별한 처리를 합니다.

셋째, JDBC 드라이버 최적화입니다. Connection.setReadOnly(true)가 호출됩니다. 드라이버가 읽기 전용 모드로 동작하여 락을 최소화할 수 있습니다.

**성능 향상 효과:**

Hibernate에서 가장 큰 효과를 봅니다. 조회한 엔티티에 대해 스냅샷을 생성하지 않습니다. flush 시 변경 감지를 하지 않아 CPU와 메모리를 절약합니다.

대량의 엔티티를 조회하는 경우 메모리 사용량이 절반으로 줄어들 수 있습니다. flush 비용이 없어 트랜잭션 커밋이 빠릅니다.

**실제 도움이 되는가:**

조회 작업이 많은 서비스 레이어에서 효과적입니다. 읽기 전용 API나 조회 쿼리에 적극 사용하면 좋습니다.

성능 향상 정도는 상황에 따라 다릅니다. 소수의 엔티티 조회에서는 차이가 미미합니다. 수백, 수천 개의 엔티티를 조회하면 눈에 띄는 개선이 있습니다.

데이터베이스와 JDBC 드라이버의 지원 여부에 따라 효과가 다릅니다. 모든 DB가 읽기 전용 최적화를 제공하는 것은 아닙니다.

**명시적 의도 표현:**

성능 외에도 코드의 의도를 명확히 합니다. 이 메서드는 데이터를 변경하지 않는다는 것을 선언합니다. 실수로 데이터를 변경하는 것을 방지합니다. 코드 리뷰와 유지보수에 도움이 됩니다.

**레플리케이션 환경:**

Master-Slave 구조에서 읽기 전용 트랜잭션을 Slave로 라우팅할 수 있습니다. 읽기 부하를 분산하여 Master의 부담을 줄입니다. Spring의 AbstractRoutingDataSource나 커스텀 라우팅 로직으로 구현합니다.

**주의사항:**

readOnly=true여도 데이터를 변경하는 것이 완전히 차단되지는 않습니다. JPA에서는 flush가 발생하지 않아 변경이 DB에 반영되지 않습니다. 하지만 Native Query나 JDBC로 직접 변경하면 실행됩니다.

일부 데이터베이스는 읽기 전용 트랜잭션에서 쓰기를 시도하면 예외를 발생시킵니다.

**조합 사용:**

클래스 레벨에 @Transactional(readOnly=true)를 붙입니다. 데이터를 변경하는 메서드에만 @Transactional(readOnly=false)를 재선언합니다. 대부분 조회인 서비스 클래스에 유용한 패턴입니다.

**트랜잭션 전파와의 관계:**

readOnly 트랜잭션에서 readOnly가 아닌 트랜잭션을 호출하면 어떻게 될까요? 기본 REQUIRED 전파에서는 readOnly 속성이 무시될 수 있습니다. REQUIRES_NEW로 새 트랜잭션을 시작하면 독립적으로 처리됩니다.

**대안:**

Native Query에 @Modifying(clearAutomatically = false, flushAutomatically = false)를 사용할 수도 있습니다. 하지만 readOnly가 더 표준적이고 권장됩니다.

**측정과 검증:**

실제 효과는 프로파일링으로 확인해야 합니다. 메모리 사용량과 실행 시간을 측정합니다. 쿼리 수와 락 대기 시간을 모니터링합니다.

**결론:**

readOnly=true는 설정하기 쉽고 부작용이 거의 없습니다. 조회 전용 메서드에는 기본적으로 사용하는 것이 좋습니다. 성능 향상이 크지 않더라도 의도를 명확히 하는 장점이 있습니다. 특히 대용량 조회나 복잡한 쿼리에서 효과적입니다.

## 질문 52: 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?

읽기 작업에도 트랜잭션이 필요한 이유가 여러 가지 있습니다.

**데이터 일관성 보장:**

트랜잭션 없이 여러 쿼리를 실행하면 각 쿼리가 다른 시점의 데이터를 볼 수 있습니다. 첫 번째 쿼리와 두 번째 쿼리 사이에 다른 트랜잭션이 데이터를 변경하면 일관되지 않은 데이터를 읽게 됩니다.

트랜잭션으로 묶으면 격리 수준에 따라 일관된 스냅샷을 보장합니다. Repeatable Read나 Serializable 격리 수준에서는 트랜잭션 시작 시점의 일관된 뷰를 제공합니다.

**JPA 영속성 컨텍스트:**

JPA에서 영속성 컨텍스트는 기본적으로 트랜잭션 범위와 같습니다. @Transactional이 없으면 영속성 컨텍스트가 각 쿼리마다 생성되고 소멸됩니다.

엔티티를 조회한 후 연관 엔티티에 접근하면 LazyInitializationException이 발생할 수 있습니다. 트랜잭션이 없어서 영속성 컨텍스트가 이미 닫혔기 때문입니다.

@Transactional(readOnly=true)를 붙이면 메서드 전체에서 영속성 컨텍스트가 유지됩니다. 지연 로딩이 정상적으로 동작합니다. 1차 캐시의 혜택을 받을 수 있습니다.

**복잡한 조회 로직:**

여러 테이블을 조회하여 데이터를 조합하는 경우 트랜잭션이 필요합니다. 중간에 데이터가 변경되면 일관성이 깨질 수 있습니다.

예를 들어 주문 정보와 결제 정보를 각각 조회하는 경우, 트랜잭션 없이는 조회 사이에 결제 상태가 변경될 수 있습니다.

**격리 수준 제어:**

트랜잭션 없이는 격리 수준을 제어할 수 없습니다. 각 쿼리가 독립적으로 autocommit 모드로 실행됩니다.

@Transactional로 격리 수준을 지정하여 Dirty Read, Non-Repeatable Read, Phantom Read를 제어할 수 있습니다.

**성능 최적화:**

@Transactional(readOnly=true)는 앞서 설명한 대로 최적화를 제공합니다. 변경 감지를 하지 않아 메모리와 CPU를 절약합니다.

여러 쿼리를 하나의 트랜잭션으로 묶으면 커넥션을 재사용할 수 있습니다. 매번 커넥션을 얻고 반환하는 오버헤드를 줄입니다.

**OSIV 패턴:**

Open Session In View 패턴을 사용하는 경우 필수입니다. View 레이어에서 지연 로딩이 동작하려면 트랜잭션이 유지되어야 합니다.

하지만 OSIV는 커넥션을 오래 유지하여 단점도 있으므로 신중히 사용해야 합니다.

**트랜잭션 전파:**

다른 트랜잭션 메서드에서 호출될 수 있습니다. @Transactional이 없으면 트랜잭션 전파가 일어나지 않아 독립적으로 실행됩니다.

읽기 메서드도 트랜잭션을 가지면 상위 트랜잭션에 참여하여 일관성을 유지합니다.

**예외 처리:**

트랜잭션 내에서 예외가 발생하면 일관되게 처리할 수 있습니다. 트랜잭션 없이는 부분적으로 실행된 상태로 남을 수 있습니다.

**@Transactional 없이 읽기를 하면:**

매 쿼리마다 autocommit됩니다. JPA 영속성 컨텍스트가 쿼리마다 생성되고 소멸됩니다. 지연 로딩이 제대로 동작하지 않을 수 있습니다. 일관된 스냅샷을 보장받지 못합니다.

단순히 하나의 쿼리로 끝나는 경우에는 문제없을 수 있습니다. 하지만 대부분의 비즈니스 로직은 여러 쿼리와 연관 엔티티 접근을 포함합니다.

**권장 사항:**

조회 전용 메서드에는 @Transactional(readOnly=true)를 붙입니다. 단순한 쿼리 하나만 실행하고 끝나는 경우에도 일관성을 위해 붙이는 것이 좋습니다. 특히 JPA를 사용하면 거의 필수입니다.

트랜잭션 없이 읽기를 하는 것은 특수한 경우에만 고려합니다. Native JDBC를 직접 사용하거나, 단순 집계 쿼리, 배치 작업 등에 해당합니다.

**결론:**

읽기에도 트랜잭션이 필요합니다. 데이터 일관성, JPA 영속성 컨텍스트, 성능 최적화 등의 이유로 @Transactional(readOnly=true)를 사용하는 것이 권장됩니다. 설정하기 쉽고 장점이 많으므로 기본적으로 적용하는 것이 좋은 습관입니다.
