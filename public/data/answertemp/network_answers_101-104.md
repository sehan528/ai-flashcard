# Network 답변 모음 (101-104)

## 101. 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?

**결론**
255.0.255.0과 같은 불연속적인 서브넷 마스크는 이론적으로는 가능하지만, 실무에서는 사용하지 않으며 대부분의 네트워크 장비에서 지원하지 않습니다.

**연속된 1의 비트 원칙**
- 서브넷 마스크는 왼쪽부터 연속된 1의 비트로 구성되어야 합니다
- 1의 비트가 끝나면 나머지는 모두 0이어야 합니다
- 255.255.255.0 (11111111.11111111.11111111.00000000)은 올바른 형태
- 255.0.255.0 (11111111.00000000.11111111.00000000)은 불연속적인 형태

**불연속 서브넷 마스크의 문제점**
- 네트워크 주소와 호스트 주소의 구분이 모호해집니다
- 라우팅 테이블 계산이 복잡하고 비효율적입니다
- CIDR 표기법으로 표현할 수 없습니다
- 네트워크 장비의 라우팅 알고리즘과 호환되지 않습니다
- 서브넷 계산 및 관리가 매우 어려워집니다

**RFC 표준과 실무**
- RFC 950과 RFC 1812에서 연속된 비트 패턴을 권장합니다
- 대부분의 라우터와 네트워크 장비는 불연속 마스크를 거부합니다
- 일부 장비는 설정은 허용하지만 예상치 못한 동작을 할 수 있습니다
- 표준 네트워크 관리 도구들이 지원하지 않습니다

**올바른 서브넷 마스크 예시**
- 255.0.0.0 (/8) - 연속된 8비트
- 255.255.0.0 (/16) - 연속된 16비트
- 255.255.255.0 (/24) - 연속된 24비트
- 255.255.255.128 (/25) - 연속된 25비트
- 255.255.255.252 (/30) - 연속된 30비트

**실무 권장사항**
- 항상 연속된 1의 비트로 구성된 표준 서브넷 마스크를 사용해야 합니다
- CIDR 표기법을 사용하여 명확하게 표현합니다
- 네트워크 설계 시 RFC 표준을 준수합니다
- 특수한 목적이 있더라도 비표준 마스크 사용을 피해야 합니다

---

## 102. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.

**멀티플렉싱 (Multiplexing) 정의**
멀티플렉싱은 전송 계층에서 여러 응용 프로세스의 데이터를 하나의 전송 채널로 합쳐서 전송하는 기술입니다. 송신 측에서 여러 소켓으로부터 데이터를 수집하여 세그먼트를 생성하고 네트워크 계층으로 전달하는 과정입니다.

**디멀티플렉싱 (Demultiplexing) 정의**
디멀티플렉싱은 수신 측에서 하나의 전송 채널로 들어온 데이터를 올바른 응용 프로세스의 소켓으로 분배하는 기술입니다. 전송 계층에서 세그먼트를 받아 헤더 정보를 기반으로 적절한 소켓으로 전달하는 과정입니다.

**멀티플렉싱의 필요성**
- 하나의 네트워크 인터페이스로 여러 애플리케이션이 동시에 통신할 수 있습니다
- 시스템 자원을 효율적으로 활용할 수 있습니다
- 다중 프로세스 환경에서 각 프로세스가 독립적으로 네트워크 통신이 가능합니다
- 포트 번호를 통해 프로세스를 식별하고 구분합니다

**동작 메커니즘**
- 송신 측: 소켓 → 전송 계층 헤더 추가 (포트 번호 포함) → 세그먼트 생성 → 네트워크 계층으로 전달
- 수신 측: 네트워크 계층 → 전송 계층 → 헤더 정보 확인 → 목적지 포트로 데이터 전달 → 해당 소켓
- 포트 번호가 핵심 식별자 역할을 수행합니다

**UDP의 멀티플렉싱/디멀티플렉싱**
- 목적지 IP 주소와 목적지 포트 번호만으로 소켓을 식별합니다
- 출발지 정보는 소켓 식별에 사용되지 않습니다
- 같은 목적지 포트로 오는 모든 데이터는 같은 소켓으로 전달됩니다
- 단순하고 빠른 처리가 가능합니다

**TCP의 멀티플렉싱/디멀티플렉싱**
- 4개의 정보로 소켓을 식별합니다: 출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트
- 각 연결마다 고유한 소켓이 생성됩니다
- 같은 서버 포트로 여러 클라이언트가 동시에 연결 가능합니다
- 연결 지향적이고 정확한 데이터 전달이 보장됩니다

**실무 활용**
- 웹 서버가 80번 포트로 여러 클라이언트의 HTTP 요청을 동시에 처리합니다
- 하나의 컴퓨터에서 브라우저, 메일 클라이언트, 파일 전송 등 여러 네트워크 애플리케이션이 동시에 작동합니다
- 서버는 수천 개의 클라이언트 연결을 하나의 포트로 관리합니다
- 포트 번호를 통해 각 애플리케이션을 독립적으로 관리할 수 있습니다

---

## 103. 디멀티플렉싱의 과정에 대해 설명해 주세요.

**디멀티플렉싱 개요**
디멀티플렉싱은 네트워크 계층으로부터 받은 세그먼트를 헤더 정보를 분석하여 올바른 애플리케이션의 소켓으로 전달하는 과정입니다.

**1단계: 세그먼트 수신**
- 네트워크 계층(IP 계층)에서 데이터그램을 전송 계층으로 전달합니다
- 데이터그램에는 IP 헤더와 전송 계층 세그먼트가 포함되어 있습니다
- IP 계층은 IP 헤더를 제거하고 세그먼트를 전송 계층으로 전달합니다

**2단계: 헤더 정보 추출**
- 전송 계층에서 세그먼트의 헤더를 읽습니다
- TCP 또는 UDP 헤더에서 필요한 정보를 추출합니다
- 목적지 포트 번호를 확인합니다
- 출발지 IP 주소와 포트 번호도 함께 확인합니다 (TCP의 경우)

**3단계: UDP 디멀티플렉싱**
- UDP는 2-tuple 방식을 사용합니다
- 목적지 IP 주소와 목적지 포트 번호만으로 소켓을 식별합니다
- 해당 포트 번호로 바인딩된 소켓을 찾습니다
- 출발지 정보와 관계없이 같은 목적지 포트로 오는 모든 데이터는 동일한 소켓으로 전달됩니다

**4단계: TCP 디멀티플렉싱**
- TCP는 4-tuple 방식을 사용합니다
- 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호를 모두 확인합니다
- 이 4개 정보의 조합으로 고유한 소켓을 식별합니다
- 같은 서버 포트라도 클라이언트가 다르면 다른 소켓으로 전달됩니다

**5단계: 소켓 테이블 조회**
- 운영체제는 소켓 테이블을 유지합니다
- 포트 번호와 연결 정보를 기반으로 소켓 테이블을 검색합니다
- 매칭되는 소켓 디스크립터를 찾습니다
- 해당 소켓과 연결된 프로세스를 식별합니다

**6단계: 데이터 전달**
- 찾아진 소켓의 수신 버퍼에 데이터를 저장합니다
- 애플리케이션이 read/recv 시스템 콜을 호출하면 버퍼의 데이터를 전달합니다
- 프로세스는 자신의 소켓으로 온 데이터만 받게 됩니다

**7단계: 오류 처리**
- 매칭되는 소켓이 없는 경우 처리합니다
- UDP는 ICMP Port Unreachable 메시지를 보냅니다
- TCP는 RST 세그먼트를 보내 연결을 거부합니다
- 방화벽 규칙에 따라 패킷을 드롭할 수도 있습니다

**실무 예시**
- 웹 서버 80번 포트로 여러 클라이언트 연결이 들어옵니다
- 각 연결은 (클라이언트IP:클라이언트포트, 서버IP:80) 조합으로 식별됩니다
- 예: (192.168.1.100:52000, 10.0.0.1:80)과 (192.168.1.101:52000, 10.0.0.1:80)은 서로 다른 소켓입니다
- 전송 계층은 이 정보를 기반으로 각 데이터를 올바른 연결의 소켓으로 전달합니다
- 애플리케이션은 각 클라이언트의 요청을 독립적으로 처리할 수 있습니다

**성능 최적화**
- 소켓 테이블은 해시 테이블로 구현되어 빠른 검색이 가능합니다
- 연결이 많을수록 효율적인 자료구조가 중요합니다
- 커널 레벨에서 최적화되어 있어 오버헤드가 최소화됩니다

---

## 104. XSS에 대해서 설명해 주세요.

**XSS (Cross-Site Scripting) 정의**
XSS는 공격자가 웹 애플리케이션에 악의적인 스크립트를 삽입하여 다른 사용자의 브라우저에서 실행되도록 하는 보안 취약점입니다. 사용자 입력을 적절히 검증하거나 이스케이프하지 않을 때 발생합니다.

**XSS의 동작 원리**
- 공격자가 악성 스크립트가 포함된 데이터를 웹 애플리케이션에 입력합니다
- 서버가 이를 검증 없이 저장하거나 반환합니다
- 다른 사용자가 해당 페이지를 방문하면 악성 스크립트가 실행됩니다
- 스크립트는 피해자의 브라우저 권한으로 실행되어 민감한 정보에 접근할 수 있습니다

**Stored XSS (저장형 XSS)**
- 악성 스크립트가 서버의 데이터베이스에 영구적으로 저장됩니다
- 게시판, 댓글, 사용자 프로필 등에 스크립트를 삽입합니다
- 해당 페이지를 방문하는 모든 사용자가 피해를 입습니다
- 가장 위험한 형태의 XSS 공격입니다
- 예: 게시글에 악성 스크립트를 작성하여 저장하면, 이를 읽는 모든 사용자가 공격당합니다

**Reflected XSS (반사형 XSS)**
- 악성 스크립트가 URL 파라미터나 폼 입력을 통해 전달됩니다
- 서버가 입력값을 그대로 응답 페이지에 포함시킵니다
- 공격자가 악의적인 링크를 피해자에게 전송해야 합니다
- 일회성 공격이지만 피싱과 결합하면 위험합니다
- 예: 검색어를 URL에 포함시키는 검색 결과 페이지에서 스크립트를 URL에 포함시켜 전달합니다

**DOM-based XSS (DOM 기반 XSS)**
- 서버가 관여하지 않고 클라이언트 측 JavaScript에서 발생합니다
- 브라우저의 DOM 환경에서 악성 스크립트가 실행됩니다
- JavaScript가 사용자 입력을 안전하게 처리하지 않을 때 발생합니다
- 서버 로그에 남지 않아 탐지가 어렵습니다
- 예: location.hash나 document.URL을 그대로 innerHTML에 삽입하는 경우

**XSS 공격의 피해**
- 세션 쿠키 탈취로 계정 하이재킹이 가능합니다
- 사용자의 개인정보를 공격자 서버로 전송할 수 있습니다
- 피해자 권한으로 악의적인 행동을 수행할 수 있습니다
- 가짜 로그인 폼을 띄워 비밀번호를 탈취할 수 있습니다
- 웹사이트의 내용을 변조하여 피싱 공격을 수행할 수 있습니다
- 악성 코드 다운로드를 유도할 수 있습니다

**XSS 방어 기법**

**입력 검증 및 필터링**
- 모든 사용자 입력을 신뢰하지 않고 검증합니다
- 화이트리스트 방식으로 허용된 문자만 받습니다
- 특수 문자와 스크립트 태그를 필터링합니다

**출력 인코딩 및 이스케이핑**
- HTML 컨텍스트에 출력할 때 특수 문자를 HTML 엔티티로 변환합니다
- JavaScript 컨텍스트에서는 JavaScript 인코딩을 사용합니다
- URL 컨텍스트에서는 URL 인코딩을 적용합니다
- 예: `<`를 `&lt;`로, `>`를 `&gt;`로 변환합니다

**CSP (Content Security Policy)**
- HTTP 헤더로 허용되는 스크립트 소스를 제한합니다
- 인라인 스크립트 실행을 차단할 수 있습니다
- 외부 도메인으로의 데이터 전송을 제한합니다
- eval 같은 위험한 기능을 비활성화합니다

**HttpOnly 쿠키**
- 세션 쿠키에 HttpOnly 플래그를 설정합니다
- JavaScript에서 쿠키에 접근할 수 없게 합니다
- XSS 공격으로 세션 하이재킹을 방지합니다

**보안 라이브러리 사용**
- DOMPurify 같은 검증된 라이브러리를 사용합니다
- React, Vue 같은 프레임워크는 기본적으로 XSS 보호 기능을 제공합니다
- 템플릿 엔진의 자동 이스케이핑 기능을 활용합니다

**실무 권장사항**
- 절대 사용자 입력을 innerHTML, eval, document.write에 직접 사용하지 않습니다
- 프레임워크의 안전한 API를 사용합니다 (React의 JSX, Vue의 템플릿)
- 정기적인 보안 감사와 취약점 스캔을 실시합니다
- 개발자 보안 교육을 통해 XSS 위험성을 인식시킵니다
- 방어를 여러 계층에서 적용합니다 (입력 검증 + 출력 인코딩 + CSP)
