# Network 답변 모음 (69-72)

## 69. 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?

**TIME_WAIT 상태**는 TCP 연결 종료 후 일정 시간(2MSL) 동안 대기하는 것으로, 두 가지 중요한 목적이 있습니다.

**목적 1 - 마지막 ACK의 재전송 대비:**

**문제 상황:**
클라이언트가 서버의 FIN에 대해 마지막 ACK를 보냅니다. 이 ACK가 네트워크에서 손실될 수 있습니다. 서버는 ACK를 받지 못하면 FIN을 재전송합니다. 클라이언트가 이미 CLOSED 상태라면 재전송된 FIN을 처리할 수 없습니다.

**TIME_WAIT의 해결:**
클라이언트가 TIME_WAIT 상태로 연결 정보를 유지합니다. 서버의 FIN 재전송을 받으면 ACK를 다시 보냅니다. 서버가 최종적으로 정상 종료할 수 있도록 보장합니다. 우아한 종료(Graceful Shutdown)를 완성합니다.

**목적 2 - 지연된 패킷으로부터 보호:**

**문제 상황:**
이전 연결의 패킷이 네트워크에서 지연되어 나중에 도착할 수 있습니다. 같은 포트 조합으로 새 연결이 즉시 수립되면 문제가 발생합니다. 지연된 패킷이 새 연결의 데이터로 오인되어 데이터 손상이 일어날 수 있습니다.

**TIME_WAIT의 해결:**
2MSL(Maximum Segment Lifetime의 2배) 동안 대기합니다. MSL은 패킷이 네트워크에 존재할 수 있는 최대 시간입니다. 2MSL이 지나면 이전 연결의 모든 패킷이 소멸됩니다. 이후 같은 포트 조합을 안전하게 재사용할 수 있습니다.

**MSL 시간:**
RFC에서는 2분을 권장하지만 구현에 따라 다릅니다. 리눅스: 일반적으로 60초(2MSL = 120초)입니다. 윈도우: 일반적으로 120초(2MSL = 240초)입니다. 실제 네트워크에서 패킷이 2분 이상 살아있는 경우는 거의 없습니다.

**누가 TIME_WAIT에 들어가나:**
능동 종료(Active Close)를 수행한 쪽이 TIME_WAIT에 들어갑니다. 일반적으로 클라이언트가 먼저 close()를 호출하므로 클라이언트가 TIME_WAIT 상태가 됩니다. 서버는 CLOSED 상태로 즉시 전환되어 새 연결을 받을 수 있습니다.

**서버가 TIME_WAIT에 들어가는 경우:**
서버가 먼저 연결을 끊으면(예: 타임아웃) 서버가 TIME_WAIT 상태가 됩니다. 이 경우 같은 포트를 2MSL 동안 재사용할 수 없어 문제가 될 수 있습니다. 웹 서버, API 서버는 일반적으로 수동 종료하여 이를 피합니다.

**TIME_WAIT 과다 문제:**

**서버 측 문제:**
서버가 많은 연결을 처리하다가 능동 종료하면 대량의 TIME_WAIT이 생성됩니다. 파일 디스크립터와 메모리를 소비합니다. 극단적인 경우 새 연결을 받을 수 없게 됩니다.

**해결 방법:**
서버가 수동 종료하도록 설계합니다(클라이언트가 먼저 FIN 보내도록). SO_REUSEADDR 소켓 옵션을 사용하여 TIME_WAIT 상태의 주소를 재사용합니다. 커널 파라미터 조정: tcp_tw_reuse, tcp_tw_recycle(주의: 일부는 deprecated).

**클라이언트 측:**
클라이언트는 매번 새로운 임시 포트를 사용하므로 TIME_WAIT이 큰 문제가 되지 않습니다. 하지만 고성능 클라이언트(로드 테스트 도구 등)는 포트 고갈 문제가 발생할 수 있습니다.

**SO_REUSEADDR vs SO_REUSEPORT:**

**SO_REUSEADDR:**
TIME_WAIT 상태의 소켓 주소를 bind()할 수 있게 합니다. 서버 재시작 시 즉시 포트를 재사용할 수 있습니다. 일반적으로 서버 소켓에 설정합니다.

**SO_REUSEPORT:**
여러 소켓이 같은 주소를 bind()할 수 있게 합니다. 멀티프로세스 서버에서 로드 밸런싱에 사용됩니다.

**TIME_WAIT Assassination:**
일부 구현은 타임아웃을 조작하여 TIME_WAIT를 강제로 종료합니다. 위험한 방법이며 권장되지 않습니다. 데이터 무결성 문제를 일으킬 수 있습니다.

**HTTP Keep-Alive와의 관계:**
HTTP/1.1의 persistent connection은 연결을 재사용하여 TIME_WAIT을 줄입니다. 여러 요청을 하나의 TCP 연결로 처리하므로 종료 횟수가 감소합니다. 서버가 타임아웃으로 종료하면 서버가 TIME_WAIT에 들어가는 문제가 있습니다.

**모니터링:**
netstat이나 ss 명령으로 TIME_WAIT 상태의 연결 수를 확인합니다. 비정상적으로 많으면 애플리케이션 설계를 검토해야 합니다.

**실무 권장:**
TIME_WAIT은 TCP의 중요한 안전장치입니다. 가능하면 자연스럽게 만료되도록 두는 것이 좋습니다. 성능 문제가 있을 때만 신중하게 조정합니다. 서버는 수동 종료, 클라이언트는 능동 종료 패턴을 따릅니다.

---

## 70. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.

브라우저에 URL을 입력하고 엔터를 치면 매우 복잡하고 다층적인 **네트워크 통신 과정**이 진행됩니다.

**1단계 - URL 파싱:**
브라우저가 입력된 문자열을 분석합니다. 프로토콜(https://), 도메인(www.github.com), 포트(생략 시 443), 경로(/)를 식별합니다. 유효하지 않은 URL이면 검색 엔진으로 리다이렉트합니다.

**2단계 - HSTS 확인:**
브라우저가 HSTS(HTTP Strict Transport Security) 목록을 확인합니다. github.com이 HSTS에 등록되어 있으면 자동으로 HTTPS를 사용합니다. HTTP로 접속 시도를 방지하여 보안을 강화합니다.

**3단계 - DNS 조회:**

**브라우저 캐시 확인:**
브라우저가 자체 DNS 캐시를 먼저 확인합니다. 최근에 방문했다면 캐시된 IP 주소를 사용합니다.

**운영체제 캐시 확인:**
브라우저 캐시에 없으면 OS의 DNS 캐시를 확인합니다. hosts 파일도 확인합니다(/etc/hosts 또는 C:\Windows\System32\drivers\etc\hosts).

**DNS 리졸버에 쿼리:**
캐시에 없으면 설정된 DNS 리졸버(보통 ISP 또는 8.8.8.8)에 쿼리를 보냅니다. UDP 53번 포트로 DNS 쿼리 패킷을 전송합니다.

**재귀적 DNS 조회:**
DNS 리졸버가 루트 DNS 서버에 문의합니다. 루트 서버가 .com TLD 서버 주소를 알려줍니다. TLD 서버가 github.com의 네임서버 주소를 알려줍니다. github.com 네임서버가 www.github.com의 실제 IP 주소를 반환합니다(예: 140.82.121.4).

**응답 캐싱:**
받은 IP 주소를 TTL 동안 캐시합니다. 다음 접속 시 빠르게 사용할 수 있습니다.

**4단계 - TCP 연결 수립(3-Way Handshake):**

**라우팅 결정:**
클라이언트가 목적지 IP(140.82.121.4)가 같은 네트워크인지 확인합니다. 다른 네트워크이므로 기본 게이트웨이(공유기)로 전송합니다.

**ARP 조회:**
게이트웨이의 IP는 알지만 MAC 주소를 모르면 ARP 요청을 브로드캐스트합니다. 게이트웨이가 자신의 MAC 주소를 응답합니다.

**SYN 전송:**
클라이언트가 임시 포트(예: 54321)를 선택하고 SYN 패킷을 보냅니다. 목적지: 140.82.121.4:443, 송신: 클라이언트IP:54321. 패킷이 게이트웨이, ISP, 인터넷 백본을 거쳐 GitHub 서버로 전달됩니다.

**SYN-ACK 수신:**
GitHub 서버가 SYN-ACK를 응답합니다. 클라이언트가 받습니다.

**ACK 전송:**
클라이언트가 ACK를 보내 연결을 완료합니다. TCP 연결이 ESTABLISHED 상태가 됩니다.

**5단계 - TLS/SSL Handshake:**

**ClientHello:**
클라이언트가 지원하는 TLS 버전, 암호화 스위트, 난수를 보냅니다.

**ServerHello:**
서버가 선택한 TLS 버전, 암호화 스위트, 난수, 인증서를 보냅니다. 인증서에는 서버의 공개키와 CA 서명이 포함됩니다.

**인증서 검증:**
브라우저가 인증서 체인을 검증합니다. CA의 공개키(브라우저에 내장)로 서명을 확인합니다. 도메인 이름, 유효 기간, 폐기 여부(OCSP)를 확인합니다.

**키 교환:**
클라이언트가 Pre-Master Secret을 서버 공개키로 암호화하여 전송합니다. 양쪽이 이를 기반으로 세션 키를 생성합니다.

**Finished 메시지:**
암호화된 연결이 수립되었음을 확인합니다. 이제 모든 데이터가 암호화됩니다.

**6단계 - HTTP 요청:**

**HTTP/2 협상:**
ALPN(Application-Layer Protocol Negotiation)으로 HTTP/2 사용을 협상합니다.

**GET 요청 전송:**
클라이언트가 암호화된 HTTP GET 요청을 보냅니다. 헤더: Host, User-Agent, Accept, Cookie 등.

**7단계 - 서버 처리:**
GitHub 서버(실제로는 로드 밸런서)가 요청을 받습니다. 적절한 백엔드 서버로 라우팅합니다. 애플리케이션이 요청을 처리하고 HTML을 생성합니다.

**8단계 - HTTP 응답:**
서버가 HTTP 응답을 보냅니다. 상태 코드 200, 헤더(Content-Type, Content-Length, Set-Cookie 등), HTML 본문. 암호화되어 전송됩니다.

**9단계 - 추가 리소스 요청:**

**HTML 파싱:**
브라우저가 HTML을 파싱하며 추가 리소스를 발견합니다(CSS, JavaScript, 이미지 등).

**병렬 요청:**
HTTP/2의 멀티플렉싱으로 여러 리소스를 동시에 요청합니다. 같은 TCP 연결을 재사용합니다.

**10단계 - 렌더링:**
브라우저가 DOM 트리와 CSSOM 트리를 구축합니다. 렌더 트리를 생성하고 레이아웃을 계산합니다. 화면에 픽셀을 그립니다(Painting). JavaScript를 실행하여 동적 콘텐츠를 처리합니다.

**중간 장비들:**

**NAT:**
공유기가 사설 IP를 공인 IP로 변환합니다. 포트 번호로 여러 기기를 구별합니다.

**방화벽:**
패킷을 검사하고 정책에 따라 허용/차단합니다.

**라우터:**
최적 경로를 계산하고 패킷을 다음 홉으로 전달합니다. 수십 개의 라우터를 거칠 수 있습니다.

**로드 밸런서:**
GitHub의 엣지 서버가 요청을 여러 백엔드에 분산합니다.

**CDN:**
정적 리소스는 CDN에서 제공될 수 있습니다. 지리적으로 가까운 서버에서 받아 속도를 향상시킵니다.

**소요 시간:**
전체 과정은 일반적으로 수백 ms에서 1-2초 정도 걸립니다. DNS: 20-120ms, TCP+TLS: 100-300ms, HTTP: 50-500ms, 렌더링: 100-1000ms.

**실제로는 더 복잡:**
HTTP/3 사용 시 QUIC 프로토콜이 추가됩니다. 서비스 워커, 캐시, 프리페칭 등이 개입할 수 있습니다. 광고, 분석 스크립트 등 서드파티 리소스도 로드됩니다.

---

## 71. DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?

DNS 쿼리로 얻은 IP 주소는 일반적으로 **실제 웹 서버가 아닌 여러 중간 인프라**를 가리킵니다.

**소규모 웹사이트:**
개인 블로그나 작은 서비스는 실제 웹 서버의 IP를 직접 가리킬 수 있습니다. 단일 서버에서 웹 서버 소프트웨어(Apache, Nginx)가 직접 동작합니다. 이 경우 DNS IP = 실제 서버 IP입니다.

**대규모 서비스(GitHub, Google 등):**

**로드 밸런서:**
DNS가 반환하는 IP는 일반적으로 로드 밸런서의 IP입니다. 로드 밸런서가 사용자 요청을 받아 여러 백엔드 서버 중 하나로 분배합니다. L4(TCP 레벨) 또는 L7(HTTP 레벨) 로드 밸런서가 사용됩니다. AWS ELB, Google Cloud Load Balancer, Nginx Plus 등이 있습니다.

**리버스 프록시:**
로드 밸런서 뒤에 리버스 프록시(Nginx, HAProxy, Varnish)가 있을 수 있습니다. 캐싱, SSL/TLS 종료, 요청 라우팅 등을 수행합니다. 실제 애플리케이션 서버는 그 뒤에 숨어 있습니다.

**CDN(Content Delivery Network):**
정적 콘텐츠를 제공하는 사이트는 CDN의 엣지 서버 IP를 반환할 수 있습니다. Cloudflare, Akamai, Fastly, AWS CloudFront 등이 있습니다. 사용자와 지리적으로 가까운 엣지 서버의 IP를 받습니다. 실제 원본(Origin) 서버는 CDN 뒤에 숨어 있습니다.

**Anycast IP:**
하나의 IP 주소를 전 세계 여러 위치에서 동시에 사용합니다. 라우팅 프로토콜(BGP)이 가장 가까운 서버로 트래픽을 전달합니다. DNS 서비스(8.8.8.8), CDN, DDoS 방어 서비스에 사용됩니다. 같은 IP라도 접속 위치에 따라 다른 물리 서버로 연결됩니다.

**지리적 DNS(GeoDNS):**
사용자의 위치에 따라 다른 IP를 반환합니다. 서울에서 쿼리하면 한국 데이터센터 IP를, 뉴욕에서 쿼리하면 미국 데이터센터 IP를 받습니다. 지연 시간을 최소화하고 사용자 경험을 향상시킵니다.

**멀티 IP 응답:**
하나의 도메인에 여러 IP 주소를 설정할 수 있습니다. DNS Round Robin으로 간단한 로드 밸런싱을 구현합니다. 브라우저는 여러 IP 중 하나를 선택하거나 순서대로 시도합니다.

**클라우드 환경:**

**AWS:**
ELB의 IP 주소를 받습니다. ELB는 여러 가용 영역(AZ)의 EC2 인스턴스로 분배합니다.

**Google Cloud:**
Cloud Load Balancer의 글로벌 Anycast IP를 받습니다. 가장 가까운 리전의 백엔드로 연결됩니다.

**Azure:**
Traffic Manager 또는 Application Gateway의 IP를 받습니다.

**실제 예시 - github.com:**
DNS 쿼리 시 140.82.121.4 같은 IP를 받습니다. 이는 GitHub의 로드 밸런서 또는 CDN 엣지 서버입니다. 실제 애플리케이션 서버는 내부 네트워크에 있으며 외부에서 직접 접근할 수 없습니다.

**보안 목적:**
실제 서버를 숨김으로써 DDoS 공격으로부터 보호합니다. 로드 밸런서나 CDN이 공격 트래픽을 필터링합니다. 실제 서버의 IP는 비공개로 유지됩니다.

**동적 변경:**
DNS TTL이 짧으면 IP를 자주 변경할 수 있습니다. 트래픽 분산, 장애 대응, 유지보수를 위해 IP를 바꿉니다. 사용자는 이를 인식하지 못합니다.

**CNAME 레코드:**
일부 도메인은 CNAME으로 다른 도메인을 가리킵니다. 예: www.example.com → example.cdn.cloudflare.net → 실제 IP. 여러 단계의 리다이렉션이 있을 수 있습니다.

**확인 방법:**
nslookup, dig, host 명령으로 DNS 조회 결과를 확인합니다. traceroute로 실제 네트워크 경로를 추적합니다. HTTP 응답 헤더(Server, X-Served-By)로 어떤 인프라가 사용되는지 힌트를 얻습니다.

**결론:**
DNS IP는 대부분 프론트엔드 인프라(로드 밸런서, CDN, 프록시)를 가리키며, 실제 애플리케이션 서버는 그 뒤에 보호되어 있습니다.

---

## 72. Web Server와 Web Application Server의 차이에 대해 설명해 주세요.

**웹 서버(Web Server)**와 **웹 애플리케이션 서버(WAS, Web Application Server)**는 서로 다른 역할과 기능을 가진 서버 소프트웨어입니다.

**웹 서버(Web Server):**

**정의:**
HTTP 프로토콜을 사용하여 클라이언트 요청을 처리하고 정적 콘텐츠를 제공하는 서버입니다.

**주요 기능:**
정적 파일(HTML, CSS, JavaScript, 이미지, 비디오) 제공합니다. HTTP 요청/응답 처리를 담당합니다. 리버스 프록시로 요청을 다른 서버로 전달합니다. SSL/TLS 종료, 캐싱, 로드 밸런싱을 수행합니다.

**대표 소프트웨어:**
Apache HTTP Server, Nginx, Microsoft IIS, LiteSpeed.

**처리 방식:**
클라이언트가 /index.html을 요청하면 파일 시스템에서 파일을 읽어 그대로 전송합니다. 동적 처리 없이 저장된 내용을 빠르게 제공합니다.

**웹 애플리케이션 서버(WAS):**

**정의:**
비즈니스 로직을 실행하고 동적 콘텐츠를 생성하는 서버입니다. 일반적으로 웹 서버 기능도 포함합니다.

**주요 기능:**
동적 콘텐츠 생성(DB 조회, 계산, 데이터 처리)을 수행합니다. 비즈니스 로직 실행(결제, 인증, 데이터 검증 등)을 담당합니다. 트랜잭션 관리, 세션 관리를 수행합니다. 데이터베이스 연결 풀 관리를 합니다. 여러 프로토콜 지원(HTTP, RMI, CORBA 등)을 제공합니다.

**대표 소프트웨어:**
Java: Tomcat, JBoss, WebLogic, WebSphere. .NET: IIS + ASP.NET. Python: Gunicorn, uWSGI. Node.js: Express, Koa. PHP: PHP-FPM.

**처리 방식:**
클라이언트가 /users/123을 요청하면 애플리케이션 코드가 실행됩니다. 데이터베이스에서 사용자 정보를 조회합니다. 템플릿을 사용하여 HTML을 동적으로 생성합니다. 생성된 HTML을 응답으로 보냅니다.

**주요 차이점:**

**콘텐츠 타입:**
- **웹 서버**: 정적 콘텐츠 중심
- **WAS**: 동적 콘텐츠 중심

**비즈니스 로직:**
- **웹 서버**: 비즈니스 로직 실행 불가
- **WAS**: 복잡한 비즈니스 로직 실행 가능

**리소스 사용:**
- **웹 서버**: 가볍고 빠름, 메모리/CPU 사용량 적음
- **WAS**: 무겁고 복잡함, 더 많은 리소스 필요

**확장성:**
- **웹 서버**: 수평 확장 용이, 상태 비저장
- **WAS**: 세션 관리 등으로 확장이 더 복잡함

**전형적인 아키텍처:**

**2-Tier 구조:**
클라이언트 → WAS (WAS가 웹 서버 역할 포함). 소규모 애플리케이션에 적합합니다.

**3-Tier 구조:**
클라이언트 → 웹 서버 → WAS → 데이터베이스. 대규모 애플리케이션의 표준 구조입니다.

**역할 분담:**
웹 서버(Nginx)가 정적 파일을 직접 제공합니다. 동적 요청만 WAS(Tomcat)로 프록시합니다. WAS는 비즈니스 로직에만 집중합니다.

**3-Tier의 장점:**

**성능 향상:**
정적 파일은 빠른 웹 서버가 처리하여 WAS 부하를 줄입니다. WAS는 동적 처리에만 리소스를 사용합니다.

**보안 강화:**
웹 서버가 외부에 노출되고 WAS는 내부 네트워크에 위치합니다. 웹 서버에서 기본적인 공격을 필터링합니다.

**확장성:**
웹 서버와 WAS를 독립적으로 스케일링할 수 있습니다. 로드 밸런서로 여러 WAS 인스턴스에 분산합니다.

**유지보수:**
WAS 재시작 시 웹 서버가 정적 콘텐츠를 계속 제공합니다. 무중단 배포가 용이합니다.

**실무 예시:**

**Nginx + Tomcat:**
Nginx가 80/443 포트로 요청을 받습니다. *.jsp, /api/* 요청은 Tomcat(8080)으로 프록시합니다. *.html, *.css, *.js, 이미지는 Nginx가 직접 제공합니다.

**Apache + PHP-FPM:**
Apache가 프론트엔드로 동작합니다. PHP 요청은 FastCGI로 PHP-FPM에 전달합니다.

**최신 트렌드:**

**서버리스:**
AWS Lambda, Google Cloud Functions 등은 WAS를 추상화합니다. 개발자는 비즈니스 로직만 작성합니다.

**컨테이너:**
Docker로 웹 서버와 WAS를 컨테이너화합니다. Kubernetes로 오케스트레이션합니다.

**마이크로서비스:**
모놀리식 WAS 대신 작은 서비스들로 분리합니다. API 게이트웨이가 웹 서버 역할을 합니다.

**선택 기준:**
정적 사이트만 필요하면 웹 서버만 사용합니다. 동적 기능이 필요하면 WAS를 추가합니다. 트래픽이 많으면 웹 서버 + WAS 분리 구조를 사용합니다.
