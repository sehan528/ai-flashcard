## 질문 5: Java의 클래스 로딩 과정을 설명해주세요.

**정의:**
클래스 로딩은 JVM이 .class 파일을 읽어 메모리에 적재하고 사용 가능한 상태로 만드는 과정입니다. 클래스 로더가 이 작업을 수행하며, 필요한 시점에 동적으로 클래스를 로드하는 동적 로딩 방식을 사용합니다.

**특징/원리:**
- 동적 로딩: 런타임에 필요한 시점에 클래스를 로드하여 초기 구동 시간을 단축하고 메모리 효율성 향상
- 계층 구조: Bootstrap, Extension, Application 클래스 로더가 계층 구조를 이루며 상위 로더에서 하위 로더 순서로 위임
- 위임 모델: 클래스 로딩 요청을 받으면 먼저 부모 클래스 로더에게 위임하고, 부모가 로드하지 못할 때만 직접 로드
- 네임스페이스 분리: 각 클래스 로더는 독립된 네임스페이스를 가져 같은 이름의 클래스도 다른 로더에 의해 별도로 로드 가능

**클래스 로딩 단계:**
- Loading: 클래스 파일을 찾아 바이너리 데이터를 읽어 메모리에 적재하고 Class 객체 생성
- Linking: Verification(바이트코드 검증), Preparation(static 변수 메모리 할당 및 기본값 초기화), Resolution(심볼릭 참조를 직접 참조로 변환)의 세 단계로 구성
- Initialization: static 변수를 개발자가 지정한 값으로 초기화하고 static 블록 실행

**실무 활용:**
- 커스텀 클래스 로더를 구현하여 암호화된 클래스 파일을 로드하거나 네트워크에서 클래스를 동적으로 다운로드
- 플러그인 시스템 구현 시 독립적인 클래스 로더를 사용하여 플러그인 간 클래스 충돌 방지
- ClassNotFoundException이나 NoClassDefFoundError 발생 시 클래스패스와 클래스 로딩 순서 확인하여 문제 해결

---

## 질문 6: static 키워드의 의미와 사용 시 주의사항은 무엇인가요?

**정의:**
static 키워드는 클래스 레벨에서 공유되는 멤버를 선언할 때 사용하며, 인스턴스가 아닌 클래스 자체에 속하는 변수나 메서드를 정의합니다. static 멤버는 클래스가 메모리에 로드될 때 단 한 번만 생성되어 모든 인스턴스가 공유합니다.

**특징/원리:**
- 클래스 레벨 소속: 객체 생성 없이 클래스명으로 직접 접근 가능하며 인스턴스와 독립적으로 존재
- 메모리 효율성: 모든 인스턴스가 하나의 static 변수를 공유하므로 메모리 사용량 절감
- 초기화 시점: 클래스가 처음 로드될 때 초기화되며, static 블록을 통해 복잡한 초기화 가능
- 접근 제한: static 메서드 내에서는 인스턴스 변수나 메서드에 직접 접근 불가능

**사용 시 주의사항:**
- 멀티스레드 환경: static 변수는 모든 스레드가 공유하므로 동시성 문제 발생 가능하며 동기화 필요
- 메모리 누수: static 컬렉션에 객체를 계속 추가하면 GC가 회수하지 못해 메모리 누수 발생 가능
- 테스트 어려움: static 변수의 상태가 테스트 간에 공유되어 테스트 독립성 저하
- 객체지향 원칙 위배: 과도한 static 사용은 캡슐화를 해치고 절차 지향적 코드가 될 수 있음

**실무 활용:**
- 유틸리티 클래스의 헬퍼 메서드를 static으로 구현하여 인스턴스 생성 없이 사용
- 상수 값을 static final로 선언하여 전역적으로 공유되는 불변 값 정의
- 싱글톤 패턴 구현 시 static 변수로 유일한 인스턴스를 저장하고 static 메서드로 접근 제공

---

## 질문 7: final, finally, finalize의 차이점을 설명해주세요.

**정의:**
final, finally, finalize는 모두 다른 목적과 사용 방식을 가진 Java의 키워드 또는 메서드입니다. final은 불변성을 나타내는 키워드, finally는 예외 처리의 일부, finalize는 가비지 컬렉션과 관련된 메서드입니다.

**특징/원리:**
- 사용 위치: final은 변수, 메서드, 클래스에 적용되며, finally는 try-catch 블록과 함께 사용되고, finalize는 Object 클래스의 메서드
- 실행 시점: final은 컴파일 타임에 체크되며, finally는 예외 발생 여부와 무관하게 실행되고, finalize는 GC가 객체를 수거하기 전에 호출
- 보장 수준: final은 불변성을 강제하고, finally는 실행을 보장하지만, finalize는 실행 시점과 실행 여부가 불확실

**각각의 특징:**
- final: 변수에 사용 시 재할당 불가, 메서드에 사용 시 오버라이딩 불가, 클래스에 사용 시 상속 불가능하며 불변성과 안정성 제공
- finally: try-catch 블록 뒤에 위치하여 예외 발생 여부와 관계없이 항상 실행되며 리소스 정리 등에 활용
- finalize: Object 클래스의 메서드로 GC가 객체를 수거하기 전 호출되지만, Java 9부터 deprecated되어 사용 권장되지 않음

**실무 활용:**
- final 키워드로 중요 상수를 정의하거나 불변 객체를 만들어 스레드 안전성 확보
- finally 블록에서 데이터베이스 연결, 파일 스트림 등의 리소스를 안전하게 해제
- finalize 대신 try-with-resources나 AutoCloseable 인터페이스를 사용하여 명시적으로 리소스 관리

---

## 질문 8: 추상 클래스와 인터페이스의 차이점과 사용 시나리오를 설명해주세요.

**정의:**
추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스로 인스턴스를 직접 생성할 수 없으며, 인터페이스는 구현을 포함하지 않는 순수한 추상 타입을 정의합니다. 두 가지 모두 추상화를 통해 다형성을 구현하는 수단이지만 목적과 사용 방식이 다릅니다.

**특징/원리:**
- 상속 제약: 추상 클래스는 단일 상속만 가능하지만, 인터페이스는 다중 구현이 가능하여 유연성 제공
- 구현 포함: 추상 클래스는 일반 메서드와 필드를 가질 수 있지만, 인터페이스는 Java 8 이전에는 상수와 추상 메서드만 가능
- 접근 제어: 추상 클래스는 다양한 접근 제어자를 사용할 수 있지만, 인터페이스의 메서드는 기본적으로 public
- 생성자: 추상 클래스는 생성자를 가질 수 있지만, 인터페이스는 생성자를 가질 수 없음

**차이점 비교:**
- 목적: 추상 클래스는 "is-a" 관계의 공통 기능 제공에 적합하고, 인터페이스는 "can-do" 관계의 계약 정의에 적합
- Java 8 이후: 인터페이스에 default 메서드와 static 메서드가 추가되어 일부 구현 제공 가능
- 상태 관리: 추상 클래스는 인스턴스 변수로 상태를 가질 수 있지만, 인터페이스는 상수만 가능
- 변경 영향도: 추상 클래스에 메서드 추가 시 하위 클래스 영향이 적지만, 인터페이스는 모든 구현 클래스에 영향

**실무 활용:**
- 공통 기능과 상태를 공유해야 하는 관련 클래스들의 기반으로 추상 클래스 사용
- 서로 관련 없는 클래스들이 동일한 행위를 구현해야 할 때 인터페이스로 계약 정의
- 프레임워크 설계 시 확장 포인트를 인터페이스로 제공하여 사용자가 자유롭게 구현하도록 지원

---
