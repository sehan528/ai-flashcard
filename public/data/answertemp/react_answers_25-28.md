# React 답변 25-28

## 질문 25: componentDidMount, componentDidUpdate, componentWillUnmount을 useEffect로 어떻게 대체하나요?

**정의:**
useEffect는 클래스 컴포넌트의 세 가지 주요 라이프사이클 메서드를 하나로 통합한 Hook입니다. 의존성 배열과 클린업 함수를 활용하여 동일한 기능을 구현할 수 있습니다.

**componentDidMount 대체:**
- 의존성 배열을 빈 배열로 설정합니다.
- effect가 마운트 시에만 한 번 실행됩니다.
- 초기 데이터 로딩이나 설정을 수행합니다.
- 이후 리렌더링되어도 다시 실행되지 않습니다.

**componentDidUpdate 대체:**
- 의존성 배열에 감시할 값들을 넣습니다.
- 해당 값이 변경될 때마다 effect가 실행됩니다.
- 여러 의존성을 추가할 수 있습니다.
- 초기 마운트 시에도 실행됩니다. 이것이 componentDidUpdate와의 차이점입니다.
- useRef로 초기 실행을 건너뛸 수 있습니다.

**componentWillUnmount 대체:**
- useEffect에서 클린업 함수를 반환합니다.
- 컴포넌트가 언마운트될 때 클린업이 실행됩니다.
- 타이머 제거 구독 해제 등을 수행합니다.
- 의존성이 있으면 재실행 전에도 클린업이 호출됩니다.

**초기 마운트 제외하기:**
- useRef로 마운트 여부를 추적합니다.
- 첫 렌더링인지 확인하고 건너뜁니다.
- componentDidUpdate와 정확히 같은 동작을 구현합니다.
- 대부분의 경우 이렇게까지 할 필요는 없습니다.

**세 가지 메서드를 모두 사용하는 패턴:**
- 하나의 useEffect로 통합할 수 있습니다.
- 의존성 배열로 업데이트 시점을 제어합니다.
- 클린업 함수로 정리를 수행합니다.
- 관련된 로직이 한곳에 모입니다.
- 클래스보다 가독성이 좋습니다.

**여러 useEffect로 분리:**
- 클래스에서는 한 메서드에 여러 로직이 섞입니다.
- useEffect는 관심사별로 분리할 수 있습니다.
- 데이터 페칭 이벤트 구독 타이머를 각각 다른 effect로 만듭니다.
- 코드가 더 명확하고 유지보수하기 쉽습니다.

**이전 Props나 State 비교:**
- useRef로 이전 값을 저장합니다.
- effect에서 현재 값과 비교합니다.
- componentDidUpdate의 prevProps prevState와 동일한 효과입니다.
- Custom Hook으로 만들어 재사용할 수 있습니다.

**실무 활용:**
- API 호출은 빈 배열로 마운트 시에만 합니다.
- 필터 변경 시 데이터를 다시 가져오려면 해당 필터를 의존성에 넣습니다.
- 타이머나 구독은 클린업 함수로 정리합니다.
- 여러 독립적인 부작용은 각각의 useEffect로 분리합니다.
- useEffect가 더 직관적이고 강력합니다.

---

## 질문 26: React에서 리렌더링이 발생하는 경우는 언제인가요?

**정의:**
리렌더링은 컴포넌트가 다시 렌더 함수를 실행하여 새로운 Virtual DOM을 생성하는 과정입니다. 상태 변경이나 부모의 리렌더링 등 여러 조건에서 발생합니다.

**리렌더링 발생 조건:**
- State가 변경될 때: setState나 useState Hook으로 상태를 업데이트하면 리렌더링됩니다.
- Props가 변경될 때: 부모로부터 받은 props가 바뀌면 리렌더링됩니다.
- 부모가 리렌더링될 때: 기본적으로 부모가 리렌더링되면 모든 자식도 리렌더링됩니다.
- Context 값이 변경될 때: useContext로 구독 중인 값이 바뀌면 리렌더링됩니다.
- forceUpdate 호출 시: 강제로 리렌더링을 유발합니다. 거의 사용하지 않습니다.

**State 변경에 의한 리렌더링:**
- setState 호출 즉시가 아닌 배치 후에 발생합니다.
- 여러 setState를 묶어서 한 번에 처리합니다.
- 같은 값으로 업데이트하면 리렌더링을 건너뜁니다.
- Object.is로 비교하여 참조가 같으면 무시합니다.

**Props 변경에 의한 리렌더링:**
- 부모가 새로운 props를 전달하면 자식이 리렌더링됩니다.
- 객체나 배열은 참조로 비교합니다.
- 내용이 같아도 새 객체면 다르다고 판단합니다.
- 메모이제이션으로 같은 참조를 유지할 수 있습니다.

**부모 리렌더링 전파:**
- 부모가 리렌더링되면 기본적으로 모든 자식도 리렌더링됩니다.
- 자식의 props가 바뀌지 않아도 리렌더링됩니다.
- React.memo로 props가 같으면 리렌더링을 건너뛸 수 있습니다.
- 최적화 기법으로 불필요한 리렌더링을 방지합니다.

**Context에 의한 리렌더링:**
- Provider의 value가 변경되면 구독 중인 모든 컴포넌트가 리렌더링됩니다.
- 중간 컴포넌트는 건너뛰고 직접 영향을 받습니다.
- Context를 분리하여 불필요한 리렌더링을 줄일 수 있습니다.
- value를 메모이제이션하여 참조를 유지합니다.

**리렌더링이 일어나지 않는 경우:**
- 같은 값으로 State를 업데이트할 때입니다.
- React.memo로 감싸고 props가 같을 때입니다.
- shouldComponentUpdate가 false를 반환할 때입니다.
- PureComponent에서 얕은 비교 결과 같을 때입니다.

**배치 업데이트:**
- React 18부터 모든 업데이트가 자동으로 배치됩니다.
- 여러 setState를 호출해도 한 번만 리렌더링됩니다.
- 이벤트 핸들러뿐 아니라 비동기 코드에서도 배치됩니다.
- 성능이 크게 향상됩니다.

**실무 활용:**
- 리렌더링 원인을 파악하여 최적화합니다.
- React DevTools Profiler로 리렌더링을 분석합니다.
- 불필요한 리렌더링은 memo나 useMemo로 방지합니다.
- State를 적절히 분리하여 영향 범위를 줄입니다.
- 과도한 최적화는 피합니다. 측정 후 최적화합니다.

---

## 질문 27: React.memo는 무엇이고 언제 사용하나요?

**정의:**
React.memo는 고차 컴포넌트로, 컴포넌트를 메모이제이션하여 props가 변경되지 않으면 리렌더링을 건너뛰게 합니다. 함수형 컴포넌트의 성능 최적화 도구입니다.

**동작 원리:**
- 컴포넌트를 React.memo로 감쌉니다.
- 이전 props와 새 props를 얕은 비교합니다.
- 모든 props가 같으면 이전 렌더링 결과를 재사용합니다.
- 하나라도 다르면 리렌더링합니다.
- PureComponent와 유사하지만 함수형 컴포넌트용입니다.

**기본 사용법:**
- 컴포넌트를 React.memo로 감싸면 됩니다.
- 별도 설정 없이 자동으로 props를 비교합니다.
- 얕은 비교를 수행합니다.
- export 시에 감싸거나 변수에 할당합니다.

**커스텀 비교 함수:**
- 두 번째 인자로 비교 함수를 전달할 수 있습니다.
- prevProps와 nextProps를 받아 같으면 true를 반환합니다.
- shouldComponentUpdate와 반대로 동작합니다.
- 복잡한 비교 로직이 필요할 때 사용합니다.
- 대부분의 경우 기본 비교로 충분합니다.

**React.memo를 사용해야 하는 경우:**
- 같은 props로 자주 렌더링되는 컴포넌트입니다.
- 렌더링이 비용이 큰 컴포넌트입니다.
- 부모가 자주 리렌더링되지만 자식은 props가 안 바뀝니다.
- 목록의 아이템 컴포넌트입니다.
- props가 원시값이거나 메모이제이션된 객체입니다.

**React.memo를 사용하지 말아야 하는 경우:**
- 항상 다른 props를 받는 컴포넌트입니다.
- 렌더링 비용이 작은 단순한 컴포넌트입니다.
- props에 항상 새로운 객체나 함수가 전달됩니다.
- 측정 없이 추측으로 최적화하는 경우입니다.

**props 메모이제이션 필요성:**
- 객체나 배열 props는 useMemo로 메모이제이션해야 합니다.
- 함수 props는 useCallback으로 메모이제이션해야 합니다.
- 메모이제이션하지 않으면 매번 새 참조가 전달되어 효과가 없습니다.
- 부모에서 메모이제이션을 제대로 해야 자식의 memo가 의미 있습니다.

**성능 고려사항:**
- memo 자체도 비교 비용이 듭니다.
- 항상 빠른 것은 아닙니다.
- 프로파일링으로 효과를 확인합니다.
- 병목이 확인된 곳에만 적용합니다.
- 과도한 사용은 오히려 성능을 해칩니다.

**실무 활용:**
- 큰 목록의 아이템 컴포넌트를 memo로 감쌉니다.
- 부모가 자주 업데이트되는 자식 컴포넌트에 적용합니다.
- 복잡한 차트나 테이블 컴포넌트를 최적화합니다.
- 항상 props 메모이제이션과 함께 사용합니다.
- React DevTools로 효과를 검증합니다.

---

## 질문 28: useMemo는 언제 사용해야 하나요?

**정의:**
useMemo는 계산 비용이 큰 값을 메모이제이션하는 Hook입니다. 의존성이 변경될 때만 재계산하고, 그렇지 않으면 캐시된 값을 반환하여 성능을 최적화합니다.

**동작 원리:**
- 첫 번째 인자는 값을 계산하는 함수입니다.
- 두 번째 인자는 의존성 배열입니다.
- 의존성이 변경되면 함수를 다시 실행합니다.
- 변경되지 않으면 이전 결과를 재사용합니다.
- 렌더링 중에 동기적으로 실행됩니다.

**사용해야 하는 경우:**
- 계산 비용이 큰 연산 결과를 캐싱할 때입니다. 복잡한 데이터 변환이나 필터링입니다.
- 참조 동등성이 중요한 객체나 배열을 생성할 때입니다.
- 자식 컴포넌트에 props로 전달하는 객체를 메모이제이션할 때입니다.
- React.memo와 함께 사용하여 불필요한 리렌더링을 방지할 때입니다.
- useEffect의 의존성으로 사용되는 값을 메모이제이션할 때입니다.

**사용하지 말아야 하는 경우:**
- 단순한 계산은 메모이제이션 비용이 더 클 수 있습니다.
- 항상 의존성이 바뀌는 경우 효과가 없습니다.
- 측정 없이 추측으로 최적화하는 경우입니다.
- 모든 값을 메모이제이션하면 오히려 느려집니다.

**계산 비용이 큰 연산:**
- 큰 배열의 정렬이나 필터링입니다.
- 복잡한 수학 계산입니다.
- 재귀적인 데이터 구조 변환입니다.
- 수천 개 항목의 데이터 처리입니다.
- 프로파일링으로 병목을 확인합니다.

**참조 동등성 유지:**
- 객체나 배열은 매 렌더링마다 새로 생성됩니다.
- 참조가 바뀌면 의존하는 컴포넌트나 effect가 재실행됩니다.
- useMemo로 같은 참조를 유지합니다.
- React.memo나 useEffect와 함께 사용할 때 중요합니다.

**의존성 관리:**
- 계산에 사용되는 모든 값을 의존성에 포함합니다.
- ESLint exhaustive-deps 규칙을 따릅니다.
- 의존성이 너무 많으면 설계를 재고합니다.
- 원시값만 의존성으로 사용하는 것이 안전합니다.

**성능 측정:**
- React DevTools Profiler로 렌더링 시간을 측정합니다.
- console.time으로 계산 시간을 측정합니다.
- 실제로 개선되는지 확인합니다.
- 추측하지 말고 측정합니다.

**실무 활용:**
- 복잡한 데이터 필터링이나 정렬 결과를 캐싱합니다.
- Context Provider의 value를 메모이제이션합니다.
- 큰 테이블의 계산된 열 값을 캐싱합니다.
- 자식에게 전달하는 설정 객체를 메모이제이션합니다.
- 항상 측정 후 최적화하고 과도한 사용을 피합니다.

---
