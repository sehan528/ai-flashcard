# Spring 답변 61-64

## 질문 61: Spring Framework의 기본 개념과 주요 특징에 대해 설명해주세요.

Spring Framework는 Java 기반의 엔터프라이즈 애플리케이션 개발을 위한 경량급 오픈 소스 프레임워크입니다.

**기본 개념:**

첫째, 경량 컨테이너입니다. Spring은 POJO(Plain Old Java Object) 기반 개발을 지원합니다. 특정 인터페이스나 클래스를 강제로 상속받을 필요가 없습니다. EJB와 달리 무겁지 않고 간단합니다. 일반 Java 객체를 사용하여 비즈니스 로직을 구현할 수 있습니다.

둘째, IoC(Inversion of Control) 컨테이너입니다. 객체의 생성과 관리를 개발자가 아닌 Spring이 담당합니다. 객체 간의 의존관계를 Spring이 주입해줍니다. 개발자는 비즈니스 로직에만 집중할 수 있습니다.

셋째, DI(Dependency Injection)를 핵심으로 합니다. 객체가 직접 의존하는 객체를 생성하지 않습니다. 외부에서 필요한 객체를 주입받아 사용합니다. 결합도가 낮아지고 테스트가 용이해집니다.

**주요 특징:**

첫째, 모듈화된 구조입니다. Spring Core, Spring MVC, Spring Data, Spring Security 등 필요한 모듈만 선택적으로 사용할 수 있습니다. 각 모듈은 독립적으로 동작하면서 통합도 잘 됩니다. 애플리케이션 요구사항에 맞게 유연하게 구성할 수 있습니다.

둘째, AOP(Aspect Oriented Programming) 지원입니다. 공통 관심사를 비즈니스 로직에서 분리할 수 있습니다. 로깅, 트랜잭션, 보안 등의 횡단 관심사를 효과적으로 처리합니다. 코드 중복을 줄이고 유지보수성을 높입니다.

셋째, 트랜잭션 관리 추상화입니다. 선언적 트랜잭션 관리를 지원합니다. JDBC, JPA, Hibernate 등 다양한 기술에 대해 일관된 트랜잭션 관리 방법을 제공합니다. 어노테이션 기반으로 간단하게 트랜잭션을 적용할 수 있습니다.

넷째, 다양한 데이터 접근 기술 지원입니다. JDBC, MyBatis, JPA, Hibernate 등을 통합하여 사용할 수 있습니다. 각 기술의 예외를 Spring의 일관된 예외 계층으로 변환합니다. 템플릿 패턴을 통해 반복적인 코드를 제거합니다.

다섯째, 테스트 편의성입니다. 의존성 주입 덕분에 Mock 객체를 쉽게 주입할 수 있습니다. Spring Test 모듈이 JUnit과 통합을 지원합니다. 통합 테스트를 위한 다양한 어노테이션과 유틸리티를 제공합니다.

여섯째, 다양한 확장 가능성입니다. 인터페이스 기반 설계로 확장이 용이합니다. 커스텀 컴포넌트를 쉽게 통합할 수 있습니다. 플러그인 아키텍처로 기능을 추가하거나 교체할 수 있습니다.

일곱째, MVC 패턴 지원입니다. Spring MVC는 웹 애플리케이션 개발을 위한 강력한 프레임워크입니다. DispatcherServlet을 중심으로 요청을 처리합니다. RESTful API 개발을 위한 편리한 기능들을 제공합니다.

**설계 철학:**

첫째, 선택의 자유입니다. 특정 기술이나 방식을 강요하지 않습니다. 개발자가 원하는 기술 스택을 선택할 수 있습니다. 다양한 옵션 중에서 상황에 맞는 것을 고를 수 있습니다.

둘째, 유연성과 확장성입니다. 기존 코드를 변경하지 않고 기능을 확장할 수 있습니다. 인터페이스와 추상화를 통해 구현을 쉽게 교체할 수 있습니다. 개방-폐쇄 원칙(OCP)을 잘 따릅니다.

셋째, 하위 호환성 유지입니다. 새 버전이 나와도 기존 코드가 대부분 동작합니다. 마이그레이션 부담이 적습니다. 장기적인 유지보수가 용이합니다.

**생태계:**

Spring 생태계는 매우 풍부합니다. Spring Boot는 빠른 애플리케이션 개발을 지원합니다. Spring Data는 데이터 접근을 단순화합니다. Spring Security는 인증과 인가를 처리합니다. Spring Cloud는 마이크로서비스 아키텍처를 지원합니다. Spring Batch는 배치 처리를 담당합니다.

**핵심 가치:**

Spring은 개발자 생산성을 높입니다. 반복적인 코드를 줄이고 비즈니스 로직에 집중하게 합니다. 테스트 가능한 코드를 작성하도록 유도합니다. 엔터프라이즈급 기능을 쉽게 사용할 수 있게 합니다. 이러한 특징들로 Spring은 Java 엔터프라이즈 개발의 사실상 표준이 되었습니다.

## 질문 62: Spring Boot와 전통적 Spring Framework의 차이점은 무엇인가요?

Spring Boot는 Spring Framework를 기반으로 하되, 설정을 최소화하고 빠르게 애플리케이션을 개발할 수 있도록 만든 프레임워크입니다.

**전통적 Spring Framework의 특징:**

첫째, 복잡한 초기 설정이 필요합니다. XML 설정 파일을 작성해야 합니다. 또는 Java Config 클래스를 만들어야 합니다. Bean 정의, 컴포넌트 스캔, 프로퍼티 설정 등을 모두 명시적으로 해야 합니다.

둘째, 의존성 관리가 수동적입니다. 각 라이브러리의 버전을 개발자가 직접 선택해야 합니다. 호환되는 버전을 찾는 데 시간이 걸립니다. pom.xml이나 build.gradle이 복잡해집니다.

셋째, 애플리케이션 서버가 필요합니다. WAR 파일로 패키징해야 합니다. Tomcat, WebLogic 등의 외부 서버에 배포해야 합니다. 서버 설정과 관리가 별도로 필요합니다.

넷째, 반복적인 보일러플레이트 코드가 많습니다. 데이터베이스 설정, 트랜잭션 관리, 로깅 설정 등을 매번 작성해야 합니다. 프로젝트마다 비슷한 설정을 반복합니다.

**Spring Boot의 특징:**

첫째, 자동 구성(Auto-Configuration)입니다. 클래스패스에 있는 라이브러리를 감지합니다. 감지된 라이브러리에 따라 자동으로 설정을 구성합니다. 개발자가 명시적으로 설정하지 않아도 합리적인 기본값으로 동작합니다.

둘째, Starter 의존성입니다. spring-boot-starter-web, spring-boot-starter-data-jpa 등 목적별로 묶인 의존성 세트를 제공합니다. 하나의 Starter만 추가하면 관련된 모든 라이브러리가 함께 들어옵니다. 버전 호환성이 검증된 라이브러리들이 자동으로 포함됩니다.

셋째, 내장 서버(Embedded Server)입니다. Tomcat, Jetty, Undertow를 내장하고 있습니다. JAR 파일로 패키징하여 독립 실행 가능합니다. java -jar 명령어 하나로 애플리케이션을 실행할 수 있습니다. 별도의 서버 설치나 배포 과정이 불필요합니다.

넷째, 설정의 외부화입니다. application.properties 또는 application.yml 파일 하나로 모든 설정을 관리합니다. 환경별 프로파일을 쉽게 전환할 수 있습니다. 환경 변수, 커맨드 라인 인자 등 다양한 방식으로 설정을 주입할 수 있습니다.

다섯째, Actuator를 통한 운영 기능입니다. 애플리케이션 상태, 메트릭, 헬스 체크 등을 제공합니다. 엔드포인트를 통해 모니터링과 관리가 가능합니다. 프로덕션 레디 기능이 기본으로 포함됩니다.

여섯째, 개발 도구 지원입니다. Spring Boot DevTools가 자동 재시작을 지원합니다. 코드 변경 시 빠르게 반영됩니다. LiveReload를 통해 브라우저도 자동 새로고침됩니다.

**주요 차이점:**

첫째, 설정 방식입니다. 전통적 Spring은 명시적 설정이 중심입니다. Spring Boot는 관례(Convention)와 자동 구성이 중심입니다. 필요한 경우에만 설정을 커스터마이징합니다.

둘째, 프로젝트 시작 시간입니다. 전통적 Spring은 초기 설정에 많은 시간이 걸립니다. Spring Boot는 Spring Initializr로 몇 분 내에 프로젝트를 생성할 수 있습니다. 바로 비즈니스 로직 개발에 착수할 수 있습니다.

셋째, 배포 방식입니다. 전통적 Spring은 WAR 파일을 서버에 배포합니다. Spring Boot는 JAR 파일을 단독으로 실행합니다. 컨테이너 환경(Docker, Kubernetes)에 훨씬 적합합니다.

넷째, 학습 곡선입니다. 전통적 Spring은 많은 설정과 개념을 알아야 합니다. Spring Boot는 빠르게 시작할 수 있지만, 내부 동작을 이해하려면 여전히 Spring 지식이 필요합니다.

**Spring Boot의 장점:**

빠른 개발 속도입니다. 설정보다 코드에 집중할 수 있습니다. 마이크로서비스 아키텍처에 적합합니다. 클라우드 네이티브 애플리케이션 개발에 유리합니다. 일관된 프로젝트 구조를 유지할 수 있습니다.

**Spring Boot의 단점:**

자동 구성이 블랙박스처럼 느껴질 수 있습니다. 내부 동작을 모르면 문제 해결이 어렵습니다. 필요 없는 라이브러리까지 포함될 수 있습니다. 세밀한 제어가 필요한 경우 오히려 복잡해질 수 있습니다.

**관계:**

Spring Boot는 Spring Framework를 대체하는 것이 아닙니다. Spring Framework 위에서 동작하며, 개발 경험을 향상시키는 레이어입니다. Spring의 모든 기능을 사용할 수 있으면서, 설정과 배포를 간소화합니다. 현대적인 Spring 개발의 표준 방식이 되었습니다.

## 질문 63: IoC(Inversion of Control)와 DI(Dependency Injection)의 개념 및 이점에 대해 설명해주세요.

IoC와 DI는 Spring의 핵심 개념으로, 객체 지향 설계의 결합도를 낮추고 유연성을 높이는 패턴입니다.

**IoC(Inversion of Control) 개념:**

첫째, 제어의 역전입니다. 전통적인 프로그래밍에서는 개발자가 작성한 코드가 라이브러리를 호출합니다. IoC에서는 프레임워크가 개발자의 코드를 호출합니다. 프로그램의 흐름 제어권이 역전됩니다.

둘째, 객체 생성과 관리의 역전입니다. 일반적으로 객체는 필요한 시점에 new 키워드로 직접 생성합니다. IoC에서는 프레임워크가 객체를 생성하고 관리합니다. 개발자는 객체를 사용하기만 하면 됩니다.

셋째, 의존관계 설정의 역전입니다. 객체가 자신이 필요로 하는 의존 객체를 직접 찾거나 생성하지 않습니다. 외부에서 의존 객체를 주입받습니다. 객체는 수동적으로 의존관계를 받아들입니다.

**Spring IoC 컨테이너:**

Spring에서 IoC를 담당하는 것이 IoC 컨테이너입니다. ApplicationContext와 BeanFactory가 대표적입니다. 컨테이너는 Bean의 생성, 초기화, 의존관계 주입, 소멸을 관리합니다. 개발자는 설정 메타데이터만 제공하면 됩니다.

**DI(Dependency Injection) 개념:**

DI는 IoC를 구현하는 구체적인 방법 중 하나입니다. 객체가 필요로 하는 의존성을 외부에서 주입하는 패턴입니다. 객체는 인터페이스에만 의존하고, 구체적인 구현은 모릅니다.

**DI의 세 가지 방식:**

첫째, 생성자 주입(Constructor Injection)입니다. 생성자의 파라미터로 의존성을 전달합니다. 객체 생성 시점에 모든 의존성이 주입됩니다. 불변성을 보장할 수 있습니다. final 키워드를 사용할 수 있습니다. Spring에서 권장하는 방식입니다.

둘째, 세터 주입(Setter Injection)입니다. Setter 메서드를 통해 의존성을 전달합니다. 객체 생성 후에 의존성을 주입합니다. 선택적 의존성에 적합합니다. 의존성을 변경할 수 있습니다.

셋째, 필드 주입(Field Injection)입니다. 필드에 직접 의존성을 주입합니다. 리플렉션을 사용하여 private 필드에도 주입할 수 있습니다. 코드가 간결하지만 테스트가 어렵습니다. 순환 참조를 발견하기 어렵습니다. 일반적으로 권장되지 않습니다.

**IoC와 DI의 이점:**

첫째, 낮은 결합도입니다. 객체는 구체적인 구현이 아닌 인터페이스에 의존합니다. 구현체를 쉽게 교체할 수 있습니다. 한 모듈의 변경이 다른 모듈에 영향을 주지 않습니다. 시스템의 유연성이 높아집니다.

둘째, 높은 응집도입니다. 각 객체는 자신의 책임에만 집중합니다. 의존성 관리라는 부가적인 책임에서 자유롭습니다. 단일 책임 원칙(SRP)을 지키기 쉽습니다.

셋째, 테스트 용이성입니다. 실제 의존 객체 대신 Mock이나 Stub을 주입할 수 있습니다. 단위 테스트를 독립적으로 작성할 수 있습니다. 외부 시스템에 의존하지 않고 테스트할 수 있습니다. 테스트 더블 패턴을 쉽게 적용할 수 있습니다.

넷째, 코드 재사용성입니다. 인터페이스 기반 설계로 다양한 구현을 사용할 수 있습니다. 같은 컴포넌트를 여러 곳에서 재사용할 수 있습니다. 다형성을 활용할 수 있습니다.

다섯째, 유지보수성입니다. 의존성이 명시적으로 드러납니다. 객체 간 관계를 파악하기 쉽습니다. 변경이 필요할 때 영향 범위를 예측할 수 있습니다. 리팩토링이 안전합니다.

여섯째, 설정의 중앙화입니다. 의존관계 설정이 한 곳에 모여 있습니다. 전체 시스템 구조를 파악하기 쉽습니다. 환경별로 다른 구현을 주입하기 쉽습니다. 프로덕션, 개발, 테스트 환경을 쉽게 구분할 수 있습니다.

일곱째, 개방-폐쇄 원칙(OCP) 준수입니다. 확장에는 열려 있고 변경에는 닫혀 있습니다. 새로운 구현을 추가할 때 기존 코드를 수정하지 않습니다. 인터페이스만 구현하면 됩니다.

여덟째, 의존관계 역전 원칙(DIP) 준수입니다. 고수준 모듈이 저수준 모듈에 의존하지 않습니다. 둘 다 추상화에 의존합니다. 안정적인 구조를 만들 수 있습니다.

**실제 활용:**

개발 환경에서는 H2 데이터베이스를 사용하고, 프로덕션에서는 MySQL을 사용할 수 있습니다. 테스트에서는 실제 결제 시스템 대신 Mock 결제 시스템을 주입할 수 있습니다. 이메일 발송을 콘솔 출력으로 대체할 수 있습니다. 이 모든 것이 비즈니스 로직 코드 변경 없이 가능합니다.

**주의점:**

과도한 추상화는 오히려 복잡도를 높일 수 있습니다. 간단한 경우에는 DI가 오버 엔지니어링일 수 있습니다. DI 컨테이너에 대한 의존성이 생깁니다. 순환 참조 문제가 발생할 수 있습니다.

하지만 장점이 단점을 크게 상회하므로, 현대적인 애플리케이션 개발에서 IoC와 DI는 필수적인 패턴이 되었습니다.

## 질문 64: Spring Bean의 라이프사이클과 관련 콜백 메서드에 대해 설명해주세요.

Spring Bean은 Spring IoC 컨테이너가 관리하는 객체입니다. Bean은 생성부터 소멸까지 정해진 라이프사이클을 가지며, 각 단계에서 개발자가 개입할 수 있는 콜백 메커니즘을 제공합니다.

**Bean 라이프사이클 전체 과정:**

첫째, 스프링 컨테이너 생성입니다. ApplicationContext가 초기화됩니다. 설정 정보를 읽어들입니다.

둘째, Bean 정의 로딩입니다. 설정 메타데이터에서 Bean 정의를 읽습니다. 어노테이션, XML, Java Config 등에서 정보를 수집합니다. BeanDefinition 객체가 생성됩니다.

셋째, Bean 인스턴스화입니다. 컨테이너가 Bean의 생성자를 호출합니다. 리플렉션을 통해 객체를 생성합니다. 아직 의존성은 주입되지 않은 상태입니다.

넷째, 의존성 주입입니다. Bean이 필요로 하는 다른 Bean들을 주입합니다. 생성자 주입, 세터 주입, 필드 주입이 수행됩니다. 프로퍼티 값도 설정됩니다.

다섯째, Bean 후처리 전처리입니다. BeanPostProcessor의 postProcessBeforeInitialization 메서드가 호출됩니다. Bean 초기화 전에 Bean을 수정하거나 프록시로 감쌀 수 있습니다.

여섯째, 초기화입니다. Bean의 초기화 콜백이 실행됩니다. 리소스 연결, 캐시 워밍업 등의 작업을 수행합니다.

일곱째, Bean 후처리 후처리입니다. BeanPostProcessor의 postProcessAfterInitialization 메서드가 호출됩니다. AOP 프록시가 여기서 생성됩니다.

여덟째, Bean 사용입니다. 애플리케이션에서 Bean을 사용합니다. Bean은 완전히 초기화되어 준비된 상태입니다.

아홉째, 소멸입니다. 컨테이너가 종료될 때 Bean도 소멸됩니다. 리소스 해제, 연결 종료 등의 정리 작업을 수행합니다.

**초기화 콜백 메서드 (우선순위 순):**

첫째, @PostConstruct 어노테이션입니다. JSR-250 표준 어노테이션입니다. 의존성 주입 완료 후 실행됩니다. 가장 권장되는 방식입니다. Spring에 종속적이지 않습니다.

둘째, InitializingBean 인터페이스의 afterPropertiesSet 메서드입니다. Spring 인터페이스를 구현해야 합니다. Spring에 종속적입니다. 현재는 권장되지 않습니다.

셋째, 커스텀 초기화 메서드입니다. Bean 설정에서 initMethod를 지정합니다. 메서드 이름을 자유롭게 정할 수 있습니다. Spring에 종속적이지 않습니다.

만약 세 가지가 모두 설정되어 있다면, PostConstruct, afterPropertiesSet, initMethod 순서로 실행됩니다.

**소멸 콜백 메서드 (우선순위 순):**

첫째, @PreDestroy 어노테이션입니다. JSR-250 표준 어노테이션입니다. 컨테이너 종료 시 실행됩니다. 가장 권장되는 방식입니다.

둘째, DisposableBean 인터페이스의 destroy 메서드입니다. Spring 인터페이스를 구현해야 합니다. Spring에 종속적입니다. 현재는 권장되지 않습니다.

셋째, 커스텀 소멸 메서드입니다. Bean 설정에서 destroyMethod를 지정합니다. 메서드 이름을 자유롭게 정할 수 있습니다.

만약 세 가지가 모두 설정되어 있다면, PreDestroy, destroy, destroyMethod 순서로 실행됩니다.

**BeanPostProcessor:**

모든 Bean에 대해 일괄적으로 처리할 수 있는 후처리기입니다. postProcessBeforeInitialization은 초기화 콜백 전에 실행됩니다. postProcessAfterInitialization은 초기화 콜백 후에 실행됩니다. AOP, 트랜잭션, 검증 등이 이 메커니즘을 사용합니다.

**BeanFactoryPostProcessor:**

Bean 생성 전에 BeanDefinition을 수정할 수 있습니다. PropertyPlaceholderConfigurer가 대표적인 예입니다. 프로퍼티 파일의 값을 Bean 정의에 주입합니다.

**Aware 인터페이스들:**

Bean이 컨테이너의 특정 기능에 접근해야 할 때 사용합니다.

BeanNameAware는 Bean의 이름을 알 수 있습니다. BeanFactoryAware는 BeanFactory에 접근할 수 있습니다. ApplicationContextAware는 ApplicationContext에 접근할 수 있습니다. 의존성 주입 후, 초기화 콜백 전에 실행됩니다.

**Scope에 따른 차이:**

싱글톤 Bean은 컨테이너 시작 시 생성되고 종료 시 소멸됩니다. 초기화와 소멸 콜백이 모두 호출됩니다.

프로토타입 Bean은 요청할 때마다 생성됩니다. 초기화 콜백은 호출되지만, 소멸 콜백은 호출되지 않습니다. 컨테이너가 프로토타입 Bean의 소멸을 관리하지 않기 때문입니다.

Request, Session, Application scope Bean은 웹 환경에서 사용됩니다. 각 스코프의 생명주기에 맞춰 생성되고 소멸됩니다.

**활용 사례:**

초기화 콜백에서는 데이터베이스 커넥션 풀 초기화, 캐시 데이터 로딩, 외부 API 연결, 스케줄러 시작 등을 수행합니다.

소멸 콜백에서는 데이터베이스 커넥션 해제, 파일 핸들 닫기, 스레드 풀 종료, 임시 파일 삭제, 리소스 정리 등을 수행합니다.

**주의사항:**

초기화 메서드에서 너무 무거운 작업을 하면 애플리케이션 시작이 느려집니다. 예외가 발생하면 Bean 생성이 실패합니다. 적절한 예외 처리가 필요합니다.

생성자에서는 의존성이 아직 주입되지 않았으므로, 의존성을 사용하는 초기화 로직은 PostConstruct나 afterPropertiesSet에서 해야 합니다.

소멸 콜백은 정상 종료 시에만 호출됩니다. kill -9 같은 강제 종료에서는 호출되지 않습니다.

**권장 방식:**

현대적인 Spring에서는 @PostConstruct와 @PreDestroy 사용을 권장합니다. 표준 어노테이션이므로 이식성이 좋습니다. 코드가 간결하고 명확합니다. Spring에 종속적이지 않습니다.

InitializingBean과 DisposableBean 인터페이스는 레거시 방식입니다. 코드가 Spring API에 강하게 결합됩니다. 특별한 이유가 없다면 피하는 것이 좋습니다.

Bean의 라이프사이클을 이해하면 적절한 시점에 초기화와 정리 작업을 수행할 수 있습니다. 리소스를 효율적으로 관리하고 안정적인 애플리케이션을 만들 수 있습니다.
