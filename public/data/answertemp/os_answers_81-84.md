# OS 답변 81-84

## 81. 캐시의 지역성에 대해 설명해 주세요.

**기본 개념**

캐시의 지역성은 프로그램이 메모리를 접근하는 패턴에 관한 원리로, 캐시가 효과적으로 동작하는 근본 이유입니다. 시간적 지역성과 공간적 지역성 두 가지 형태가 있습니다.

**시간적 지역성**

시간적 지역성은 최근에 접근한 데이터를 가까운 미래에 다시 접근할 가능성이 높다는 원리입니다. 루프에서 같은 변수를 반복적으로 사용하거나, 함수가 여러 번 호출될 때 같은 코드를 실행하는 경우가 대표적입니다. 캐시는 최근 사용한 데이터를 보관하여 재접근 시 빠르게 제공합니다. LRU 교체 정책이 시간적 지역성을 잘 활용하는 알고리즘입니다.

**공간적 지역성**

공간적 지역성은 어떤 데이터에 접근하면 인접한 주소의 데이터도 곧 접근할 가능성이 높다는 원리입니다. 배열을 순차적으로 탐색하거나, 구조체의 여러 필드를 연속으로 접근하는 경우입니다. 캐시 라인은 요청된 바이트뿐만 아니라 인접한 바이트들도 함께 가져와서 공간적 지역성을 활용합니다. 프리페칭도 공간적 지역성에 기반합니다.

**지역성의 실제 예시**

단순 루프에서 배열을 순회하면 시간적 지역성과 공간적 지역성이 모두 나타납니다. 루프 카운터는 반복적으로 접근되어 시간적 지역성을, 배열 원소는 순차 접근되어 공간적 지역성을 보입니다. 함수 호출은 코드의 시간적 지역성을, 스택 변수는 공간적 지역성을 나타냅니다. 대부분의 프로그램은 강한 지역성을 가지므로 캐시가 매우 효과적입니다.

**지역성이 약한 경우**

무작위 접근 패턴은 지역성이 약합니다. 연결 리스트 순회는 노드가 메모리에 분산되어 있어 공간적 지역성이 낮습니다. 해시 테이블 탐색도 무작위 메모리 접근으로 캐시 미스가 많습니다. 큰 데이터셋을 한 번씩만 읽는 스트리밍 작업은 시간적 지역성이 없습니다. 이런 경우 캐시 효율이 떨어지고 성능이 낮아집니다.

**프로그래머의 활용**

코드를 작성할 때 지역성을 높이도록 노력해야 합니다. 배열을 행 우선 순서로 순회하여 공간적 지역성을 활용합니다. 자주 사용하는 데이터를 지역 변수로 저장하여 시간적 지역성을 높입니다. 루프 융합으로 같은 데이터를 여러 루프에서 접근하는 것을 하나의 루프로 합칩니다. 데이터 구조를 캐시 친화적으로 재배치합니다.

**지역성 측정**

프로파일러로 캐시 히트율을 측정하여 지역성을 평가할 수 있습니다. perf stat로 L1, L2, L3 미스율을 확인합니다. Cachegrind는 캐시 시뮬레이터로 상세한 분석을 제공합니다. 히트율이 낮으면 접근 패턴을 개선하거나 데이터 레이아웃을 조정해야 합니다.

**실무 최적화**

데이터베이스 인덱스는 B-tree로 공간적 지역성을 높입니다. 게임 엔진은 Entity Component System으로 같은 타입의 컴포넌트를 연속 배열에 저장합니다. 정렬 알고리즘은 퀵소트보다 머지소트가 캐시 친화적일 수 있습니다. 행렬 연산은 블로킹으로 지역성을 극대화합니다. 고성능 코드는 지역성 최적화가 필수입니다.

---

## 82. 캐시의 지역성을 기반으로, 이차원 배열을 가로/세로로 탐색했을 때의 성능 차이에 대해 설명해 주세요.

**기본 개념**

이차원 배열의 메모리 배치 방식과 접근 순서에 따라 캐시 성능이 크게 달라집니다. C/C++는 행 우선 순서로 배열을 저장하므로, 가로 탐색과 세로 탐색의 성능 차이가 발생합니다.

**행 우선 메모리 배치**

C/C++에서 이차원 배열은 행 단위로 연속된 메모리에 저장됩니다. 배열의 첫 행이 먼저 배치되고, 그 다음 두 번째 행이 이어집니다. 같은 행의 원소들은 메모리 상에서 인접하지만, 같은 열의 원소들은 한 행의 크기만큼 떨어져 있습니다. 이는 공간적 지역성에 큰 영향을 미칩니다.

**가로 탐색의 성능**

행을 따라 탐색하면 메모리를 순차적으로 접근합니다. 한 캐시 라인에 여러 원소가 들어가므로, 한 번 캐시 미스가 발생하면 여러 원소를 동시에 가져옵니다. 이후 같은 캐시 라인의 원소들은 캐시 히트로 빠르게 접근됩니다. 64바이트 캐시 라인에 4바이트 정수가 16개 들어가므로, 한 번 미스로 16번 히트를 얻습니다. 공간적 지역성이 매우 높아 성능이 우수합니다.

**세로 탐색의 성능**

열을 따라 탐색하면 한 행 크기만큼 점프하며 접근합니다. 각 접근이 서로 다른 캐시 라인에 있을 가능성이 높습니다. 특히 행 크기가 캐시 크기보다 크면, 같은 열의 다음 원소에 접근할 때 이전 원소가 이미 캐시에서 제거되었을 수 있습니다. 매 접근마다 캐시 미스가 발생하여 성능이 크게 저하됩니다. 공간적 지역성이 거의 없습니다.

**성능 차이 측정**

실험적으로 1000x1000 정수 배열을 가로와 세로로 탐색하면, 가로가 세로보다 5배에서 10배 이상 빠릅니다. 배열이 클수록, 캐시가 작을수록 차이가 더 커집니다. perf stat로 측정하면 세로 탐색의 캐시 미스율이 훨씬 높게 나타납니다. 이는 알고리즘 복잡도는 같지만 캐시 동작에 따라 실제 성능이 크게 다름을 보여줍니다.

**타 언어의 차이**

Fortran이나 Matlab은 열 우선 순서를 사용하여, 세로 탐색이 빠르고 가로 탐색이 느립니다. NumPy는 기본적으로 행 우선이지만 열 우선도 지정할 수 있습니다. 언어의 메모리 배치를 이해하고 그에 맞게 알고리즘을 작성해야 합니다. 상호 운용 시 메모리 순서를 맞추는 것이 중요합니다.

**최적화 전략**

행렬 연산은 가능한 한 행 단위로 처리합니다. 전치 연산이 필요하면 블로킹을 사용하여 캐시 크기에 맞춥니다. 루프 교환 기법으로 내부 루프가 연속 메모리를 접근하도록 순서를 바꿉니다. 컴파일러 최적화도 이런 변환을 수행하지만, 명시적으로 작성하는 것이 확실합니다.

**실무 응용**

이미지 처리에서 픽셀을 행 단위로 순회해야 빠릅니다. 행렬 곱셈은 블로킹으로 양쪽 행렬의 지역성을 모두 높입니다. 과학 계산 라이브러리는 캐시를 고려하여 알고리즘을 최적화합니다. 데이터 레이아웃만 바꿔도 성능이 몇 배 향상될 수 있으므로, 메모리 접근 패턴은 매우 중요합니다.

---

## 83. 캐시의 공간 지역성은 어떻게 구현될 수 있을까요?

**기본 개념**

캐시의 공간 지역성 구현은 하드웨어와 소프트웨어 양쪽에서 이루어집니다. 하드웨어는 캐시 라인과 프리페칭을 통해, 소프트웨어는 데이터 레이아웃과 접근 패턴을 통해 공간 지역성을 활용합니다.

**캐시 라인의 역할**

캐시는 바이트 단위가 아닌 캐시 라인 단위로 데이터를 관리합니다. 일반적으로 64바이트 크기의 캐시 라인을 사용합니다. CPU가 한 바이트를 요청해도, 하드웨어는 해당 바이트가 속한 64바이트 전체를 메모리에서 가져와 캐시에 저장합니다. 인접한 63바이트도 함께 캐시에 들어가므로, 이후 인접 주소 접근은 캐시 히트가 됩니다. 이것이 공간 지역성을 하드웨어적으로 구현하는 핵심입니다.

**하드웨어 프리페칭**

현대 CPU는 접근 패턴을 감지하여 자동으로 다음 데이터를 미리 가져옵니다. 순차 프리페처는 연속된 주소 접근을 감지하면 앞쪽 주소를 예측하여 미리 로드합니다. 스트라이드 프리페처는 일정 간격으로 접근하는 패턴을 인식하여 다음 위치를 예측합니다. 스트림 버퍼를 사용하여 프리페치된 데이터를 임시 저장합니다. 프리페칭이 정확하면 캐시 미스를 크게 줄일 수 있습니다.

**연속 메모리 할당**

배열은 원소들이 메모리에 연속적으로 배치되어 공간 지역성이 높습니다. 순차 탐색 시 한 번의 캐시 미스로 여러 원소를 가져와 이후 접근이 빠릅니다. 반면 연결 리스트는 노드가 흩어져 있어 공간 지역성이 낮습니다. 동적 할당 시 메모리 풀이나 아레나 할당자를 사용하면 연관된 객체들을 인접하게 배치할 수 있습니다.

**구조체 배열 vs 배열의 구조체**

구조체 배열은 같은 구조체의 필드들이 인접하지만, 같은 필드끼리는 떨어져 있습니다. 배열의 구조체는 같은 필드들이 연속 배열로 저장됩니다. 한 필드만 반복 접근하면 배열의 구조체가 공간 지역성이 높습니다. 게임 엔진의 Entity Component System이 이 원리를 활용합니다. 사용 패턴에 맞게 레이아웃을 선택해야 합니다.

**루프 블로킹과 타일링**

큰 데이터를 작은 블록으로 나누어 처리하면 각 블록이 캐시에 들어갑니다. 행렬 곱셈에서 전체 행렬 대신 타일 단위로 계산하여 캐시 재사용을 극대화합니다. 블록 크기는 캐시 크기에 맞춰 조정합니다. 여러 레벨의 캐시를 고려한 다단계 블로킹도 가능합니다. 이는 공간 지역성과 시간적 지역성을 모두 높입니다.

**데이터 정렬과 패딩**

구조체 필드를 접근 빈도 순으로 배치하여 자주 사용하는 필드가 같은 캐시 라인에 들어가도록 합니다. 패딩으로 중요 필드를 캐시 라인 경계에 맞춥니다. False Sharing을 방지하기 위해 스레드별 변수를 서로 다른 캐시 라인에 배치합니다. alignas 키워드나 컴파일러 속성을 사용합니다.

**소프트웨어 프리페칭**

프로그래머가 명시적으로 프리페치 명령어를 사용할 수 있습니다. 복잡한 접근 패턴에서 하드웨어 프리페처가 예측하지 못하는 경우 유용합니다. 충분히 앞서서 프리페치해야 데이터가 도착할 시간이 있습니다. 너무 많이 프리페치하면 캐시 오염이 발생하여 역효과입니다. 신중하게 사용해야 합니다.

**실무 최적화**

이미지 처리는 픽셀을 행 단위로 처리합니다. 데이터베이스는 B-tree 노드를 한 페이지에 모아 공간 지역성을 높입니다. 압축 알고리즘은 슬라이딩 윈도우로 인접 데이터를 접근합니다. 정렬 알고리즘은 머지 단계에서 순차 접근하여 캐시를 활용합니다. 공간 지역성 최적화는 성능 향상의 핵심입니다.

---

## 84. 연속할당 방식 세 가지를 설명해주세요.

**기본 개념**

연속할당 방식은 프로세스에 메모리를 할당할 때, 여러 개의 빈 공간 중 어느 것을 선택할지 결정하는 전략입니다. First-fit, Best-fit, Worst-fit 세 가지 기본 방식이 있으며, 각각 장단점이 다릅니다.

**First-fit**

First-fit은 메모리를 처음부터 탐색하여 요청 크기 이상인 첫 번째 빈 공간을 할당합니다. 탐색 시간이 짧아서 가장 빠릅니다. 구현이 간단하고 오버헤드가 적습니다. 메모리 앞쪽에 작은 조각들이 누적되는 경향이 있습니다. 하지만 전체적으로 봤을 때 평균 성능이 좋고 실용적입니다. 대부분의 운영체제가 First-fit을 기본으로 사용하거나 변형합니다.

**Best-fit**

Best-fit은 모든 빈 공간을 탐색하여 요청 크기에 가장 근접한 것을 선택합니다. 남는 공간을 최소화하여 메모리 낭비를 줄입니다. 하지만 전체 리스트를 탐색해야 하므로 느립니다. 역설적으로 매우 작은 조각들을 많이 생성하여 외부 단편화를 악화시킬 수 있습니다. 작은 조각은 사용하기 어려워 결국 메모리 낭비가 됩니다. 이론적으로 좋아 보이지만 실제로는 First-fit만큼 효율적이지 않습니다.

**Worst-fit**

Worst-fit은 가장 큰 빈 공간을 선택하여 할당합니다. 남은 공간이 커서 나중에 다른 프로세스가 사용할 가능성이 높습니다. 매우 작은 쓸모없는 조각 생성을 방지합니다. 하지만 모든 빈 공간을 탐색해야 하므로 느립니다. 큰 빈 공간을 빠르게 소진하여, 큰 프로세스가 들어올 공간이 부족해질 수 있습니다. 일반적으로 성능이 가장 나쁩니다.

**성능 비교**

시뮬레이션 연구에 따르면 First-fit과 Best-fit이 비슷한 성능을 보이며, Worst-fit이 가장 나쁩니다. First-fit이 속도와 메모리 활용도 측면에서 균형이 좋습니다. Best-fit은 탐색 비용이 높고 단편화 개선 효과가 제한적입니다. Worst-fit은 큰 공간 부족 문제로 실용성이 떨어집니다. 대부분의 시스템은 First-fit 기반 전략을 채택합니다.

**외부 단편화**

모든 연속할당 방식은 외부 단편화 문제를 겪습니다. 총 빈 공간은 충분하지만 연속되지 않아 할당할 수 없는 상황입니다. 압축으로 단편화를 해소할 수 있지만 비용이 매우 큽니다. 현대 시스템은 페이징으로 이 문제를 근본적으로 해결합니다. 연속할당은 주로 학습용이며, 실제로는 페이징이 지배적입니다.

**최적화 기법**

Next-fit은 First-fit의 변형으로, 마지막 할당 위치부터 탐색을 시작합니다. 메모리 전체를 균등하게 사용하지만, First-fit보다 성능이 약간 낮습니다. Buddy system은 2의 거듭제곱 크기로 분할하여 빠른 할당과 합병을 지원합니다. Segregated free list는 크기별로 빈 공간을 분류하여 탐색을 최적화합니다.

**실무 적용**

malloc 구현체는 다양한 할당 전략을 혼합합니다. 작은 할당은 빠른 캐시에서, 큰 할당은 시스템 호출로 처리합니다. 파일 시스템의 블록 할당도 유사한 전략을 사용합니다. ext4는 extent 기반으로 연속 블록을 할당하여 단편화를 줄입니다. 메모리 풀이나 슬랩 할당자는 고정 크기 객체에 특화되어 단편화를 제거합니다.
